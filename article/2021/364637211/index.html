<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="MySQL 锁信息, Lcn29">
    <meta name="description" content="1 MySQL 锁定义MySQL 锁 (Lock) 是数据库管理系统用于管理并发访问的一种机制。在多用户同时访问数据库的环境下，可能会出现多个事务同时对相同的数据进行读取或写入操作，为了保证数据的一致性和完整性，需要使用锁来控制对数据的访问">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>MySQL 锁信息 | Lcn29</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Lcn29" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.svg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Lcn29</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友链</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.svg" class="logo-img circle responsive-img">
        
        <div class="logo-name">Lcn29</div>
        <div class="logo-desc">
            
            Technical System
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友链
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/lcn29" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #121317;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/lcn29" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/9.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">MySQL 锁信息</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/MySQL/">
                                <span class="chip bg-color">MySQL</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-07-26
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2024-10-10
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    7.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    26 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="1-MySQL-锁定义"><a href="#1-MySQL-锁定义" class="headerlink" title="1 MySQL 锁定义"></a>1 MySQL 锁定义</h2><p>MySQL 锁 (Lock) 是数据库管理系统用于管理并发访问的一种机制。<br>在多用户同时访问数据库的环境下，可能会出现多个事务同时对相同的数据进行读取或写入操作，为了保证数据的一致性和完整性，需要使用锁来控制对数据的访问。</p>
<p>在并发环境下，当多个事务试图同时访问相同的数据时，锁可以确保只有一个事务能够成功地获取对数据的访问权限，其他事务需要等待或被阻塞，直到获得相应的锁为止。<br>锁的主要作用是防止多个事务同时对同一数据进行不一致的修改，从而避免数据的丢失、错误或混乱。</p>
<p>总的来说，MySQL 锁是用于管理并发访问的机制，通过控制对数据的访问权限，确保多个事务之间不会发生冲突，从而维护数据的一致性和完整性。</p>
<h2 id="2-锁的一些概念"><a href="#2-锁的一些概念" class="headerlink" title="2 锁的一些概念"></a>2 锁的一些概念</h2><h3 id="2-1-行级锁和表级锁"><a href="#2-1-行级锁和表级锁" class="headerlink" title="2.1 行级锁和表级锁"></a>2.1 行级锁和表级锁</h3><p>一般情况下, 数据库都会支持 2 种不同的<strong>锁方式</strong></p>
<blockquote>
<ol>
<li>表锁, 直接锁住整张表数据</li>
<li>行锁, 锁住表里面的特定行数据</li>
</ol>
</blockquote>
<p>区别</p>
<blockquote>
<ol>
<li>从锁定粒度上看, 表锁肯定是大于行锁的</li>
<li>从加锁效率上看, 表锁快于行锁。表锁只需要直接锁住这张表就行了, 而行锁, 还需要在表里面去检索这一行数据</li>
<li>从冲突的概率上看, 表锁大于行锁。在表锁上, 其他任何一个事务都不能操作这张表, 但是行锁, 其他的事务还可以来操作表里面其他行的数据</li>
</ol>
</blockquote>
<p>注: MyISAM 只支持表级锁。</p>
<h3 id="2-2-共享锁和排他锁"><a href="#2-2-共享锁和排他锁" class="headerlink" title="2.2 共享锁和排他锁"></a>2.2 共享锁和排他锁</h3><p>共享锁, 也可以叫做读锁。它允许多个事务同时对相同的资源 (通常是数据库中的某个数据) 进行读取操作，而不允许任何事务在同一时间内对该资源进行写入操作。<br>共享锁通常用于实现读取的并发性，多个事务可以同时读取同一份数据而不会相互干扰。</p>
<p>排他锁, 也可以叫做写锁。它用于确保在某一时刻只有一个事务能够对资源进行写入操作。<br>当一个事务获得了排他锁，其他事务无法同时获得相同资源的共享锁或排他锁，从而阻止了其他事务对该资源的读取或写入操作。</p>
<p><strong>行级锁和表级锁 + 共享锁和排他锁</strong>之间两两配合, 基本就构成了整个 MySQL 所有锁的形式</p>
<blockquote>
<ol>
<li>共享行锁</li>
<li>排他行锁</li>
<li>共享表锁</li>
<li>排他表锁</li>
</ol>
</blockquote>
<h2 id="3-MySQL-InnoDB-锁的基本类型"><a href="#3-MySQL-InnoDB-锁的基本类型" class="headerlink" title="3 MySQL InnoDB 锁的基本类型"></a>3 MySQL InnoDB 锁的基本类型</h2><p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html">官网</a>把 InnoDB 的锁分成了 8 大类</p>
<blockquote>
<ol>
<li>Shared and Exclusive Locks</li>
<li>Intention Locks</li>
<li>Record Locks</li>
<li>Gap Locks</li>
<li>Next-Key Locks</li>
<li>Insert Intention Locks</li>
<li>AUTO-INC Locks</li>
<li>Predicate Locks for Spatial Indexes</li>
</ol>
</blockquote>
<p>备注: 下面锁的分析场景都需要关闭自动提交, 否则每一条语句执行完就自动提交, 事务就结束了, 达不到验证的效果,<br>可以在同一个 session 中执行 <strong>set autocommit &#x3D; 0;</strong>, 临时关闭自动提交。</p>
<h3 id="3-1-Shared-and-Exclusive-Locks"><a href="#3-1-Shared-and-Exclusive-Locks" class="headerlink" title="3.1 Shared and Exclusive Locks"></a>3.1 Shared and Exclusive Locks</h3><p>共享和排他锁。</p>
<p>Shared Locks (共享锁, 简称 S 锁), 可以细分为 <strong>共享行锁 + 共享表锁</strong>, 主要用于支持多个事务同时读取相同的数据, <strong>并发读取</strong>, 但阻止对同一数据的写入操作。<br>注意不要在加上了读锁以后去写数据, 不然的话可能会出现死锁的情况。<br>共享锁可以用 <code>select …… lock in share mode</code> 的方式手动加共享锁, 只要事务结束, 锁就会自动释放。  </p>
<p>Exclusive Locks (排他锁, 简称 X 锁), 同样可以细分为 <strong>排他行锁 + 排他表锁</strong>, 主要用于确保在某一时刻只有一个事务能够对数据进行写入操作，<strong>独占写入</strong>, 阻止其他事务对同一数据进行读取或写入。  </p>
<p>排他锁的加锁方式有三种</p>
<blockquote>
<ol>
<li>自动加排他锁, 在操作数据的时候, 包括增删改, 都会默认加上一个排他锁</li>
<li>手工加排他锁, 可以用一个 <code>select …… for update</code> 给一行数据 (表) 加上一个排他锁, 其他事务操作相同资源时, <strong>进行阻塞</strong></li>
<li>手工加排他锁, 可以用一个 <code>select …… for update nowait</code> 给一行数据 (表), 加上一个排他锁, 其他事务操作相同资源时, <strong>直接拒绝</strong></li>
</ol>
</blockquote>
<h3 id="3-2-行锁的原理"><a href="#3-2-行锁的原理" class="headerlink" title="3.2 行锁的原理"></a>3.2 行锁的原理</h3><p>假设当前有一张表 t1, 有 2 个字段: </p>
<table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="center">字段类型</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">name</td>
<td align="center">varchar</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>同时, 表中已经有 2 条数据:  </p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">one</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">two</td>
</tr>
</tbody></table>
<p><strong>场景一</strong>  </p>
<p>假设当前表 t1 2 个字段的设置如下:  </p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">类型</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">int</td>
<td align="center">没有任何的索引</td>
</tr>
<tr>
<td align="center">name</td>
<td align="center">varchar</td>
<td align="center">没有任何的索引</td>
</tr>
</tbody></table>
<blockquote>
<ol>
<li>事务 A : <code>select * from t1 where id = 1 for update;</code>, 看起来是锁住 id &#x3D; 1 的行</li>
<li>事务 B : <code>select * from t1 where id = 2 for update;</code>, 这时候加锁失败, 阻塞住了</li>
<li>事务 C : <code>insert into t1 values(3, &#39;three&#39;)</code>, 这时候插入失败, 同样阻塞住了</li>
</ol>
</blockquote>
<p>通过上面的情景可以得到:   </p>
<p>分析</p>
<blockquote>
<ol>
<li>表中的所有字段都没有索引</li>
<li>这时事务 A 对 id &#x3D; 1 的记录加了锁</li>
<li>事务 B 尝试对 id &#x3D; 2 的记录加锁失败</li>
<li>事务 C 尝试向表新增一条记录, 也失败</li>
</ol>
</blockquote>
<p>做个猜想: <strong>InnoDB 的行锁的依赖索引实现的</strong></p>
<p><strong>场景二</strong> </p>
<p>假设当前表 t1 2 个字段的设置如下:  </p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">类型</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">int</td>
<td align="center">主键索引</td>
</tr>
<tr>
<td align="center">name</td>
<td align="center">varchar</td>
<td align="center">没有任何的索引</td>
</tr>
</tbody></table>
<p>现在表中已经有 2 条数据。</p>
<blockquote>
<ol>
<li>事务 A : <code>select * from t1 where id = 1 for update;</code>, 锁住 id &#x3D; 1 的行</li>
<li>事务 B : <code>select * from t1 where id = 1 for update;</code>, 尝试锁住 id &#x3D; 1 的行失败, 阻塞住</li>
<li>事务 C : <code>select * from t1 where id = 2 for update;</code>, 尝试锁住 id &#x3D; 2 的行, 成功</li>
<li>事务 D : <code>insert into t1 values(3, &#39;three&#39;)</code>, 新增记录成功</li>
</ol>
</blockquote>
<p>分析</p>
<blockquote>
<ol>
<li>表中的 id 为主键</li>
<li>这时事务 A 对 id &#x3D; 1 的记录加了锁</li>
<li>事务 B 尝试对 id &#x3D; 1 的记录加锁失败</li>
<li>事务 C 尝试对 id &#x3D; 2 的记录加锁成功</li>
<li>事务 D 尝试向表新增一条记录, 也失败</li>
</ol>
</blockquote>
<p>场景一和场景二表的区别就是 id 是否为主键<br>做个推测: <strong>InnoDB 的行锁的实现是通过主键索引实现的</strong></p>
<p><strong>场景三</strong>  </p>
<p>假设当前表 t1 2 个字段的设置如下: </p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">类型</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">int</td>
<td align="center">主键索引</td>
</tr>
<tr>
<td align="center">name</td>
<td align="center">varchar</td>
<td align="center">唯一索引</td>
</tr>
</tbody></table>
<blockquote>
<ol>
<li>事务 A : <code>select * from t1 where name = &#39;one&#39; for update;</code>, 锁住 name &#x3D; one 的行</li>
<li>事务 B : <code>select * from t1 where name = &#39;one&#39; for update;</code>, 尝试锁住 name &#x3D; one 的行失败, 阻塞住</li>
<li>事务 C : <code>select * from t1 where id = 1 for update;</code>, 尝试锁住 id &#x3D; 1 的行失败, 阻塞住</li>
<li>事务 D : <code>select * from t1 where id = 2 for update;</code>, 尝试锁住 id &#x3D; 2 的行, 成功</li>
</ol>
</blockquote>
<p>可以得出一个推测: InnoDB 的行锁, 既不是锁行记录, 也不是锁字段, 而是就是通过<strong>锁住索引</strong>来实现的。</p>
<p>备注: 上面整个过程实际是从结论推导过程, 所以不必太过深究, 只是为了验证 InnoDB 的行锁是通过锁索引实现的。</p>
<p>下面做个总结: </p>
<p><strong>在表中没有索引的时候, InnoDB 是如何加锁的</strong></p>
<p>索引的定义</p>
<blockquote>
<ol>
<li>如果我们定义了主键 (PRIMARY KEY), 那么 InnoDB 会选择主键作为聚集索引</li>
<li>如果没有显式定义主键, 则 InnoDB 会选择第一个不包含有 NULL 值的唯一索引作为主键索引</li>
<li>如果也没有这样的唯一索引, 则 InnoDB 会选择内置 6 字节长的 ROWID 作为隐藏的聚集索引, 它会随着行记录的写入而主键递增</li>
</ol>
</blockquote>
<p>所以 InnoDB 在没有任何索引时, 会通过内置的 ROWID 作为索引, 然后借助锁住这个索引达到加锁效果</p>
<p><strong>在表中没有索引的时候, 查询一行记录, 为什么也会导致锁全表</strong></p>
<p>上面知道, 没有任何索引时, InnoDB 通过锁住内置的 ROWID 索引达到加锁效果。<br>但是在查询时, 查询条件的字段和 ROWID 之间如何对应呢?<br>比如条件 id &#x3D; 1, 那么他对应的 ROWID 是多少呢? InnoDB 无法确定, 所以最保险的做法就是整张表锁住。  </p>
<p>所以查询没有使用索引, 会进行全表扫描, 然后把每一个隐藏的聚集索引都锁住了。</p>
<p><strong>为什么通过唯一索引给数据行加锁, 主键索引也会被锁住</strong></p>
<p>通过辅助索引进行查询数据时, 先在辅助索引里面找到对应的主键的值, 然后再在主键索引里面查询数据。<br>所以我们通过辅助索引锁定一行数据的时候, 它跟我们检索数据的步骤是一样的, 会通过主键值找到主键索引, 然后锁定。</p>
<p><strong>表锁什么时候使用</strong><br>当一张表加锁时, 无法通过行锁锁住, 那么就会晋升为表锁, 也就是行锁无法锁住资源, 就直接通过表锁实现。</p>
<h3 id="3-3-意向锁"><a href="#3-3-意向锁" class="headerlink" title="3.3 意向锁"></a>3.3 意向锁</h3><h4 id="3-3-1-介绍"><a href="#3-3-1-介绍" class="headerlink" title="3.3.1 介绍"></a>3.3.1 介绍</h4><p>意向锁, 重点其实是<strong>意向</strong>, 有趋势但是还未做。<br>所以意向锁实际上是没有<strong>真正</strong>给表或者表中的行进行加锁操作, 而更像是给表打了一个标识, 表示有锁的意思。</p>
<p>意向锁是由数据库自己维护的 (非存储引擎维护), 同时 2 个意向锁都是<strong>表级别的锁</strong></p>
<blockquote>
<ol>
<li>给一行数据加上<strong>共享锁</strong>之前, 数据库会自动在这张表上面加一个<strong>意向共享锁</strong> (Intention Sharded Lock, 简称 IS 锁)</li>
<li>给一行数据加上<strong>排他锁</strong>之前, 数据库会自动在这张表上面加一个<strong>意向排他锁</strong> (Intention Exclusive Lock, 简称 IX 锁)</li>
</ol>
</blockquote>
<p>也就是说:  </p>
<blockquote>
<ol>
<li>如果一张表上面至少有一个<strong>意向共享锁</strong>, 说明有其他的事务给表中的某些数据行加上了<strong>共享锁</strong>  </li>
<li>如果一张表上面至少有一个<strong>意向排他锁</strong>, 说明有其他的事务给表中的某些数据行加上了<strong>排他锁</strong></li>
</ol>
</blockquote>
<h4 id="3-3-2-特点"><a href="#3-3-2-特点" class="headerlink" title="3.3.2 特点"></a>3.3.2 特点</h4><p>意向锁的特点:  </p>
<blockquote>
<ol>
<li>2 个意向锁之间不像共享和排他锁是互斥的, 他们之间是互相兼容的</li>
<li>2 个意向锁都是表级别锁, 所以只会影响到表级别的共享锁和排他锁, 对行级别的共享锁和排他锁无影响</li>
</ol>
</blockquote>
<p>举个例子吧<br>假设现在有一张表 t1, 数据如下</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">one</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">two</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">three</td>
</tr>
</tbody></table>
<p>情况一, id 是主键</p>
<blockquote>
<ol>
<li>事务 A : <code>select * from t1 where id = 1 for update;</code>, 这时表 t1 在行 id &#x3D; 1 上有一个行级别排他锁, 同时表上有一个意向排他锁</li>
<li>事务 B : <code>select * from t1 where id = 2 lock in share mode;</code>, 尝试给 id &#x3D; 2 加上行级别共享锁, 虽然表上已经有意向排他锁, 但是意向锁不互斥, 同时意向锁不影响行锁, 所以 2 个锁都加成功</li>
<li>事务 C : <code>select * from t1 where id = 3 for update;</code>, 尝试给 id &#x3D; 3 加上行级别排他锁, 意向锁不互斥和意向锁不影响行锁, 所以还是加锁成功</li>
</ol>
</blockquote>
<p>可以发现</p>
<blockquote>
<ol>
<li>意向锁都是表级别的锁, 不会影响到行级别的锁</li>
<li>意向锁互不影响</li>
</ol>
</blockquote>
<p>情况二, id 是主键, name 没有任何索引</p>
<blockquote>
<ol>
<li>事务 A : <code>select * from t1 where id = 1 for update;</code>, 这时表 t1 在行 id &#x3D; 1 上有一个行级别排他锁, 同时表上有一个意向排他锁</li>
<li>事务 B : <code>select * from t1 where name = &#39;one&#39; for update;</code>, 没有使用索引, 需要加表级别排他锁, 但是发现上面已经有一个意向排他锁, 加锁失败, 阻塞</li>
<li>事务 C : <code>select * from t1 where name = &#39;one&#39; lock in share mode;</code>, 没有使用索引, 需要加表级别共享锁, 但是发现上面已经有一个意向排他锁, 加锁失败, 阻塞</li>
</ol>
</blockquote>
<p>可以发现</p>
<blockquote>
<ol>
<li>事务 A 只是给表中的某一行加了一个行级别的排他锁, 同时给表加了一个意向排他锁</li>
<li>事务 B 试图给表加上表排他锁, 需要先确定表中没有其他锁, 在没有意向锁时, 需要遍历所有行确定这个结论, 但是现在有意向锁, 直接知道表中某些行有锁, 可以确定不能加了</li>
<li>事务 C 同理</li>
</ol>
</blockquote>
<p>各个锁之间的兼容关系如下</p>
<p>|     | 共享锁 (S ) | 排他锁 (X) | 共享意向锁 (IS) | 排他意向锁 (IX) |<br>| :-: |:-: |:-: |:-: |<br>| 共享锁 (S ) | 兼容 | 排斥 | 兼容 | 排斥 |<br>| 排他锁 (X)  | 排斥 | 排斥 | 排斥 | 排斥 |<br>| 共享意向锁 (IS) | 兼容 | 排斥 | 兼容 | 兼容 |<br>| 排他意向锁 (IX) | 排斥 | 排斥 | 兼容 | 兼容 |</p>
<h4 id="3-3-3-意义"><a href="#3-3-3-意义" class="headerlink" title="3.3.3 意义"></a>3.3.3 意义</h4><p>两个意向锁存在的意义</p>
<blockquote>
<ol>
<li>有了 2 个意向锁, 在 InnoDB 里面就可以支持更多粒度的锁, 特定场景下, 行级锁可以与表级锁共存 (共享锁和共享意向锁基本都是兼容的, 已经存在共享表锁时, 可以支持共享行锁)</li>
<li>可以把它理解成一个标志, 是用来提高加表锁的效率的。 比如要给一张表加表锁, 那么就需要判断是否有行锁, 先要判断有没其他的事务锁定了其中了某些行, 有了意向锁这个标志, 就可以不去遍历行</li>
</ol>
</blockquote>
<h3 id="3-4-锁算法"><a href="#3-4-锁算法" class="headerlink" title="3.4 锁算法"></a>3.4 锁算法</h3><p>Record Locks、Gap Locks、Next-Key Locks 虽然官方将他们分为锁的类型, 但是更形象的说法是<strong>锁的算法</strong>, 也就是在什么情况下锁定什么范围。</p>
<p>假设当前有一张表 t, 有 2 个字段: </p>
<blockquote>
<ol>
<li>int 类型的 id, 是主键索引</li>
<li>varchar 类型的 name</li>
</ol>
</blockquote>
<p>表中当前有 4 条数据, id 分别为 1, 4, 7, 10。</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">10</td>
</tr>
</tbody></table>
<h4 id="3-4-1-几个名词的定义"><a href="#3-4-1-几个名词的定义" class="headerlink" title="3.4.1 几个名词的定义"></a>3.4.1 几个名词的定义</h4><p><img src="https://pic.imgdb.cn/item/65f2e40c9f345e8d030d7874.png" alt="Alt &#39;记录&#39;"></p>
<p>表里面存在的数据的行, 就叫做 Record (记录), 当前 t 表有 4 个 Record。</p>
<p><img src="https://pic.imgdb.cn/item/65f2e40f9f345e8d030d89e2.png" alt="Alt &#39;间隙&#39;"></p>
<p>在表中, Record 和 Record 之间可能存在一段数据不存在的区间, 叫做 Gap (间隙), 它是一个左开右开的区间, 当前 t 表这里有 5 个 Gap。</p>
<p><img src="https://pic.imgdb.cn/item/65f2e4119f345e8d030d9605.png" alt="Alt &#39;临键&#39;"></p>
<p>间隙 (Gap) 连同右边的记录 (Record), 公共组成的区间, 叫做 Next-Key (临键), 它是一个左开右闭的区间, 当前 t 表这里有 4 个 Next-Key。</p>
<h4 id="3-4-2-Record-Lock-记录锁"><a href="#3-4-2-Record-Lock-记录锁" class="headerlink" title="3.4.2 Record Lock - 记录锁"></a>3.4.2 Record Lock - 记录锁</h4><p>只对表中的某行记录加锁, 就是记录锁。</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">4</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">and</span> id <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span></code></pre>

<p>上面 2 个 SQL 都可以查询唯一一条记录: id &#x3D; 4 的记录。<br>像这种通过<strong>唯一索引 (主键也属于唯一索引)</strong> 进行查询的语句, 同时查询结果明确<strong>只有 1 条记录</strong>的情况, 就是使用到了记录锁。<br>记录锁主要用于唯一性的索引 (包括唯一索引和主键索引), 非唯一性索引的只会出现间隙锁或临键锁。  </p>
<p>记录锁是一个排他锁, 会<strong>阻塞</strong>其他事务对对应记录的<strong>所有相关</strong>操作。</p>
<h4 id="3-4-3-Gap-Lock-间隙锁"><a href="#3-4-3-Gap-Lock-间隙锁" class="headerlink" title="3.4.3 Gap Lock - 间隙锁"></a>3.4.3 Gap Lock - 间隙锁</h4><p>在记录和记录之间存在着某些间隙, 对这些间隙进行加锁, 就是间隙锁。</p>
<p><strong>特别说明:</strong></p>
<blockquote>
<ol>
<li>间隙锁主要是阻塞插入 insert, 对于删改查都不会有影响, 查很容易理解, 删改, InnoDB 的 MVCC 机制可以保证数据在事务中的正常</li>
<li>相同的间隙锁之间不冲突, 2 个间隙锁的区间可以是包含关系, 也可以是部分重叠</li>
<li>间隙锁只在 RR 的隔离级别出现, 所以将隔离级别修改成别的, 可以关闭间隙锁功能</li>
<li>另一种关闭间隙锁的方式, 将 <code>innodb_locks_unsafe_for_binlog</code> 设置为 0, 这时候除了外键约束和唯一性检查会加间隙锁, 其他情况都不会用间隙锁</li>
</ol>
</blockquote>
<p>例子:</p>
<blockquote>
<ol>
<li>事务 A: <code>select * from t where id = 6 for update;</code>, 找不到, 导致 4 - 7 之间出现间隙锁</li>
<li>事务 B: <code>insert into t (&#39;id&#39;, &#39;name&#39;) values(5, &#39;5&#39;);</code> 在 4 - 7 之间有间隙锁, 插入失败</li>
<li>事务 C: <code>select * from t where id = 6 for update;</code>, 查询结果为空, 没有被阻塞</li>
</ol>
</blockquote>
<h4 id="3-4-4-Next-Key-Lock-临键锁"><a href="#3-4-4-Next-Key-Lock-临键锁" class="headerlink" title="3.4.4 Next-Key Lock - 临键锁"></a>3.4.4 Next-Key Lock - 临键锁</h4><p>将记录和记录之间的间隙一起加锁, 就是临键锁。</p>
<p><strong>特别说明:</strong></p>
<blockquote>
<ol>
<li>临键锁就是 MySQL 里面默认的行锁算法, 等于<strong>间隙锁 + 记录锁</strong></li>
<li>临键锁等于<strong>间隙锁 + 记录锁</strong>, 所以其锁住的范围和间隙锁是相同的, 只是间隙中命中的记录会变成记录锁, 比如查询条件为 7, 那么间隙锁的范围为 (4, 10), 命中记录 7, 最终变为 (4, 7] 和 (7, 10)</li>
<li>临键锁会进行退化: 通过等值查询匹配到一条记录, 退化为记录锁</li>
<li>临键锁会进行退化: 使用唯一性索引, 没有匹配到任何记录的时候, 退化成间隙锁</li>
</ol>
</blockquote>
<p>使用唯一性索引, 临键锁锁住的是<strong>条件范围内, 小于等于查询范围最小值的最后一个索引 (可以是索引本身) + 大于等于查询范围最大值的第一个索引 (不包含索引本身) 间所有的索引记录 + 索引记录前边的间隙</strong>  </p>
<p>例子: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id <span class="token operator">></span> <span class="token number">5</span> <span class="token operator">and</span> id <span class="token operator">&lt;</span> <span class="token number">9</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span></code></pre>
<p>查询范围为 (5, 9),<br>小于等于查询范围最小值 (这里就是 5) 的最后一个索引 (这里是 4)<br>大于等于查询范围最大值 (这里就是 9) 的第一个索引 (这里是 10)<br>所以这条 SQL 锁住的范围为 (4, 7] 和 (7, 10)</p>
<p>同理</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t2 <span class="token keyword">where</span> id <span class="token operator">></span> <span class="token number">5</span> <span class="token operator">and</span> id <span class="token operator">&lt;=</span> <span class="token number">7</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span></code></pre>
<p>这时候锁住的范围为 (4, 7] 和 (7, 10]</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t2 <span class="token keyword">where</span> id <span class="token operator">></span> <span class="token number">8</span> <span class="token operator">and</span> id <span class="token operator">&lt;=</span> <span class="token number">10</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span></code></pre>
<p>这时候锁住的范围为 (7, 10] 和 (10, +∞] </p>
<h4 id="3-4-5-非唯一性索引的锁算法"><a href="#3-4-5-非唯一性索引的锁算法" class="headerlink" title="3.4.5 非唯一性索引的锁算法"></a>3.4.5 非唯一性索引的锁算法</h4><p>上面讨论的锁算法讨论的都是唯一索引下的情况, 那么如果查询条件是非唯一索引 (值是可以重复的) 呢?</p>
<p>假设现在有一张表, id 的主键, num 是普通的索引, 表中有数据</p>
<table>
<thead>
<tr>
<th align="center">id (主键)</th>
<th align="center">num (普通索引)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>使用非唯一索引时, InnoDB 在使用锁的时候, <strong>会先按照非唯一索引进行排序, 非唯一索引排序后, 非唯一索引有相同值时, 会再按照主键排序</strong>, 所以排序后的变为</p>
<table>
<thead>
<tr>
<th align="center">id (主键)</th>
<th align="center">num (普通索引)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">6</td>
</tr>
</tbody></table>
<p>对于间隙锁的范围, 等值查询的一般情况下, 锁住的是 <strong>左区间是以当前条件向左找到第一条记录, 右区间是向右找到的第一条记录</strong><br>如果现在条件为 <code>where num = 4</code>,  num 4 向左找到的第一条记录为 (10, 3), 向右找到的第一条记录为 (6, 5), 所以这个条件锁住的间隙为 (3, 5), 在具体的是 (10, 3) 到 (6, 5)。<br>如果这时候想里面插入 (7, 5) 是能插入成功的, 因为不在上面说的范围内。</p>
<p>我们知道, <strong>当查询条件没有索引时, 会导致锁表</strong>, 所以下面讨论的是在有索引的情况:<br>影响锁的范围的影响因素</p>
<blockquote>
<ol>
<li>条件是否为唯一索引</li>
<li>查询的方式, 等值查询, 范围查询</li>
</ol>
</blockquote>
<p><strong>情况一: 唯一索引 + 等值查询</strong></p>
<blockquote>
<ol>
<li>命中了记录, 直接就是记录锁</li>
<li>未命中记录, 间隙锁, 锁住的就是包住这个条件的 2 个记录的区间, (注意上面间隙锁范围的说明)</li>
</ol>
</blockquote>
<p><strong>情况二: 唯一索引 + 范围查询</strong></p>
<p>使用范围查询的话, 基本锁住的范围就是条件限制的范围, 这个范围内的记录加上的都是记录锁。</p>
<p>需要说明的是, 如果 where <code>主键 &gt; 条件</code>, 这个条件不是记录, 那么会向左找到第一条记录, 以这条记录开始,<br>同理如果 where <code>主键 &lt; 条件</code>, 这个条件不是记录, 会向右找到第一条记录</p>
<p><strong>情况三: 非唯一索引 + 等值查询</strong></p>
<p>以这个条件, 向左找到第一条记录, 向右找到的第一条记录, 组成一个区间, 中间的记录为记录锁, 同时会锁住这条记录对应的主键索引。</p>
<p><strong>情况四: 非唯一索引 + 范围查询</strong></p>
<p>和唯一索引不同的, 非唯一索引, 还会增加 2 侧的间隙</p>
<blockquote>
<ol>
<li>where <code>非唯一索引 &gt; 条件</code>, 无论条件是否为记录, 都会向左找到第一条记录, 从这里开始加上条件的范围组成区间, 中间出现的记录都会加上记录锁, 同理 <code>where 非唯一索引 &lt; 条件</code> 会向右找到第一条记录, 加上条件的范围。</li>
</ol>
</blockquote>
<h3 id="3-5-其他几个锁"><a href="#3-5-其他几个锁" class="headerlink" title="3.5 其他几个锁"></a>3.5 其他几个锁</h3><h4 id="3-5-1-插入意向锁"><a href="#3-5-1-插入意向锁" class="headerlink" title="3.5.1 插入意向锁"></a>3.5.1 插入意向锁</h4><p>插入意向锁是一种特殊的间隙锁, 但不同于间隙锁的是, 该锁只用于并发插入操作: 如果多个事务插入到相同的索引间隙中, 如果它们不在间隙中的相同位置插入, 则无需等待其他事务。<br>比如说有索引记录 4 和 7, 有两个事务想要分别插入 5, 6, 在获取插入行上的排它锁之前, 每个事务都使用插入意图锁锁定 4 和 7 之间的间隙, 但是不会互相阻塞, 因为行是不冲突的。<br>简单来说: 插入意向锁锁定了索引之间的间隙, 但是事务之间只要不插入同一个位置, 彼此之间是不会阻塞的。</p>
<h4 id="3-5-2-自增锁"><a href="#3-5-2-自增锁" class="headerlink" title="3.5.2 自增锁"></a>3.5.2 自增锁</h4><p>自增锁是一种比较特殊的表级锁, 主要用于在事务中插入自增字段。<br>通过 <code>innodb_autoinc_lock_mode</code> 配置控制自动增量锁定的算法, 允许用户在<code>可预测的自动增量值序列</code>和<code>插入操作的最大并发之间</code>进行权衡选择。</p>
<p>为了便于介绍 innodb_autoinc_lock_mode 参数, 先将需要用到自增锁的 Insert 语句进行分类</p>
<blockquote>
<ol>
<li>INSERT-like: 所有可以向表中增加行的语句, 包含 insert, insert … select, replace, replace … select, load data, insert … on duplicate key update 6 个语句</li>
<li>Simple inserts: 可以预先确定要插入的行数的语句, 直接的 insert 和 replace</li>
<li>Bulk inserts: 事先不知道要插入的行数的语句, insert … select, replace … select, load data</li>
<li>Mixed-mode inserts: 在 Simple inserts 语句的基础上, 部分行手动指定了自增列的值, 比如, insert into t1(id, name) values(1, ‘one’), (Null, ‘two’), (Null, ‘three’) 和 insert … on duplicate key update 语句</li>
</ol>
</blockquote>
<p>innodb_autoinc_lock_mode 三种取值的含义</p>
<p><strong>traditional (取值: 0)</strong></p>
<p>在此锁定模式下, 所有 “INSERT-like” 语句获得一个特殊的表级 AUTO-INC 锁, 用于插入具有 AUTO_INCREMENT 列的表。<br>此锁定通常保持到 insert 语句结束 (不是事务结束) , 以确保为给定的INSERT语句序列以可预测和可重复的顺序分配自动递增值, 并确保自动递增由任何给定语句分配的值是连续的。</p>
<p>在<strong>基于语句复制 (statement-based replication</strong>) 的情况下, 这意味着当在从服务器上复制 SQL 语句时, 自动增量列使用与主服务器上相同的值。多个 INSERT 语句的执行结果是确定性的, 从服务器再现与主服务器相同的数据</p>
<p><strong>consecutive (取值: 1)</strong></p>
<p>在此锁定模式下, “Simple inserts” (要插入的行数事先已知) , 不使用表级 AUTO-INC 锁, 而是通过在 mutex (轻量锁) 的控制下获得所需数量的自动递增值来避免表级 AUTO-INC 锁, 它只在分配过程的持续时间内保持, 而不是直到语句完成。<br>当然: 如果另一个事务保持 AUTO-INC 锁, 则 “Simple inserts” 则需要等待 AUTO-INC 锁, 然后按照 “Bulk inserts” 处理。</p>
<p>此锁定模式确保, 当有行数不预先知道的 INSERT 存在时, 任何 “INSERT-like” 语句分配的所有自动递增值是连续的, 并且对于基于语句的复制 (statement-based replication) 操作是安全的。<br>此模式大体是和 traditional 一致的。但有个特殊场景需要注意: 混合模式的插入, 可能会有部分多余自增值丢失。<br>InnoDB 分配比要插入的行数更多的自动增量值。但是, 所有自动分配的值都是连续生成的 (因此高于) 由最近执行的前一条语句生成的自动增量值, “多余” 的数字丢失。</p>
<p><strong>interleaved (取值: 2)</strong></p>
<p>在此锁定模式下, 所有 “INSERT-like” 语句不使用 AUTO-INC 锁, 可以同时执行多个语句, 这是最快和最可扩展的锁定模式。</p>
<p>但是当使用基于语句的复制或恢复方案时, 从二进制日志重播SQL语句时, 这是不安全的</p>
<p>在此锁定模式下, 自动递增值保证在所有并发执行的 “INSERT-like” 语句中是唯一且单调递增的。但是, 由于多个语句可以同时生成数字 (即, 跨语句交叉编号) , 为任何给定语句插入的行生成的值可能不是连续的。<br>如果执行的语句是 “simple inserts”, 其中要插入的行数已提前知道, 则除了 “Mixed-mode inserts” 之外, 为单个语句生成的数字不会有间隙。然而, 当执行 “Bulk inserts”时, 在由任何给定语句分配的自动递增值中可能存在间隙。</p>
<p>如果不使用二进制日志作为恢复或复制的一部分来重放 SQL 语句, 则可以使用 interleaved 模式来消除所有使用表级 AUTO-INC 锁, 以实现更大的并发性和性能, 其代价是由于并发的语句交错执行, 同一语句生成的 AUTO-INCREMENT 值可能会产生间隙。</p>
<p>Binlog 一般用于 MySQL 的数据复制, 通俗一点就是用于主从同步。在 MySQL 中 Binlog 的格式有 3 种, 分别是:</p>
<blockquote>
<ol>
<li>Statement: 基于语句, 只记录对数据做修改的 SQL 语句, 能够有效的减少 binlog 的数据量, 提高读取, 基于 Binlog 重放的性能</li>
<li>Row: 只记录被修改的行, 所以 Row 记录的 binlog 日志量一般来说会比 Statement 格式要多</li>
<li>Mixed: Statement 和 Row 的结合, 怎么个结合法呢。表结构变更使用 statement 模式来记录, 如果 SQL 语句是 update 或者 delete 语句, 那么使用 row 模式</li>
</ol>
</blockquote>
<p>如果 MySQL 采用的格式为 Statement, 那么 MySQL 的主从同步实际上同步的就是一条一条的 SQL 语句。如果此时采用了交叉模式, 那么并发情况下 INSERT 语句的执行顺序就无法得到保障。<br>INSERT 同时交叉执行, 并且 AUTO_INCREMENT 交叉分配将会直接导致主从之间同行的数据主键 ID 不同。</p>
<p>和自增锁相关的三个参数</p>
<blockquote>
<ol>
<li>auto_increment_offset: 表示起始数字</li>
<li>auto_increment_increment: 表示自增的步长 (即每次增加 n 个数字, 2 就代表每次 +2)</li>
<li>innodb_autoinc_lock_mode: 加锁的模式, 可以设定 3 个值, 0, 1, 2, 默认为 1</li>
</ol>
</blockquote>
<h4 id="3-5-3-空间索引的谓词锁"><a href="#3-5-3-空间索引的谓词锁" class="headerlink" title="3.5.3 空间索引的谓词锁"></a>3.5.3 空间索引的谓词锁</h4><p>InnoDB 支持对包含空间的列建立 SPATIAL 索引。</p>
<p>要处理涉及 SPATIAL 索引的操作的锁定, next-key 锁定不能很好地支持 REPEATABLE READ 或 SERIALIZABLE 事务隔离级别, 因为在多维数据中没有绝对排序概念, 因此不清楚哪个是邻键。<br>为了支持具有 SPATIAL 索引的表的隔离级别, InnoDB 使用谓词锁。SPATIAL 索引包含最小边界矩形 (MBR) 值, 因此 InnoDB 通过设置用于查询的 MBR 值的谓词锁来强制对索引进行一致读取。<br>此时, 其他事务不能插入或修改与查询条件匹配的行。</p>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/better-farther-world2099/articles/14955475.html">彻底搞懂 MySQL 中的锁机制</a><br><a target="_blank" rel="noopener" href="https://nicky-chin.cn/2022/03/17/mysql-lock-struct/">mysql之innodb锁系统源码分析</a>  </p>

                
            </div>
            <hr/>
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/article/2021/2368526883/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="Java LinkedList">
                        
                        <span class="card-title">Java LinkedList</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-08-09
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Lcn29
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                    <a href="/tags/Java-%E9%9B%86%E5%90%88/">
                        <span class="chip bg-color">Java 集合</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/article/2021/4103934888/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="MySQL 事务">
                        
                        <span class="card-title">MySQL 事务</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-07-26
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Lcn29
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/MySQL/">
                        <span class="chip bg-color">MySQL</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2024</span>
            
            <br/>

            Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            &nbsp; | &nbsp;&nbsp;Theme <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>

            
            <br>
            
            
                <span id="busuanzi_container_site_pv">
                    总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
            
            
                <span id="busuanzi_container_site_uv">
                    &nbsp; | &nbsp;&nbsp;总访问人数:&nbsp; <span id="busuanzi_value_site_uv" class="white-color"></span>
                </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
