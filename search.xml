<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis Cluster 简单介绍</title>
      <link href="/article/2024/3024014473/"/>
      <url>/article/2024/3024014473/</url>
      
        <content type="html"><![CDATA[<p>Redis Cluster 是 Redis 3.0 提供的一种分布式解决方案, 允许数据在多个节点之间分散存储, 从而实现高可用性和可扩展性。</p><p>特点:</p><ol><li>分片: Redis Cluster 将数据分散到多个节点, 通过哈希槽 (hash slots) 机制将键映射到不同的节点上。总共有 16384 个哈希槽, 每个节点负责一部分槽。</li><li>高可用性: Redis Cluster 支持主从复制, 每个主节点可以有多个从节点, 从节点可以在主节点故障时自动提升为主节点。</li><li>自动故障转移: 当主节点宕机时, Cluster 会自动检测并选择从节点提升为新的主节点, 保持服务的可用性。</li><li>无中心化: Redis Cluster 是去中心化的, 没有单点故障。所有节点都可以处理请求, 提升了系统的健壮性。</li></ol><p>解决的问题:</p><ol><li>数据存储限制: 单个 Redis 实例的内存限制使其在处理大规模数据时受到约束, Redis Cluster 通过分片技术克服了这一限制, 支持更大规模的数据存储。</li><li>高可用性需求: 在传统的 Redis 配置中, 主节点故障会导致服务不可用。Redis Cluster 通过主从复制和自动故障转移确保服务的连续性, 满足高可用性的需求。</li><li>负载均衡: 随着数据量和访问量的增加, Redis Cluster 可以通过增加节点和分配哈希槽实现负载均衡, 避免某一节点过载。</li></ol><h2 id="1-Redis-Cluster-的搭建"><a href="#1-Redis-Cluster-的搭建" class="headerlink" title="1 Redis Cluster 的搭建"></a>1 Redis Cluster 的搭建</h2><p>Redis Cluster 可以看成是由多个 Redis 实例组成的数据集合。<br>客户端不需要关注数据的子集到底存储在哪个节点, 只需要关注这个集合整体。</p><p>那么如何搭建一个这样的集群呢?<br>注: 这里用一台集群搭建集群, Ip 地址为 192.169.10.10, 7000&#x2F;7001&#x2F;7002 为主节点的端口, 8000&#x2F;8001&#x2F;8002 为对应的从节点的端口。</p><h3 id="1-1-修改配置"><a href="#1-1-修改配置" class="headerlink" title="1.1 修改配置"></a>1.1 修改配置</h3><p>修改 redis.conf 配置文件中的 3 个参数</p><blockquote><ol><li>cluster-enabled yes</li><li>cluster-config-file “node-7000.conf”</li><li>cluster-node-timeout 5000</li></ol></blockquote><p>其他的参数和单个 Redis 实例的一样。</p><p><code>cluster-enabled yes</code>: Redis 实例可以分为单机模式 (standalone) 和集群模式 (cluster)。 yes 开启为集群模式。 </p><p><code>cluster-config-file</code>: 该参数指定了集群配置文件的位置。每个节点在运行过程中, 会维护一份集群配置文件; 每当集群信息发生变化时 (如增减节点), 集群内所有节点会将最新信息更新到自己维护的配置文件。<br>当节点重启后, 会重新读取该配置文件, 获取集群信息, 可以方便的重新加入到集群中。<br>也就是说当 Redis 节点以集群模式启动时, 会首先寻找是否有集群配置文件, 如果有则使用文件中的配置启动, 如果没有, 则初始化配置并将配置保存到文件中。 集群配置文件由 Redis 节点维护, 不需要人工修改。</p><p><code>cluster-node-timeout</code>: 节点之间心跳超时时间</p><p><code>cluster-require-full-coverage</code>: 默认值为 yes, 将其修改为 no, 表示 Redis 节点的槽没有完全分配时，集群仍可以上线。</p><h3 id="1-2-启动节点"><a href="#1-2-启动节点" class="headerlink" title="1.2 启动节点"></a>1.2 启动节点</h3><p>通过 <code>redis-server redis.conf</code> 配置文件启动 Redis。<br>可以通过 <strong>cluster nodes</strong> 查看当前的节点集群信息。</p><h3 id="1-3-节点握手"><a href="#1-3-节点握手" class="headerlink" title="1.3 节点握手"></a>1.3 节点握手</h3><p><strong>执行 redis-cli –cluster create 命令</strong></p><p>节点启动以后是相互独立的，并不知道其他节点存在, 需要进行节点握手。<br>将独立的节点组成一个网络。<strong>注下面的操作, 不能使用 localhost 和 127.0.0.1, 需要使用局域网 Ip 或 公网 Ip</strong>。</p><pre class="language-bash" data-language="bash"><code class="language-bash">redis-cli <span class="token parameter variable">--cluster</span> create <span class="token number">192.169</span>.10.10:7000 <span class="token number">192.169</span>.10.10:7001 <span class="token number">192.169</span>.10.10:7002 <span class="token number">192.169</span>.10.10:8000 <span class="token number">192.169</span>.10.10:8001 <span class="token number">192.169</span>.10.10:8002 --cluster-replicas <span class="token number">1</span></code></pre><p>–cluster-replicas 1 表示每个主节点有 1 个从节点, 后面的多个 {ip:port} 表示节点地址。(默认: 所有节点平均分成 2 组, 前面一组为主节点, 后面一组为从节点)</p><p>执行创建命令后, Redis 会给出一个预计的方案, 对 6 个节点分配 3 主 3 从, 如果认为没有问题，输入 yes 确认</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> Performing <span class="token builtin class-name">hash</span> slots allocation on <span class="token number">6</span> nodes<span class="token punctuation">..</span>.Master<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> -<span class="token operator">></span> Slots <span class="token number">0</span> - <span class="token number">5460</span>Master<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> -<span class="token operator">></span> Slots <span class="token number">5461</span> - <span class="token number">10922</span>Master<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> -<span class="token operator">></span> Slots <span class="token number">10923</span> - <span class="token number">16383</span>Adding replica <span class="token number">192.169</span>.10.10:8000 to <span class="token number">192.169</span>.10.10:7000Adding replica <span class="token number">192.169</span>.10.10:8001 to <span class="token number">192.169</span>.10.10:7001Adding replica <span class="token number">192.169</span>.10.10:8002 to <span class="token number">192.169</span>.10.10:7002<span class="token operator">>></span><span class="token operator">></span> Trying to optimize slaves allocation <span class="token keyword">for</span> anti-affinity<span class="token punctuation">[</span>WARNING<span class="token punctuation">]</span> Some slaves are <span class="token keyword">in</span> the same <span class="token function">host</span> as their masterM: dfdc9c0589219f727e4fd0ad8dafaf7e0cfb4f1c <span class="token number">192.169</span>.10.10:7000   slots:<span class="token punctuation">[</span><span class="token number">0</span>-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> masterM: 8c878b45905bba3d7366c89ec51bd0cd7ce959f8 <span class="token number">192.169</span>.10.10:7001   slots:<span class="token punctuation">[</span><span class="token number">5461</span>-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5462</span> slots<span class="token punctuation">)</span> masterM: aeeb7d7076d9b25a7805ac6f508497b43887e599 <span class="token number">192.169</span>.10.10:7002   slots:<span class="token punctuation">[</span><span class="token number">10923</span>-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> masterS: ebc479e609ff8f6ca9283947530919c559a08f80 <span class="token number">192.169</span>.10.10:8000   replicates aeeb7d7076d9b25a7805ac6f508497b43887e599S: 49385ed6e58469ef900ec48e5912e5f7b7505f6e <span class="token number">192.169</span>.10.10:8001   replicates dfdc9c0589219f727e4fd0ad8dafaf7e0cfb4f1cS: 8d6227aefc4830065624ff6c1dd795d2d5ad094a <span class="token number">192.169</span>.10.10:8002   replicates 8c878b45905bba3d7366c89ec51bd0cd7ce959f8Can I <span class="token builtin class-name">set</span> the above configuration? <span class="token punctuation">(</span>type <span class="token string">'yes'</span> to accept<span class="token punctuation">)</span>: </code></pre><p>输入 yes 后</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> Nodes configuration updated<span class="token operator">>></span><span class="token operator">></span> Assign a different config epoch to each <span class="token function">node</span><span class="token operator">>></span><span class="token operator">></span> Sending CLUSTER MEET messages to <span class="token function">join</span> the clusterWaiting <span class="token keyword">for</span> the cluster to <span class="token function">join</span><span class="token punctuation">..</span><span class="token operator">>></span><span class="token operator">></span> Performing Cluster Check <span class="token punctuation">(</span>using <span class="token function">node</span> <span class="token number">192.169</span>.10.10:7000<span class="token punctuation">)</span>M: dfdc9c0589219f727e4fd0ad8dafaf7e0cfb4f1c <span class="token number">192.169</span>.10.10:7000   slots:<span class="token punctuation">[</span><span class="token number">0</span>-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> master   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>M: 8c878b45905bba3d7366c89ec51bd0cd7ce959f8 <span class="token number">192.169</span>.10.10:7001   slots:<span class="token punctuation">[</span><span class="token number">5461</span>-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5462</span> slots<span class="token punctuation">)</span> master   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>S: ebc479e609ff8f6ca9283947530919c559a08f80 <span class="token number">192.169</span>.10.10:8002   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave   replicates aeeb7d7076d9b25a7805ac6f508497b43887e599S: 49385ed6e58469ef900ec48e5912e5f7b7505f6e <span class="token number">192.169</span>.10.10:8000   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave   replicates dfdc9c0589219f727e4fd0ad8dafaf7e0cfb4f1cM: aeeb7d7076d9b25a7805ac6f508497b43887e599 <span class="token number">192.169</span>.10.10:7002   slots:<span class="token punctuation">[</span><span class="token number">10923</span>-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> master   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>S: 8d6227aefc4830065624ff6c1dd795d2d5ad094a <span class="token number">192.169</span>.10.10:8001   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave   replicates 8c878b45905bba3d7366c89ec51bd0cd7ce959f8<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All nodes agree about slots configuration.<span class="token operator">>></span><span class="token operator">></span> Check <span class="token keyword">for</span> <span class="token function">open</span> slots<span class="token punctuation">..</span>.<span class="token operator">>></span><span class="token operator">></span> Check slots coverage<span class="token punctuation">..</span>.<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All <span class="token number">16384</span> slots covered.</code></pre><p>上面的操作是 Redis 提供的脚步式搭建, 隐藏了一些细节。如果想要体验完整的搭建过程, 可以参考 <a href="https://www.cnblogs.com/Yunya-Cnblogs/p/14608937.html">Redis 超详细的手动搭建Cluster集群步骤</a>, 完全的通过命令的方式搭建集群。</p><h3 id="1-4-Redis-Cluster-相关的命令"><a href="#1-4-Redis-Cluster-相关的命令" class="headerlink" title="1.4 Redis Cluster 相关的命令"></a>1.4 Redis Cluster 相关的命令</h3><p>集群命令</p><table><thead><tr><th align="center">命令</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">cluster info</td><td align="center">打印集群的信息</td></tr><tr><td align="center">cluster nodes</td><td align="center">列出集群当前已知的所有节点 (node), 以及这些节点的相关信息</td></tr><tr><td align="center">cluster meet <ip> <port></td><td align="center">将 ip 和 port 所指定的节点添加到集群当中, 让它成为集群的一份子, 这时候没有主从关系</td></tr><tr><td align="center">cluster forget <node_id></td><td align="center">从集群中移除 node_id 指定的节点 (保证空槽道)</td></tr><tr><td align="center">cluster replicate <node_id></td><td align="center">将当前节点设置为 node_id 指定的节点的从节点</td></tr><tr><td align="center">cluster saveconfig</td><td align="center">将节点的配置文件保存到硬盘里面</td></tr></tbody></table><p>槽slot命令</p><table><thead><tr><th align="center">命令</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">cluster addslots [slot …]</td><td align="center">将一个或多个槽 (slot) 指派 (assign) 给当前节点</td></tr><tr><td align="center">cluster delslots [slot …]</td><td align="center">移除一个或多个槽对当前节点的指派</td></tr><tr><td align="center">cluster flushslots</td><td align="center">移除指派给当前节点的所有槽, 让当前节点变成一个没有指派任何槽的节点</td></tr><tr><td align="center">cluster setslot node <node_id></td><td align="center">将槽 slot 指派给 node_id 指定的节点, 如果槽已经指派给另一个节点, 那么先让另一个节点删除该槽, 然后再进行指派</td></tr><tr><td align="center">cluster setslot migrating <node_id></td><td align="center">将本节点的槽 slot 迁移到 node_id 指定的节点中</td></tr><tr><td align="center">cluster setslot importing <node_id></td><td align="center">从 node_id 指定的节点中导入槽 slot 到本节点</td></tr><tr><td align="center">cluster setslot stable</td><td align="center">取消对槽 slot 的导入 (imort) 或者迁移 (migrate)</td></tr></tbody></table><p>键命令</p><table><thead><tr><th align="center">命令</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">cluster keyslot <key></td><td align="center">计算键 key 应该被放置在哪个槽上</td></tr><tr><td align="center">cluster countkeysinslot <slot></td><td align="center">返回槽 slot 目前包含的键值对数量</td></tr><tr><td align="center">cluster getkeysinslot <slot> <count></td><td align="center">返回 count 个 slot 槽中的键</td></tr></tbody></table><h2 id="2-故障转移"><a href="#2-故障转移" class="headerlink" title="2 故障转移"></a>2 故障转移</h2><p>集群的实现与哨兵思路类似: 通过定时任务发送 PING 消息检测其他节点状态。节点下线分为主观下线和客观下线, 客观下线后选取从节点进行故障转移。  </p><p>与哨兵一样, 集群只实现了主节点的故障转移, 从节点故障时只会被下线, 不会进行故障转移。因此, 使用集群时, 应谨慎使用读写分离技术, 因为从节点故障会导致读服务不可用, 可用性变差。</p><p>大体是:</p><blockquote><ol><li>slave 发现自己的 maste 变为 Fail 状态, 偏尝试进行 Failover, 以期成为新的 master</li><li>slave 将自己记录的集群 currentEpoch + 1, 然后广播 FAILOVER_AUTH_REQUEST 信息</li><li>其他节点收到改消息后, 只有 master 节点会进行响应, 判断请求这的合法性, 并发送 FAILOVER_AUTH_ACK, 对每一个 epoch 只发送一次 ack</li><li>尝试 Failover 的 slave 收集 FAILOVER_AUTH_ACK</li><li>超过半数后变成新的 master</li><li>广播 Pong 通知其他集群节点</li></ol></blockquote><p>节点数量: 在故障转移阶段, 需要由主节点投票选出哪个从节点成为新的主节点, 从节点选举胜出需要的票数为 N&#x2F;2+1, 其中 N 为主节点数量 (包括故障主节点), 但故障主节点实际上不能投票。<br>因此为了能够在故障发生时顺利选出从节点, 集群中至少需要3个主节点 (且部署在不同的物理机上)。</p><p>故障转移时间: 从主节点故障发生到完成转移, 所需要的时间主要消耗在主观下线识别、主观下线传播、选举延迟等几个环节。具体时间与参数 cluster-node-timeout 有关, 一般来说：<br>故障转移时间(毫秒) ≤ 1.5 * cluster-node-timeout + 1000<br>cluster-node-timeout 的默认值为 15000ms (15s), 因此故障转移时间会在 20s 量级</p><h2 id="3-Hash-Tag"><a href="#3-Hash-Tag" class="headerlink" title="3 Hash Tag"></a>3 Hash Tag</h2><p>有些 multi key 操作是不能跨阶段的, 如果要让某些数据统一分配到同一个节点上, 可以借助 Hast Tag 功能。</p><p>Hash Tag 原理是: 当一个 key 包含 {} 的时候, 不对整个 key 做 hash, 而仅对 {} 包括的字符串做 hash。<br>Hash Tag 可以让不同的 key 拥有相同的 hash 值, 从而分配在同一个槽里, 这样针对不同 key 的批量操作 (mget&#x2F;mset等), 以及事务、Lua 脚本等都可以支持。  </p><p>Hash Tag 可能会带来数据分配不均的问题, 这时可以</p><blockquote><ol><li>调整不同节点中槽的数量，使数据分布尽量均匀</li><li>避免对热点数据使用 Hash Tag, 导致请求分布不均</li></ol></blockquote><h2 id="4-Redis-Cluster-的不足"><a href="#4-Redis-Cluster-的不足" class="headerlink" title="4 Redis Cluster 的不足"></a>4 Redis Cluster 的不足</h2><blockquote><ol><li>Client 实现复杂, 驱动要求实现 Smart Client, 缓存 slots mapping 信息并及时更新, 提高了开发难度, 客户端的不成熟影响业务的稳定性</li><li>节点会因为某些原因发生阻塞 (阻塞时间大于 cluster-node-timeout), 被判断下线, 这种 failover 是没必要的</li><li>数据通过异步复制, 不保证数据的强一致性</li><li>多个业务使用同一套集群时, 无法根据统计区分冷热数据, 资源隔离性较差, 容易出现相互影响的情况</li></ol></blockquote><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><a href="https://www.cnblogs.com/kismetv/p/9853040.html">深入学习Redis（5）：集群</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 集群槽设计原理</title>
      <link href="/article/2024/2904586595/"/>
      <url>/article/2024/2904586595/</url>
      
        <content type="html"><![CDATA[<p>在 Redis 中, 为了支持高可用, 官方提供了 3 种方式</p><blockquote><ol><li>主从复制</li><li>哨兵模式</li><li>集群模式 (Cluster)</li></ol></blockquote><p>但是主从复制和哨兵模式都有一个问题: 无法水平扩缩容, 而这个问题在集群模式中得到了解决。</p><p>假设有 3 个 Redis 节点, 所有的数据均匀的分散在 3 个节点中。<br>如果现在需要往里面加入一个新的节点或移出一个已有的节点, 那么就需要对已有的数据做迁移。<br>这个迁移可以说是涉及到所有数据, 这是一个大成本的操作。</p><p>Redis 为了避免全数据量的迁移, 在集群中引入了一个槽的概念。<br>在 Redis 的集群模式 (Cluster) 中, Redis 内置了 16384 个哈希槽, 将以前数据存储在 Redis 节点的转为数据层存储在哈希槽 (实际最终还是在具体的节点中)。<br>当我们向 Redis 中存入一个 key-value, 会先通过 crc16 算法对 key 计算出一个值, 再通过这个值对 16384 取余数, 得到其存储到哪个哈希槽中。</p><p>这里面有个问题: 为什么引入槽设计后, 可以避免全量的数据迁移, 同时还有其他什么好处吗, 下面简单的做一个分析。</p><h2 id="1-数据分区"><a href="#1-数据分区" class="headerlink" title="1 数据分区"></a>1 数据分区</h2><p>Redis 集群如果需要支持水平的扩缩容, 就需要先解决一个问题: 数据分区, 即如何将大型数据集按一定的规则或策略进行分割或划分, 以便更有效地管理、存储和处理数据。</p><p>常见的数据分区有</p><blockquote><p>顺序分区<br>范围分区<br>哈希分区<br>…</p></blockquote><p>其中哈希分区由于其天然的随机性, 使用广泛。集群的分区方案便是哈希分区的一种。</p><p>哈希分区的基本思路是: 对数据的特征值 (如 Key) 进行哈希, 然后根据哈希值决定数据落在哪个节点。<br>常见的哈希分区包括: 哈希取余分区, 一致性哈希分区, 带虚拟节点的一致性哈希分区等。</p><p>衡量数据分区方法好坏的标准有很多, 其中比较重要的两个因素是 <strong>数据分布是否均匀</strong>, <strong>增加或删减节点对数据分布的影响</strong>。<br>由于哈希的随机性, 哈希分区基本可以保证数据分布均匀。 因此在比较哈希分区方案时, 重点要看增减节点对数据分布的影响。</p><h2 id="2-哈希取余分区"><a href="#2-哈希取余分区" class="headerlink" title="2 哈希取余分区"></a>2 哈希取余分区</h2><p>哈希取余分区, 对特征值进行哈希, 得到一个需要的哈希值, 然后通过这个哈希值取余已有的分区数, 得到另外一个值, 这个值就是当前数据后续所在的分区位置。<br>比如当前 Redis 集群中有 3 个节点, 往这个集群中存入一个 key-value, 假设对 key 哈希后得到的值为 15, 15 % 3 &#x3D; 0, 那么 key-value 这对键值对就存在 0 号节点。</p><p>该方案最大的问题是: 当新增或删减节点时, 节点数量发生变化, 系统中几乎所有的数据都需要重新计算映射关系, 引发大规模数据迁移。<br>比如当前有 3 个节点, 其中 (假设 hash 函数为 hash(数字) &#x3D; 数字)<br>节点 A 已有数据 (0, 3, 6, 9)<br>节点 B 已有数据 (1, 4, 7, 10, 13)<br>节点 C 已有数据 (2, 5, 8, 11)</p><p>现在向里面加入多一个节点, 变成了 4 个节点, 原本 hash(3) &#x3D; 3 % 3 (个节点)&#x3D; 0, 变为 hash(3) &#x3D; 3 % 4 &#x3D; 3。<br>因为多加了一个节点, 计算后 3 由原本的 A 节点变为了 D 节点, 所以需要将 3 从 A 迁移到 D 节点, 最终整个集群数据变为<br>节点 A (0, 4, 8)<br>节点 B (1, 5, 9, 13)<br>节点 C (2, 6, 10)<br>节点 D (3, 7, 11)</p><p>可以看到集群中的数据变动还是挺大的, 如果这个发生在 Redis 那种几百 G 的数据中, 需要迁移多久。</p><h2 id="3-一致性哈希分区"><a href="#3-一致性哈希分区" class="headerlink" title="3 一致性哈希分区"></a>3 一致性哈希分区</h2><p>为了解决哈希取余分区, 节点的变更, 带来大数据量迁移的问题, 就有了一致性哈希分区。</p><p>一致性哈希分区原理</p><ol><li>设定有 0 - 2^32-1 个整数, 将这些整数按照一个圆环的形式排列起来, 然后 0 和 2^32-1 相连, 这样就形成一个哈希环<br><img src="https://pic.imgdb.cn/item/66e1a371d9c307b7e9480908.png" alt="Alt &#39;哈希环&#39;"></li><li>将已有的几个 Redis 节点通过计算得到一个在 0 - 2^32-1 中的某个值, 这个值就是当前节点在哈希环上的位置</li><li>当有数据需要存储时, 先计算数据的哈希值, 得到一个在 0 - 2^32-1 中的某个值, 也就是在哈希环上某个位置<blockquote><p>3.1 如果这个位置有节点, 则这个位置就是数据的存储的节点<br>3.2 如果这个位置没有节点, 则在哈希环上的这个位置开始, 顺时针的方向向前找到第一个节点, 将数据存储到这个节点中<br><img src="https://pic.imgdb.cn/item/66e1a374d9c307b7e94813c6.png" alt="Alt &#39;一致性哈希分区&#39;"></p></blockquote></li></ol><p>与<strong>哈希取余分区</strong>相比, 一致性哈希分区将增减节点的影响限制在下一个节点。</p><ol><li>当新增一个节点时(设前一个节点到新增节点的区间为 A, 设新增节点到后一个节点区间为 B), 那么只需要将区间 A 的数据从后一个节点迁移到新增节点中即可</li></ol><p>如图: 新增一个节点 node-4, 此时只需要将数据 data 从原本的 node-1 迁移到 node-4 中即可<br><img src="https://pic.imgdb.cn/item/66e1a377d9c307b7e9481909.png" alt="Alt &#39;一致性哈希分区-新增节点&#39;"></p><ol start="2"><li>当减少一个节点时, 只需要将这个节点的数据存储到其顺时针方向的下一个节点即可</li></ol><p>如图: 新增一个节点 node-1, 此时只需要将数据 data 从原本的 node-1 迁移到 node-2 中即可<br><img src="https://pic.imgdb.cn/item/66e1a37dd9c307b7e9482333.png" alt="Alt &#39;一致性哈希分区-删除节点&#39;"></p><p>如图中, 在一致哈希算法中，如果增加或者移除一个节点，仅影响该节点的下一个节点。<br>但是一致性哈希算法不能保证节点能够在哈希环上分布均匀，这样就会带来一个问题: 数据倾斜, 可能存在某些节点的数据比其他节点多&#x2F;少的情况。<br>如果某个节点的数据量过大, 会导致这个节点的负载过高, 从而影响整个集群的性能, 如果这个节点挂掉, 会导致整个集群的大量的数据无法访问等问题。</p><h2 id="4-带虚拟节点的一致性哈希分区"><a href="#4-带虚拟节点的一致性哈希分区" class="headerlink" title="4 带虚拟节点的一致性哈希分区"></a>4 带虚拟节点的一致性哈希分区</h2><p>一致性哈希分区的问题在于节点不能在哈希环上分布均匀, 但是如果有大量的节点, 节点的分布就会更加均匀, 极端点, 环上的每个位置都有一个节点, 这样就可以保证节点的分布均匀。</p><p>但是实际中, 节点的数量是有限的, 为了解决这个问题, 引入了虚拟节点的概念,  **Redis 集群使用的便是该方案, 其中的虚拟节点称为槽 (slot)**。  </p><p>具体做法是，不再将真实节点映射到哈希环上, 而是将虚拟节点映射到哈希环上, 并将虚拟节点映射到实际节点, 形成 2 层的映射关系。<br>即数据的映射关系由数据 hash -&gt; 实际节点, 变成了数据 hash -&gt; 槽 -&gt; 实际节点。</p><p>假设现在有 3 个节点, 有 9 个虚拟节点, 那么每个节点就包含 3 个虚拟节点</p><ol><li>节点 A 保存 0-2 槽</li><li>节点 B 保存 3-5 槽</li><li>节点 C 保存 6-8 槽</li></ol><p>那么原本的哈希环, 就变成了这样,<br><img src="https://pic.imgdb.cn/item/66e1a386d9c307b7e9482fb4.png" alt="Alt &#39;带虚拟节点的一致性哈希分区&#39;"></p><p>可以看出: 虚拟节点越多，哈希环上的节点就越多，数据分布就越均匀，从而避免了数据倾斜的问题, (现实中, 虚拟节点会很多, 比如 Redis 就设置了 16384 个槽)。</p><p>另外, 虚拟节点除了提高节点的平衡, 还可以提高系统的稳定性, 比如: 当有节点数量变化时, 可能有不同的节点分担系统的变化, 提高了稳定性。<br>比如有一个哈希环, 上面的虚拟节点如下: A-1, B-1, C-1, A-2, C-2, B-2, A-3, C-3, B-3。<br>现在因为 A 节点挂掉, 那么 A-1, A-2, A-3 的数据就需要迁移到下一个节点中, A-1 &#x3D;&#x3D;&gt; B-1,  A-2 &#x3D;&#x3D;&gt; C-2, A-3 &#x3D;&#x3D;&gt; C-3。<br>迁移的压力就分担到的 B, C 节点, 而不是由某个节点进行处理。</p><p>同时, 因为有虚拟节点的存在, 还可以动态地调整每个节点分担的虚拟节点的数量, 比如: 高性能的机器可以分配更多的虚拟节点, 从而提高性能。</p><p>可以看出<strong>带虚拟节点的一致性哈希分区</strong></p><blockquote><ol><li>保证了节点的数据分布均匀</li><li>提高了系统的稳定性</li><li>提高了系统的灵活性</li></ol></blockquote><p>因为这些优点, Redis 集群采用了带虚拟节点的一致性哈希分区的方案。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><a href="https://github.com/xiaolincoder/CS-Base/blob/main/os/8_network_system/hash.md">9.4 什么是一致性哈希？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 主从复制 - relication 源码分析</title>
      <link href="/article/2024/3467330524/"/>
      <url>/article/2024/3467330524/</url>
      
        <content type="html"><![CDATA[<h2 id="1-replicationUnsetMaster-断开主从关系"><a href="#1-replicationUnsetMaster-断开主从关系" class="headerlink" title="1 replicationUnsetMaster  -  断开主从关系"></a>1 replicationUnsetMaster  -  断开主从关系</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 断开主从关系 */</span> <span class="token keyword">void</span> <span class="token function">replicationUnsetMaster</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 没有设置主节点的, 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 释放主节点的 host 配置</span>    <span class="token function">sdsfree</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost<span class="token punctuation">)</span><span class="token punctuation">;</span>f    server<span class="token punctuation">.</span>masterhost <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">// 把当前的 replid 复制到 replid2</span>    <span class="token comment">// 重新生成一个新的 40 位随机 id 并赋值到 replid</span>    <span class="token function">shiftReplicationId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 释放代表主节点的 client 对象</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span>         <span class="token function">freeClient</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将 server.cached_server 设置为空, 同时设置释放对应的内存</span>    <span class="token function">replicationDiscardCachedMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 取消主从复制的握手</span>    <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 关闭所有的从节点客户端</span>    <span class="token function">disconnectSlaves</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 当前节点的主从复制状态设置为 REPL_STATE_NONE</span>    server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_NONE<span class="token punctuation">;</span>    <span class="token comment">// 从节点选中的数据库为 - 1</span>    server<span class="token punctuation">.</span>slaveseldb <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_no_slaves_since <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span></code></pre><h3 id="1-1-shiftReplicationId-切换第一组-replid-和-offset-到第二组"><a href="#1-1-shiftReplicationId-切换第一组-replid-和-offset-到第二组" class="headerlink" title="1.1 shiftReplicationId - 切换第一组 replid 和 offset 到第二组"></a>1.1 shiftReplicationId - 切换第一组 replid 和 offset 到第二组</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">shiftReplicationId</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 将 replid 复制到 replid2</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid2<span class="token punctuation">,</span> server<span class="token punctuation">.</span>replid<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将原本的复制积压缓冲区的偏移量 master_repl_offset + 1 放到第二组的  second_replid_offset </span>    server<span class="token punctuation">.</span>second_replid_offset <span class="token operator">=</span> server<span class="token punctuation">.</span>master_repl_offset<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 重新生成一个 replid, 并赋值到 server.replid</span>    <span class="token function">changeReplicationId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="1-2-changeReplicationId-重新生成一个-replid"><a href="#1-2-changeReplicationId-重新生成一个-replid" class="headerlink" title="1.2 changeReplicationId - 重新生成一个 replid"></a>1.2 changeReplicationId - 重新生成一个 replid</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">changeReplicationId</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// CONFIG_RUN_ID_SIZE = 40, 重新随机生成一个 40 位的 id 并赋值到 replid</span>    <span class="token function">getRandomHexChars</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">,</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>replid<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="1-3-replicationDiscardCachedMaster-清空缓存的-cached-master"><a href="#1-3-replicationDiscardCachedMaster-清空缓存的-cached-master" class="headerlink" title="1.3 replicationDiscardCachedMaster - 清空缓存的 cached_master"></a>1.3 replicationDiscardCachedMaster - 清空缓存的 cached_master</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationDiscardCachedMaster</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>cached_master <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// CLIENT_MASTER = 1&lt;&lt;1 = 1</span>    <span class="token comment">// 先设置为 cashed_master 的 flags = flag &amp; (~CLIENT_MASTER), 简单理解就是把主节点的标识去掉</span>    server<span class="token punctuation">.</span>cached_master<span class="token operator">-></span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>CLIENT_MASTER<span class="token punctuation">;</span>    <span class="token comment">// 然后再释放 cached_master</span>    <span class="token function">freeClient</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>cached_master<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>cached_master <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="1-4-cancelReplicationHandshake-取消主从复制的握手"><a href="#1-4-cancelReplicationHandshake-取消主从复制的握手" class="headerlink" title="1.4 cancelReplicationHandshake -  取消主从复制的握手"></a>1.4 cancelReplicationHandshake -  取消主从复制的握手</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_TRANSFER<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 当前从节点的状态为 REPL_STATE_TRANSFER (正在接收从主节点发送过来的 RDB 文件)</span>        <span class="token comment">// 停止同步传输</span>        <span class="token comment">// 关闭从节点同步主节点的 socket 和临时文件描述符 repl_transfer_tmpfile</span>        <span class="token function">replicationAbortSyncTransfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新状态为 REPL_STATE_CONNECT (未连接上主节点)</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECT<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_CONNECTING <span class="token operator">||</span> <span class="token function">slaveIsInHandshakeState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 当前的状态为 REPL_STATE_CONNECTING (正在建立连接) 或者处于握手阶段</span>        <span class="token comment">// 关闭从节点同步主节点信息的 Socket, 对应的 Socket 文件描述符为 repl_transfer_s</span>        <span class="token function">undoConnectWithMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新状态为 REPL_STATE_CONNECT (未连接上主节点)</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECT<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 3. 其他的情况 </span>        <span class="token comment">// 其他状态返回 0</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="1-5-replicationAbortSyncTransfer-停止文件同步传输"><a href="#1-5-replicationAbortSyncTransfer-停止文件同步传输" class="headerlink" title="1.5 replicationAbortSyncTransfer - 停止文件同步传输"></a>1.5 replicationAbortSyncTransfer - 停止文件同步传输</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationAbortSyncTransfer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">serverAssert</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_TRANSFER<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 关闭从节点同步主节点信息的 Socket repl_transfer_s 和对应的文件描述符 repl_transfer_tmpfile</span>    <span class="token function">undoConnectWithMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unlink</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">zfree</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="1-6-undoConnectWithMaster-断开和主节点的连接"><a href="#1-6-undoConnectWithMaster-断开和主节点的连接" class="headerlink" title="1.6 undoConnectWithMaster - 断开和主节点的连接"></a>1.6 undoConnectWithMaster - 断开和主节点的连接</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">undoConnectWithMaster</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd <span class="token operator">=</span> server<span class="token punctuation">.</span>repl_transfer_s<span class="token punctuation">;</span>    <span class="token comment">// 删除 repl_transfer_s 这个文件描述符的事件</span>    <span class="token function">aeDeleteFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>AE_READABLE<span class="token operator">|</span>AE_WRITABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 关闭这个文件描述符</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 重置为 - 1 </span>    server<span class="token punctuation">.</span>repl_transfer_s <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="1-7-slaveIsInHandshakeState-判断当前从节点是否处于握手阶段"><a href="#1-7-slaveIsInHandshakeState-判断当前从节点是否处于握手阶段" class="headerlink" title="1.7 slaveIsInHandshakeState - 判断当前从节点是否处于握手阶段"></a>1.7 slaveIsInHandshakeState - 判断当前从节点是否处于握手阶段</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">slaveIsInHandshakeState</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 3 &lt;= server.repl_state &lt;= 13 </span>    <span class="token keyword">return</span> server<span class="token punctuation">.</span>repl_state <span class="token operator">>=</span> REPL_STATE_RECEIVE_PONG <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>repl_state <span class="token operator">&lt;=</span> REPL_STATE_RECEIVE_PSYNC<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="1-8-disconnectSlaves-关闭所有的从节点"><a href="#1-8-disconnectSlaves-关闭所有的从节点" class="headerlink" title="1.8 disconnectSlaves - 关闭所有的从节点"></a>1.8 disconnectSlaves - 关闭所有的从节点</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">disconnectSlaves</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 遍历自身所有的从节点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        listNode <span class="token operator">*</span>ln <span class="token operator">=</span> <span class="token function">listFirst</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">freeClient</span><span class="token punctuation">(</span><span class="token punctuation">(</span>client<span class="token operator">*</span><span class="token punctuation">)</span>ln<span class="token operator">-></span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="2-replicationSetMaster-保存主节点信息并进入待连接状态"><a href="#2-replicationSetMaster-保存主节点信息并进入待连接状态" class="headerlink" title="2 replicationSetMaster - 保存主节点信息并进入待连接状态"></a>2 replicationSetMaster - 保存主节点信息并进入待连接状态</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationSetMaster</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>ip<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">/</span> was_master <span class="token operator">=</span> 当前从节点的原本的主节点为 null    <span class="token keyword">int</span> was_master <span class="token operator">=</span> server<span class="token punctuation">.</span>masterhost <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">// 将入参的 IP 和 端口赋值给对应的字段</span>    <span class="token function">sdsfree</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>masterhost <span class="token operator">=</span> <span class="token function">sdsnew</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>masterport <span class="token operator">=</span> port<span class="token punctuation">;</span>    <span class="token comment">// 旧的主节点客户端存在, 进行释放</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">freeClient</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 解除所有阻塞状态的客户端</span>    <span class="token function">disconnectAllBlockedClients</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 释放所有的从节点信息 </span>    <span class="token function">disconnectSlaves</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 取消主从复制的握手</span>    <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// was_master = true, 也就是当前的从节点是第一次被设置为从节点</span>    <span class="token comment">// 创建出一个 cache_server, 用于后续数据复制</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>was_master<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 将 server.cached_server 设置为空, 同时设置释放对应的内存</span>        <span class="token function">replicationDiscardCachedMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 根据当前参数合成出一个 client, 同时将其放到 cached_master</span>        <span class="token function">replicationCacheMasterUsingMyself</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 设置当前的主从复制状态为待连接上主节点 (REPL_STATE_CONNECT)</span>    server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECT<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-1-disconnectAllBlockedClients-释放所有阻塞状态的客户端"><a href="#2-1-disconnectAllBlockedClients-释放所有阻塞状态的客户端" class="headerlink" title="2.1 disconnectAllBlockedClients - 释放所有阻塞状态的客户端"></a>2.1 disconnectAllBlockedClients - 释放所有阻塞状态的客户端</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">disconnectAllBlockedClients</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>    listIter li<span class="token punctuation">;</span>    <span class="token comment">// 将 server.clients 的信息转移到 li 上</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 遍历 li</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 客户端为阻塞状态</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_BLOCKED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token function">addReplySds</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token function">sdsnew</span><span class="token punctuation">(</span><span class="token string">"-UNBLOCKED force unblock from blocking operation, instance state changed (master -> replica?)\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 解除所有阻塞状态的客户端</span>            <span class="token function">unblockClient</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            c<span class="token operator">-></span>flags <span class="token operator">|=</span> CLIENT_CLOSE_AFTER_REPLY<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-2-replicationCacheMasterUsingMyself-为-server-cached-master-赋值一个默认合成的客户端"><a href="#2-2-replicationCacheMasterUsingMyself-为-server-cached-master-赋值一个默认合成的客户端" class="headerlink" title="2.2 replicationCacheMasterUsingMyself - 为 server.cached_master 赋值一个默认合成的客户端"></a>2.2 replicationCacheMasterUsingMyself - 为 server.cached_master 赋值一个默认合成的客户端</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationCacheMasterUsingMyself</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 设置当前的 master_initial_offset 等于 master_repl_offset</span>    server<span class="token punctuation">.</span>master_initial_offset <span class="token operator">=</span> server<span class="token punctuation">.</span>master_repl_offset<span class="token punctuation">;</span>    <span class="token comment">// 创建一个新的主节点客户端, 并存放发到 server.master 中</span>    <span class="token function">replicationCreateMasterClient</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将 server.replid 拷贝到创建出来的节点的 replid</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token operator">-></span>replid<span class="token punctuation">,</span> server<span class="token punctuation">.</span>replid<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 通过 replicationCreateMasterClient 创建出来的客户端, unlinkClient 里面的逻辑都不符合条件, 直接结束了</span>    <span class="token comment">// 可以看成是没有这个方法的逻辑</span>    <span class="token function">unlinkClient</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置 cached_master = master, 同时置空 master </span>    server<span class="token punctuation">.</span>cached_master <span class="token operator">=</span> server<span class="token punctuation">.</span>master<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>master <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-3-replicationCreateMasterClient-创建主节点客户端"><a href="#2-3-replicationCreateMasterClient-创建主节点客户端" class="headerlink" title="2.3 replicationCreateMasterClient - 创建主节点客户端"></a>2.3 replicationCreateMasterClient - 创建主节点客户端</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** *  创建主节点客户端 */</span><span class="token keyword">void</span> <span class="token function">replicationCreateMasterClient</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> dbid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 创建新的客户端, 赋值到 master, createClient 创建出来的 flag 默认为 0 </span>    <span class="token comment">// 具体的创建逻辑可以查看 networking.c 中的 createClient 函数</span>    server<span class="token punctuation">.</span>master <span class="token operator">=</span> <span class="token function">createClient</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 此时 flag = CLIENT_MASTER = 1, 主节点</span>    server<span class="token punctuation">.</span>master<span class="token operator">-></span>flags <span class="token operator">|=</span> CLIENT_MASTER<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>master<span class="token operator">-></span>authenticated <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>master<span class="token operator">-></span>reploff <span class="token operator">=</span> server<span class="token punctuation">.</span>master_initial_offset<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>master<span class="token operator">-></span>read_reploff <span class="token operator">=</span> server<span class="token punctuation">.</span>master<span class="token operator">-></span>reploff<span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token operator">-></span>replid<span class="token punctuation">,</span> server<span class="token punctuation">.</span>master_replid<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master_replid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果一个主节点的偏移量为 -1, 那么这个主节点是旧的, 并且是无法进行 psync 的, 所以将其设置为 CLIENT_PRE_PSYNC (1 &lt;&lt; 16, 65536)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token operator">-></span>reploff <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">// | CLIENT_PRE_PSYNC 后, flags 等于 65537</span>        server<span class="token punctuation">.</span>master<span class="token operator">-></span>flags <span class="token operator">|=</span> CLIENT_PRE_PSYNC<span class="token punctuation">;</span>    <span class="token comment">// 指定当前的数据库 (0 - 16 个数据库)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dbid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token function">selectDb</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">,</span> dbid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="3-connectWithMaster-尝试和主节点建立-TCP-连接"><a href="#3-connectWithMaster-尝试和主节点建立-TCP-连接" class="headerlink" title="3 connectWithMaster -  尝试和主节点建立 TCP 连接"></a>3 connectWithMaster -  尝试和主节点建立 TCP 连接</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">connectWithMaster</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    <span class="token comment">// 建立非阻塞的 Tcp 连接</span>    fd <span class="token operator">=</span> <span class="token function">anetTcpNonBlockBestEffortBindConnect</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>masterhost<span class="token punctuation">,</span> server<span class="token punctuation">.</span>masterport<span class="token punctuation">,</span> NET_FIRST_BIND_ADDR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 文件描述符为 -1, 建立连接失败</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 为 Tcp 连接的文件描述符注册一个的可读可写的事件, 处理的逻辑函数为 syncWithMaster</span>    <span class="token comment">// 注意这里注册的类型为 AE_READABLE|AE_WRITABLE, 在 epoll 中, 底层注册的是 EPOLLIN | EPOLLOUT</span>    <span class="token comment">// epoll 有个机制, 同时注册 EPOLLIN | EPOLLOUT 事件, 会立即触发一次 EPOLLOUT 事件, 也就是 AE_WRITABLE 事件</span>    <span class="token comment">// 也就是在下次事件轮询中会执行一次 syncWithMaster 函数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> fd<span class="token punctuation">,</span>AE_READABLE<span class="token operator">|</span>AE_WRITABLE<span class="token punctuation">,</span> syncWithMaster<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> AE_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 更新从节点和主节点最近一次进行数据同步的时间, 默认为当前时间</span>    server<span class="token punctuation">.</span>repl_transfer_lastio <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_transfer_s <span class="token operator">=</span> fd<span class="token punctuation">;</span>    <span class="token comment">// 当前从节点的主从复制的状态为 REPL_STATE_CONNECTING (正在连接主节点)</span>    server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECTING<span class="token punctuation">;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="4-sendSynchronousCommand-发送命令到主节点"><a href="#4-sendSynchronousCommand-发送命令到主节点" class="headerlink" title="4 sendSynchronousCommand - 发送命令到主节点"></a>4 sendSynchronousCommand - 发送命令到主节点</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span><span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 发送写命令</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> SYNC_CMD_WRITE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 发送 ping 命令时, 入参为 (SYNC_CMD_WRITE,fd,"PING",NULL)</span>        <span class="token comment">// flags = SYNC_CMD_WRITE</span>                <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">;</span>        <span class="token comment">// 下面的 va_ 开头的函数, 都是用来处理动态入参的</span>        va_list ap<span class="token punctuation">;</span>        sds cmd <span class="token operator">=</span> <span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sds cmdargs <span class="token operator">=</span> <span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">size_t</span> argslen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">va_start</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            arg <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arg <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>                 <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment">// 拼接 cmd 命令的参数</span>            cmdargs <span class="token operator">=</span> <span class="token function">sdscatprintf</span><span class="token punctuation">(</span>cmdargs<span class="token punctuation">,</span><span class="token string">"$%zu\r\n%s\r\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">,</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>            argslen<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">va_end</span><span class="token punctuation">(</span>ap<span class="token punctuation">)</span><span class="token punctuation">;</span>        cmd <span class="token operator">=</span> <span class="token function">sdscatprintf</span><span class="token punctuation">(</span>cmd<span class="token punctuation">,</span><span class="token string">"*%zu\r\n"</span><span class="token punctuation">,</span>argslen<span class="token punctuation">)</span><span class="token punctuation">;</span>        cmd <span class="token operator">=</span> <span class="token function">sdscatsds</span><span class="token punctuation">(</span>cmd<span class="token punctuation">,</span>cmdargs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>cmdargs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 发送给对应的文件描述符, 这里的 fd 是 Socket 通道</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">syncWrite</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> cmd<span class="token punctuation">,</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>repl_syncio_timeout<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">sdsfree</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">sdscatprintf</span><span class="token punctuation">(</span><span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"-Writing to master: %s"</span><span class="token punctuation">,</span><span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 接受读操作</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> SYNC_CMD_READ<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 读取数据到 buf 中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">syncReadLine</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span>server<span class="token punctuation">.</span>repl_syncio_timeout<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">sdscatprintf</span><span class="token punctuation">(</span><span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"-Reading from master: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        server<span class="token punctuation">.</span>repl_transfer_lastio <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">sdsnew</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="5-slaveTryPartialResynchronization-根据条件判断是发送部分同步复制还是全量同步复制-同时支持读取主节点发送信息"><a href="#5-slaveTryPartialResynchronization-根据条件判断是发送部分同步复制还是全量同步复制-同时支持读取主节点发送信息" class="headerlink" title="5 slaveTryPartialResynchronization - 根据条件判断是发送部分同步复制还是全量同步复制, 同时支持读取主节点发送信息"></a>5 slaveTryPartialResynchronization - 根据条件判断是发送部分同步复制还是全量同步复制, 同时支持读取主节点发送信息</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">slaveTryPartialResynchronization</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> read_reply<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 入参的 read_reply 0: 表示向主节点写读取 1: 表示读取主节点的数据</span>    <span class="token keyword">char</span> <span class="token operator">*</span>psync_replid<span class="token punctuation">;</span>    <span class="token keyword">char</span> psync_offset<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    sds reply<span class="token punctuation">;</span>    <span class="token comment">// 写操作</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>read_reply<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 设置初始的偏移量为 -1</span>        <span class="token comment">// -1 表示示主节点的 replid 和全局复制偏移量是无效的</span>        server<span class="token punctuation">.</span>master_initial_offset <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 主节点的缓存不为空，可以尝试进行部分重同步</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>cached_master<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// psync_replid 为缓存的主节点的 replid</span>            psync_replid <span class="token operator">=</span> server<span class="token punctuation">.</span>cached_master<span class="token operator">-></span>replid<span class="token punctuation">;</span>            <span class="token comment">// 获取部分同步的开始位置 , 赋值给 psync_offset</span>            <span class="token function">snprintf</span><span class="token punctuation">(</span>psync_offset<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>psync_offset<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"%lld"</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>cached_master<span class="token operator">-></span>reploff<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 没有主节点缓存, 进行全量同步</span>            psync_replid <span class="token operator">=</span> <span class="token string">"?"</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>psync_offset<span class="token punctuation">,</span><span class="token string">"-1"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 部分复制, 最终发送的命令 psync replid repl_offset</span>        <span class="token comment">// 全量复制, 最终发送的命令 psync ? -1</span>        reply <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_WRITE<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token string">"PSYNC"</span><span class="token punctuation">,</span>psync_replid<span class="token punctuation">,</span>psync_offset<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 写失败, 删除对应的文件描述符的读监听</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>reply <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">sdsfree</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">aeDeleteFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>AE_READABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> PSYNC_WRITE_ERROR<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> PSYNC_WAIT_REPLY<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 下面的读操作可以等待下面的 psync 命令应答在回来看, 现在下面不影响整个的流程</span>    <span class="token comment">// 读操作</span>    reply <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_READ<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sdslen</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 没有响应数据</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> PSYNC_WAIT_REPLY<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// strncmp 比较字符串是否一样, 一样返回 0, 不一样, 返回值为非 0 </span>    <span class="token comment">// 比较 reply 前 11 个字符是否为 +FULLRESYNC</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strncmp</span><span class="token punctuation">(</span>reply<span class="token punctuation">,</span><span class="token string">"+FULLRESYNC"</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 响应的数据前面的内容为 +FULLRESYNC</span>        <span class="token keyword">char</span> <span class="token operator">*</span>replid <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">*</span>offset <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token comment">// 这个是 psync 命令, 全量复制的响应 </span>        <span class="token comment">// 定位到第一个空格的位置</span>        replid <span class="token operator">=</span> <span class="token function">strchr</span><span class="token punctuation">(</span>reply<span class="token punctuation">,</span><span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取响应的 replid</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>replid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 定位到 replid 的位置</span>            replid<span class="token operator">++</span><span class="token punctuation">;</span>            offset <span class="token operator">=</span> <span class="token function">strchr</span><span class="token punctuation">(</span>replid<span class="token punctuation">,</span><span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>offset<span class="token punctuation">)</span>                 <span class="token comment">// 定位到 offset 的位置</span>                offset<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// replid 为  0 || offset 为 0 || offset - replid - 1 不等于 40 (replid 的长度为 40)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>replid <span class="token operator">||</span> <span class="token operator">!</span>offset <span class="token operator">||</span> <span class="token punctuation">(</span>offset<span class="token operator">-</span>replid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 设置 replid 为 0</span>            <span class="token function">memset</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master_replid<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>CONFIG_RUN_ID_SIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 将 replid 复制给 server.master_replid </span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master_replid<span class="token punctuation">,</span> replid<span class="token punctuation">,</span> offset<span class="token operator">-</span>replid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            server<span class="token punctuation">.</span>master_replid<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>            <span class="token comment">// server.master_initial_offset = 获取到的 offset</span>            server<span class="token punctuation">.</span>master_initial_offset <span class="token operator">=</span> <span class="token function">strtoll</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 全量复制了, 缓存的主节点没有意义, 清空了</span>        <span class="token comment">// 将 server.cached_server 设置为空, 同时设置释放对应的内存</span>        <span class="token function">replicationDiscardCachedMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> PSYNC_FULLRESYNC<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 响应的前面的数据为 +CONTINUE</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strncmp</span><span class="token punctuation">(</span>reply<span class="token punctuation">,</span><span class="token string">"+CONTINUE"</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> <span class="token operator">*</span>start <span class="token operator">=</span> reply<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>end <span class="token operator">=</span> reply<span class="token operator">+</span><span class="token number">9</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>end<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\r'</span> <span class="token operator">&amp;&amp;</span> end<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\n'</span> <span class="token operator">&amp;&amp;</span> end<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>             end<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token comment">// 结束的位置 - 开始的位置 = 40 </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">==</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 新的 replid </span>            <span class="token keyword">char</span> new<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span>start<span class="token punctuation">,</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            new<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>            <span class="token comment">// replid 和当前的缓存主节点 cached_master 的 replid 不一致</span>            <span class="token comment">// 只能进行全量复制</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span> server<span class="token punctuation">.</span>cached_master<span class="token operator">-></span>replid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 缓存的主节点的 replid 和参数的 replid 不一致</span>                <span class="token comment">// 将当前的 cached_master 的 replid 赋值给 replid2</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid2<span class="token punctuation">,</span> server<span class="token punctuation">.</span>cached_master<span class="token operator">-></span>replid<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                server<span class="token punctuation">.</span>second_replid_offset <span class="token operator">=</span> server<span class="token punctuation">.</span>master_repl_offset<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// 新的 replid 赋值到 server.replid</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">,</span> new<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 设置缓存的客户端的 cached_master 的 replid = server.replid</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>cached_master<span class="token operator">-></span>replid<span class="token punctuation">,</span> new<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 释放从节点</span>                <span class="token function">disconnectSlaves</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                 <span class="token function">sdsfree</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 重新将 cached_master 作为主节点使用</span>        <span class="token function">replicationResurrectCachedMaster</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>             <span class="token comment">// 没有复制积压缓冲区, 进行创建</span>            <span class="token function">createReplicationBacklog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> PSYNC_CONTINUE<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>        <span class="token comment">// 主节点无法响应 psync 命令</span>    <span class="token comment">// 主节点处于一个特殊的状态, 无法处理对应的请求</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strncmp</span><span class="token punctuation">(</span>reply<span class="token punctuation">,</span><span class="token string">"-NOMASTERLINK"</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">strncmp</span><span class="token punctuation">(</span>reply<span class="token punctuation">,</span><span class="token string">"-LOADING"</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> PSYNC_TRY_LATER<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 响应了异常</span>    <span class="token function">sdsfree</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将 server.cached_server 设置为空, 同时设置释放对应的内存</span>    <span class="token function">replicationDiscardCachedMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> PSYNC_NOT_SUPPORTED<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre><h3 id="5-1-replicationResurrectCachedMaster-重新将-cached-master-作为主节点使用"><a href="#5-1-replicationResurrectCachedMaster-重新将-cached-master-作为主节点使用" class="headerlink" title="5.1 replicationResurrectCachedMaster - 重新将 cached_master 作为主节点使用"></a>5.1 replicationResurrectCachedMaster - 重新将 cached_master 作为主节点使用</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationResurrectCachedMaster</span><span class="token punctuation">(</span><span class="token keyword">int</span> newfd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    server<span class="token punctuation">.</span>master <span class="token operator">=</span> server<span class="token punctuation">.</span>cached_master<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>cached_master <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>master<span class="token operator">-></span>fd <span class="token operator">=</span> newfd<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>master<span class="token operator">-></span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span>CLIENT_CLOSE_AFTER_REPLY<span class="token operator">|</span>CLIENT_CLOSE_ASAP<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>master<span class="token operator">-></span>authenticated <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>master<span class="token operator">-></span>lastinteraction <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    <span class="token comment">// 修改状态为 REPL_STATE_CONNECTED (已连接上主节点)</span>    server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECTED<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_down_since <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">linkClient</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 添加事件</span>    <span class="token comment">// 为当前的主节点添加一个读事件, 触发逻辑为 readQueryFromClient</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> newfd<span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">,</span> readQueryFromClient<span class="token punctuation">,</span> server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 当前的主节点有数据需要发送 </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 添加一个写事件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> newfd<span class="token punctuation">,</span> AE_WRITABLE<span class="token punctuation">,</span> sendReplyToClient<span class="token punctuation">,</span> server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="5-2-clientHasPendingReplies-判断当前的入参的客户端是否有数据需要发送"><a href="#5-2-clientHasPendingReplies-判断当前的入参的客户端是否有数据需要发送" class="headerlink" title="5.2 clientHasPendingReplies - 判断当前的入参的客户端是否有数据需要发送"></a>5.2 clientHasPendingReplies - 判断当前的入参的客户端是否有数据需要发送</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 固定缓存区有数据 或者 回复列表有数据</span>    <span class="token keyword">return</span> c<span class="token operator">-></span>bufpos <span class="token operator">||</span> <span class="token function">listLength</span><span class="token punctuation">(</span>c<span class="token operator">-></span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="5-3-createReplicationBacklog-创建复制积压缓冲区"><a href="#5-3-createReplicationBacklog-创建复制积压缓冲区" class="headerlink" title="5.3 createReplicationBacklog - 创建复制积压缓冲区"></a>5.3 createReplicationBacklog - 创建复制积压缓冲区</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">createReplicationBacklog</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">serverAssert</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_backlog <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_backlog_histlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_backlog_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 虽然没有任何数据, 但是第一个字节是数据写入的位置</span>    server<span class="token punctuation">.</span>repl_backlog_off <span class="token operator">=</span> server<span class="token punctuation">.</span>master_repl_offset<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="6-clearReplicationId2-清除-replid2-和-second-replid-offset"><a href="#6-clearReplicationId2-清除-replid2-和-second-replid-offset" class="headerlink" title="6 clearReplicationId2 - 清除 replid2 和 second_replid_offset"></a>6 clearReplicationId2 - 清除 replid2 和 second_replid_offset</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 清除 replid2 和 second_replid_offset */</span><span class="token keyword">void</span> <span class="token function">clearReplicationId2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid2<span class="token punctuation">,</span><span class="token char">'0'</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>replid2<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>second_replid_offset <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="7-masterTryPartialResynchronization-尝试和从节点进行部分同步复制"><a href="#7-masterTryPartialResynchronization-尝试和从节点进行部分同步复制" class="headerlink" title="7 masterTryPartialResynchronization - 尝试和从节点进行部分同步复制"></a>7 masterTryPartialResynchronization - 尝试和从节点进行部分同步复制</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">masterTryPartialResynchronization</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// client 进到这里面执行的命令为 psync ? -1 或 psync master_repl_id repl_offset</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> psync_offset<span class="token punctuation">,</span> psync_len<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>master_replid <span class="token operator">=</span> c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> buflen<span class="token punctuation">;</span>    <span class="token comment">// 读取入参的第 3 个参数到 psync_offset</span>    <span class="token comment">// 读取失败, 直接全量同步</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getLongLongFromObjectOrReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>psync_offset<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span>         <span class="token keyword">goto</span> need_full_resync<span class="token punctuation">;</span>    <span class="token comment">// 在入参的 repl_id 和当前主节点的 replid 不一样的条件下</span>    <span class="token comment">// 1. 入参的 repl_id 和当前主节点一样的 replid2 不一样</span>    <span class="token comment">// 2. 请求的偏移量 大于 second_replid_offset (也就是 replid2)</span>    <span class="token comment">// replid2 可以看出当前节点同步了旧主节点数据的位置, second_replid_offset 可以看出是从节点同步了旧节点数据的位置</span>    <span class="token comment">// 如果 second_replid_offset > replid2, 表示从节点同步的数据快于当前节点的, 从节点的数据比主节点多, 不合理, 直接全量同步</span>    <span class="token comment">// 满足其中一种情况, 直接进入全量赋值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>master_replid<span class="token punctuation">,</span> server<span class="token punctuation">.</span>replid<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>master_replid<span class="token punctuation">,</span> server<span class="token punctuation">.</span>replid2<span class="token punctuation">)</span> <span class="token operator">||</span> psync_offset <span class="token operator">></span> server<span class="token punctuation">.</span>second_replid_offset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 这 2 种请求都不能进行部分同步, 直接进入全量同步</span>        <span class="token keyword">goto</span> need_full_resync<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// psync_offset 可以看做是从复制积压缓冲区的哪个位置开始复制</span>    <span class="token comment">// 当前复制积压缓冲区没有数据</span>    <span class="token comment">// 请求的偏移量小于 repl_backlog_off (复制积压缓冲区 backlog 的第一个字节的逻辑位置是下次复制的开始位置), 说明 backlog 所备份的数据的已经太新了, 有一些数据被覆盖，则需要进行全量复制</span>    <span class="token comment">// 请求的偏移量大于 repl_backlog_off + repl_backlog_histlen (backlog 的实际数据大小) 表示当前 backlog 的数据不够全，则需要进行全量复制</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>server<span class="token punctuation">.</span>repl_backlog <span class="token operator">||</span> psync_offset <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>repl_backlog_off <span class="token operator">||</span> psync_offset <span class="token operator">></span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_off <span class="token operator">+</span> server<span class="token punctuation">.</span>repl_backlog_histlen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> need_full_resync<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 部分复制</span>    <span class="token comment">// 设置为从节点标识 </span>    c<span class="token operator">-></span>flags <span class="token operator">|=</span> CLIENT_SLAVE<span class="token punctuation">;</span>    <span class="token comment">// 设置状态为 在线状态</span>    c<span class="token operator">-></span>replstate <span class="token operator">=</span> SLAVE_STATE_ONLINE<span class="token punctuation">;</span>    <span class="token comment">// 设置当前客户端, 也就是从节点的 应答时间为当前时间</span>    c<span class="token operator">-></span>repl_ack_time <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    <span class="token comment">// 设置当前客户端, 也就是从节点需要向主节点发送 ack 的标志 为 0, 没有 ack</span>    c<span class="token operator">-></span>repl_put_online_on_ack <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 当前节点的从节点列表添加当前的节点</span>    <span class="token function">listAddNodeTail</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 从节点的复制能力支持 psync2</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>slave_capa <span class="token operator">&amp;</span> SLAVE_CAPA_PSYNC2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 发送内容 +CONTINUE 主节点当前的 repl_id \r\n</span>        buflen <span class="token operator">=</span> <span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"+CONTINUE %s\r\n"</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>replid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 不支持</span>        <span class="token comment">// 发送内容 +CONTINUE\r\n</span>        buflen <span class="token operator">=</span> <span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"+CONTINUE\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 发送数据给从节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">write</span><span class="token punctuation">(</span>c<span class="token operator">-></span>fd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>buflen<span class="token punctuation">)</span> <span class="token operator">!=</span> buflen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    psync_len <span class="token operator">=</span> <span class="token function">addReplyReplicationBacklog</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>psync_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 计算延迟值小于 min-slaves-max-lag 的从节点的个数</span>    <span class="token function">refreshGoodSlavesCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>              need_full_resync<span class="token operator">:</span>    <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="7-1-addReplyReplicationBacklog-进行部分同步复制"><a href="#7-1-addReplyReplicationBacklog-进行部分同步复制" class="headerlink" title="7.1 addReplyReplicationBacklog - 进行部分同步复制"></a>7.1 addReplyReplicationBacklog - 进行部分同步复制</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">addReplyReplicationBacklog</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> offset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> j<span class="token punctuation">,</span> skip<span class="token punctuation">,</span> len<span class="token punctuation">;</span>    <span class="token comment">// 复制积压缓冲区没有数据实际没有数据, 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_histlen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* Compute the amount of bytes we need to discard. */</span>    <span class="token comment">// 跳过初始位置多少个字节</span>    skip <span class="token operator">=</span> offset <span class="token operator">-</span> server<span class="token punctuation">.</span>repl_backlog_off<span class="token punctuation">;</span>    <span class="token comment">// 因为复用着这一个复制积压缓冲区 repl_backlog, 写满了, 新的数据又重开始位置进行写</span>    <span class="token comment">// repl_backlog 的容量 repl_backlog_size 和当前容量 repl_backlog_histlen 基本不会大于 repl_backlog 的容量大小</span>    <span class="token comment">// 但是几个代表位置的字段 repl_backlog_idx repl_backlog_off 会大于 repl_backlog_size</span>    <span class="token comment">// 所以下面位置的计算才那么复杂</span>    <span class="token comment">// 计算出我们的复制积压缓冲区中数据实际最旧的位置, 在复制积压缓冲区的位置</span>    <span class="token comment">// （下一个字节写入的位置 + 复制积压缓冲区的大小 - 复制积压缓冲区当前实际的容量）% 复制积压缓冲区的大小</span>    j <span class="token operator">=</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_idx <span class="token operator">+</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_size <span class="token operator">-</span> server<span class="token punctuation">.</span>repl_backlog_histlen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> server<span class="token punctuation">.</span>repl_backlog_size<span class="token punctuation">;</span>     <span class="token comment">// 计算当前复制的开始位置</span>    j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> skip<span class="token punctuation">)</span> <span class="token operator">%</span> server<span class="token punctuation">.</span>repl_backlog_size<span class="token punctuation">;</span>    <span class="token comment">// 需要发送发送的数据长度</span>    len <span class="token operator">=</span> server<span class="token punctuation">.</span>repl_backlog_histlen <span class="token operator">-</span> skip<span class="token punctuation">;</span>    <span class="token comment">// 不为空</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// (复制积压缓冲区的容量 - 开始发送的位置) &lt; 需要发送的数据的长度 的话, 表示当前可以发送的数据有部分在复制积压缓冲区的开头</span>        <span class="token comment">// 计算这次发送的数据长度</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> thislen <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_size <span class="token operator">-</span> j<span class="token punctuation">)</span> <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_size <span class="token operator">-</span> j<span class="token punctuation">)</span> <span class="token operator">:</span> len<span class="token punctuation">;</span>        <span class="token comment">// 发送数据</span>        <span class="token function">addReplySds</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token function">sdsnewlen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog <span class="token operator">+</span> j<span class="token punctuation">,</span> thislen<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 重新计算下次需要发送的数据长度</span>        len <span class="token operator">-=</span> thislen<span class="token punctuation">;</span>        <span class="token comment">// 开始的位置重新从 0 开始</span>        j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 返回写入的长度</span>    <span class="token keyword">return</span> server<span class="token punctuation">.</span>repl_backlog_histlen <span class="token operator">-</span> skip<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="8-replicationSetupSlaveForFullResync-将最新的-repl-id-和-repl-offset-发送给从节点"><a href="#8-replicationSetupSlaveForFullResync-将最新的-repl-id-和-repl-offset-发送给从节点" class="headerlink" title="8 replicationSetupSlaveForFullResync - 将最新的 repl_id 和 repl_offset 发送给从节点"></a>8 replicationSetupSlaveForFullResync - 将最新的 repl_id 和 repl_offset 发送给从节点</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">replicationSetupSlaveForFullResync</span><span class="token punctuation">(</span>client <span class="token operator">*</span>slave<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> offset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> buflen<span class="token punctuation">;</span>    <span class="token comment">// 更新入参的客户端的 psync 偏移量为 offset </span>    slave<span class="token operator">-></span>psync_initial_offset <span class="token operator">=</span> offset<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> buflen<span class="token punctuation">;</span>    <span class="token comment">// 更新入参的客户端的 psync 偏移量为 offset </span>    slave<span class="token operator">-></span>psync_initial_offset <span class="token operator">=</span> offset<span class="token punctuation">;</span>    <span class="token comment">// 更新状态为 SLAVE_STATE_WAIT_BGSAVE_END (等待 bgsave 结束)</span>    slave<span class="token operator">-></span>replstate <span class="token operator">=</span> SLAVE_STATE_WAIT_BGSAVE_END<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>slaveseldb <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// 如果从节点的状态是 CLIENT_PRE_PSYNC，则表示是 Redis 是 2.8 之前的版本，则不将这些信息发送给从节点</span>    <span class="token comment">// 在 2.8 之前只支持 SYNC 的全量复制同步，而在之后的版本提供了部分的重同步</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>slave<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_PRE_PSYNC<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 发送全量复制的消息给从节点</span>        <span class="token comment">// 发送 +FULLRESYNC replid offset\r\n 给从节点 </span>        buflen <span class="token operator">=</span> <span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"+FULLRESYNC %s %lld\r\n"</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>replid<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">write</span><span class="token punctuation">(</span>slave<span class="token operator">-></span>fd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>buflen<span class="token punctuation">)</span> <span class="token operator">!=</span> buflen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>slave<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="9-startBgsaveForReplication-通过执行-Bgsave-进行全量同步"><a href="#9-startBgsaveForReplication-通过执行-Bgsave-进行全量同步" class="headerlink" title="9 startBgsaveForReplication - 通过执行 Bgsave 进行全量同步"></a>9 startBgsaveForReplication - 通过执行 Bgsave 进行全量同步</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">startBgsaveForReplication</span><span class="token punctuation">(</span><span class="token keyword">int</span> mincapa<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> retval<span class="token punctuation">;</span>    <span class="token comment">// 是否支持 socket 同步, 支持无盘同步同时同步复制能力支持 EOF</span>    <span class="token keyword">int</span> socket_target <span class="token operator">=</span> server<span class="token punctuation">.</span>repl_diskless_sync <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>mincapa <span class="token operator">&amp;</span> SLAVE_CAPA_EOF<span class="token punctuation">)</span><span class="token punctuation">;</span>    listIter li<span class="token punctuation">;</span>    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>    rdbSaveInfo rsi<span class="token punctuation">,</span> <span class="token operator">*</span>rsiptr<span class="token punctuation">;</span>    <span class="token comment">// 创建出一个初始的 rdbSaveInfo</span>    rsiptr <span class="token operator">=</span> <span class="token function">rdbPopulateSaveInfo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rsi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rsiptr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 创建处理的 rdbSaveInfo 不为空</span>                <span class="token comment">// 支持 socket </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>socket_target<span class="token punctuation">)</span>            <span class="token comment">// 大体的流程和正常的 RDB 相关, 就不张开了, 太长了, 可以查看 rdb.c 这个文件进行了解</span>            <span class="token comment">// 1. 在节点客户端列表中找到所有状态为 SLAVE_STATE_WAIT_BGSAVE_START (等待 bgsave 开始, 也就是开始创建 RDB 文件) 并且支持 psync 命令的客户端, 向他们发送 +FULLRESYNC replid offset\r\n, 并修改状态为 SLAVE_STATE_WAIT_BGSAVE_END (等待 RDB 创建文件结束), 同时设置他们的 Socket 为阻塞模式 (可以理解为数据先堆积在 Socket 中, 后序一起发送)</span>            <span class="token comment">// 2. 创建出一个子进程, 将当前主节点的数据以 EOF 要求的格式写入到满足上一步的所有从节点的 Socket 中</span>            <span class="token comment">// EOF 格式</span>            <span class="token comment">// 开头 $EOF: + 长度 40 的 16 位字符串 + \r\n</span>            <span class="token comment">// 中间 RDB 内容</span>            <span class="token comment">// 结尾 一开始的 长度 40 的 16 位字符串 </span>            <span class="token comment">// 3. 全部写完后, 发送给对应的从节点</span>            retval <span class="token operator">=</span> <span class="token function">rdbSaveToSlavesSockets</span><span class="token punctuation">(</span>rsiptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// 正常的 RDB 持久化, 将数据写入到一个文件中, rdb 类型为 RDB_CHILD_TYPE_DISK</span>            retval <span class="token operator">=</span> <span class="token function">rdbSaveBackground</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_filename<span class="token punctuation">,</span>rsiptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 为空, 直接返回失败</span>        retval <span class="token operator">=</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 执行同步失败</span>        <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            client <span class="token operator">*</span>slave <span class="token operator">=</span> ln<span class="token operator">-></span>value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slave<span class="token operator">-></span>replstate <span class="token operator">==</span> SLAVE_STATE_WAIT_BGSAVE_START<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 删除对应的从节点</span>                slave<span class="token operator">-></span>replstate <span class="token operator">=</span> REPL_STATE_NONE<span class="token punctuation">;</span>                slave<span class="token operator">-></span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>CLIENT_SLAVE<span class="token punctuation">;</span>                <span class="token function">listDelNode</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 响应一个失败的提示</span>                <span class="token function">addReplyError</span><span class="token punctuation">(</span>slave<span class="token punctuation">,</span><span class="token string">"BGSAVE failed, replication can't continue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                slave<span class="token operator">-></span>flags <span class="token operator">|=</span> CLIENT_CLOSE_AFTER_REPLY<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> retval<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 磁盘同步类型处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>socket_target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 无盘同步, 已经在 rdbSaveToSlavesSockets 中已更新从节点的信息</span>        <span class="token comment">// 有盘同步, 在这一步处理</span>        <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            client <span class="token operator">*</span>slave <span class="token operator">=</span> ln<span class="token operator">-></span>value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slave<span class="token operator">-></span>replstate <span class="token operator">==</span> SLAVE_STATE_WAIT_BGSAVE_START<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>、                <span class="token comment">// 更新从节点客户端的偏移量, 状态和发送全量复制的消息给从节点</span>                <span class="token comment">// 当前的从节点的状态将会变为 SLAVE_STATE_WAIT_BGSAVE_END</span>                <span class="token function">replicationSetupSlaveForFullResync</span><span class="token punctuation">(</span>slave<span class="token punctuation">,</span> <span class="token function">getPsyncInitialOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 同步成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">==</span> C_OK<span class="token punctuation">)</span>         <span class="token comment">// 清除脚本缓存</span>        <span class="token function">replicationScriptCacheFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> retval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="9-1-replicationScriptCacheFlush-清除-Lua-脚本的缓存"><a href="#9-1-replicationScriptCacheFlush-清除-Lua-脚本的缓存" class="headerlink" title="9.1 replicationScriptCacheFlush - 清除 Lua 脚本的缓存"></a>9.1 replicationScriptCacheFlush - 清除 Lua 脚本的缓存</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationScriptCacheFlush</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">dictEmpty</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_scriptcache_dict<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listRelease</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_scriptcache_fifo<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_scriptcache_fifo <span class="token operator">=</span> <span class="token function">listCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="10-freeReplicationBacklog-清空复制积压缓冲区"><a href="#10-freeReplicationBacklog-清空复制积压缓冲区" class="headerlink" title="10 freeReplicationBacklog - 清空复制积压缓冲区"></a>10 freeReplicationBacklog - 清空复制积压缓冲区</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">freeReplicationBacklog</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">serverAssert</span><span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">zfree</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_backlog <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="11-putSlaveOnline-更新从节点的状态"><a href="#11-putSlaveOnline-更新从节点的状态" class="headerlink" title="11 putSlaveOnline - 更新从节点的状态"></a>11 putSlaveOnline - 更新从节点的状态</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">putSlaveOnline</span><span class="token punctuation">(</span>client <span class="token operator">*</span>slave<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 更新从节点的状态为 SLAVE_STATE_ONLINE (在线状态)</span>    slave<span class="token operator">-></span>replstate <span class="token operator">=</span> SLAVE_STATE_ONLINE<span class="token punctuation">;</span>    <span class="token comment">// 未 ack 应答</span>    slave<span class="token operator">-></span>repl_put_online_on_ack <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 更新 ack 为未应答</span>    slave<span class="token operator">-></span>repl_ack_time <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>     <span class="token comment">// 新增写事件, 将当前客户端的输出缓冲区数据发生给从节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> slave<span class="token operator">-></span>fd<span class="token punctuation">,</span> AE_WRITABLE<span class="token punctuation">,</span> sendReplyToClient<span class="token punctuation">,</span> slave<span class="token punctuation">)</span> <span class="token operator">==</span> AE_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">freeClient</span><span class="token punctuation">(</span>slave<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 更新当前从节点中延迟值小于配置的</span>    <span class="token function">refreshGoodSlavesCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="11-1-refreshGoodSlavesCount-刷新在线从节点且超时时间小于配置的从节点数量"><a href="#11-1-refreshGoodSlavesCount-刷新在线从节点且超时时间小于配置的从节点数量" class="headerlink" title="11.1 refreshGoodSlavesCount - 刷新在线从节点且超时时间小于配置的从节点数量"></a>11.1 refreshGoodSlavesCount - 刷新在线从节点且超时时间小于配置的从节点数量</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">refreshGoodSlavesCount</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    listIter li<span class="token punctuation">;</span>    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>    <span class="token keyword">int</span> good <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 没有配置这 2 个配置, 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>server<span class="token punctuation">.</span>repl_min_slaves_to_write <span class="token operator">||</span> <span class="token operator">!</span>server<span class="token punctuation">.</span>repl_min_slaves_max_lag<span class="token punctuation">)</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 遍历当前所有的从节点, 找出状态为 SLAVE_STATE_ONLINE 和 超时时间小于配置的 repl_min_slaves_max_lag 的节点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        client <span class="token operator">*</span>slave <span class="token operator">=</span> ln<span class="token operator">-></span>value<span class="token punctuation">;</span>        <span class="token class-name">time_t</span> lag <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime <span class="token operator">-</span> slave<span class="token operator">-></span>repl_ack_time<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>slave<span class="token operator">-></span>replstate <span class="token operator">==</span> SLAVE_STATE_ONLINE <span class="token operator">&amp;&amp;</span> lag <span class="token operator">&lt;=</span> server<span class="token punctuation">.</span>repl_min_slaves_max_lag<span class="token punctuation">)</span>             good<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 更新个数</span>    server<span class="token punctuation">.</span>repl_good_slaves_count <span class="token operator">=</span> good<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="12-cancelReplicationHandshake-从节点取消和主节点的握手"><a href="#12-cancelReplicationHandshake-从节点取消和主节点的握手" class="headerlink" title="12 cancelReplicationHandshake - 从节点取消和主节点的握手"></a>12 cancelReplicationHandshake - 从节点取消和主节点的握手</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_TRANSFER<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">replicationAbortSyncTransfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECT<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_CONNECTING <span class="token operator">||</span> <span class="token function">slaveIsInHandshakeState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">undoConnectWithMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECT<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="13-feedReplicationBacklogWithObject-向复制积压缓冲区-backlog-写数据"><a href="#13-feedReplicationBacklogWithObject-向复制积压缓冲区-backlog-写数据" class="headerlink" title="13 feedReplicationBacklogWithObject - 向复制积压缓冲区 backlog 写数据"></a>13 feedReplicationBacklogWithObject - 向复制积压缓冲区 backlog 写数据</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">feedReplicationBacklogWithObject</span><span class="token punctuation">(</span>robj <span class="token operator">*</span>o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> llstr<span class="token punctuation">[</span>LONG_STR_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> len<span class="token punctuation">;</span>    <span class="token comment">// 写入的对象为 int 整数, 转为字符串处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>encoding <span class="token operator">==</span> OBJ_ENCODING_INT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        len <span class="token operator">=</span> <span class="token function">ll2string</span><span class="token punctuation">(</span>llstr<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>llstr<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>o<span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> llstr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        len <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>o<span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> o<span class="token operator">-></span>ptr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">feedReplicationBacklog</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="13-1-feedReplicationBacklog-更新复制积压缓冲区-backlog"><a href="#13-1-feedReplicationBacklog-更新复制积压缓冲区-backlog" class="headerlink" title="13.1 feedReplicationBacklog - 更新复制积压缓冲区 backlog"></a>13.1 feedReplicationBacklog - 更新复制积压缓冲区 backlog</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">feedReplicationBacklog</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> ptr<span class="token punctuation">;</span>    <span class="token comment">// 更新全局复制的偏移量</span>    server<span class="token punctuation">.</span>master_repl_offset <span class="token operator">+=</span> len<span class="token punctuation">;</span>    <span class="token comment">// 复制积压缓冲区, 随着是一个字符串数组, 但是可以看成是一个环形的, 写的尾部</span>    <span class="token comment">// 会重新回到头部继续写, 所以每次写入时, 都需要更新写入位置的索引 repl_backlog_idx</span>    <span class="token comment">// 写入的对象的长度不为 0, 就一直写 </span>    <span class="token keyword">while</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 计算环形缓冲区还有多少空间</span>        <span class="token class-name">size_t</span> thislen <span class="token operator">=</span> server<span class="token punctuation">.</span>repl_backlog_size <span class="token operator">-</span> server<span class="token punctuation">.</span>repl_backlog_idx<span class="token punctuation">;</span>        <span class="token comment">// 如果空间足够，设置 thislen 写的长度为 len</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>thislen <span class="token operator">></span> len<span class="token punctuation">)</span>             thislen <span class="token operator">=</span> len<span class="token punctuation">;</span>        <span class="token comment">// 空间不足够或着刚刚好，那么只写入剩余的空间数，等待下次循环时写入</span>        <span class="token comment">// 将数据拷贝到复制积压缓冲区中    </span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog<span class="token operator">+</span>server<span class="token punctuation">.</span>repl_backlog_idx<span class="token punctuation">,</span>p<span class="token punctuation">,</span>thislen<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新下次写的下标</span>        server<span class="token punctuation">.</span>repl_backlog_idx <span class="token operator">+=</span> thislen<span class="token punctuation">;</span>        <span class="token comment">// 如果 repl_backlog_idx 已经到达缓冲区的尾部，那么重置它</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_idx <span class="token operator">==</span> server<span class="token punctuation">.</span>repl_backlog_size<span class="token punctuation">)</span>            server<span class="token punctuation">.</span>repl_backlog_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 更新未写入的数据长度    </span>        len <span class="token operator">-=</span> thislen<span class="token punctuation">;</span>        <span class="token comment">// 更新未写入数据的地址</span>        p <span class="token operator">+=</span> thislen<span class="token punctuation">;</span>        <span class="token comment">// 更新实际数据的长度</span>        server<span class="token punctuation">.</span>repl_backlog_histlen <span class="token operator">+=</span> thislen<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 实际数据的长度最大只能为复制缓冲区的大小，因为之后环形写入时会覆盖开头位置的数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_histlen <span class="token operator">></span> server<span class="token punctuation">.</span>repl_backlog_size<span class="token punctuation">)</span>        server<span class="token punctuation">.</span>repl_backlog_histlen <span class="token operator">=</span> server<span class="token punctuation">.</span>repl_backlog_size<span class="token punctuation">;</span>    <span class="token comment">// 设置 backlog 所备份已复制的数据的偏移量，用于处理复制时的断线</span>    server<span class="token punctuation">.</span>repl_backlog_off <span class="token operator">=</span> server<span class="token punctuation">.</span>master_repl_offset <span class="token operator">-</span> server<span class="token punctuation">.</span>repl_backlog_histlen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="14-replicationSendAck-从节点发送心跳-ack-给主节点"><a href="#14-replicationSendAck-从节点发送心跳-ack-给主节点" class="headerlink" title="14 replicationSendAck - 从节点发送心跳 ack 给主节点"></a>14 replicationSendAck - 从节点发送心跳 ack 给主节点</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationSendAck</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    client <span class="token operator">*</span>c <span class="token operator">=</span> server<span class="token punctuation">.</span>master<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        c<span class="token operator">-></span>flags <span class="token operator">|=</span> CLIENT_MASTER_FORCE_REPLY<span class="token punctuation">;</span>        <span class="token function">addReplyMultiBulkLen</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 内容: REPLCONF ACK repl_offset</span>        <span class="token function">addReplyBulkCString</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"REPLCONF"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addReplyBulkCString</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"ACK"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addReplyBulkLongLong</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>c<span class="token operator">-></span>reploff<span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token operator">-></span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>CLIENT_MASTER_FORCE_REPLY<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 主从复制 - 源码</title>
      <link href="/article/2024/3467330528/"/>
      <url>/article/2024/3467330528/</url>
      
        <content type="html"><![CDATA[<p>因为主从复制的过程很复杂, 同时核心逻辑主要集中在 <strong>replication.c</strong> 这个文件中, 避免篇幅过大, 所以将主从复制中涉及这个文件的代码集中到了另一篇文章。<br>在当前文章主要分析主从复制的大体代码逻辑, 如果需要了解整体的过程, 可以配合 <a href="https://lcn29.github.io/article/2024/3467330524/">Redis 主从复制 - relication 源码分析</a> 这篇文章。</p><h2 id="1-主从节点建立连接准备"><a href="#1-主从节点建立连接准备" class="headerlink" title="1 主从节点建立连接准备"></a>1 主从节点建立连接准备</h2><p>Redis 主从节点建立连接的 3 种方式, 本质都是从节点执行 <strong>slaveof</strong> 命令, 和父节点建立初步的关联关系。<br>这个命令执行的方法为 <strong>replicaofCommand</strong> (高版本的 Redis 可以通过 replicaof 达到 slaveof 的效果)。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicaofCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 开启了集群功能, 直接返回, 集群模式不允许执行 slaveof </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster_enabled<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReplyError</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"REPLICAOF not allowed in cluster mode."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 第一参数为 no, 第二个参数为 one</span>    <span class="token comment">// slaveof no one, 可以让从节点和主节点断开连接, 停止主从复制 </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"no"</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 取消复制操作, 同时设置当前节点为主节点</span>            <span class="token comment">// 具体代码逻辑, 可以查看 replication 文章的 replicationUnsetMaster 方法解析</span>            <span class="token comment">// 1. 置空 server.masterhost </span>            <span class="token comment">// 2. 将第一组 replid 和 offset 赋值到第二组, 重试生成一个 replid</span>            <span class="token comment">// 3. 置空 server.cached_server</span>            <span class="token comment">// 4. 如果在传输 RDB 文件中或者处于握手阶段, 进行取消, 同时取消和主节点的连接</span>            <span class="token comment">// 5. 如果有从节点, 释放所有的从节点客户端, 也就是断开从节点的连接</span>            <span class="token comment">// 6. 当前节点的状态变为 REPL_STATE_NONE (普通状态, 无主从复制状态)</span>            <span class="token function">replicationUnsetMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 获取 client 的每种信息, 并以 sds 形式返回, 并打印到日志中</span>            sds client <span class="token operator">=</span> <span class="token function">catClientInfoString</span><span class="token punctuation">(</span><span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sdsfree</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 本身是一个从节点了, 无法在执行 salveof ip 端口</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_SLAVE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">addReplyError</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token string">"Command is not valid when client is a replica."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 从入参中获取端口</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">getLongFromObjectOrReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>port<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment">// 已经有主节点了, 同时主节点的的 host 和 ip 和入参的相同</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost<span class="token punctuation">,</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>masterport <span class="token operator">==</span> port<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              <span class="token function">addReplySds</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token function">sdsnew</span><span class="token punctuation">(</span><span class="token string">"+OK Already connected to specified master\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 保存主节点信息并进入待连接状态</span>        <span class="token comment">// 具体代码逻辑, 可以查看 replication 文章的 replicationSetMaster 方法解析</span>        <span class="token comment">// 1. 保存主节点的 IP 和 端口到 server.masterhost 和 server.masterport</span>        <span class="token comment">// 2. 解除所有阻塞状态的客户端</span>        <span class="token comment">// 3. 释放所有的从节点信息</span>        <span class="token comment">// 4. 取消主从复制的握手操作</span>        <span class="token comment">// 5. 当前节点如果没有主节点, 为 server.cached_server 赋值一个默认生成的 client</span>        <span class="token comment">// 6. 设置当前的节点的状态为 REPL_STATE_CONNECT (待连接上主节点)</span>        <span class="token function">replicationSetMaster</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 响应客户端 ok</span>    <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>ok<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/66de83f8d9c307b7e9880337.png" alt="Alt &#39;主从节点建立连接准备&#39;"></p><p>主从复制的第一步逻辑</p><ol><li>将入参的主节点的 ip 和 port 保存在 server </li><li>创建出一个代表主节点的客户端 client, 赋值给 server.cached_server (如果是一开始是从节点, 重启了, 这一步未必会有)</li><li>当前从节点的节点状态变更为 REPL_STATE_CONNECT (开启了主从复制, 但是还没连接上主节点)</li></ol><p>执行完上的逻辑后, salveof (replicaof) 就结束的, 但是整个的主从复制还没有开始, 可以得出 salveof 是一个异步的命令。<br>接下来的步骤则是由定时函数 serverCron 定时的调用。</p><h2 id="2-主从节点建立-TCP-连接"><a href="#2-主从节点建立-TCP-连接" class="headerlink" title="2 主从节点建立 TCP 连接"></a>2 主从节点建立 TCP 连接</h2><p>在第一步中, 只是将主节点的信息保存到从节点中就结束了, 之间还是没有建立起相关的网络连接的, 第二步就是完成这个网络连接的操作。<br>而这个网络连接建立的触发是通过定时函数执行的</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 定时 1 秒执行一次</span>    <span class="token function">run_with_period</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token function">replicationCron</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span></code></pre><p>replicationCron 里面涉及到了大量的逻辑, 基本整个复制运行阶段的状态判断等都是在里面判断的, 这里只截取了涉及到当前步骤相关的逻辑。<br>在第一步操作完成后, 可以知道从节点当前的状态为 <strong>REPL_STATE_CONNECT</strong>。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationCron</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 当前的状态为 REPL_STATE_CONNECT (开启了主从复制, 但是还没连接上主节点)</span>    <span class="token comment">// 顺利执行了 salveof 后, 从节点的默认状态</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_CONNECT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 尝试连接主节点, 连接成功后, 从节点的状态会变为 REPL_STATE_CONNECTING (正在连接主节点)</span>        <span class="token comment">// 具体代码逻辑, 可以查看 replication 文章的 connectWithMaster 方法解析</span>        <span class="token comment">// 1. 通过保存的 ip 和 port 和主节点建立一个 TCP 连接</span>        <span class="token comment">// 2. 向事件轮询添加对应的 TCP 通道的读写事件, 执行的函数为 syncWithMaster</span>        <span class="token comment">// 3. 更新当前节点的状态为 REPL_STATE_CONNECTING (正在连接主节点)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connectWithMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/66de83f6d9c307b7e987fa57.png" alt="Alt &#39;主从节点建立 TCP 连接&#39;"></p><p>主从复制的第二步逻辑 </p><ol><li>和主节点建立起了 TCP 连接</li><li>向事件轮询注册一个读写事件, 触发的函数为 connectWithMaster, 同时这个函数会在下次事件轮询时自动执行一次</li><li>将当前节点的状态更新为 REPL_STATE_CONNECTING (从节点开始连接主节点)</li></ol><h2 id="3-发送-PING-命令"><a href="#3-发送-PING-命令" class="headerlink" title="3 发送 PING 命令"></a>3 发送 PING 命令</h2><h3 id="3-1-从节点发送-PING-命令给主节点"><a href="#3-1-从节点发送-PING-命令给主节点" class="headerlink" title="3.1 从节点发送 PING 命令给主节点"></a>3.1 从节点发送 PING 命令给主节点</h3><p>在第二步的步骤中, 通过保存的主节点 ip 和 port 建立起 TCP 连接后, 会向事件轮询中注册一个 AE_READABLE|AE_WRITABLE 的事件。<br>读写同时注册时, 会自动触发一次, 也就是在下次事件轮询中会执行到其注册的函数 syncWithMaster 函数, 所以第三步的入口就是这个函数了。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 入参中的 fd 就是和主节点建立的 Socket 连接的文件描述符</span><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sockerr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">socklen_t</span> errlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sockerr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">UNUSED</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>privdata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 状态为 REPL_STATE_NONE, 关闭对应的文件描述符</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_NONE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 检查当前的 Socket 通道的状态</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getsockopt</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_ERROR<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sockerr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>errlen<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">// 获取异常信息</span>        sockerr <span class="token operator">=</span> errno<span class="token punctuation">;</span>    <span class="token comment">// 有异常信息</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sockerr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> error<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 从节点和父节点建立了 Socket 后的第一个状态为 REPL_STATE_CONNECTING</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_CONNECTING<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 删除当前这个 Socket 的可写事件, 不关心写事件</span>        <span class="token function">aeDeleteFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>AE_WRITABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 状态修改为 REPL_STATE_RECEIVE_PONG (发送 pong, 等待 ping 回答)</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_RECEIVE_PONG<span class="token punctuation">;</span>                <span class="token comment">// 发送同步命令, 也就是 ping 到主节点, SYNC_CMD_WRITE = 1</span>        <span class="token comment">// 具体代码逻辑, 可以查看 replication 文章的 sendSynchronousCommand 方法解析</span>        err <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_WRITE<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token string">"PING"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>             <span class="token keyword">goto</span> write_error<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>error<span class="token operator">:</span>    <span class="token function">aeDeleteFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>AE_READABLE<span class="token operator">|</span>AE_WRITABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dfd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">close</span><span class="token punctuation">(</span>dfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_transfer_s <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECT<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>write_error<span class="token operator">:</span>     <span class="token comment">// 从节点向父节点发送 SYNC_CMD_WRITE 失败时的处理逻辑</span>    <span class="token function">sdsfree</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">goto</span> error<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-2-主节点发送-Pong-响应从节点的-Ping-命令"><a href="#3-2-主节点发送-Pong-响应从节点的-Ping-命令" class="headerlink" title="3.2 主节点发送 Pong 响应从节点的 Ping 命令"></a>3.2 主节点发送 Pong 响应从节点的 Ping 命令</h3><p>主节点收到了从节点的 Ping 命令后, 处理正常后, 会响应一个 Pong 的命令。</p><p><strong>主节点</strong> 执行的 Ping 命令的逻辑如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">pingCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ping 命令的参数只能是 1 个或者 0 个</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>argc <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReplyErrorFormat</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"wrong number of arguments for '%s' command"</span><span class="token punctuation">,</span> c<span class="token operator">-></span>cmd<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 对应的客户端处于 Pub/Sub 模式</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_PUBSUB<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>mbulkhdr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addReplyBulkCBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"pong"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>argc <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token function">addReplyBulkCBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">addReplyBulk</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 其他模式</span>        <span class="token comment">// 参数是 1 个, 响应一个 pong</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>argc <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>pong<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// 响应入参的第 2 个参数</span>            <span class="token function">addReplyBulk</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-3-从节点收到主节点的响应的-Pong-命令"><a href="#3-3-从节点收到主节点的响应的-Pong-命令" class="headerlink" title="3.3 从节点收到主节点的响应的 Pong 命令"></a>3.3 从节点收到主节点的响应的 Pong 命令</h3><p><strong>从节点</strong> 收到了主节点发送过来的 Pone 响应命令, 这时会触发在上面第 2 步对 Socket 连接建立的可读事件。<br>当事件轮询循环中找到了可读事件, 又执行到 <strong>syncWithMaster</strong> 函数</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>        <span class="token comment">// 当前从节点处于 REPL_STATE_RECEIVE_PONG 状态 (发送 ping, 等待 pong  应答)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_PONG<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 读取主节点响应的信息</span>        err <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_READ<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 异常情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'+'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">strncmp</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span><span class="token string">"-NOAUTH"</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">strncmp</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span><span class="token string">"-ERR operation not permitted"</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">sdsfree</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">goto</span> error<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 响应的是 Pong, 能继续处理</span>        <span class="token punctuation">&#125;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 状态切换到 REPL_STATE_SEND_AUTH, 等待认证结果应答</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_AUTH<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/66dee096d9c307b7e923fa2d.png" alt="Alt &#39;发送 PING 命令&#39;"></p><p>主从复制的第三步逻辑</p><ol><li>从节点向主节点发送了一个 Ping 命令, 自身状态由 REPL_STATE_CONNECTING (从节点开始连接主节点) 变为 REPL_STATE_RECEIVE_PONG (等待主节点响应 Pong 命令)</li><li>主节点收到从节点发送的 Ping 命令, 向其响应了一个 Pong 命令</li><li>从节点收到主节点响应的 Pong 命令, 会将其自身的状态从 REPL_STATE_RECEIVE_PONG (等待主节点响应 Pong 命令) 变为 REPL_STATE_SEND_AUTH (准备发送认证)</li></ol><p>主要是通过发送 Ping 命令和接受主节点响应的 Pong 命令, 初步确定双方网络的正常</p><h2 id="4-密码认证"><a href="#4-密码认证" class="headerlink" title="4 密码认证"></a>4 密码认证</h2><p>在从节点发送 Ping, 主节点响应 Pong , 从节点收到 Pong 响应后, 进入处理时 (syncWithMaster 函数),<br>状态修改为 <strong>REPL_STATE_SEND_AUTH</strong> 后, 方法继续执行下去, 立即进入密码认证的过程。</p><h3 id="4-1-从节点发送认证密码"><a href="#4-1-从节点发送认证密码" class="headerlink" title="4.1 从节点发送认证密码"></a>4.1 从节点发送认证密码</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 当前从节点处于 REPL_STATE_RECEIVE_PONG 状态 (发送 ping, 等待 pong  应答)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_PONG<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>        <span class="token comment">// 状态切换到 REPL_STATE_SEND_AUTH, 准备发送认证</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_AUTH<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 进入认证, 如果需要的话</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_SEND_AUTH<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 配置了主节点的密码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterauth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 发送认证请求和密码到主节点</span>            <span class="token comment">// auth 密码</span>            err <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_WRITE<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token string">"AUTH"</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>masterauth<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>                 <span class="token keyword">goto</span> write_error<span class="token punctuation">;</span>            <span class="token comment">// 状态切换为 REPL_STATE_RECEIVE_AUTH (等待认证结果响应)</span>            server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_RECEIVE_AUTH<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 不需要认证, 状态之间切换为 REPL_STATE_SEND_PORT 准备发送端口</span>            server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_PORT<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>从节点</strong>根据是否配置了主节点认证密码, 走不同的逻辑</p><ol><li>配置了认证密码, 发送<strong>auth 密码</strong>给主节点, 同时状态变为 REPL_STATE_RECEIVE_AUTH (等待主节点响应认证结果应答)</li><li>没有配置认证密码, 直接将状态变为 REPL_STATE_SEND_PORT (准备发送从节点的监听的端口)</li></ol><h3 id="4-2-主节点响应-Auth-命令"><a href="#4-2-主节点响应-Auth-命令" class="headerlink" title="4.2 主节点响应 Auth 命令"></a>4.2 主节点响应 Auth 命令</h3><p><strong>主节点</strong>收到从节点的认证请求 auth, 就会进入到权限认证的过程,  执行的逻辑如下:</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">authCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 主节点不需要密码认证</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>server<span class="token punctuation">.</span>requirepass<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReplyError</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"Client sent AUTH, but no password is set"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">time_independent_strcmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span> server<span class="token punctuation">.</span>requirepass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 密码认证成功  </span>        c<span class="token operator">-></span>authenticated <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>ok<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 密码认证失败  </span>        c<span class="token operator">-></span>authenticated <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">addReplyError</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"invalid password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>主节点</strong>收到从节点的 auth 命令后</p><ol><li>本身没有设置密码, 直接返回错误</li><li>收到的密码和自身配置的密码一样, 返回成功</li><li>收到的密码和自身配置的密码不一样, 返回错误</li></ol><h3 id="4-3-从节点收到-Auth-命令的响应结果"><a href="#4-3-从节点收到-Auth-命令的响应结果" class="headerlink" title="4.3 从节点收到 Auth 命令的响应结果"></a>4.3 从节点收到 Auth 命令的响应结果</h3><p>同 <strong>Ping Pong</strong> 的处理逻辑一样, 这时<strong>从节点</strong>读取到主节点的响应, 事件轮询触发 <strong>syncWithMaster</strong> 函数</p><pre class="language-C" data-language="C"><code class="language-C">void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) &#123;    &#x2F;&#x2F; 当前从节点处于 REPL_STATE_RECEIVE_PONG 状态 (发送 ping, 等待 pong  应答)    if (server.repl_state &#x3D;&#x3D; REPL_STATE_RECEIVE_PONG) &#123;        &#x2F;&#x2F; 省略         &#x2F;&#x2F; 状态切换为 REPL_STATE_RECEIVE_AUTH (等待认证结果响应)        server.repl_state &#x3D; REPL_STATE_RECEIVE_AUTH;        return;    &#125;    &#x2F;&#x2F; 接收到请求认证的响应    if (server.repl_state &#x3D;&#x3D; REPL_STATE_RECEIVE_AUTH) &#123;        &#x2F;&#x2F; 读取响应信息        err &#x3D; sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);                &#x2F;&#x2F; 认证失败        if (err[0] &#x3D;&#x3D; &#39;-&#39;) &#123;            sdsfree(err);            goto error;        &#125;        &#x2F;&#x2F; 认证成功        sdsfree(err);        &#x2F;&#x2F; 状态变为 REPL_STATE_SEND_PORT (准备发送从节点的监听的端口)        server.repl_state &#x3D; REPL_STATE_SEND_PORT;    &#125;&#125;</code></pre><p><img src="https://pic.imgdb.cn/item/66dee099d9c307b7e923fd75.png" alt="Alt &#39;密码认证&#39;"></p><p>主从复制的第四步逻辑</p><ol><li>如果从节点没有配置 masterauth, 则直接进入下一个阶段, 状态从 REPL_STATE_SEND_AUTH (准备发送认证) 直接变为 REPL_STATE_SEND_PORT (准备发送从节点的监听的端口)</li><li>如果有配置 masterauth, 则会<blockquote><p>1 从节点向主节点发送了 Auth 密码 的命令给主节点, 自身状态由 REPL_STATE_SEND_AUTH (准备发送认证) 变为 REPL_STATE_RECEIVE_AUTH (等待认证结果响应)<br>2 主节点收到从节点发送的 Auth 密码, 在确定没错后, 向其响应了一个 ok 的字符串<br>3 从节点收到主节点响应的 ok, 会将其自身的状态从 REPL_STATE_RECEIVE_AUTH (等待认证结果响应) 变为 REPL_STATE_SEND_PORT (准备发送从节点的监听的端口)</p></blockquote></li></ol><p>第四步, 通过配置的密码和主节点进行认证(如果需要的话), 在认证成功或无需认证后, 进入到 REPL_STATE_SEND_PORT (准备发送从节点的监听的端口)</p><h2 id="5-发送端口号"><a href="#5-发送端口号" class="headerlink" title="5 发送端口号"></a>5 发送端口号</h2><p>在不需要权限认证或者从节点收到主节点的权限认证成功后, 此时从节点的状态为 <strong>REPL_STATE_SEND_PORT</strong>, 顺着上一步的处理逻辑中, 继续处理</p><h3 id="5-1-发送从节点主从复制的端口"><a href="#5-1-发送从节点主从复制的端口" class="headerlink" title="5.1 发送从节点主从复制的端口"></a>5.1 发送从节点主从复制的端口</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 收到权限认证的响应</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_AUTH<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 配置了主节点的密码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterauth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 不需要认证, 状态之间切换为 REPL_STATE_SEND_PORT 准备发送端口</span>            server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_PORT<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 接收到请求认证的响应</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_AUTH<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>        <span class="token comment">// 状态变为 REPL_STATE_SEND_PORT (准备发送从节点的监听的端口)</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_PORT<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 进入发送端口阶段</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_SEND_PORT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果有配置一个专门复制的端口的话, 使用配置的端口, 没有使用当前服务器的端口</span>        sds port <span class="token operator">=</span> <span class="token function">sdsfromlonglong</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slave_announce_port <span class="token operator">?</span> server<span class="token punctuation">.</span>slave_announce_port <span class="token operator">:</span> server<span class="token punctuation">.</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 发送端口信息给主节点 命令: replconf listening-port 端口</span>        err <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_WRITE<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token string">"REPLCONF"</span><span class="token punctuation">,</span> <span class="token string">"listening-port"</span><span class="token punctuation">,</span> port<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>             <span class="token keyword">goto</span> write_error<span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 切换状态为 REPL_STATE_RECEIVE_PORT (等待主节点响应收到从节点端口)</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_RECEIVE_PORT<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>向主节点发送自己的主从复制的端口</p><h3 id="5-2-主节点响应从节点的发送端口命令"><a href="#5-2-主节点响应从节点的发送端口命令" class="headerlink" title="5.2 主节点响应从节点的发送端口命令"></a>5.2 主节点响应从节点的发送端口命令</h3><p><strong>主节点</strong>收到从节点的发送端口请求 replconf listening-port 端口, 执行的逻辑如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replconfCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token comment">// 参数需要是 2 的倍数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argc <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>syntaxerr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> c<span class="token operator">-></span>argc<span class="token punctuation">;</span> j<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 每个循环使用 2 个参数</span>        <span class="token comment">// replconf listening-port port</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"listening-port"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">long</span> port<span class="token punctuation">;</span>            <span class="token comment">// 获取下一个项, 也就是端口号</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">getLongFromObjectOrReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>port<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token comment">// 保存到对应的客户端的 slave_listening_port     </span>            c<span class="token operator">-></span>slave_listening_port <span class="token operator">=</span> port<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"ip-address"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"capa"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"ack"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"getack"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 响应错误</span>            <span class="token function">addReplyErrorFormat</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"Unrecognized REPLCONF option: %s"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 响应 OK </span>    <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>ok<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到主节点收到从节点发送过来的端口</p><ol><li>会保存到从节点客户端 client 的 slave_listening_port 字段</li><li>响应一个 ok 字符串</li></ol><h3 id="5-3-从节点收到主节点对自己发送端口命令的响应"><a href="#5-3-从节点收到主节点对自己发送端口命令的响应" class="headerlink" title="5.3 从节点收到主节点对自己发送端口命令的响应"></a>5.3 从节点收到主节点对自己发送端口命令的响应</h3><p>收到主节点的响应后, 从节点同样是事件轮询触发 <strong>syncWithMaster</strong> 函数</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 进入发送端口阶段</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_SEND_PORT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>        <span class="token comment">// 切换状态为 REPL_STATE_RECEIVE_PORT (等待主节点响应收到从节点端口)</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_RECEIVE_PORT<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// REPL_STATE_RECEIVE_PORT 等待主节点响应发送端口请求的响应</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_PORT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        err <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_READ<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 状态变为 REPL_STATE_SEND_IP, 准备发送 IP 到主节点</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_IP<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/66dee09bd9c307b7e923ff2c.png" alt="Alt &#39;发送端口号&#39;"></p><p>主从复制的第五步逻辑</p><ol><li>从节点向主节点发送 replconf listening-port 自身的端口给主节点, 同时进入到 REPL_STATE_RECEIVE_PORT (等待主节点响应收到从节点端口请求)</li><li>主节点收到 replconf listening-port 从节点的端口 命令后, 将其存到自身维护的客户端对象的 slave_listening_port 字段, 向其响应了一个 ok 的字符串</li><li>从节点收到主节点响应的 ok, 会将其自身的状态从 REPL_STATE_RECEIVE_PORT 变为 REPL_STATE_SEND_IP (发送主从复制配置的监听的 IP 地址)</li></ol><h2 id="6-发送-IP-地址"><a href="#6-发送-IP-地址" class="headerlink" title="6 发送 IP 地址"></a>6 发送 IP 地址</h2><p>从节点收到主节点对 <strong>replconf listening-port 端口</strong> 的响应后, 从节点会将状态修改为 <strong>REPL_STATE_SEND_IP</strong>, 然后顺着逻辑走下去</p><h3 id="6-1-发送从节点主从复制的-Ip"><a href="#6-1-发送从节点主从复制的-Ip" class="headerlink" title="6.1 发送从节点主从复制的 Ip"></a>6.1 发送从节点主从复制的 Ip</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// REPL_STATE_RECEIVE_PORT 等待主节点响应发送 IP 请求的响应</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_PORT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>        <span class="token comment">// 状态变为 REPL_STATE_SEND_IP, 准备发送 IP 到主节点</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_IP<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// slave_announce_ip 为空 (没有配置指定的 IP), 直接跳过发送 IP 的阶段</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_SEND_IP <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>slave_announce_ip <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 进入下一个节点 准备发送从节点的发送能力</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_CAPA<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_SEND_IP<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 发送 replconf ip-address ip</span>        err <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_WRITE<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token string">"REPLCONF"</span><span class="token punctuation">,</span> <span class="token string">"ip-address"</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>slave_announce_ip<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>             <span class="token keyword">goto</span> write_error<span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 状态变为 REPL_STATE_RECEIVE_IP (等待主节点响应收到从节点的 IP 地址)</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_RECEIVE_IP<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>从节点进入发送 IP 地址阶段时, 除了状态需要为 REPL_STATE_SEND_IP (准备发送 IP 地址阶段), 还必须有指定 slave_announce_ip, 从节点的 IP (对应配置文件的 slave-announce-ip),<br>2 个条件都满足的情况下, 才会真正的进入发送 Ip 地址, 否则直接进入下一阶段 REPL_STATE_SEND_CAPA (准备发送从节点支持的复制能力)。</p><h3 id="6-2-主节点响应从节点的发送-Ip-命令"><a href="#6-2-主节点响应从节点的发送-Ip-命令" class="headerlink" title="6.2 主节点响应从节点的发送 Ip 命令"></a>6.2 主节点响应从节点的发送 Ip 命令</h3><p><strong>主节点</strong>收到从节点的发送的 <strong>replconf ip-address Ip</strong> 请求, 执行的逻辑如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replconfCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token comment">// 参数需要是 2 的倍数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argc <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>syntaxerr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> c<span class="token operator">-></span>argc<span class="token punctuation">;</span> j<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 每个循环使用 2 个参数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"listening-port"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"ip-address"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// replconf ip-address Ip</span>            <span class="token comment">// 获取对应的从节点发送的 Ip </span>            sds ip <span class="token operator">=</span> c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">;</span>            <span class="token comment">// Ip 的长度判断</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sdslen</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>c<span class="token operator">-></span>slave_ip<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 保存到客户端的 client 的 slave_ip 属性</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>c<span class="token operator">-></span>slave_ip<span class="token punctuation">,</span>ip<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 错误提示</span>                <span class="token function">addReplyErrorFormat</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"REPLCONF ip-address provided by replica instance is too long: %zd bytes"</span><span class="token punctuation">,</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"capa"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"ack"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"getack"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 响应错误</span>            <span class="token function">addReplyErrorFormat</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"Unrecognized REPLCONF option: %s"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 响应 OK </span>    <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>ok<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到主节点收到从节点发送过来的 Ip</p><ol><li>会保存到从节点客户端 client 的 slave_ip 字段</li><li>响应一个 ok 字符串</li></ol><h3 id="6-3-从节点收到主节点对自己发送-Ip-命令的响应"><a href="#6-3-从节点收到主节点对自己发送-Ip-命令的响应" class="headerlink" title="6.3 从节点收到主节点对自己发送 Ip 命令的响应"></a>6.3 从节点收到主节点对自己发送 Ip 命令的响应</h3><p><strong>从节点</strong>收到主节点的响应后, 同样是由事件轮询触发 <strong>syncWithMaster</strong> 函数</p><pre class="language-C" data-language="C"><code class="language-C">void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) &#123;    &#x2F;&#x2F; 省略    &#x2F;&#x2F; 收到主节点对发送 IP 请求的响应    if (server.repl_state &#x3D;&#x3D; REPL_STATE_RECEIVE_IP) &#123;        err &#x3D; sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);        sdsfree(err);        &#x2F;&#x2F; 状态变为等待发送发送能力状态        server.repl_state &#x3D; REPL_STATE_SEND_CAPA;    &#125;&#125;</code></pre><p><img src="https://pic.imgdb.cn/item/66dee09dd9c307b7e924025a.png" alt="Alt &#39;发送 IP 地址&#39;"></p><p>主从复制的第六步逻辑</p><ol><li>如果没有配置从节点用于主从复制的专门 Ip, 则直接进入到 REPL_STATE_SEND_CAPA (准备发送从节点支持的同步能力)</li><li>如果配置了专门的主从复制 Ip<blockquote><p>1 从节点向主节点发送 replconf ip-address Ip, 同时进入到 REPL_STATE_RECEIVE_IP (等待主节点响应收到从节点的 IP 地址)<br>2 主节点收到 replconf ip-address Ip 命令后, 将其存到自身维护的客户端对象的 slave_ip 字段, 向其响应了一个 ok 的字符串<br>3 从节点收到主节点对自身的 replconf 命令的响应后, 将自身从 REPL_STATE_RECEIVE_PORT 切换到 REPL_STATE_SEND_CAPA (准备发送从节点支持的同步能力)</p></blockquote></li></ol><h2 id="7-发送支持的同步能力"><a href="#7-发送支持的同步能力" class="headerlink" title="7 发送支持的同步能力"></a>7 发送支持的同步能力</h2><p>收到主节点响应的 Ip 请求, 从节点的状态切换为了 REPL_STATE_SEND_CAPA (准备发送从节点支持的复制能力),<br>如果从节点没有配置  slave-announce-ip, 也就不会有发送 IP 相关的操作, 也会直接过度到 REPL_STATE_SEND_CAPA。<br>这一步主要是兼容不同版本的 Redis, 主节点需要知道当前从节点支持的复制能力, 才可以决定如何和从节点进行数据复制。</p><p>状态切换到 REPL_STATE_SEND_CAPA 后, 会继续下面的逻辑, 同样在 <strong>syncWithMaster</strong> 函数。</p><h3 id="7-1-发送从节点支持的复制能力"><a href="#7-1-发送从节点支持的复制能力" class="headerlink" title="7.1 发送从节点支持的复制能力"></a>7.1 发送从节点支持的复制能力</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 没有配置宣布的 IP, slave_announce_ip 为空, 直接跳过发送 IP 的阶段</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_SEND_IP <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>slave_announce_ip <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 进入下一个节点 准备发送从节点的发送能力</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_CAPA<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 省略</span>    <span class="token comment">// 收到主节点对发送 IP 请求的响应</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_IP<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 状态变为等待发送发送能力状态</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_CAPA<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_SEND_CAPA<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 发送从节点支持的复制能力到主节点 </span>        <span class="token comment">// replconf capa eof capa psync2</span>        err <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_WRITE<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token string">"REPLCONF"</span><span class="token punctuation">,</span> <span class="token string">"capa"</span><span class="token punctuation">,</span> <span class="token string">"eof"</span><span class="token punctuation">,</span> <span class="token string">"capa"</span><span class="token punctuation">,</span> <span class="token string">"psync2"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">goto</span> write_error<span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 状态修改为 REPL_STATE_RECEIVE_CAPA, 等待主节点响应发送能力的应答</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_RECEIVE_CAPA<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>从节点发送过去的支持的 2 种复制能力</p><blockquote><ol><li>eof: 全量复制, 正常 全量复制时, 主节点将数据持久化为一个文件, 然后将文件发送给从节点, EOF 则表示直接将数据通过 Socket 直接发送给从节点</li><li>psync2: 部分复制, 利用复制积压缓冲区等实现部分复制</li></ol></blockquote><h3 id="7-2-主节点响应从节点的复制能力请求"><a href="#7-2-主节点响应从节点的复制能力请求" class="headerlink" title="7.2 主节点响应从节点的复制能力请求"></a>7.2 主节点响应从节点的复制能力请求</h3><p><strong>主节点</strong>收到从节点的 <strong>replconf capa eof capa psync2</strong> 请求后, 执行的逻辑如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replconfCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token comment">// 参数需要是 2 的倍数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argc <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>syntaxerr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> c<span class="token operator">-></span>argc<span class="token punctuation">;</span> j<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 每个循环使用 2 个参数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"listening-port"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"ip-address"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"capa"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"eof"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment">// SLAVE_CAPA_EOF = 1</span>                c<span class="token operator">-></span>slave_capa <span class="token operator">|=</span> SLAVE_CAPA_EOF<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"psync2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment">// SLAVE_CAPA_PSYNC2 = 2 </span>                c<span class="token operator">-></span>slave_capa <span class="token operator">|=</span> SLAVE_CAPA_PSYNC2<span class="token punctuation">;</span>                            <span class="token comment">// 如果不支持的能力, 不做处理</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"ack"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"getack"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 响应错误</span>            <span class="token function">addReplyErrorFormat</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"Unrecognized REPLCONF option: %s"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 响应 OK </span>    <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>ok<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>主节点收到从节点发送的复制能力</p><ol><li>会保存到从节点客户端 client 的 slave_capa 字段</li><li>响应一个 ok 字符串</li></ol><h3 id="7-3-从节点收到主节点对自己发送支持的复制能力-命令的响应"><a href="#7-3-从节点收到主节点对自己发送支持的复制能力-命令的响应" class="headerlink" title="7.3 从节点收到主节点对自己发送支持的复制能力 命令的响应"></a>7.3 从节点收到主节点对自己发送支持的复制能力 命令的响应</h3><p><strong>从节点</strong>收到主节点的响应后, 从节点同样是事件轮询触发 <strong>syncWithMaster</strong> 函数</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>    <span class="token comment">// 读取主节点发送过来的信息</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_CAPA<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        err <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_READ<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 变更状态为 REPL_STATE_SEND_PSYNC (向主节点发送 psync 命令, 请求同步复制)</span>        <span class="token comment">// 向主节点发送 psync 命令, 请求全量复制</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_PSYNC<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/66dee09fd9c307b7e924055f.png" alt="Alt &#39;发送支持的同步能力&#39;"></p><p>主从复制的第七步逻辑</p><ol><li>从节点向主节点发送 replconf capa eof capa psync2, 同时进入到 REPL_STATE_RECEIVE_CAPA (等待主节点响应收到支持的复制能力的应答)</li><li>主节点收到 replconf capa eof capa psync2 命令后, 将其存到自身维护的客户端对象的 slave_capa 字段</li><li>从节点收到主节点对自身的 replconf 命令的响应后, 将自身从 REPL_STATE_RECEIVE_CAPA 切换到 REPL_STATE_SEND_PSYNC (向主节点发送 psync 命令, 请求同步复制)</li></ol><h2 id="8-发送-PSYNC-命令"><a href="#8-发送-PSYNC-命令" class="headerlink" title="8 发送 PSYNC 命令"></a>8 发送 PSYNC 命令</h2><p>上面 7 步只是主从复制前的准备, 而到了 psync 这步, 就是真正的复制开始了。而且这个过程涉及到全量复制 + 部分复制等情况, 有的绕。</p><h3 id="8-1-从节点发送-psync-命令-通知主节点开始复制"><a href="#8-1-从节点发送-psync-命令-通知主节点开始复制" class="headerlink" title="8.1 从节点发送 psync 命令, 通知主节点开始复制"></a>8.1 从节点发送 psync 命令, 通知主节点开始复制</h3><p><strong>从节点</strong>收到了主节点对其同步能力的响应后, 接着会发送一个 psync 的命令给主节点, 这个请求就是同步复制的真正开始了</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 读取主节点发送过来的信息</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_CAPA<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>        <span class="token comment">// 向主节点发送 psync 命令, 请求全量复制</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_PSYNC<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 发送 psync 命令</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_SEND_PSYNC<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 入参的 0 表示写消息给主节点, 1 表示从主节点读取数据</span>        <span class="token comment">// 入参 0 的逻辑, 根据当前是否缓存了主节点 (cached_master 是否为空), 来发送 psync 命令, 为空, 发送全量复制请求, 不为空, 发送部分复制请求</span>        <span class="token comment">// 部分复制, 最终发送的命令 psync replid repl_offset (主节点还是会判断这 2 个的值, 最终决定是全量还是部分)</span>        <span class="token comment">// 全量复制, 最终发送的命令 psync ? -1</span>        <span class="token comment">// 具体代码逻辑, 可以查看 replication 文章的 slaveTryPartialResynchronization 方法解析</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">slaveTryPartialResynchronization</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> PSYNC_WRITE_ERROR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            err <span class="token operator">=</span> <span class="token function">sdsnew</span><span class="token punctuation">(</span><span class="token string">"Write error sending the PSYNC command."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">goto</span> write_error<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 切换状态为 REPL_STATE_RECEIVE_PSYNC (等待 psync 应答)</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_RECEIVE_PSYNC<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>slaveTryPartialResynchronization 函数可以根据入参进行写消息给主节点和读取主节点消息, 因为上面只涉及到写的操作，下面梳理的是写部分的逻辑</p><blockquote><ol><li>声明了 2 个变量 psync_replid 和 psync_offset, 前者用来存储缓存主节点的 replid, 后者存储的是当前从节点同步复制积压缓冲区的位置</li><li>首先根据自身保存的 server.cached_master 是否为空, 得出 2 个变量的值</li><li>如果 server.cached_master 不为空, psync_replid 等于 cached_master.replid, psync_offset 等于 cached_master.reploff + 1</li><li>如果 server.cached_master 为空, psync_replid 等于 ?, psync_offset 等于 -1</li><li>server.cached_master 不为空, 表示从节点上次是有主节点的, 当前可能是重启等情况, 导致从节点重新走了一次复制的流程, 可以尝试进行部分复制, 不进行全量复制</li><li>向主节点发送 psync <psync_replid> <psync_offset>, 也就是 psync ? -1 或者 psync replid offset, 后者主节点收到后会直接判定为全量复制, 后者主节点会判断是否可进行部分复制</li></ol></blockquote><p>上面就是 slaveTryPartialResynchronization 写操作的逻辑, 也是从节点向主节点发送 psync 的过程</p><h3 id="8-2-主节点收到-psync-命令-为开始复制做准备"><a href="#8-2-主节点收到-psync-命令-为开始复制做准备" class="headerlink" title="8.2 主节点收到 psync 命令, 为开始复制做准备"></a>8.2 主节点收到 psync 命令, 为开始复制做准备</h3><p><strong>主节点</strong>收到从节点的发送过来的同步请求命令 psync, 执行的逻辑如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 客户端不是从节点, 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_SLAVE<span class="token punctuation">)</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 当前节点是另一个节点的从节点, 同时节点的状态不是 REPL_STATE_CONNECTED (已经连接状态), 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>repl_state <span class="token operator">!=</span> REPL_STATE_CONNECTED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReplySds</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token function">sdsnew</span><span class="token punctuation">(</span><span class="token string">"-NOMASTERLINK Can't SYNC while not connected with my master\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 判断 client c 的 bufpos != 0 || reply 有数据</span>    <span class="token comment">// 也就是判断当前节点有数据准备发送给从节点, 是的话, 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReplyError</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"SYNC and PSYNC are invalid with pending output"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 执行的命令为 psync</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span> <span class="token string">"psync"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// psync repl_id repl_offset</span>        <span class="token comment">// 主节点尝试进行部分同步复制 </span>        <span class="token comment">// 可以部分复制 stat_sync_partial_ok 部分复制次数 + 1, 然后直接结束</span>        <span class="token comment">// 这段代码的核心, 尝试进行部分复制, 不行返回内会返回 C_ERR, 走到下面全量复制的逻辑</span>        <span class="token comment">// 可以结合下面的说明继续分析</span>        <span class="token comment">// 具体代码逻辑, 可以查看 replication 文章的 masterTryPartialResynchronization 方法解析</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">masterTryPartialResynchronization</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            server<span class="token punctuation">.</span>stat_sync_partial_ok<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">char</span> <span class="token operator">*</span>master_replid <span class="token operator">=</span> c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">;</span>                <span class="token comment">// 从节点指定了 replid, 但是现在部分复制失败了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>master_replid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'?'</span><span class="token punctuation">)</span>             <span class="token comment">// 部分同步复制失败次数 + 1</span>            server<span class="token punctuation">.</span>stat_sync_partial_err<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 执行的命令不是 psync, 按照 sync 命令处理</span>        c<span class="token operator">-></span>flags <span class="token operator">|=</span> CLIENT_PRE_PSYNC<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 全量复制 --> 可以结合下面的 8.2.1 一起使用 </span>    <span class="token comment">// 全量复制次数 + 1</span>    server<span class="token punctuation">.</span>stat_sync_full<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 修改从节点的状态为 SLAVE_STATE_WAIT_BGSAVE_START (等待 bgsave 的开始, 也就是 RDB 文件的创建)</span>    c<span class="token operator">-></span>replstate <span class="token operator">=</span> SLAVE_STATE_WAIT_BGSAVE_START<span class="token punctuation">;</span>        <span class="token comment">// 关闭了 TCP_NODELAY 功能</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_disable_tcp_nodelay<span class="token punctuation">)</span>        <span class="token comment">// 启用 nagle 算法</span>        <span class="token function">anetDisableTcpNoDelay</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> c<span class="token operator">-></span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>      c<span class="token operator">-></span>repldbfd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 客户端设置从节点标识</span>    c<span class="token operator">-></span>flags <span class="token operator">|=</span> CLIENT_SLAVE<span class="token punctuation">;</span>    <span class="token comment">// 把当前的客户端添加到从节点列表</span>    <span class="token function">listAddNodeTail</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果有需要, 创建复制积压缓冲区</span>    <span class="token comment">// 条件: 从节点只有 1 个, 复制积压缓冲区为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>repl_backlog <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 生成 replid, 存放到 server.replid 中</span>        <span class="token function">changeReplicationId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 清除 replid2 和 second_replid_offset</span>        <span class="token comment">// 具体逻辑可以查看 replication 文章的 clearReplicationId2 方法解析</span>        <span class="token function">clearReplicationId2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 创建复制积压缓冲区</span>        <span class="token function">createReplicationBacklog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>rdb_child_type <span class="token operator">==</span> RDB_CHILD_TYPE_DISK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 正在执行 RDB, 同时类型是写入磁盘</span>        client <span class="token operator">*</span>slave<span class="token punctuation">;</span>        listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>        listIter li<span class="token punctuation">;</span>                <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 遍历所有的从节点, 找到第一个节点的状态为 SLAVE_STATE_WAIT_BGSAVE_END (等待 bgsave 的结束, 即等待 RDB 文件的创建结束)</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            slave <span class="token operator">=</span> ln<span class="token operator">-></span>value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slave<span class="token operator">-></span>replstate <span class="token operator">==</span> SLAVE_STATE_WAIT_BGSAVE_END<span class="token punctuation">)</span>                 <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 有找到对应的节点, 当前客户端的节点的复制能力和找到的节点的复制能力一样</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ln <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">-></span>slave_capa <span class="token operator">&amp;</span> slave<span class="token operator">-></span>slave_capa<span class="token punctuation">)</span> <span class="token operator">==</span> slave<span class="token operator">-></span>slave_capa<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 把找到的节点的输出缓存复制到当前的客户端</span>            <span class="token comment">// 将 slave 的 buf 拷贝到 c 的 buf</span>            <span class="token comment">// 将 slave 的 reply_bytes 拷贝到 c 的 reply_bytes, 响应缓冲区</span>            <span class="token comment">// 将 slave 的 bufpos 设置等于 c 的 bufpos</span>            <span class="token function">copyClientOutputBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>slave<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 更新从节点客户端的偏移量, 状态和发送全量复制消息给从节点</span>            <span class="token comment">// 这个命令会发送 FULLRESYNC replid offset\r\n 的响应给从节点, 可以看做是对 psync 命令的响应</span>            <span class="token comment">// 具体逻辑可以查看 replication 文章的 replicationSetupSlaveForFullResync 方法解析</span>            <span class="token function">replicationSetupSlaveForFullResync</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>slave<span class="token operator">-></span>psync_initial_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>rdb_child_type <span class="token operator">==</span> RDB_CHILD_TYPE_SOCKET<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 正在执行将主节点的数据写入到 Socket, 直接结束</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>             <span class="token comment">// 没有在执行 RDB </span>        <span class="token comment">// 复制类型为无盘同步 同时 当前的客户端支持 EOF 的同步方式</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_diskless_sync <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>slave_capa <span class="token operator">&amp;</span> SLAVE_CAPA_EOF<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 支持延迟无盘同步, 打印日志后结束</span>            <span class="token comment">// 后续在定时器执行的 replicationCron 函数时, 会创建出子进程进行同步</span>            <span class="token comment">// 延迟一段时间, 可以等待几个从节点, 后面同步处理</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 没有子进程正在执行 BGSAVE, 且没有进行写 AOF 文件, 则开始为复制执行 BGSAVE, 并且是将 RDB 文件写到磁盘上</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 内部和 RDB 的操作类似, 分为主子进程, fork 出子进程后, 子进程进行 RDB 的生成</span>                <span class="token comment">// 主进程也会通过 replicationSetupSlaveForFullResync 函数进行 psync 的应答</span>                <span class="token comment">// 具体逻辑可以查看 replication 文章的 startBgsaveForReplication 方法解析</span>                <span class="token function">startBgsaveForReplication</span><span class="token punctuation">(</span>c<span class="token operator">-></span>slave_capa<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>这段代码的核心 <strong>masterTryPartialResynchronization</strong>,<br>内部会根据 psync 的 2 个参数 repl_id + repl_offset 和自身的 replid 和 replid2 和复制积压缓冲区的情况, 判断是否走部分复制</p><blockquote><p>1 入参的 repl_id 和当前主节点的 replid 和 replid2 (自己保存的主节点的 id) 不一样<br>2 入参的 repl_id 和当前主节点的 repl_id2 一样, 但是 repl_offset 和当前主节点的 second_replid_offset 大 (以前同步于同一个主节点, 但是现在的从节点比自己同步的快)<br>3 请求的偏移量 repl_offset 小于 repl_backlog_off (复制积压缓冲区最老的位置) , 说明 backlog 所备份的数据的已经太新了, 需要的已经不在复制积压缓冲区中<br>4 请求的偏移量 repl_offset 大于 repl_backlog_off + repl_backlog_histlen (复制积压缓冲区的容量大小) , 表示当前 backlog 的数据不够全，从节点超过了复制积压缓冲区的最新数据了, 需要进行全量复制</p></blockquote><p>出现上面 4 种情况的其中一种, 就会进入到全量复制</p><h4 id="8-2-1-masterTryPartialResynchronization-判断需要全量复制"><a href="#8-2-1-masterTryPartialResynchronization-判断需要全量复制" class="headerlink" title="8.2.1 masterTryPartialResynchronization 判断需要全量复制"></a>8.2.1 masterTryPartialResynchronization 判断需要全量复制</h4><ol><li>设置当前的客户端为 SLAVE_STATE_WAIT_BGSAVE_START (等待 bgsave 开始, 也就是 RDB 文件的创建)</li><li>把当前的客户端加入维护的<strong>从节点客户端列表</strong>中</li><li>如果从节点客户端列表只有 1 个节点同时复制积压缓冲区为空, 创建复制积压缓冲区</li><li>如果当前主节点在执行自身的持久化 RDB, 并且从<strong>节点客户端列表</strong>中找到第一个状态为 SLAVE_STATE_WAIT_BGSAVE_END (等待 RDB 创建文件结束) 同时复制能力和自己一样的<blockquote><p>4.1 将这个节点的响应缓冲区的数据拷贝一份到自己的输出缓冲区 (自身不需要在去触发一次 RDB 了, 复用它已有的输出数据)<br>4.2 修改状态为自身的状态为 SLAVE_STATE_WAIT_BGSAVE_END (等待 RDB 创建文件结束)<br>4.3 同时向从节点发送 +FULLRESYNC replid offset\r\n (避免从节点发一次全量复制就触发一次 RDB, 复用已有的)<br>4.4 发送 +FULLRESYNC replid offset\r\n 给从节点 </p></blockquote></li><li>如果当前主节点在执行主从复制的 RDB, 直接结束方法, 避免大量的子进程写文件, 拖垮主节点</li><li>当前的主节点支持<strong>无盘延迟同步</strong>同时当前从节点支持 <strong>EOF 也就是网络同步</strong>, 那么先结束, 后续由定时任务触发 replicationCron 函数, 创建 RDB 文件, 这样可以延迟同步, 延迟的这段时间可能等到其他需要全量复制和同配置的从节点, 到时可以 bgsave 出一个文件, 共用 (replicationCron 1s 触发一次, 每次会检查所有的从节点和当前主节点的上次交流的时间差, 有一个超过了配置的 repl_diskless_sync_delay 时间, 就立即主从复制)</li><li>当前主节点在 AOF 持久化中, 提前结束</li><li>如果当前的从节点支持 EOF 复制能力同时主节点设置了支持无盘同步<blockquote><p>8.1 在<strong>节点客户端列表</strong>中找到所有状态为 SLAVE_STATE_WAIT_BGSAVE_START (等待 bgsave 开始, 也就是开始创建 RDB 文件) 并且支持 psync 命令的客户端, 发送 +FULLRESYNC replid offset\r\n, 并修改状态为 SLAVE_STATE_WAIT_BGSAVE_END (等待 RDB 创建文件结束)<br>8.2 fork 出一个子进程, 将当前主节点的数据以 EOF 要求的格式写入到满足上一步的所有从节点的 Socket 中, 并阻塞住, 全部写完后一次性全部发送过期</p></blockquote></li><li>如果当前的从节点不支持 EOF 复制能力<blockquote><blockquote><p>9.1 fork 出一个子进程, 将当前主节点的数据按照 RDB 的方式保存到文件中<br>9.1 在<strong>节点客户端列表</strong> 中找到所有状态为 SLAVE_STATE_WAIT_BGSAVE_START (等待 bgsave 开始, 也就是开始创建 RDB 文件) 并且支持 psync 命令的客户端, 发送 +FULLRESYNC replid offset\r\n, 并修改状态为 SLAVE_STATE_WAIT_BGSAVE_END (等待 RDB 创建文件结束)</p></blockquote></blockquote></li></ol><h4 id="8-2-2-masterTryPartialResynchronization-判断可以部分复制"><a href="#8-2-2-masterTryPartialResynchronization-判断可以部分复制" class="headerlink" title="8.2.2 masterTryPartialResynchronization 判断可以部分复制"></a>8.2.2 masterTryPartialResynchronization 判断可以部分复制</h4><ol><li>设置当前的从节点 repl_put_online_on_ack 为 0, 也就是还未 ack </li><li>把当前的从节点加入动节点客户端列表</li><li>如果当前的从节点支持 psync2 则向其发送 +CONTINUE 主节点当前的 repl_id \r\n, 否则发送 +CONTINUE\r\n</li><li>根据入参的 repl_offset 从复制积压缓冲区获取对应的数据, 写入到客户端的输出缓冲区中</li></ol><p>上面就是主节点收到从节点 psync 命令, 为开始复制做准备, 虽然全量复制和部分部分复制有些不同, 但是都可以简单的看为, 将复制的数据写入到从节点的输出缓冲区中, 等待发送。</p><h3 id="8-3-从节点收到主节点对-psync-命令的响应"><a href="#8-3-从节点收到主节点对-psync-命令的响应" class="headerlink" title="8.3 从节点收到主节点对 psync 命令的响应"></a>8.3 从节点收到主节点对 psync 命令的响应</h3><p><strong>从节点</strong>收到主节点的响应后, 从节点同样是事件轮询触发 <strong>syncWithMaster</strong> 函数。</p><p>在从节点发送出 <strong>psync</strong> 命令后, 状态为 <strong>REPL_STATE_RECEIVE_PSYNC (等待 psync 应答)</strong>, 继续从这个状态走下去</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 状态不是 REPL_STATE_RECEIVE_PSYNC 直接失败</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">!=</span> REPL_STATE_RECEIVE_PSYNC<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> error<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 读取主节点的响应, 如果是全量复制, 响应为 PSYNC_FULLRESYNC, 部分复制, 响应为 PSYNC_CONTINUE</span>    <span class="token comment">// 具体逻辑可以查看 replication 文章的 slaveTryPartialResynchronization 方法读的部分逻辑</span>    psync_result <span class="token operator">=</span> <span class="token function">slaveTryPartialResynchronization</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 等待重新执行</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>psync_result <span class="token operator">==</span> PSYNC_WAIT_REPLY<span class="token punctuation">)</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>     <span class="token comment">// 主节点正处于暂时性错误状态</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>psync_result <span class="token operator">==</span> PSYNC_TRY_LATER<span class="token punctuation">)</span>         <span class="token keyword">goto</span> error<span class="token punctuation">;</span>    <span class="token comment">// psync 命令主节点完成, 判断可以部分复制, 从节点可以继续执行其他的, 到这步直接结束</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>psync_result <span class="token operator">==</span> PSYNC_CONTINUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 释放所有的从节点连接</span>    <span class="token function">disconnectSlaves</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 清空已有的复制积压缓冲区</span>    <span class="token comment">// 具体逻辑可以查看 replication 文章的 freeReplicationBacklog 方法解析</span>    <span class="token function">freeReplicationBacklog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 主节点无法识别 psync, 需要尝试执行 sync </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>psync_result <span class="token operator">==</span> PSYNC_NOT_SUPPORTED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 不支持 psync, 则发送 sync</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">syncWrite</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token string">"SYNC\r\n"</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span>server<span class="token punctuation">.</span>repl_syncio_timeout<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">goto</span> error<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>            <span class="token keyword">char</span> tmpfile<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>err <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dfd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> maxtries <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment">// 尝试创建一个临时文件, 失败的话, 进行重试, 可以重试 5 次</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>maxtries<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 创建一个临时文件</span>        <span class="token function">snprintf</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token string">"temp-%d.%ld.rdb"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span>unixtime<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dfd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span>O_CREAT<span class="token operator">|</span>O_WRONLY<span class="token operator">|</span>O_EXCL<span class="token punctuation">,</span><span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dfd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 创建文件失败</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dfd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> error<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 为创建的文件描述符 添加可读事件, 用来下载监听到的数据, 也就是父级发送过来的 RDB, 处理函数为 readSyncBulkPayload</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">,</span> readSyncBulkPayload<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> AE_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> error<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 修改状态为 REPL_STATE_TRANSFER (开始接收 RDB 文件)</span>    server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_TRANSFER<span class="token punctuation">;</span>    <span class="token comment">// 更新复制相关变量的值</span>    server<span class="token punctuation">.</span>repl_transfer_size <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_transfer_read <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_transfer_last_fsync_off <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_transfer_fd <span class="token operator">=</span> dfd<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_transfer_lastio <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_transfer_tmpfile <span class="token operator">=</span> <span class="token function">zstrdup</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>slaveTryPartialResynchronization 函数可以根据入参进行写消息给主节点和读取主节点消息, 这里需要读取主节点的响应数据, 所以下面梳理的是读部分的逻辑</p><ol><li>读取到的内容为 +FULLRESYNC<blockquote><p>1.1 将当前的从节点的 server 的 master_replid 和 master_initial_offset 设置为 +FULLRESYNC 后面的 replId 和 replId_offset<br>1.2 释放到 server.cached_master 的缓存主节点<br>1.3 返回 PSYNC_FULLRESYNC</p></blockquote></li><li>读取到的内容为 +CONTINUE<blockquote><p>2.1 获取 +CONTINUE 后面的 replId, 如果和已有的 server.cached_master 的 replId 不一致, 则将 server.cached_master 的 replId 和 offset 变为 replId2 和 offset2, 参数的 replId 变为 server.cached_master 的 replId, 同时断开所有自己所有从节点的连接<br>2.2 将原本的 server.cached_master 晋升为 server.master, server.cached_master 变为 null<br>2.3 将当前的从节点状态变为 REPL_STATE_CONNECTED (已连接上主节点)<br>2.4 为当前的主节点注册一个可读的事件, 执行函数为 readQueryFromClient<br>2.5 返回 PSYNC_CONTINUE</p></blockquote></li></ol><p>上面就是 slaveTryPartialResynchronization 读操作的逻辑, 整合 syncWithMaster 的 REPL_STATE_RECEIVE_PSYNC 状态的核心逻辑如下</p><ol><li>收到了 +FULLRESYNC<blockquote><p>1.1 创建一个临时的 RDB 文件, 向事件轮询注册一个可读的事件, 执行函数 readSyncBulkPayload, 用于将主节点发送的数据写入到临时文件中和其他的逻辑<br>1.2 自身状态变更为 REPL_STATE_TRANSFER (开始接收 RDB 文件)<br>1.3 更新自身的主从复制相关的信息</p></blockquote></li></ol><p>全量复制整个过程串起来如下:<br><img src="https://pic.imgdb.cn/item/66def5fad9c307b7e94f1d76.png" alt="Alt &#39;psync 命令, 判断为全量复制&#39;"></p><ol start="2"><li>收到了 +CONTINUE<blockquote><p>2.1 将当前的从节点状态变为 REPL_STATE_CONNECTED (已连接上主节点)<br>2.2 向事件轮询注册一个可读的事件, 执行函数 readQueryFromClient, 用于读取并处理主节点发送过来的命令</p></blockquote></li></ol><p>部分复制整个过程串起来如下:<br><img src="https://pic.imgdb.cn/item/66def5fdd9c307b7e94f250a.png" alt="Alt &#39;psync命令, 判断为部分复制&#39;"></p><h2 id="9-主节点向从节点推送数据"><a href="#9-主节点向从节点推送数据" class="headerlink" title="9 主节点向从节点推送数据"></a>9 主节点向从节点推送数据</h2><p>上面的步骤基本就是主从节点为数据同步做的前期准备, 主从节点只是做好了发送同步数据的准备, 实际此时还是没有数据的复制的 (无盘同步先写入到 Socket, 写完直接全部发送, 因为有不确定暂时认为未复制)。  </p><p>从第 8 位可以知道, 在主节点将自身的数据发送给从节点的方式有 2 种</p><blockquote><p>1 只能全量复制, 主节点所有数据的以 RDB 数据发送给从节点, 这里又细分为 2 种, 无盘同步, 直接将数据通过 Socket 发送过去, 非无盘同步, 先将数据保存为 rdb 文件, 再发送文件<br>2 可以部分复制, 从主节点复制积压缓冲区中获取的数据</p></blockquote><p>对于这 2 种数据, 主节点有 2 种方式发送数据给从节点。</p><h3 id="9-1-主节点和从节点全量复制的数据"><a href="#9-1-主节点和从节点全量复制的数据" class="headerlink" title="9.1 主节点和从节点全量复制的数据"></a>9.1 主节点和从节点全量复制的数据</h3><h4 id="9-1-1-主节点向推送节点全量复制的数据"><a href="#9-1-1-主节点向推送节点全量复制的数据" class="headerlink" title="9.1.1 主节点向推送节点全量复制的数据"></a>9.1.1 主节点向推送节点全量复制的数据</h4><p>前期的准备完成后, 主节点会尝试发送数据到从节点, 触发发送的链路如下:</p><ol><li>定时函数 serverCron, 判断出当前的 RDB 子进程不为空, 同时子进行已经完成, 触发 backgroundSaveDoneHandler 函数</li><li>backgroundSaveDoneHandler 中无论什么类型的 RDB (Socket&#x2F;磁盘), 都会走到 updateSlavesWaitingBgsave 函数</li><li>updateSlavesWaitingBgsave 中, 遍历所有的从节点<blockquote><p>4.1 所有从节点中任意有一个的状态为 SLAVE_STATE_WAIT_BGSAVE_START (等待 bgsave 开始, 也就是开始创建 RDB 文件), 触发第 8.2.1 中第 8 步的逻辑<br>4.2 遍历的从节点状态等于 SLAVE_STATE_WAIT_BGSAVE_END 并且同步类型为 Socket 同步, 则当前的从节点的状态变为 SLAVE_STATE_ONLINE (在线), 同时 repl_put_online_on_ack &#x3D; 1, 从节点已 ack<br>4.3 遍历的从节点状态等于 SLAVE_STATE_WAIT_BGSAVE_END 并且同步类型不是 Socket 同步, 向事件轮询注册发送数据事件 sendBulkToSlave, 从节点的状态变为 SLAVE_STATE_SEND_BULK (批量发送数据中)</p></blockquote></li></ol><pre class="language-C" data-language="C"><code class="language-C">void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) &#123;    client *slave &#x3D; privdata;    UNUSED(el);    UNUSED(mask);    char buf[PROTO_IOBUF_LEN];    ssize_t nwritten, buflen;        &#x2F;&#x2F; 发送序言, 这里只是简单发送出了文件的大小, 格式 $&lt;length&gt;\r\n&quot;    if (slave-&gt;replpreamble) &#123;        nwritten &#x3D; write(fd,slave-&gt;replpreamble,sdslen(slave-&gt;replpreamble));        if (nwritten &#x3D;&#x3D; -1) &#123;            freeClient(slave);            return;        &#125;        &#x2F;&#x2F; 更新已经写到网络的字节数        server.stat_net_output_bytes +&#x3D; nwritten;        &#x2F;&#x2F; 保留未写的字节, 删除已写的字节        sdsrange(slave-&gt;replpreamble,nwritten,-1);        &#x2F;&#x2F; 如果已经写完了, 则释放 replpreamble        if (sdslen(slave-&gt;replpreamble) &#x3D;&#x3D; 0) &#123;            sdsfree(slave-&gt;replpreamble);            &#x2F;&#x2F; 设置为 null, 下次进来不会再触发            slave-&gt;replpreamble &#x3D; NULL;        &#125; else &#123;            return;        &#125;    &#125;        &#x2F;&#x2F; slave-&gt;repldbfd 代表 RDB 文件    &#x2F;&#x2F; 将文件指针移动到 slave-&gt;repldboff 位置, 准备读操作    lseek(slave-&gt;repldbfd, slave-&gt;repldboff, SEEK_SET);    &#x2F;&#x2F; PROTO_IOBUF_LEN &#x3D; 1024 * 16, 16kb    &#x2F;&#x2F; 从 RDB 文件的 slave-&gt;repldboff 位置读取 16k 数据的内容保存在 buf 中    buflen &#x3D; read(slave-&gt;repldbfd, buf, PROTO_IOBUF_LEN);        &#x2F;&#x2F; 读取不到数据, 结束    if (buflen &lt;&#x3D; 0) &#123;        freeClient(slave);        return;    &#125;        &#x2F;&#x2F; 将读取到的 16k 数据写到从节点    if ((nwritten &#x3D; write(fd, buf, buflen)) &#x3D;&#x3D; -1) &#123;        &#x2F;&#x2F; 写入失败        if (errno !&#x3D; EAGAIN) &#123;            freeClient(slave);        &#125;        return;    &#125;        &#x2F;&#x2F; 到了这里, 大概可以理解这个发送 RDB 文件的过程不是一次性的    &#x2F;&#x2F; 每次发送 16k, 下次事件轮询触发, 再触发发送 16k, 知道全部写完    &#x2F;&#x2F; 更新主节点已经向从节点同步的字节数    slave-&gt;repldboff +&#x3D; nwritten;    &#x2F;&#x2F; 更新服务器已经写到网络的字节数    server.stat_net_output_bytes +&#x3D; nwritten;    &#x2F;&#x2F; 如果写入完成, 即从网络读到的大小等于文件大小, 写完了    if (slave-&gt;repldboff &#x3D;&#x3D; slave-&gt;repldbsize) &#123;        &#x2F;&#x2F; 关闭 RDB 文件流        close(slave-&gt;repldbfd);        slave-&gt;repldbfd &#x3D; -1;        &#x2F;&#x2F; 删除等待从节点的文件可写事件        aeDeleteFileEvent(server.el, slave-&gt;fd, AE_WRITABLE);        &#x2F;&#x2F; 更新从节点的状态为 SLAVE_STATE_ONLINE (在线状态) 和 repl_put_online_on_ack &#x3D; 0 (ack 为未应答)        &#x2F;&#x2F; 为当前的从节点注册一个写事件, 触发函数为 sendReplyToClient, 将输出缓冲区中的数据发送给从节点, 也就是后续有新数据写给从节点, 就由 sendReplyToClient 触发发送        &#x2F;&#x2F; 具体逻辑可以查看 replication 文章的 putSlaveOnline 方法解析        putSlaveOnline(slave);    &#125;&#125; </code></pre><p>主节点的事件轮询触发 sendBulkToSlave 函数, 逻辑大体如下</p><ol><li>先向从节点发送了当前 RDB 文件的大小</li><li>间断地将 RDB 文件的数据按照 16k 的大小发送给从节点</li><li>RDB 文件全部写给从节点后, 修改从节点的状态为 SLAVE_STATE_ONLINE (在线), 但是 repl_put_online_on_ack &#x3D; 0, 从节点未来 ack</li></ol><h4 id="9-1-2-从节点接收主节点推送的全量复制的数据"><a href="#9-1-2-从节点接收主节点推送的全量复制的数据" class="headerlink" title="9.1.2 从节点接收主节点推送的全量复制的数据"></a>9.1.2 从节点接收主节点推送的全量复制的数据</h4><p>在 8.3 中从节点收到主节点对 psync 命令的响应, 判断到只能全量复制, 就注册了一个 readSyncBulkPayload 函数, 用来读取主节点发送过来的 RDB 数据</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">readSyncBulkPayload</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">4096</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">ssize_t</span> nread<span class="token punctuation">,</span> readlen<span class="token punctuation">,</span> nwritten<span class="token punctuation">;</span>    <span class="token class-name">off_t</span> left<span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>privdata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">char</span> eofmark<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">char</span> lastbytes<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> usemark <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 没有传输过任何数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_size <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 读取 1024 个字节的数据到 buf 中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">syncReadLine</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>repl_syncio_timeout<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">goto</span> error<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'-'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 主节点返回错误信息</span>            <span class="token keyword">goto</span> error<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 回复了一个空行, 只是为了像 ping 一样让连接存活, 只是简单的刷新了一些最新的传输时间</span>            server<span class="token punctuation">.</span>repl_transfer_lastio <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'$'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 协议格式错误</span>            <span class="token keyword">goto</span> error<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// CONFIG_RUN_ID_SIZE 40 </span>        <span class="token comment">// 响应的内容为 EOF: 同时 buf 第 5 位后的字符串长度大于 40 (replid 的最大长度)</span>        <span class="token comment">// Socket 方式发送过来的数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strncmp</span><span class="token punctuation">(</span>buf<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"EOF:"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">>=</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 使用 EOF 标记模式</span>            usemark <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">// 2 个静态变量, 主要是保存 EOF 的中的 replid</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>eofmark<span class="token punctuation">,</span> buf<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">,</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">memset</span><span class="token punctuation">(</span>lastbytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 修改为 0, 防止下次调用又跑到这段逻辑里面</span>            server<span class="token punctuation">.</span>repl_transfer_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 使用固定长度模式 (RDB 文件的方式, 主节点默认每次发送 16k 数据)</span>            usemark <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment">// 读取长度大小</span>            server<span class="token punctuation">.</span>repl_transfer_size <span class="token operator">=</span> <span class="token function">strtol</span><span class="token punctuation">(</span>buf<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 根据模式, 计算这次读多少数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>usemark<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 每次读取缓冲区大小的数据</span>        readlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 读取剩余数据与缓冲区大小的较小值</span>        left <span class="token operator">=</span> server<span class="token punctuation">.</span>repl_transfer_size <span class="token operator">-</span> server<span class="token punctuation">.</span>repl_transfer_read<span class="token punctuation">;</span>        readlen <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">signed</span><span class="token punctuation">)</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> left <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">signed</span><span class="token punctuation">)</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 读取数据到 buf 中</span>    nread <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nread <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 读取失败, 取消握手</span>        <span class="token comment">// 具体逻辑可以查看 replication 文章的 cancelReplicationHandshake 方法解析  </span>        <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    server<span class="token punctuation">.</span>stat_net_input_bytes <span class="token operator">+=</span> nread<span class="token punctuation">;</span>    <span class="token keyword">int</span> eof_reached <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>usemark<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 当使用 EOF 标记模式时，需要检测是否已经到达数据结尾</span>        <span class="token comment">// 更新 lastbytes 并检查是否匹配 EOF 标记</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nread <span class="token operator">>=</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>lastbytes<span class="token punctuation">,</span> buf<span class="token operator">+</span>nread<span class="token operator">-</span>CONFIG_RUN_ID_SIZE<span class="token punctuation">,</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> rem <span class="token operator">=</span> CONFIG_RUN_ID_SIZE <span class="token operator">-</span> nread<span class="token punctuation">;</span>            <span class="token function">memmove</span><span class="token punctuation">(</span>lastbytes<span class="token punctuation">,</span>lastbytes<span class="token operator">+</span>nread<span class="token punctuation">,</span>rem<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>lastbytes<span class="token operator">+</span>rem<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>nread<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 通过维护一个 lastbytes 数组，存储最近接收到的字节，与 eofmark 进行比较</span>        <span class="token comment">// 如果匹配，表示已经接收到完整的数据，设置 eof_reached 标志</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">memcmp</span><span class="token punctuation">(</span>lastbytes<span class="token punctuation">,</span> eofmark<span class="token punctuation">,</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>           eof_reached <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将读取到的数据写入到 repl_transfer_fd 临时文件中</span>    server<span class="token punctuation">.</span>repl_transfer_lastio <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> nread<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> nread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> error<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 更新同步的字节数</span>    server<span class="token punctuation">.</span>repl_transfer_read <span class="token operator">+=</span> nread<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>usemark <span class="token operator">&amp;&amp;</span> eof_reached<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// EOF 模式, 同时读取到末尾了</span>        <span class="token comment">// 计算文件 repl_transfer_read 的大小, 也就是把末尾的 40 个字节去掉</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ftruncate</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_fd<span class="token punctuation">,</span> server<span class="token punctuation">.</span>repl_transfer_read <span class="token operator">-</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">goto</span> error<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 当前读取到的数据大于上次刷盘数据的 REPL_MAX_WRITTEN_BEFORE_FSYNC 8M, 进行刷盘</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_read <span class="token operator">>=</span> server<span class="token punctuation">.</span>repl_transfer_last_fsync_off <span class="token operator">+</span> REPL_MAX_WRITTEN_BEFORE_FSYNC<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">off_t</span> sync_size <span class="token operator">=</span> server<span class="token punctuation">.</span>repl_transfer_read <span class="token operator">-</span> server<span class="token punctuation">.</span>repl_transfer_last_fsync_off<span class="token punctuation">;</span>        <span class="token function">rdb_fsync_range</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_fd<span class="token punctuation">,</span> server<span class="token punctuation">.</span>repl_transfer_last_fsync_off<span class="token punctuation">,</span> sync_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>repl_transfer_last_fsync_off <span class="token operator">+=</span> sync_size<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 在固定长度模式下, 检查已读取的字节数是否等于预期的总长度, 确定传输是否完成</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>usemark<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_read <span class="token operator">==</span> server<span class="token punctuation">.</span>repl_transfer_size<span class="token punctuation">)</span>            eof_reached <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>eof_reached<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// aof 是否启用状态</span>        <span class="token keyword">int</span> aof_is_enabled <span class="token operator">=</span> server<span class="token punctuation">.</span>aof_state <span class="token operator">!=</span> AOF_OFF<span class="token punctuation">;</span>        <span class="token comment">// 当前节点在 RDB 中, 则结束掉这个 RDB 过程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">kill</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid<span class="token punctuation">,</span>SIGUSR1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rdbRemoveTempFile</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 最后一次刷盘</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fsync</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_fd<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 把从主节点同步的 RDB 文件重命名为真实的 RDB 文件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rename</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_tmpfile<span class="token punctuation">,</span>server<span class="token punctuation">.</span>rdb_filename<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 停止 AOF 写入, 防止在清空和加载数据时出现写时复制（COW）问题，导致内存占用过高</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>aof_is_enabled<span class="token punctuation">)</span> <span class="token function">stopAppendOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">signalFlushedDb</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">emptyDb</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>repl_slave_lazy_flush <span class="token operator">?</span> EMPTYDB_ASYNC <span class="token operator">:</span> EMPTYDB_NO_FLAGS<span class="token punctuation">,</span> replicationEmptyDbCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 删除文件事件，避免再次调用</span>        <span class="token function">aeDeleteFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> server<span class="token punctuation">.</span>repl_transfer_s<span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>        rdbSaveInfo rsi <span class="token operator">=</span> RDB_SAVE_INFO_INIT<span class="token punctuation">;</span>        <span class="token comment">// 将新的 RDB 文件数据加载到内存中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbLoad</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_filename<span class="token punctuation">,</span><span class="token operator">&amp;</span>rsi<span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 加载失败</span>            <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 重写开始 AOF 同步</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>aof_is_enabled<span class="token punctuation">)</span> <span class="token function">restartAOFAfterSYNC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 释放临时文件名的内存</span>        <span class="token function">zfree</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 关闭文件描述符</span>        <span class="token function">close</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 创建与主节点的新客户端连接, 同时指定数据库</span>        <span class="token function">replicationCreateMasterClient</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_s<span class="token punctuation">,</span> rsi<span class="token punctuation">.</span>repl_stream_db<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新复制状态为已连接, 重置下线时间</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECTED<span class="token punctuation">;</span>        server<span class="token punctuation">.</span>repl_down_since <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">,</span>server<span class="token punctuation">.</span>master<span class="token operator">-></span>replid<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>master_repl_offset <span class="token operator">=</span> server<span class="token punctuation">.</span>master<span class="token operator">-></span>reploff<span class="token punctuation">;</span>        <span class="token function">clearReplicationId2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token function">createReplicationBacklog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 有停掉的 AOF, 重新启动</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>aof_is_enabled<span class="token punctuation">)</span> <span class="token function">restartAOFAfterSYNC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>error<span class="token operator">:</span>    <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/66def601d9c307b7e94f2d7c.png" alt="Alt &#39;全量复制, 主从节点推送数据&#39;"></p><p>readSyncBulkPayload 的逻辑算是比较清晰的, 主节点每次发送数据给从节点, 就触发一次 readSyncBulkPayload</p><ol><li>计算结束表示, EOF 方式 (Socket 同步) 数据以 EOF:40位的 replId 开始, 以 replId 结束, 而正常的 RDB 文件同步, 则会在以开始就发送数据的长度 </li><li>将读取到的数据写入到临时的 RDB 文件中</li><li>通过判断读取到的数据是否等于一开始读取到的 prelId 或者读取到的长度等于一开始读取到的长度, 确定是否已经读取完成了</li><li>读取到了末尾了, 将临时的 RDB 文件重命名为真实的 RDB 文件, 清空数据库, 删除注册的 readSyncBulkPayload 函数, 将 RDB 中的数据加载到内存中, 更新从节点的状态为 REPL_STATE_CONNECTED (主从节点连接中)</li></ol><p>到此, 从节点和主节点开始的全量复制完成了</p><h3 id="9-2-主节点向从节点推送部分复制的数据"><a href="#9-2-主节点向从节点推送部分复制的数据" class="headerlink" title="9.2 主节点向从节点推送部分复制的数据"></a>9.2 主节点向从节点推送部分复制的数据</h3><p>主节点向从节点推送部分复制的数据这个, 只需要了解赋值积压缓冲区存储的内容是 Redis 执行的请求命令, 就很容易了。</p><p>复制积压缓冲区是一个大小为 1M 的循环队列。主节点在命令传播时, 不仅会将命令发送给所有的从节点, 还会将命令写入复制积压缓冲区中。<br>复制积压缓冲区最多可以备份 1M 大小的数据, 主节点会不断往里面写新的数据, 同时淘汰旧的。如果主从节点断线时间过长, 复制积压缓冲区的数据被新数据覆盖, 旧节点需要的数据已经不在里面, 就只能走全量复制, 否则可以从断开的位置继续同步复制积压缓冲区中的数据。</p><p>在 8.2.2 中判断可以部分复制时, 主节点的逻辑就是将复制积压缓冲区中将从节点指定的 repl_offset 后面的请求命令发送给从节点<br>从节点收到对应的命令重新执行一遍, 同时更新一下自己维护的 repl_offset 就行了</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">processCommand</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 执行命令成功, 更新主从复制同步的偏移量</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_MASTER <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_MULTI<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            c<span class="token operator">-></span>reploff <span class="token operator">=</span> c<span class="token operator">-></span>read_reploff <span class="token operator">-</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-></span>querybuf<span class="token punctuation">)</span> <span class="token operator">+</span> c<span class="token operator">-></span>qb_pos<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/66def604d9c307b7e94f338b.png" alt="Alt &#39;部分复制, 主从节点推送数据&#39;"></p><p>到此, 从节点和主节点开始的部分复制完成了</p><h2 id="10-运行中的数据同步-命令传播"><a href="#10-运行中的数据同步-命令传播" class="headerlink" title="10 运行中的数据同步 - 命令传播"></a>10 运行中的数据同步 - 命令传播</h2><p>经过 psync 命令后, 也就是第一次复制后, 主从节点之间数据都同步了, 但是后续如果主节点继续数据的变更, 又会不一致。<br>为了数据的一致, 主节点应该有种方式将自身的变更同步到从节点, 这个实现的步骤就是命令传播。</p><p>在执行 Redis 命令的函数 call 中, 里面会根据执行的命令和客户端的类型等元素, 判断是否需要执行 propagate 函数, propagate 函数就是命令传播的方法。<br>propagate 函数很简单根据入参的标识判断是否需要进行复制传播, 如果判断为是, 会执行 replicationFeedSlaves 方法</p><p>replicationFeedSlaves 方法的执行逻辑如下:</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationFeedSlaves</span><span class="token punctuation">(</span>list <span class="token operator">*</span>slaves<span class="token punctuation">,</span> <span class="token keyword">int</span> dictid<span class="token punctuation">,</span> robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">int</span> argc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>    listIter li<span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token punctuation">,</span> len<span class="token punctuation">;</span>    <span class="token keyword">char</span> llstr<span class="token punctuation">[</span>LONG_STR_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 有配置主节点, 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 没有复制积压缓冲区 backlog 且没有从节点, 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> <span class="token function">listLength</span><span class="token punctuation">(</span>slaves<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaveseldb <span class="token operator">!=</span> dictid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果当前从节点使用的数据库不是目标的数据库, 则要生成一个 select 命令</span>        robj <span class="token operator">*</span>selectcmd<span class="token punctuation">;</span>        <span class="token comment">// 0 &lt;= id &lt; 10, 可以使用共享的 select 命令对象</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dictid <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dictid <span class="token operator">&lt;</span> PROTO_SHARED_SELECT_CMDS<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            selectcmd <span class="token operator">=</span> shared<span class="token punctuation">.</span>select<span class="token punctuation">[</span>dictid<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 按照协议格式构建 select 命令对象</span>            <span class="token keyword">int</span> dictid_len<span class="token punctuation">;</span>            dictid_len <span class="token operator">=</span> <span class="token function">ll2string</span><span class="token punctuation">(</span>llstr<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>llstr<span class="token punctuation">)</span><span class="token punctuation">,</span>dictid<span class="token punctuation">)</span><span class="token punctuation">;</span>            selectcmd <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span>OBJ_STRING<span class="token punctuation">,</span> <span class="token function">sdscatprintf</span><span class="token punctuation">(</span><span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n"</span><span class="token punctuation">,</span> dictid_len<span class="token punctuation">,</span> llstr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 把当前的 select 命令写入到复制积压缓冲区</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog<span class="token punctuation">)</span>             <span class="token comment">// 具体逻辑可以查看 replication 文章的 feedReplicationBacklogWithObject 方法解析</span>            <span class="token function">feedReplicationBacklogWithObject</span><span class="token punctuation">(</span>selectcmd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">listRewind</span><span class="token punctuation">(</span>slaves<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 遍历所有的从节点</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            client <span class="token operator">*</span>slave <span class="token operator">=</span> ln<span class="token operator">-></span>value<span class="token punctuation">;</span>            <span class="token comment">// 从节点服务器状态为等待 bgsave 的开始, 因此跳过回复, 遍历下一个节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slave<span class="token operator">-></span>replstate <span class="token operator">==</span> SLAVE_STATE_WAIT_BGSAVE_START<span class="token punctuation">)</span>                 <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment">// 添加 select 命令到当前从节点的回复中    </span>            <span class="token function">addReply</span><span class="token punctuation">(</span>slave<span class="token punctuation">,</span>selectcmd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 释放临时对象</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dictid <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> dictid <span class="token operator">>=</span> PROTO_SHARED_SELECT_CMDS<span class="token punctuation">)</span>            <span class="token function">decrRefCount</span><span class="token punctuation">(</span>selectcmd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 设置当前从节点使用的数据库 ID</span>    server<span class="token punctuation">.</span>slaveseldb <span class="token operator">=</span> dictid<span class="token punctuation">;</span>    <span class="token comment">// 将命令写入一份 backlog, 也就是复制积压缓冲区</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> aux<span class="token punctuation">[</span>LONG_STR_SIZE<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 拼写命令 *&lt;argc>\r\n</span>        aux<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'*'</span><span class="token punctuation">;</span>        len <span class="token operator">=</span> <span class="token function">ll2string</span><span class="token punctuation">(</span>aux<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aux<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>argc<span class="token punctuation">)</span><span class="token punctuation">;</span>        aux<span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\r'</span><span class="token punctuation">;</span>        aux<span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>        <span class="token comment">// 写入复制积压缓冲区</span>        <span class="token function">feedReplicationBacklog</span><span class="token punctuation">(</span>aux<span class="token punctuation">,</span>len<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 遍历所有的参数个数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 参数对象的长度</span>            <span class="token keyword">long</span> objlen <span class="token operator">=</span> <span class="token function">stringObjectLen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 构建成协议标准的字符串, 并添加到 backlog 中</span>            <span class="token comment">// $&lt;len>\r\n&lt;argv>\r\n </span>            aux<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'$'</span><span class="token punctuation">;</span>            len <span class="token operator">=</span> <span class="token function">ll2string</span><span class="token punctuation">(</span>aux<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aux<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>objlen<span class="token punctuation">)</span><span class="token punctuation">;</span>            aux<span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\r'</span><span class="token punctuation">;</span>            aux<span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>            <span class="token comment">// 添加 $&lt;len>\r\n</span>            <span class="token function">feedReplicationBacklog</span><span class="token punctuation">(</span>aux<span class="token punctuation">,</span>len<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 添加参数对象 &lt;argv></span>            <span class="token function">feedReplicationBacklogWithObject</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 添加\r\n</span>            <span class="token function">feedReplicationBacklog</span><span class="token punctuation">(</span>aux<span class="token operator">+</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>slaves<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        client <span class="token operator">*</span>slave <span class="token operator">=</span> ln<span class="token operator">-></span>value<span class="token punctuation">;</span>        <span class="token comment">// 从节点的状态为等待 bgsave 开始跳过</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>slave<span class="token operator">-></span>replstate <span class="token operator">==</span> SLAVE_STATE_WAIT_BGSAVE_START<span class="token punctuation">)</span>             <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">// 将命令写给正在等待初次 SYNC 的从节点 (所以这些命令在输出缓冲区中排队, 直到初始 SYNC 完成), 或已经与主节点同步</span>        <span class="token comment">// 添加回复的长度</span>        <span class="token function">addReplyMultiBulkLen</span><span class="token punctuation">(</span>slave<span class="token punctuation">,</span>argc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将所有的参数列表添加到从节点的输出缓冲区, 发送给从节点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token function">addReplyBulk</span><span class="token punctuation">(</span>slave<span class="token punctuation">,</span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>和 AOF 持久化一样, 再给从节点 client 写命令时, 会将 SELECT 命令强制写入, 以保证命令正确读到数据库中。<br>同时不仅写入了从节点 client 的输出缓冲区, 而且还会将命令记录到主节点服务器的复制积压缓冲区 server.repl_backlog 中, 这是为了网络闪断后进行部分复制做准备。</p><p><img src="https://pic.imgdb.cn/item/66def608d9c307b7e94f3ace.png" alt="Alt &#39;运行中，数据同步&#39;"></p><h2 id="11-心跳机制"><a href="#11-心跳机制" class="headerlink" title="11 心跳机制"></a>11 心跳机制</h2><p>如果有留意的话, 可以发现上面有一行代码 <strong>slave-&gt;repl_put_online_on_ack &#x3D; 0</strong>, 可以简单的猜到主从节点之间是有一个应答 (心跳) 的机制的。</p><p>在主从节点建立连接后, 他们之间都维护着长连接并彼此发送心跳命令。<br>主从节点彼此都有心跳机制, 各自模拟成对方的客户端进行通信。</p><p>主节点默认每隔 10 秒发送 PING 命令, 判断从节点的连接状态, 可以通过 <strong>repl-ping-salve-period</strong> 进行时间的配置, 默认为 10 秒</p><p>在定时函数 serverCron 中</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 如果当前节点是某个节点的主节点, 那么发送 PING 给从节点</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>replication_cron_loops <span class="token operator">%</span> server<span class="token punctuation">.</span>repl_ping_slave_period<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 创建 PING 命令对象</span>    ping_argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">createStringObject</span><span class="token punctuation">(</span><span class="token string">"PING"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将 PING 发送给从服务器</span>    <span class="token function">replicationFeedSlaves</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span> server<span class="token punctuation">.</span>slaveseldb<span class="token punctuation">,</span> ping_argv<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 对象的引用次数 - 1</span>    <span class="token function">decrRefCount</span><span class="token punctuation">(</span>ping_argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>从节点在主线程中每隔 1 秒发送 <strong>REPLCONF ACK <offset></strong> 命令, 给主节点报告自己当前复制偏移量</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 定期发送 ack 给主节点, 旧版本的 Redis 除外</span><span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>master <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_PRE_PSYNC<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// 发送一个 replconf ack 命令给主节点 报告自身的 repl_offset</span>    <span class="token comment">// 具体逻辑可以查看 replication 文章的 replicationSendAck 方法解析</span>    <span class="token function">replicationSendAck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>主节点</strong> 收到后, 同样是在 replconfCommand 中处理</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replconfCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argc <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>syntaxerr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> c<span class="token operator">-></span>argc<span class="token punctuation">;</span> j<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"listening-port"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"ip-address"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"capa"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"ack"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">long</span> <span class="token keyword">long</span> offset<span class="token punctuation">;</span>            <span class="token comment">// 不是从节点不做处理</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_SLAVE<span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token comment">// 获取第二个参数 repl_offset</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">getLongLongFromObject</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>offset<span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token comment">// 更新客户端对应的偏移量</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">></span> c<span class="token operator">-></span>repl_ack_off<span class="token punctuation">)</span>                c<span class="token operator">-></span>repl_ack_off <span class="token operator">=</span> offset<span class="token punctuation">;</span>                            <span class="token comment">// 更新收到 ack 的时间为当前时间</span>            c<span class="token operator">-></span>repl_ack_time <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>            <span class="token comment">// 客户端设置了收到 ack 时需要变更为在线状态 同时当前客户端的状态为 SLAVE_STATE_ONLINE</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>repl_put_online_on_ack <span class="token operator">&amp;&amp;</span> c<span class="token operator">-></span>replstate <span class="token operator">==</span> SLAVE_STATE_ONLINE<span class="token punctuation">)</span>                <span class="token function">putSlaveOnline</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 结束, 这个命令不需要响应任何信息</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"getack"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token function">addReplyErrorFormat</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"Unrecognized REPLCONF option: %s"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>ok<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>从节点</strong>还会在周期性函数 replicationCron() 中, 每次都要检查和主节点处于连接状态的从节点和主节点的交互时间是否超时,<br>如果超时则会调用 cancelReplicationHandshake() 函数, 取消和主节点的连接。 等到下一个周期在和主节点重新建立连接, 进行复制。</p><h2 id="12-参考"><a href="#12-参考" class="headerlink" title="12 参考"></a>12 参考</h2><p><a href="https://blog.csdn.net/men_wen/article/details/72628439">Redis 复制(replicate)实现</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 主从复制分析 - 基础</title>
      <link href="/article/2024/1622708120/"/>
      <url>/article/2024/1622708120/</url>
      
        <content type="html"><![CDATA[<h2 id="1-主从节点运行数据的存储"><a href="#1-主从节点运行数据的存储" class="headerlink" title="1 主从节点运行数据的存储"></a>1 主从节点运行数据的存储</h2><p>在主从复制中, 对于主节点, 从节点就是自身的一个客户端, 所以和普通的客户端一样, 会被组织为一个 client 的结构体。 </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span> client<span class="token punctuation">;</span></code></pre><p>同时无论是从节点, 还是主节点, 在运行中的数据都存放在一个 redisServer 的结构体中, 定义如下:</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>在主从复制中的 client 和 redisServer 都是用来存储运行中的一些数据。<br>具体里面存储的数据是什么, 在后面的源码分析中, 逐渐了解。</p><h2 id="2-主从节点复制中的状态枚举"><a href="#2-主从节点复制中的状态枚举" class="headerlink" title="2 主从节点复制中的状态枚举"></a>2 主从节点复制中的状态枚举</h2><h3 id="2-1-从节点自身状态的状态枚举"><a href="#2-1-从节点自身状态的状态枚举" class="headerlink" title="2.1 从节点自身状态的状态枚举"></a>2.1 从节点自身状态的状态枚举</h3><p>整个主从复制是一个复杂的过程, 所以在从节点中, 维护了一套状态, 通过状态来判断下一步的流程 (有点像状态模式)</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 没有开启主从复制功能, 默认的状态</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_NONE</span> <span class="token expression"><span class="token number">0</span></span></span><span class="token comment">// 开启了主从复制, 但是还没连接上主节点</span><span class="token comment">// 执行了 slaveof/replicaof 命令时, 从节点的切换成的状态 </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_CONNECT</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token comment">// 正在连接主节点, 从节点开始连接主节点</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_CONNECTING</span> <span class="token expression"><span class="token number">2</span></span></span><span class="token comment">/* --- 握手阶段的状态开始, 整个握手过程必须按照下面的顺序进行 --- */</span><span class="token comment">// 从节点发送了 ping, 等待主节点 pong  应答 (正常情况, 主节点会回复一个 pong)</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_RECEIVE_PONG</span> <span class="token expression"><span class="token number">3</span></span></span><span class="token comment">// 准备发送认证密码给主节点</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_SEND_AUTH</span> <span class="token expression"><span class="token number">4</span></span></span><span class="token comment">// 等待主节点响应认证结果应答</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_RECEIVE_AUTH</span> <span class="token expression"><span class="token number">5</span></span></span><span class="token comment">// 准备发送从节点的监听的端口</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_SEND_PORT</span> <span class="token expression"><span class="token number">6</span> </span></span><span class="token comment">// 等待主节点响应收到从节点端口</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_RECEIVE_PORT</span> <span class="token expression"><span class="token number">7</span></span></span><span class="token comment">// 发送主从复制配置的监听的 IP 地址</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_SEND_IP</span> <span class="token expression"><span class="token number">8</span> </span></span><span class="token comment">// 等待主节点响应收到从节点的 IP 地址</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_RECEIVE_IP</span> <span class="token expression"><span class="token number">9</span></span></span><span class="token comment">// 准备发送从节点支持的同步能力 </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_SEND_CAPA</span> <span class="token expression"><span class="token number">10</span> </span></span><span class="token comment">// 等待主节点响应收到支持的同步能力的应答</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_RECEIVE_CAPA</span> <span class="token expression"><span class="token number">11</span></span></span><span class="token comment">// 向主节点发送 psync 命令, 请求同步复制</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_SEND_PSYNC</span> <span class="token expression"><span class="token number">12</span> </span></span><span class="token comment">// 等待 psync 应答</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_RECEIVE_PSYNC</span> <span class="token expression"><span class="token number">13</span></span></span><span class="token comment">/* --- 握手阶段的状态结束 --- */</span><span class="token comment">// 正在接收从主节点发送过来的 RDB 文件</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_TRANSFER</span> <span class="token expression"><span class="token number">14</span> </span></span><span class="token comment">// 已经连接状态</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_CONNECTED</span> <span class="token expression"><span class="token number">15</span> </span></span></code></pre><h3 id="2-2-主节点保存从节点的状态枚举"><a href="#2-2-主节点保存从节点的状态枚举" class="headerlink" title="2.2 主节点保存从节点的状态枚举"></a>2.2 主节点保存从节点的状态枚举</h3><p>对于主节点而言, 需要知道从节点当前的状态的, 好进行对应的操作, 但是不需要那么详细, 主节点也维护了一套从节点运行时的状态</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 等待 bgsave (生成 RDB 文件的函数) 的开始</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLAVE_STATE_WAIT_BGSAVE_START</span> <span class="token expression"><span class="token number">6</span></span></span><span class="token comment">// 等待 bgsave 的结束, 也就是 RDB 文件的创建结束</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLAVE_STATE_WAIT_BGSAVE_END</span> <span class="token expression"><span class="token number">7</span></span></span><span class="token comment">// 发送一个 RDB 文件到从节点</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLAVE_STATE_SEND_BULK</span> <span class="token expression"><span class="token number">8</span></span></span><span class="token comment">// 从节点在线</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLAVE_STATE_ONLINE</span> <span class="token expression"><span class="token number">9</span></span></span></code></pre><h2 id="3-从节点复制能力"><a href="#3-从节点复制能力" class="headerlink" title="3 从节点复制能力"></a>3 从节点复制能力</h2><h3 id="3-1-全量复制和部分复制"><a href="#3-1-全量复制和部分复制" class="headerlink" title="3.1 全量复制和部分复制"></a>3.1 全量复制和部分复制</h3><p>整个主从复制, 大体可以概括为 3 种情况</p><blockquote><ol><li>一开始, 主从节点建立连接, 这时候主节点需要将自身所有的数据全部同步给从节点</li><li>运行中, 主节点需要将自己处理的命令, 发送一份给从节点, 这样才能保证主从的一致</li><li>运行中, 出现了网络波动, 服务重启等情况, 重新恢复正常时, 主从需要重新通过<strong>复制</strong>, 让彼此的数据重新保持一致</li></ol></blockquote><p><strong>第一步</strong><br>主从建立了连接, 主节点会将自身所有的数据生成为一个 RDB 的文件, 然后以 <strong>EOF</strong> 的流格式发送给从节点。<br>当然, Redis 在 2.8.18 版本开始支持<strong>无盘复制</strong>, 子进程直接将 RDB 通过网络发送给从服务器, 不使用磁盘作为中间存储。<br>主要是防止比较低速的磁盘, 写入缓慢, 影响到整个应用。<br>这个主节点将所有数据发送给从节点的操作, 叫做<strong>全量复制</strong>。  </p><p><strong>第二步</strong><br>在运行中, 主节点处理完了命令, 会遍历自身维护的所有的从节点, 将自身执行的命令发送给所有状态符合的从节点, 保证数据的一致。<br>可以看出来, 第一, 二步的操作是一个比较简单的过程, 而第三步, 在兼容性能的情况下, 将会是一个复杂的过程。</p><p><strong>第三步</strong><br>主从节点之间出现网络波动, 从节点重启等行为后, 主从之间就可能出现数据不一致。<br>在 Reids 2.8 版本之前, Reids 的操作就是通过在来一次<strong>全量复制</strong>, 保证了主从节点数据的一致性。</p><p><strong>全量复制</strong> 我们可以很容易就想到这是一个耗时, 耗资源的过程, 比如 fork 子进程, RDB 文件生成, 数据发送。<br>所以为了尽量避免<strong>全量复制</strong>的出现, 在 Redis 2.8 版本, 引入了一个<strong>复制积压缓冲区</strong>的缓存区, 主节点执行的命令, 会先保存一份到这个缓存区<br>(这个缓存区是一个环形的数组, 从头写到尾, 写满了, 重新回到头, 继续写, 新的数据覆盖掉旧的, 同时所有的从节点共用一个缓冲区)。</p><p><img src="https://pic.imgdb.cn/item/669e267fd9c307b7e9c9b2dc.png" alt="Alt &#39;复制积压缓冲区&#39;"></p><p>大体的实现如下</p><blockquote><ol><li>主节点启动的时候, 会生成一个 run_id (用来确保复制的主节点的唯一性)</li><li>同时生成一个复制积压缓冲区, 并且有一个变量, 记录着缓冲区中当前最旧的数据的位置, 假设为 min, 假设复制积压缓冲区的容量为 len</li><li>从节点保存着主节点生成的 run_id, 同时维持着一个变量, 当前自身最新的数据在复制积压缓冲区的哪个位置, 也就是复制偏移量, 假设为 offset</li><li>当前主从复制出现问题时, 主从重新建立连接后, 从节点会将 run_id 和 offset 发送给主节点</li><li>主节点收到后, 如果 run_id 和自身的一致, 同时 min &lt;&#x3D; offset &lt;&#x3D; min + len, 也就是需要开始复制的位置的数据, 可以在缓存区中找到, 那么从这个位置进行<strong>部分复制</strong></li><li>主节点如果收到的 run_id 不一致, 或者 offset &lt; min 或者 offset &gt; min + len, 也就是需要开始复制的位置不在缓冲区中, 直接进行<strong>全量复制</strong></li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/669e26a5d9c307b7e9c9d3de.png" alt="Alt &#39;部分复制过程&#39;"></p><p>这个的功能叫做 <strong>psync</strong>, 可以理解为 <strong>部分复制</strong>, 这个功能可以减少<strong>全量复制</strong>的发生。<br>但是这个功能有些问题, 就是从节点需要维护好 run_id, run_id 需要和从节点的一致, 同时 offset 需要在复制积压缓存中, 这其中</p><blockquote><ol><li>slave 维护性重启, run_id 和 offset 会丢失</li><li>主节点故障转移, run_id 会改变<br>都会导致从节点直接<strong>全量复制</strong></li></ol></blockquote><p>所以在 Redis 4.0 针对上面的 2 种情况进行了优化, 使其在上面说的情况下, 可以进行使用<strong>部分复制</strong>, 这个升级的功能也被叫做 <strong>psync2</strong>。<br>涉及的几个名词</p><blockquote><ol><li>replid1, 每个 Redis 实例启动就会自动产生的一个 id, 这个实例变成从节点, 会被替换为主节点的 replid1</li><li>replid2, 默认初始为 0, 用于存储上次主节点的 replid1</li></ol></blockquote><p>当然还要其他的情况, 会导致<strong>部分复制</strong>的失效, 比如: 直接重启主节点, 这是复制积压缓冲区的数据丢了, 没法<strong>部分复制</strong></p><p>所以 <strong>psync2</strong> 只是针对上面的 2 种情况进行了优化, 其他的情况, 还是会直接进入到<strong>全量复制</strong></p><h4 id="3-2-从节点重启的部分复制"><a href="#3-2-从节点重启的部分复制" class="headerlink" title="3.2 从节点重启的部分复制"></a>3.2 从节点重启的部分复制</h4><p>在 Redis 4.0 中</p><blockquote><ol><li>Redis 关闭时, 会把复制相关的信息 replid1 和 offset 作为辅助信息保存到 RDB 文件</li><li>Redis 重启时, 会将从 RDB 文件中重新加载对应的复制信息到对应的字段</li><li>在进行同步时, 将 replid 和 offset 发送给主节点, 尝试进行部分复制</li></ol></blockquote><h4 id="3-3-主节点故障转移的部分复制"><a href="#3-3-主节点故障转移的部分复制" class="headerlink" title="3.3 主节点故障转移的部分复制"></a>3.3 主节点故障转移的部分复制</h4><p>当前的场景主要是在 Redis Cluster 中的故障转移情景的分析, 在单纯的主从复制中, 主节点重启, 挂了等, 都无法避免<strong>全量复制</strong>(单纯的主从复制不会触发故障转移)。</p><p>在 Redis 4.0 中</p><blockquote><ol><li>使用了 2 组 replid 和 offset</li><li>从节点也会开启复制积压缓冲区功能, 以便从节点故障切换变化为主节点后, 其他落后的从节点可以进行同步</li><li>第一组 replid 和 offset, 如果是主节点, 表示的是自己的 replid 和复制偏移量 offset, 从节点表示的是主节点的 replid (确保级联时, replid 都是一致的) 和自身同步主节点的赋值偏移量</li><li>第二组 replid 和 offset, 无论是主从, 都表示自己的上次主节点的 replid 和 offset, 没有则默认为 0 和 -1</li></ol></blockquote><p>故障转移时</p><blockquote><ol><li>从节点中被选举为主节点的节点, 先将自身的 replid1 和 offset1 复制给 replid2 和 offset2, 给自己重新生成另一组 replid 和 offset</li><li>原主节点这时会变为从节点, 也会将自身的 replid1 和 offset1 复制给 replid2 和 offset2, 更新 replid1 和 offset1 为新的主节点的 replid1 和 offset1</li><li>原主节点其他没有被选为主节点的从节点, 同样会将当前的 replid1 和 offest1 复制给 replid2 和 offset2, 更新 replid1 和 offset1 为新的主节点的 replid1 和 offset1</li><li>原主节点和其他从节点和新主节点进行同步时, 会先发送自身的 replid2 和 offset2, 主节点会根据这个信息, 判断是否可以进行部分复制</li></ol></blockquote><p>上面说的 3 个版本的复制能力, 在代码中分别叫做 <strong>EOF</strong>, <strong>psync</strong>, <strong>psync2</strong>。</p><p>复制能力的定义如下:  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 什么能力都不支持</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLAVE_CAPA_NONE</span> <span class="token expression"><span class="token number">0</span></span></span><span class="token comment">// 支持 EOF, 支持全量复制, 可以解析 RDB EOF 流式处理格式</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLAVE_CAPA_EOF</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> </span></span><span class="token comment">// 支持 psync2, 支持部分复制</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLAVE_CAPA_PSYNC2</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span></span></span></code></pre><p>对于 Redis 从节点, 可能因为版本问题, 存在着复制能力不一致的情况, 所以在主从复制开始的阶段, 从节点需要将自身支持的复制能力发送给主节点,<br>主节点才能以正确的方式同步数据给从节点。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><a href="https://blog.csdn.net/qq_42409788/article/details/104246731">redis psync1和psync2 同步详解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 主从复制分析 - 使用</title>
      <link href="/article/2024/3467330523/"/>
      <url>/article/2024/3467330523/</url>
      
        <content type="html"><![CDATA[<p>Reids 主从复制:<br>将一台 Redis 服务器的数据, 复制到其他的 Redis 服务器。前者称为主节点 (master), 后者称为从节点 (slave)。<br>数据的复制是单向的, 只能由主节点到从节点, 同时主节点以写为主 (可写也可以读), 从节点只能读不可写入。</p><h2 id="1-主从复制的建立"><a href="#1-主从复制的建立" class="headerlink" title="1 主从复制的建立"></a>1 主从复制的建立</h2><p>本文简单的介绍一下如何配置一个 一主两从的 Redis 主从复制集群。</p><p><strong>假设</strong><br>主节点        192.168.0.1, 端口为 6379<br>从节点 1      192.168.0.2, 端口为 6379<br>从节点 2      192.168.0.3, 端口为 6379  </p><h3 id="1-1-方式一-过配置文件进行配置"><a href="#1-1-方式一-过配置文件进行配置" class="headerlink" title="1.1 方式一: 过配置文件进行配置"></a>1.1 方式一: 过配置文件进行配置</h3><blockquote><ol><li>在 2 个从节点的 redis.conf 文件中追加 <strong>slaveof 192.168.0.1(主节点的 IP) 6379(主节点的端口)</strong>    </li><li>启动主节点, 再依次启动从节点, 这样一主两从的配置就完成了</li></ol></blockquote><h3 id="1-2-方式二-Redis-启动时指定主节点"><a href="#1-2-方式二-Redis-启动时指定主节点" class="headerlink" title="1.2 方式二: Redis 启动时指定主节点"></a>1.2 方式二: Redis 启动时指定主节点</h3><blockquote><ol><li>启动主节点</li><li>再启动 2 个从节点, 在启动的参数追加: <strong>–slaveof 192.168.0.1(主节点的 IP) 6379(主节点的端口)</strong>, 即 <strong>.&#x2F;redis-server –slaveof 192.168.0.1 6379</strong></li></ol></blockquote><h3 id="1-3-方式三-Redis-运行中指定主节点"><a href="#1-3-方式三-Redis-运行中指定主节点" class="headerlink" title="1.3 方式三: Redis 运行中指定主节点"></a>1.3 方式三: Redis 运行中指定主节点</h3><blockquote><ol><li>主从节点都正常的启动</li><li>在 2 个从节点都执行命令 <strong>slaveof 192.168.0.1(主节点的 IP) 6379(主节点的端口)</strong></li></ol></blockquote><p>上面就是 3 种建立主从复制的方式。<br>建立了连接后, 从节点可以通过 <strong>slaveof no one</strong> 断开连接, 断开了连接后, 从节点会自动变为主节点。</p><h2 id="2-主从复制节点信息查看"><a href="#2-主从复制节点信息查看" class="headerlink" title="2 主从复制节点信息查看"></a>2 主从复制节点信息查看</h2><p>主节点连接上<strong>从节点</strong>, 执行 <strong>info replication</strong> 就能查看到当前从节点的信息, 大体如下 (截取了主从复制相关的)</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Replication</span><span class="token comment"># 节点角色: 从节点</span>role:slave<span class="token comment"># 主节点的 IP</span>master_host:192.168.0.1<span class="token comment"># 主节点的端口</span>master_port:8888<span class="token comment"># 主节点的连接状态</span>master_link_status:up<span class="token comment"># 主节点最后与从节点的通信时间间隔, 单位秒</span>master_last_io_seconds_ago:0<span class="token comment"># 从节点是否正在全量同步主节点的 RDB 文件</span>master_sync_in_progress:0       <span class="token comment"># 复制偏移量</span>slave_repl_offset:407<span class="token comment"># 从节点的优先级</span>slave_priority:100<span class="token comment"># 从节点是否只读, 一般情况从节点都是只读的, 但是也可以通过在配置文件中配置 slave-read-only 或者 config set 强制修改为可写可读</span>slave_read_only:1 <span class="token comment"># 连接从节点的个数, Redis 支持从节点后面继续配置从节点</span>connected_slaves:0<span class="token comment"># 当前从节点作为其他从节点的主节点时的复制偏移量</span>master_repl_offset:0<span class="token comment"># 以下四种信息为主从节点通用的配置</span><span class="token comment"># 复制缓冲区的状态</span>repl_backlog_active:0 <span class="token comment"># 复制缓冲区的大小</span>repl_backlog_size:1048576<span class="token comment"># 复制缓冲区起始偏移量, 标识当前缓冲区可用的范围</span>repl_backlog_first_byte_offset:0<span class="token comment"># 标识复制缓冲区已存在的有效数据长度</span>repl_backlog_histlen:0 </code></pre><p>同样的, 从节点连上<strong>主节点</strong>后, 也可以通过 <strong>info replication</strong> 查看到当前主节点的信息</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 节点角色: 主节点</span>role:master  <span class="token comment"># 连接从节点的个数</span>connected_slaves:2<span class="token comment"># 连接从节点的信息</span>slave0:ip<span class="token operator">=</span><span class="token number">192.168</span>.0.2,port<span class="token operator">=</span><span class="token number">6379</span>,state<span class="token operator">=</span>online,offset<span class="token operator">=</span><span class="token number">631</span>,lag<span class="token operator">=</span><span class="token number">0</span>slave1:ip<span class="token operator">=</span><span class="token number">192.168</span>.0.3,port<span class="token operator">=</span><span class="token number">6379</span>,state<span class="token operator">=</span>online,offset<span class="token operator">=</span><span class="token number">631</span>,lag<span class="token operator">=</span><span class="token number">0</span> <span class="token comment"># 主节点的偏移量</span>master_repl_offset:631 <span class="token comment"># 以下四种信息为主从节点通用的配置</span><span class="token comment"># 复制缓冲区的状态</span>repl_backlog_active:1 <span class="token comment"># 复制缓冲区的大小</span>repl_backlog_size:1048576<span class="token comment"># 复制缓冲区起始偏移量, 标识当前缓冲区可用的范围</span>repl_backlog_first_byte_offset:2<span class="token comment"># 标识复制缓冲区已存在的有效数据长度</span>repl_backlog_histlen:630                                        </code></pre><h2 id="3-主从复制的其他配置"><a href="#3-主从复制的其他配置" class="headerlink" title="3 主从复制的其他配置"></a>3 主从复制的其他配置</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 从节点是否只读，默认为 true</span>slave-read-only <span class="token boolean">true</span><span class="token comment"># 无盘复制, 默认为 no</span><span class="token comment"># 在全量复制时, 主节点会将自身所有的数据生成为 1 个 RDB 文件, 然后发送给从节点</span><span class="token comment"># 这种发送的方式有 2 种</span><span class="token comment"># 1. 有盘复制: 主节点将 RDB 文件先写入到自己的磁盘, 再发送给从节点</span><span class="token comment"># 2. 无盘复制：主节点直接将 RDB 文件通过 Socket 发送给从节点</span><span class="token comment"># 无盘复制, 在主节点开始传输时, 新进来从节点会先排成队列，等待一段可以配置的时间, 竟可能的等待多个从节点到达, 进行并行传输</span>repl-diskless-sync no<span class="token comment"># 无盘复制, 从节点延迟等待的时间, 默认为 5 秒</span>repl-diskless-sync-deplay <span class="token number">5</span><span class="token comment"># 从节点向主节点发送心跳的时间间隔, 默认 10 秒</span>repl-ping-slave-period <span class="token number">10</span> <span class="token comment"># yes 主节点将使用更小 tcp 包和更少宽带向从节点发送数据, 但是这个会造成延迟</span><span class="token comment"># no  反过来, 延迟会减少, 但会使用更多的宽带</span><span class="token comment"># 默认为 no</span>repl-disable-tcp-nodelay no<span class="token comment"># 复制的超时时间, 默认为 60 秒</span><span class="token comment"># 使用到的场景</span><span class="token comment"># 1. 从节点同步数据时, 连接主节点超时</span><span class="token comment"># 2. 主节点向从节点发送 ack ping 超时</span><span class="token comment"># 3. 从节点连接主节点超时</span>repl-timeout <span class="token number">60</span><span class="token comment"># 复制积压缓冲区大小, 默认为 1m</span>repl-backlog-size 1mb<span class="token comment"># 主节点没法连接到从节点超过配置的时间, 复制积压缓冲区数据清掉</span>repl-backlog-ttl <span class="token number">3600</span><span class="token comment"># 从节点 priority 越低, 有着越高的保证,当主节点挂断的时候, 越有可能成为主节点</span>slave-priority <span class="token number">100</span><span class="token comment"># 所有从节点的延迟 (lag) 值, 大于或等于 10, 主节点拒绝执行写命令</span>min-slaves-max-lag <span class="token number">10</span> <span class="token comment"># 从节点数量少于 3 个, 主节点拒绝执行写命令</span>min-slaves-to-write <span class="token number">3</span><span class="token comment"># 当前节点作为从节点, 暴露给主节点的端口, 这个没有配置, 使用当前节点的运行的端口</span>slave-announce-port <span class="token number">6666</span><span class="token comment"># 当前节点作为从节点, 暴露给主节点的 IP</span>slave-announce-ip <span class="token number">127.0</span>.0.1</code></pre><h2 id="4-主从复制特点"><a href="#4-主从复制特点" class="headerlink" title="4 主从复制特点"></a>4 主从复制特点</h2><p>一主多从的特点:</p><blockquote><ol><li>主节点挂了, 从节点依然还是从节点, 无法变为主节点</li><li>主节点挂了, 重启后, 还是为主节点</li></ol></blockquote><h2 id="1-5-参考"><a href="#1-5-参考" class="headerlink" title="1.5 参考"></a>1.5 参考</h2><p><a href="https://blog.csdn.net/y1247793952/article/details/66974329">redis主从相关配置</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次 SQL 优化</title>
      <link href="/article/2024/277668067/"/>
      <url>/article/2024/277668067/</url>
      
        <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>我们的数据库中配置了一套慢 SQL 的监控(这里存在 SQL 本身不慢, 但是触发某些场景, 比如 filesort 等也会被采集), 会不定时的输出一批需要排查的 SQL, 下面挑了几条比较有意思的进行分享。</p><h2 id="2-table-1"><a href="#2-table-1" class="headerlink" title="2 table_1"></a>2 table_1</h2><p>表结构:</p><pre class="language-sql" data-language="sql"><code class="language-sql">CEATE <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>        column_1<span class="token punctuation">,</span>    column_2<span class="token punctuation">,</span>    column_3<span class="token punctuation">,</span>    column_4<span class="token punctuation">,</span>    time_column_5    <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_001<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>column_3<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_002<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>column_2<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>column_3<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>time_column_5<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>SQL:</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> column_1 <span class="token keyword">from</span> table_1 <span class="token keyword">where</span> column_2 <span class="token operator">and</span> column_3 <span class="token operator">and</span> time_column_5 <span class="token operator">></span> ? <span class="token keyword">order</span> <span class="token keyword">by</span> time_column_5 <span class="token keyword">desc</span></code></pre><p>执行计划: </p><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_1</td><td align="center"></td><td align="center">range</td><td align="center">idx_001,idx_002</td><td align="center">idx_002</td><td align="center">133</td><td align="center"></td><td align="center">1</td><td align="center">5</td><td align="center">Using index condition</td></tr></tbody></table><p>通过分析执行过程, 可以发现这条 SQL 本身已经是 range 同时基本走到符合条件的索引 <strong>idx_002</strong> 了。<br>因为这条 SQL 只需要在查询出一个 column_1 字段, 如果还想再进一步优化的话, 可以直接将这个字段添加到 <strong>idx_002</strong> 的索引, 直接让这条 SQL 在索引树中处理, 不回表查询。</p><p>修改 idx_002 的索引如下 <strong>column_2, column_3, column_1, time_column_4</strong></p><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_1</td><td align="center"></td><td align="center">range</td><td align="center">idx_001, idx_002</td><td align="center">idx_002</td><td align="center">133</td><td align="center"></td><td align="center">1</td><td align="center">5</td><td align="center">Using where, Backward index scan, Using index</td></tr></tbody></table><p>可以发现 Extra 中, 整条 SQL 为 <strong>Using index</strong>, 只使用到了索引树, 同时利用到了 MySQL8 的新特性 backward index scan (MySQL 8 对字段倒序排序做的一种优化, 同样是直接在索引树上操作, 不回表处理)。</p><h2 id="3-table-2"><a href="#3-table-2" class="headerlink" title="3 table_2"></a>3 table_2</h2><p>表结构:</p><pre class="language-sql" data-language="sql"><code class="language-sql">CEATE <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_2<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>        column_1<span class="token punctuation">,</span>    column_2<span class="token punctuation">,</span>    column_3<span class="token punctuation">,</span>    column_4<span class="token punctuation">,</span>    time_column_5    <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_001<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>column_3<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_002<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>column_2<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>column_3<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>time_column_5<span class="token punctuation">`</span></span><span class="token punctuation">)</span>    <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_003<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>column_4<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>time_column_5<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>SQL:</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> column_1 <span class="token keyword">from</span> table_2 <span class="token keyword">where</span> <span class="token punctuation">(</span>column_2 <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">or</span> column_4 <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token operator">+</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">and</span> time_column_5 <span class="token operator">></span> ? <span class="token operator">and</span> time_column_5 <span class="token operator">&lt;=</span> ?</code></pre><p>执行计划: </p><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_2</td><td align="center"></td><td align="center">index_merge</td><td align="center">idx_001, idx_002, idx_003</td><td align="center">idx_002</td><td align="center">128128</td><td align="center"></td><td align="center">17907</td><td align="center">0.11</td><td align="center">Using sort_union(idx_002, idx_003); Using where</td></tr></tbody></table><p><strong>index_merge</strong>: 分别通过对两个独立的 index 进行过滤之后，将过滤之后的结果聚合在一起，然后在返回结果集<br><strong>sort_union</strong>: 简单理解: 使用到了 or, 回表捞到需要的数据，合并后再排序</p><p>column_2 和 column_4 都有各种适合的索引, 尝试通过 union all 将 or 替换掉</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> column_1 <span class="token keyword">from</span> table_2 <span class="token keyword">where</span> column_2 <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">and</span> time_column_5 <span class="token operator">></span> ? <span class="token operator">and</span> time_column_5 <span class="token operator">&lt;=</span> ?<span class="token keyword">union</span> <span class="token keyword">all</span><span class="token keyword">select</span> column_1 <span class="token keyword">from</span> table_2 <span class="token keyword">where</span> column_4 <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">and</span> time_column_5 <span class="token operator">></span> ? <span class="token operator">and</span> time_column_5 <span class="token operator">&lt;=</span> ?</code></pre><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_2</td><td align="center"></td><td align="center">range</td><td align="center">idx_002</td><td align="center">idx_002</td><td align="center">133</td><td align="center"></td><td align="center">6323</td><td align="center">1</td><td align="center">Using index condition; Using where</td></tr><tr><td align="center">SIMPLE</td><td align="center">table_2</td><td align="center"></td><td align="center">range</td><td align="center">idx_003</td><td align="center">idx_00</td><td align="center">133</td><td align="center"></td><td align="center">5</td><td align="center">1</td><td align="center">Using index condition; Using where</td></tr></tbody></table><p>观察 rows 预测扫描的行数少了, 同时 Extra 中切换到了 使用索引 + 回表查询</p><h2 id="4-table-3"><a href="#4-table-3" class="headerlink" title="4 table_3"></a>4 table_3</h2><p>表结构: </p><pre class="language-sql" data-language="sql"><code class="language-sql">CEATE <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_2<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>        column_1<span class="token punctuation">,</span>    column_2<span class="token punctuation">,</span>    char_column_3<span class="token punctuation">,</span>    time_column_4    <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_001<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>char_column_3<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>time_column_4<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>SQL:</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> column_1<span class="token punctuation">,</span> char_column_3<span class="token punctuation">,</span> time_column_4 <span class="token keyword">from</span> table_3 <span class="token keyword">where</span> char_column_3 <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token operator">+</span><span class="token punctuation">)</span> <span class="token keyword">order</span> <span class="token keyword">by</span> time_column_4 <span class="token keyword">desc</span> lmit ?<span class="token punctuation">,</span> ?</code></pre><p>执行计划: </p><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_3</td><td align="center"></td><td align="center">range</td><td align="center">idx_001</td><td align="center">idx_001</td><td align="center">128</td><td align="center"></td><td align="center">4</td><td align="center">5</td><td align="center">Using index condition; Using where; Using filesort</td></tr></tbody></table><p>这条 SQL 主要是因为使用到了 filesort。<br>通过索引 idx_001 可以看出 查询的条件 char_column_3 和 time_column_4 都是在索引里面的, 理而导致 Using filesort 的原因是因为 char_column_3 的条件是 in</p><p>尝试将 char_column_3 的条件修改为 &#x3D;, 执行计划如下</p><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_3</td><td align="center"></td><td align="center">ref</td><td align="center">idx_001</td><td align="center">idx_001</td><td align="center">128</td><td align="center">const</td><td align="center">4</td><td align="center">5</td><td align="center">Using index condition; Using where</td></tr></tbody></table><p>in 导致索引中的 time_column_4 失效原因:<br>索引是有序的, 通过索引找到的数据, 理论上也是有序的。<br>比如表中当前有数据 (1, 1), (2, 2), (3, 3), (1,5) (1,3)。<br>通过 char_column_3 in 查询出来的数据为 (1, 1), (1,3), (1,5), (2, 2), (3, 3), 可以发现是按照 char_column_3 排序好了。<br>但是现在我们需要的是按照 time_column_4 进行排序, 那么就在用 char_column_3 查询出来的数据后再进行多一次排序, 就导致了 filesort 的出现。  </p><p>尝试去掉 filesort, 建立 idx_02(time_column_4, char_column_3) 的组合索引, 同时强制走这个索引 (通过尝试, 发现 MySQL 的优化器分析走旧索引比较好)</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> column_1<span class="token punctuation">,</span> char_column_3<span class="token punctuation">,</span> time_column_4 <span class="token keyword">from</span> table_3 <span class="token keyword">force</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_02<span class="token punctuation">)</span> <span class="token keyword">where</span> char_column_3 <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token operator">+</span><span class="token punctuation">)</span> <span class="token keyword">order</span> <span class="token keyword">by</span> time_column_4 <span class="token keyword">desc</span> lmit ?<span class="token punctuation">,</span> ?</code></pre><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_3</td><td align="center"></td><td align="center">ref</td><td align="center">idx_001</td><td align="center">idx_001</td><td align="center">128</td><td align="center">const</td><td align="center">15</td><td align="center">0.33</td><td align="center">Using where</td></tr></tbody></table><p>可以发现 filesort 去掉了, 但是对应的 rows 查询条数上涨了。<br>结论: 当前 SQL 暂时这样, 不修改。</p><h2 id="5-table-4"><a href="#5-table-4" class="headerlink" title="5 table_4"></a>5 table_4</h2><p>表结构: </p><pre class="language-sql" data-language="sql"><code class="language-sql">CEATE <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_4<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>        column_1<span class="token punctuation">,</span>    column_2<span class="token punctuation">,</span>    column_3<span class="token punctuation">)</span></code></pre><p>SQL: </p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> table_4 <span class="token keyword">where</span> column_2 <span class="token operator">=</span> ? <span class="token operator">and</span> column_3 <span class="token operator">=</span> ?</code></pre><p>执行计划: </p><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_4</td><td align="center"></td><td align="center">ALL</td><td align="center"></td><td align="center"></td><td align="center">128</td><td align="center">const</td><td align="center">1026</td><td align="center">0.2</td><td align="center">Using where</td></tr></tbody></table><p>走到了 ALL, 整张表数据量也在 900+ 左右, 可能初期设想时不会有那么多数据, 所以没加索引。<br>现在走动了 ALL, 第一时间想到的是给查询的 2 个字段加上索引, 那么直接加上吗？</p><p>先分析一下 column_2 和 column_3 各自的分布。</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> column_2 <span class="token keyword">from</span> table_4 <span class="token keyword">group</span> <span class="token keyword">by</span> column_2</code></pre><table><thead><tr><th align="center">count(1)</th><th align="center">column_2</th></tr></thead><tbody><tr><td align="center">10</td><td align="center">2</td></tr><tr><td align="center">901</td><td align="center">3</td></tr><tr><td align="center">7</td><td align="center">4</td></tr><tr><td align="center">1</td><td align="center">5</td></tr><tr><td align="center">12</td><td align="center">6</td></tr><tr><td align="center">1</td><td align="center">7</td></tr><tr><td align="center">1</td><td align="center">8</td></tr><tr><td align="center">2</td><td align="center">9</td></tr></tbody></table><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> column_3 <span class="token keyword">from</span> table_4 <span class="token keyword">group</span> <span class="token keyword">by</span> column_3</code></pre><table><thead><tr><th align="center">count(1)</th><th align="center">column_3</th></tr></thead><tbody><tr><td align="center">9</td><td align="center">1</td></tr><tr><td align="center">64</td><td align="center">2</td></tr><tr><td align="center">861</td><td align="center">3</td></tr></tbody></table><p>可以发现 column_2 和 column_3 应该都是枚举值 (一开始可能考虑到都是枚举所以没加索引吧)。<br>回到代码中查看 SQL 的调用链, 发现调用的地方就 2 个, 查询的条件 column_2 主要在 (6,7,8), 而 column_3 则是 2。</p><p>虽然平常我们都知道枚举类型的字段不要加索引，因为区分度不高。<br>但是在某些情况下，还是建议建立索引的。举个例子: 有一张大表, 发送给客户的短信信息和状态, 表中有个字段存储的是当前这条短信是否发送给客户了，0: 未发送, 1: 已发送。<br>短信发送成功后, 会将状态修改为 1: 已发送。 基于这种情况, 这张大表中的未发送的数据量和远远小于已发送的数据量, 同时平时查询的时候也都几乎是查询未发送的, 这时候就可以给这个枚举值字段加上索引, 因为通过未发送这种情况可以筛选掉很多的数据量。</p><p>所以给 column_2 和 column_3 建立一个组合索引, 同时因为 column_2 的区分度更高, 所以将 column_2 放在 column_1 的前面。</p><h2 id="6-table-5"><a href="#6-table-5" class="headerlink" title="6 table_5"></a>6 table_5</h2><p>表结构: </p><pre class="language-sql" data-language="sql"><code class="language-sql">CEATE <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_5<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>        column_1<span class="token punctuation">,</span>    column_2<span class="token punctuation">,</span>    column_3    <span class="token keyword">KEY</span> idx_001<span class="token punctuation">(</span>column_1<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>SQL: </p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> table_5 <span class="token keyword">where</span> column_1 <span class="token operator">=</span> ? <span class="token operator">and</span> column_2 <span class="token operator">=</span> ? <span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token keyword">convert</span><span class="token punctuation">(</span>column_1 <span class="token keyword">using</span> gbk<span class="token punctuation">)</span></code></pre><p>执行计划: </p><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_5</td><td align="center"></td><td align="center">ref</td><td align="center">idx_001</td><td align="center">idx_001</td><td align="center">152</td><td align="center">const</td><td align="center">1</td><td align="center">5</td><td align="center">Using index condition; Using where; Using filesort</td></tr></tbody></table><p>同时是因为 filesort, 这里可以将排序的字段 column_1 加入到 idx 索引中。<br>但是因为 column_1 使用到了索引, 最终只会导致加的这个字段不起作用, 那么</p><ol><li>去掉这个函数, 排序而已, 对数据的准确性没有影响, 但是排序的的顺序和生产的不一致</li><li>将这个排序移到代码中进行</li></ol><h2 id="7-table-6"><a href="#7-table-6" class="headerlink" title="7 table_6"></a>7 table_6</h2><pre class="language-sql" data-language="sql"><code class="language-sql">CEATE <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_6<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>        column_1<span class="token punctuation">,</span>    column_2<span class="token punctuation">,</span>    column_3<span class="token punctuation">,</span>    is_deleted    <span class="token keyword">KEY</span> idx_001<span class="token punctuation">(</span>column_1<span class="token punctuation">,</span> is_deleted<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> idx_002<span class="token punctuation">(</span>column_2<span class="token punctuation">,</span> is_deleted<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>当前表数据量 80155064, 使用了逻辑删除, 未删除:已删除 &#x3D; 5:3 左右 </p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> column_1<span class="token punctuation">,</span> column_2<span class="token punctuation">,</span> column_3 <span class="token keyword">from</span> table_6 <span class="token keyword">where</span> column_1 <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">and</span> is_deleted <span class="token operator">=</span> <span class="token number">0</span></code></pre><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_6</td><td align="center"></td><td align="center">range</td><td align="center">idx_001</td><td align="center">idx_001</td><td align="center">303</td><td align="center"></td><td align="center">2</td><td align="center">10</td><td align="center">Using index condition; Using where</td></tr></tbody></table><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> column_1<span class="token punctuation">,</span> column_2<span class="token punctuation">,</span> column_3 <span class="token keyword">from</span> table_6 <span class="token keyword">where</span> column_2 <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">and</span> is_deleted <span class="token operator">=</span> <span class="token number">0</span></code></pre><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_6</td><td align="center"></td><td align="center">range</td><td align="center">idx_002</td><td align="center">idx_002</td><td align="center">153</td><td align="center"></td><td align="center">2</td><td align="center">10</td><td align="center">Using index condition; Using where</td></tr></tbody></table><p>2 条 SQL 的执行时间都是秒级别, 但是通过分析可以发现走的索引都很准确了, 通过调整索引的方式不太合适了。<br>那么有别的方式优化吗? 逻辑删除 –&gt; 已经删除的数据还有保存的意义吗? –&gt; 清除(或迁移到另一张表), 减轻表的数据量, 也能达到优化的效果。</p><h3 id="7-1-本地尝试清除数据"><a href="#7-1-本地尝试清除数据" class="headerlink" title="7.1 本地尝试清除数据"></a>7.1 本地尝试清除数据</h3><h4 id="7-1-1-初始数据"><a href="#7-1-1-初始数据" class="headerlink" title="7.1.1 初始数据"></a>7.1.1 初始数据</h4><table><thead><tr><th align="center">总数据量</th><th align="center">未删除</th><th align="center">已删除</th></tr></thead><tbody><tr><td align="center">10000001</td><td align="center">5002602</td><td align="center">4997399</td></tr></tbody></table><p>表内存情况</p><table><thead><tr><th align="center">Name</th><th align="center">Engine</th><th align="center">Version</th><th align="center">Row_formant</th><th align="center">Rows</th><th align="center">Avg_row_length</th><th align="center">Data_length</th><th align="center">Max_data_length</th><th align="center">Data_free</th><th align="center">Auto_increment</th><th align="center">Create_time</th><th align="center">Update_time</th><th align="center">Check_time</th><th align="center">Collation</th><th align="center">Checksum</th><th align="center">Create_options</th></tr></thead><tbody><tr><td align="center">table_6</td><td align="center">InnoDb</td><td align="center">10</td><td align="center">Dynamic</td><td align="center">9657234</td><td align="center">160</td><td align="center">1547698176 (1476.00M)</td><td align="center"></td><td align="center">3801726976 (3625.60M)</td><td align="center">4194304</td><td align="center">10000003</td><td align="center">2024-06-20 14:50:34</td><td align="center">2024-06-20 16:27:10</td><td align="center">NULL</td><td align="center">utf8_general_ci</td><td align="center">NULL</td></tr></tbody></table><p>备注:<br>date_length: 数据的大小<br>index_length: 索引的大小<br>data_free: 碎片空间的大小  </p><h4 id="7-1-2-继续往表追加数据"><a href="#7-1-2-继续往表追加数据" class="headerlink" title="7.1.2 继续往表追加数据"></a>7.1.2 继续往表追加数据</h4><p>向表中追加 1529500 条数据</p><table><thead><tr><th align="center">总数据量</th><th align="center">未删除</th><th align="center">已删除</th></tr></thead><tbody><tr><td align="center">11529501</td><td align="center">5766861</td><td align="center">5762640</td></tr></tbody></table><table><thead><tr><th align="center">Name</th><th align="center">Engine</th><th align="center">Version</th><th align="center">Row_formant</th><th align="center">Rows</th><th align="center">Avg_row_length</th><th align="center">Data_length</th><th align="center">Max_data_length</th><th align="center">Data_free</th><th align="center">Auto_increment</th><th align="center">Create_time</th><th align="center">Update_time</th><th align="center">Check_time</th><th align="center">Collation</th><th align="center">Checksum</th><th align="center">Create_options</th></tr></thead><tbody><tr><td align="center">table_6</td><td align="center">InnoDb</td><td align="center">10</td><td align="center">Dynamic</td><td align="center">11422530</td><td align="center">156</td><td align="center">1785724928 (1703.00M)</td><td align="center">0</td><td align="center">4484366336 (4276.62M)</td><td align="center">5242880</td><td align="center">11529503</td><td align="center">2024-06-20 14:50:34</td><td align="center">2024-06-20 16:53:30</td><td align="center">NULL</td><td align="center">utf8_general_ci</td><td align="center">NULL</td></tr></tbody></table><h4 id="7-1-3-尝试清除表中一半逻辑删除的数据"><a href="#7-1-3-尝试清除表中一半逻辑删除的数据" class="headerlink" title="7.1.3 尝试清除表中一半逻辑删除的数据"></a>7.1.3 尝试清除表中一半逻辑删除的数据</h4><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">from</span> table_6 <span class="token keyword">where</span> id <span class="token operator">&lt;=</span> <span class="token string">'5764751'</span> <span class="token operator">and</span> is_deleted <span class="token operator">=</span> <span class="token number">1</span></code></pre><table><thead><tr><th align="center">总数据量</th><th align="center">未删除</th><th align="center">已删除</th></tr></thead><tbody><tr><td align="center">8648665</td><td align="center">5766861</td><td align="center">2881804</td></tr></tbody></table><table><thead><tr><th align="center">Name</th><th align="center">Engine</th><th align="center">Version</th><th align="center">Row_formant</th><th align="center">Rows</th><th align="center">Avg_row_length</th><th align="center">Data_length</th><th align="center">Max_data_length</th><th align="center">Data_free</th><th align="center">Auto_increment</th><th align="center">Create_time</th><th align="center">Update_time</th><th align="center">Check_time</th><th align="center">Collation</th><th align="center">Checksum</th><th align="center">Create_options</th></tr></thead><tbody><tr><td align="center">table_6</td><td align="center">InnoDb</td><td align="center">10</td><td align="center">Dynamic</td><td align="center">8610990</td><td align="center">207</td><td align="center">1785724928 (1703.00M)</td><td align="center">0</td><td align="center">4484366336 (4276.62M)</td><td align="center">42991616</td><td align="center">11529503</td><td align="center">2024-06-20 14:50:34</td><td align="center">2024-06-20 17:14:58</td><td align="center">NULL</td><td align="center">utf8_general_ci</td><td align="center">NULL</td></tr></tbody></table><p>可以看到虽然删除了表中的部分数据, 但是实际占用的空间没有变化。 这时 InnoDB 内部的设计, 将删除的数据的位置标记为删除的, 后续有新的数据新增进来时, 就复用这个位置。<br>如果要强制进行空间的整理, 可以通过 <strong>alter table 表明 engine&#x3D;innodb;</strong> 的方式进行整理, 但是这个会很耗时。</p><h4 id="7-1-4-清除表中所有逻辑删除的数据"><a href="#7-1-4-清除表中所有逻辑删除的数据" class="headerlink" title="7.1.4 清除表中所有逻辑删除的数据"></a>7.1.4 清除表中所有逻辑删除的数据</h4><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">from</span> table_6 <span class="token keyword">where</span> is_deleted <span class="token operator">=</span> <span class="token number">1</span></code></pre><table><thead><tr><th align="center">总数据量</th><th align="center">未删除</th><th align="center">已删除</th></tr></thead><tbody><tr><td align="center">5766861</td><td align="center">5766861</td><td align="center">0</td></tr></tbody></table><p>通过 alter 手动整理空间</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> table_6 <span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">innodb</span><span class="token punctuation">;</span></code></pre><p>表内存情况</p><table><thead><tr><th align="center">Name</th><th align="center">Engine</th><th align="center">Version</th><th align="center">Row_formant</th><th align="center">Rows</th><th align="center">Avg_row_length</th><th align="center">Data_length</th><th align="center">Max_data_length</th><th align="center">Data_free</th><th align="center">Auto_increment</th><th align="center">Create_time</th><th align="center">Update_time</th><th align="center">Check_time</th><th align="center">Collation</th><th align="center">Checksum</th><th align="center">Create_options</th></tr></thead><tbody><tr><td align="center">table_6</td><td align="center">InnoDb</td><td align="center">10</td><td align="center">Dynamic</td><td align="center">5713155</td><td align="center">178</td><td align="center">1021296640 (973.98M)</td><td align="center">0</td><td align="center">1571340288 (1498.54M)</td><td align="center">3145728</td><td align="center">11529503</td><td align="center">2024-06-20 14:50:34</td><td align="center">NULL</td><td align="center">NULL</td><td align="center">utf8_general_ci</td><td align="center">NULL</td></tr></tbody></table><p>完整的清除数据和整理了碎片空间。</p><p>注: 最终落实到生产(保留前 3 个月的数据, 将 3 个月前的数据迁移到另一张表)</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 生产记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 内存回收和内存淘汰机制</title>
      <link href="/article/2024/862777855/"/>
      <url>/article/2024/862777855/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>Redis 所有的数据都是存储在内存中的, 如果不进行任何的内存回收, 那么很容易出现内存爆满的情况。因此，在某些情况下需要对占用的内存空间进行释放。</p><p>Redis 中内存的释放主要分为两类<br>Redis 中内存的释放主要分为两类: </p><blockquote><ol><li>内存回收: 将过期的 key 清除，以减少内存占用</li><li>内存淘汰: 在内存使用达到上限(max_memory), 按照一定的策略删除一些键，以释放内存空间</li></ol></blockquote><p>两者都是通过删除 key (及其对应的 value) 来达到释放空间的效果。<br>区别在于前者清除的是用户明确不需要的 key, 而后者清除的则是用户可能仍然需要的 key。</p><h2 id="2-内存回收"><a href="#2-内存回收" class="headerlink" title="2 内存回收"></a>2 内存回收</h2><h3 id="2-1-过期策略"><a href="#2-1-过期策略" class="headerlink" title="2.1 过期策略"></a>2.1 过期策略</h3><p>在内存中的大量 key 中, 如何清除其中已经过期的 key 呢?</p><p>常用的方式有 3 种</p><blockquote><ol><li>定时过期 </li><li>惰性过期 </li><li>定期过期</li></ol></blockquote><p><strong>定时过期</strong></p><p>为每个 key 都创建一个定时器, 时间到了, 就将这个 key 清除。<br>该策略可以立即清除过期的数据, 对内存很友好。但是会占用大量的 CPU 资源去处理过期的数据, 从而影响缓存的响应时间和吞吐量。</p><p><strong>惰性过期</strong></p><p>key 过期了, 不进行处理。当后续访问到这个 key 时, 才会判断该 key 是否已过期, 过期则清除。<br>该策略可以最大化地节省 CPU 资源, 却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问, 从而不会被清除, 占用大量内存。</p><p><strong>定期过期</strong></p><p>将所有的 key 维护在一起, 每隔一段时间就从中扫描一定的数量的 key(采样), 并清除其中已经过期的 key。<br>通过调整定时扫描的时间间隔和每次扫描的耗时, 可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。</p><p>在 Reids 的实现中是通过 <strong>惰性过期</strong> + <strong>定期过期</strong> 2 种策略配合, 达到内存回收的效果。</p><h3 id="2-2-惰性过期-在-Redis-中的实现"><a href="#2-2-惰性过期-在-Redis-中的实现" class="headerlink" title="2.2 惰性过期 在 Redis 中的实现"></a>2.2 惰性过期 在 Redis 中的实现</h3><p>前提: Redis 中一个对象的过期时间存放在 dictEntry 的 v.s64 中, 至于 dictEntry 的设计可以看一下后面的<strong>附录</strong>。</p><p>Redis 大部分读写对象的命令, 在执行前都会调用 <strong>expireIfNeeded</strong> 函数做一个过期检查</p><blockquote><ol><li>如果 key 已经过期了, 将其删除</li><li>如果 key 未过期, 不做任何处理</li></ol></blockquote><p>expireIfNeeded 函数的定义如下</p><pre class="language-C" data-language="C"><code class="language-C">int expireIfNeeded(redisDb *db, robj *key) &#123;    &#x2F;&#x2F; key 未过期返回 0    if (!keyIsExpired(db,key)) return 0;    &#x2F;&#x2F; 下面的逻辑都是 Key 过期的逻辑处理    &#x2F;&#x2F; 当前的节点是从节点, 返回 1, 然后结束    &#x2F;&#x2F; 为了保持主从数据的一致, 从节点不会主动清除数据, 都是主节点同步消息在删除    if (server.masterhost !&#x3D; NULL) return 1;    &#x2F;&#x2F; 已经删除过期键个数 + 1    server.stat_expiredkeys++;    &#x2F;&#x2F; 向从节点和 AOF 文件传播 key 过期信息, 清除过期 key    propagateExpire(db,key,server.lazyfree_lazy_expire);    &#x2F;&#x2F; 发送事件通知    notifyKeyspaceEvent(NOTIFY_EXPIRED,&quot;expired&quot;,key,db-&gt;id);    &#x2F;&#x2F; lazyfree-lazy-expire 配置参数 (版本 4.0 以上支持), 默认为 0    &#x2F;&#x2F; 根据配置, 同步或异步删除 key (异步删除: 先将 key 逻辑删除, 然后在通过后台的线程池进行真正的空间释放)    return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : dbSyncDelete(db,key);&#125;int keyIsExpired(redisDb *db, robj *key) &#123;    &#x2F;&#x2F; 从过期字典中获取 key 对应的过期时间, 实际就是获取 dictEntity 的 v 中的 s64 值 (dictEntity.v.s64)    mstime_t when &#x3D; getExpire(db,key);    mstime_t now;    &#x2F;&#x2F; 没有过期时间    if (when &lt; 0) return 0;    &#x2F;&#x2F; redis 在加载数据中    if (server.loading) return 0;        &#x2F;&#x2F; 获取当前的事件    if (server.lua_caller) &#123;        &#x2F;&#x2F; 有 lua 脚本在执行中, 当前时间等于脚本开始执行前的时间        now &#x3D; server.lua_time_start;    &#125; else if (server.fixed_time_expire &gt; 0) &#123;        &#x2F;&#x2F; 有缓存时间, 线使用缓存时间        &#x2F;&#x2F; server.mstime 这个时间会在调用执行命令函数的 call() 前进行更新        &#x2F;&#x2F; 这样可以避免一些批量操作的命令, 比如 RPOPLPUSH 等命令, 这些命令会执行过程中可能多次访问这个 key        &#x2F;&#x2F; 而在多次的访问过程中, 可能出现上一次访问未过期, 下次访问已经过期了, 通过这个缓冲时间可以解决这个问题        now &#x3D; server.mstime;    &#125; else &#123;        &#x2F;&#x2F; 其他情况, 直接获取当前时间        now &#x3D; mstime();    &#125;    &#x2F;&#x2F; 当前时间是否大于 key 的过期时间    return now &gt; when;&#125;</code></pre><p>expireIfNeeded 的调用时机, 基本都是在各个命令内部。 以 String 的 get 命令为例, 大体的流程如下</p><pre class="language-C" data-language="C"><code class="language-C">&#x2F;** * get 命令对应的执行函数 * 需要的参数都封装在 client 对象中 *&#x2F;void getCommand(client *c) &#123;    &#x2F;&#x2F; getGenericCommand -&gt; lookupKeyReadOrReply -&gt; lookupKeyRead -&gt; lookupKeyReadWithFlags    &#x2F;&#x2F; getGenericCommand 经过几个函数最终调用到 lookupKeyReadWithFlags    getGenericCommand(c);&#125;robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) &#123;    robj *val;    &#x2F;&#x2F; expireIfNeeded 返回 &gt; 0, 过期了    if (expireIfNeeded(db,key) &#x3D;&#x3D; 1) &#123;        &#x2F;&#x2F; 省略过期处理        &#x2F;&#x2F; 过期的处理, 然后 return null    &#125;    &#x2F;&#x2F; 非过期处理, 查找然后返回    val &#x3D; lookupKey(db,key,flags);    if (val &#x3D;&#x3D; NULL)        server.stat_keyspace_misses++;    else        server.stat_keyspace_hits++;    return val;&#125;</code></pre><p>上面就是 get 指令的中的惰性过期的过程, 其他命令的逻辑差不多, 核心就是一个 expireIfNeeded 函数。</p><h3 id="2-3-定期过期在-Redis-中的实现"><a href="#2-3-定期过期在-Redis-中的实现" class="headerlink" title="2.3 定期过期在 Redis 中的实现"></a>2.3 定期过期在 Redis 中的实现</h3><p>Redis 默认是 16 个数据库, 每个数据库会将设置了过期时间的 key 放到各自的一个独立的字典中, 称为过期字典 (redisDb 对象的 dict *expires 属性)。</p><p>然后 Redis 默认会按照每秒 10 次的频率（可以通过 redis.conf 中的 hz 配置）进行过期扫描。<br>扫描的过程不会遍历整个过期字典，而是按照以下策略进行</p><blockquote><ol><li>从过期字典中随机选择 20 个 key </li><li>删除其中已经过期的键</li><li>如果超过 25% 的键被删除, 则重复步骤 1, 2, 3, 没有超过, 就结束这次扫描</li><li>同时为防止重复循环, 导致线程卡死, 增加了每 16 次抽样, 就做一次扫描时间的上限的检查 (默认是慢模式下, 上限是 25 毫秒, 如果是快模式，扫描上限是 1 毫秒), 超过就结束循环</li></ol></blockquote><p>定期过期删除的实现主要在 <strong>&#x2F;activeExpireCycle</strong> 函数, 大体的逻辑如下</p><pre class="language-C" data-language="C"><code class="language-C">&#x2F;** * 过期循环清除 * 为了便于理解, 这里对函数的逻辑做了一点小调整和删除一些非必要的逻辑, 但是整体的逻辑不变 * @type 模式, 取值有 2 个 ACTIVE_EXPIRE_CYCLE_SLOW (0, 慢模式), ACTIVE_EXPIRE_CYCLE_FAST (1, 快模式) *&#x2F;void activeExpireCycle(int type) &#123;    &#x2F;&#x2F; 静态变量, 当前处理的数据库索引    &#x2F;&#x2F; 静态的效果, 这个变量执行后的值不会被清空, 每次调用这个方法, 是上一次执行的值    &#x2F;&#x2F; 这样就可以保证 16 个数据库, 每次方法执行完, 下次进来可以执行到下一个数据库, 循环起来，而不是每次进来都从第 0 个开始    static unsigned int current_db &#x3D; 0;    &#x2F;&#x2F; 上一次清理是否是因为时间超时结束循环的, 同样是静态变量    static int timelimit_exit &#x3D; 0;        &#x2F;&#x2F; 上一次快速循环循环的时间, 同样是静态变量    static long long last_fast_cycle &#x3D; 0;    &#x2F;&#x2F; 当前时间    long long start &#x3D; ustime(),    &#x2F;&#x2F; 本次循环清除是快速循环, 上一次是时间超时获取 2 次快速循环的时间差在 2 毫秒内, 不执行    if (type &#x3D;&#x3D; ACTIVE_EXPIRE_CYCLE_FAST) &#123;        &#x2F;&#x2F; 上一次循环是因为时间超时结束的, 本次快速循环不进行        if (!timelimit_exit) return;        &#x2F;&#x2F; 上次快速循环距离当前时间在 1000 * 2 &#x3D; 2 毫秒内, 也不进行快速循环        if (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) return;        last_fast_cycle &#x3D; start;    &#125;    &#x2F;&#x2F; 计算循环的上限毫秒限制     &#x2F;&#x2F; server.hz 默认等于 10, ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC 等于 25    &#x2F;&#x2F; 1000000 * 25 &#x2F; 10 &#x2F; 100 &#x3D; 25000 单位: 微秒, 即 25 毫秒    long long timelimit &#x3D; 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC&#x2F;server.hz&#x2F;100;    &#x2F;&#x2F; ACTIVE_EXPIRE_CYCLE_FAST_DURATION &#x3D; 1000    &#x2F;&#x2F; 如果是快模式, 修改为 1000 微秒, 即 1 毫秒超时    if (type &#x3D;&#x3D; ACTIVE_EXPIRE_CYCLE_FAST)        timelimit &#x3D; ACTIVE_EXPIRE_CYCLE_FAST_DURATION;    &#x2F;&#x2F; CRON_DBS_PER_CALL &#x3D; 16, 每次循环处理的数据库数量    int dbs_per_call &#x3D; CRON_DBS_PER_CALL;    &#x2F;&#x2F; 遍历当前数据库的次数    int iteration &#x3D; 0;    &#x2F;&#x2F; 遍历循环 16 个数据库    for (int j &#x3D; 0; j &lt; dbs_per_call &amp;&amp; timelimit_exit &#x3D;&#x3D; 0; j++) &#123;        &#x2F;&#x2F; 清理过期的 key 个数        int expired;        &#x2F;&#x2F; 计算本次处理的数据库        redisDb *db &#x3D; server.db+(current_db % server.dbnum);        current_db++;        do &#123;            &#x2F;&#x2F; 开始循环清除当前数据库中过期的 key            &#x2F;&#x2F; 遍历次数 + 1            iteration++;            &#x2F;&#x2F; dictSize 获取整个过期字典的已经使用大小            unsigned long num &#x3D; dictSize(db-&gt;expires);            &#x2F;&#x2F; num &#x3D;&#x3D; 0 表示整个字典没有数据, 跳出循环，处理下一个数据库            if (num &#x3D;&#x3D; 0) &#123;                break;            &#125;            &#x2F;&#x2F; 计算整个过期字典的总大小            unsigned long slots &#x3D; dictSlots(db-&gt;expires);            &#x2F;&#x2F; DICT_HT_INITIAL_SIZE &#x3D; 4, 每个字典初始化时的默认值            &#x2F;&#x2F; num &gt; 0, 字典中有数据了, slots 大于 4, 表示当前的字典扩容过了            &#x2F;&#x2F; num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE, 当前的字典扩容过同时里面有数据            &#x2F;&#x2F; num * 100 &#x2F; slots &lt; 1 计算当前使用的数据占整个字典的百分比是否小于 1%            &#x2F;&#x2F; Redis 认为, 如果一个字典中的使用率小于 1%, 花时间去进行清理是一个昂贵的操作            &#x2F;&#x2F; 应该停下来，等待更好的时间再进行调整            &#x2F;&#x2F; 所以简单理解: 当这个字典中使用的空间小于 1%, 这里跳过了这个数据的处理            if (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp; (num * 100 &#x2F; slots &lt; 1))                 break;            expired &#x3D; 0;            &#x2F;&#x2F; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP &#x3D; 20             &#x2F;&#x2F; 本次从过期字典中获取多少个 key, 如果字典中的已经使用的 key 大于 20, 则只取 20 个, 否则有多少取多少            if (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)                num &#x3D; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;                        &#x2F;&#x2F; 循环 num 次从字典中获取 key             while (num--) &#123;                dictEntry *de;                &#x2F;&#x2F; 从过期字典中随机获取一个 key, 获取不到, 就停止本次循环                if ((de &#x3D; dictGetRandomKey(db-&gt;expires)) &#x3D;&#x3D; NULL) break;                &#x2F;&#x2F; 尝试释放这个 key, 如果 key 释放成功, 过期次数 + 1                if (activeExpireCycleTryExpire(db,de,now)) expired++;            &#125;            &#x2F;&#x2F; 0xf &#x3D; 15, iteration 表示遍历了 15 次            if ((iteration &amp; 0xf) &#x3D;&#x3D; 0) &#123;                &#x2F;&#x2F; 计算消耗时间                int elapsed &#x3D; ustime()-start;                &#x2F;&#x2F; 消耗时间超过了限制时间, 结束本次循环                if (elapsed &gt; timelimit) &#123;                    &#x2F;&#x2F; 超过时间限制标识设置为 true, 本次循环清除超时了, 结束本次循环清除                    timelimit_exit &#x3D; 1;                    break;                &#125;            &#125;            &#x2F;&#x2F; 本次清理的过期 key 超过了 25%, 继续, 否则结束            &#x2F;&#x2F; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP &#x3D; 20            &#x2F;&#x2F; 每次抽取的个数最大为 20 个, 控制 25%, 20 * 25% &#x3D; 5 个            &#x2F;&#x2F; 也就是过期的个数大于 5 就是大于 25%, (ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP&#x2F;4 &#x3D; 5)        &#125; while (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP&#x2F;4);    &#125;    &#x2F;&#x2F; 省略各种分析数据的记录&#125;</code></pre><p>调用 activeExpireCycle 的入口有 2 个</p><ol><li>Redis 定时事件触发</li></ol><pre class="language-C" data-language="C"><code class="language-C">&#x2F;** * Reids 启动时, 向事件轮询中注册的唯一一个定时事件(默认 100 毫秒执行一次), 执行的函数 *&#x2F;int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) &#123;    ...    &#x2F;&#x2F; 数据库扫描    databasesCron();    ...&#125;void databasesCron(void) &#123;    &#x2F;&#x2F; 过期功能开启中, 默认为开启    if (server.active_expire_enabled) &#123;        &#x2F;&#x2F; 主节点        if (server.masterhost &#x3D;&#x3D; NULL) &#123;            &#x2F;&#x2F; 慢模式循环清除            activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);        &#125; else &#123;            &#x2F;&#x2F; 从节点处理            expireSlaveKeys();        &#125;    &#125;    ...&#125;</code></pre><ol start="2"><li>事件轮询中, 进入阻塞前的调用函数</li></ol><pre class="language-C" data-language="C"><code class="language-C">void beforeSleep(struct aeEventLoop *eventLoop) &#123;    ...    &#x2F;&#x2F; 过期功能开启中同时为主节点    if (server.active_expire_enabled &amp;&amp; server.masterhost &#x3D;&#x3D; NULL)        &#x2F;&#x2F; 快模式循环清除        activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);    ...&#125;</code></pre><h2 id="3-内存淘汰"><a href="#3-内存淘汰" class="headerlink" title="3 内存淘汰"></a>3 内存淘汰</h2><h3 id="3-1-淘汰算法"><a href="#3-1-淘汰算法" class="headerlink" title="3.1 淘汰算法"></a>3.1 淘汰算法</h3><p>为了能够腾出内存空间, 需要在一大群对象中选择某一些进行淘汰, 哪么应该基于什么标准进行选择呢?<br>比较常见的算法有 2 个: LRU 和 LFU。</p><p>LRU (Least Recently Used): 最近最少使用算法, 根据数据的历史访问记录进行淘汰数据，优先移除<strong>最近最少使用</strong>的数据。<br>简单理解就是根据对象的访问时间, 优先淘汰访问时间最早的对象。</p><p>LFU (Least Frequently Used): 最少频率使用算法, 根据数据的访问频率频率进行淘汰数据, 优先移除<strong>最近使用频率最少</strong>的数据。<br>简单理解就是根据对象的访问次数, 优先淘汰访问次数最少的对象。</p><h3 id="3-2-Redis-内存淘汰策略"><a href="#3-2-Redis-内存淘汰策略" class="headerlink" title="3.2 Redis 内存淘汰策略"></a>3.2 Redis 内存淘汰策略</h3><p>在 LFU 和 LRU 的基础上, Redis 提供了 8 种淘汰策略</p><table><thead><tr><th align="center">策略</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">noeviction</td><td align="center">默认策略, 不会删除任何数据, 但是拒绝所有写入操作并返回客户端错误信息 (error)OOM command not allow when used memory。此时 Redis 只响应读操作。</td></tr><tr><td align="center">volatile-lru</td><td align="center">Least Recently Used, 最近最少使用。在所有设置了 expire 的 key 中删除最近最少使用的键值对, 即距离上次访问时间最久的。</td></tr><tr><td align="center">allkeys-lru</td><td align="center">Least Recently Used, 最近最少使用。在所有的 key 中删除最近最少使用的键值对, 即距离上次访问时间最久的。</td></tr><tr><td align="center">volatile-lfu</td><td align="center">Least Frequently Used, 最不经常使用。在所有设置了 expire 的 key 中删除最不经常使用的键值对, 即访问次数最少的。</td></tr><tr><td align="center">allkeys-lfu</td><td align="center">Least Frequently Used, 最不经常使用。在所有的 key 中删除最不经常使用的键值对, 即访问次数最少的。</td></tr><tr><td align="center">volatile-random</td><td align="center">在所有设置了 expire 的 key 中随机选择删除</td></tr><tr><td align="center">allkeys-random</td><td align="center">在所有的 key 中随机选择删除。</td></tr><tr><td align="center">volatile-ttl</td><td align="center">Time To Live, 存活时间。 在所有设置了 expire 的 key 中删除 ttl 值最多的。</td></tr></tbody></table><p>volatile-lru, volatile-random, volatile-ttl, 在没有符合条件的 key 的情况下, 会按照 noeviction 的策略进行处理。</p><h3 id="3-3-Redis-对象淘汰判断标准设计"><a href="#3-3-Redis-对象淘汰判断标准设计" class="headerlink" title="3.3 Redis 对象淘汰判断标准设计"></a>3.3 Redis 对象淘汰判断标准设计</h3><p>在上面介绍的几种策略可以知道, 要判断一个对象是否可以被淘汰, 需要对象自身存放使用策略对应的数据, 以便于判断<br>比如: </p><blockquote><ol><li>2 个 lru 策略, 需要对象自身保存好上次访问的时间</li><li>2 个 lfu 策略, 需要对象自身保存好访问次数</li><li>ttl 策略, 需要对象自身保存好过期时间</li><li>2 个 random 策略, 不需要保存额外的数据, 通过随机一个数, 根据这个数从字典中获取数据即可</li></ol></blockquote><h5 id="3-3-1-Redis-对象的设计"><a href="#3-3-1-Redis-对象的设计" class="headerlink" title="3.3.1 Redis 对象的设计"></a>3.3.1 Redis 对象的设计</h5><p>正常情况下, 当我们向 Redis 中存入一对键值对, 实际可以拆分为 2 个对象, 一个 key, 一个 value。<br>其中 key 可以明确为是一个字符串, 所以存入到 Redis 的键值对的 key 会被封装为 sds 对象。<br>但是 value 可以类型可以很多, 为了行为的统一等, 需要对 value 做一个封装, 落实到源码中就是一个 <strong>redisObject</strong> 对象, 其定义如下</p><pre class="language-C" data-language="C"><code class="language-C">typedef struct redisObject &#123;        &#x2F;**      * 标识这个对象的数据类型, 常说的 String, Hash, List 等     *&#x2F;    unsigned type:4;    &#x2F;**     * 可以理解为数据类型的具体实现类型     * 比如数据类型为 List, 在具体的实现中可以是 ArrayList LinkedList 等     *&#x2F;    unsigned encoding:4;    &#x2F;**      * LRU_BITS &#x3D; 24,     * 一个 24 位的变量, 表示对象最后一次被程序访问的时间或者访问的次数, 与内存回收有关     * 暂时知道有这个对象即可, 后面有分析     *&#x2F;    unsigned lru:LRU_BITS;    &#x2F;**     * 被引用的次数, 当 refcount 为 0 的时候, 表示该对象已经不被任何对象引用, 则可以进行垃圾回收了     *&#x2F;    int refcount;    &#x2F;**     * 一个指针, 指向具体的数据     *&#x2F;    void *ptr;&#125; robj;</code></pre><p>一个对象的 lru 和 lfu 计算后的值, 都是存放在这个对象的 lru 字段中的, 但是 lru 和 lfu 的计算方式是不一样的。</p><h5 id="3-3-2-lru-策略-对象的访问时间设计"><a href="#3-3-2-lru-策略-对象的访问时间设计" class="headerlink" title="3.3.2 lru 策略, 对象的访问时间设计"></a>3.3.2 lru 策略, 对象的访问时间设计</h5><h6 id="3-3-2-1-全局时间-lruclock"><a href="#3-3-2-1-全局时间-lruclock" class="headerlink" title="3.3.2.1 全局时间 lruclock"></a>3.3.2.1 全局时间 lruclock</h6><p>在 Redis 的中维护了一个全局的变量 lruclock, 表示当前时间的一个相对值。</p><pre class="language-C" data-language="C"><code class="language-C">&#x2F;** * redisServer 可以看做整个 Redis 运行时的上下文, 保存的数据, 配置等都在这个结构体中 *&#x2F;struct redisServer &#123;    unsigned int lruclock &#x3D; getLRUClock();&#125;unsigned int getLRUClock(void) &#123;    &#x2F;&#x2F; LRU_CLOCK_RESOLUTION &#x3D; 1000    &#x2F;&#x2F; mstime() 当前时间毫秒, 当前时间的毫秒&#x2F;LRU_CLOCK_RESOLUTION &#x3D; 当前时间的毫秒&#x2F;1000 &#x3D; 变为单位秒    &#x2F;&#x2F; LRU_CLOCK_MAX &#x3D; ((1&lt;&lt;LRU_BITS)-1) &#x3D; 1&lt;&lt;24-1 &#x3D; redisObject lru 字段的最大值    &#x2F;&#x2F; (当前的时间 &#x2F; 1000) &amp; (1&lt;&lt;24-1) 确保时间的精度是秒, 同时不会超过 24 位的整数的最多值    &#x2F;&#x2F; 整个全局时间的进度为秒, 2 个对象的访问时间差如果在秒内, 得到的是他们的访问时间是一样的        &#x2F;&#x2F; 得到一个当前时间的相对值    return (mstime()&#x2F;LRU_CLOCK_RESOLUTION) &amp; LRU_CLOCK_MAX;&#125;</code></pre><p>同时这个时间会在 Redis 的定时任务 serverCron 中定时的更新为最新的值</p><pre class="language-C" data-language="C"><code class="language-C">int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) &#123;    &#x2F;&#x2F; serverCron 默认是 100 毫秒执行一次    unsigned int lruclock &#x3D; getLRUClock();    atomicSet(server.lruclock,lruclock);&#125;</code></pre><h6 id="3-3-2-2-对象的访问时间设计"><a href="#3-3-2-2-对象的访问时间设计" class="headerlink" title="3.3.2.2 对象的访问时间设计"></a>3.3.2.2 对象的访问时间设计</h6><p>Redis 每次通过 key 在数据库中查询对应的 value 时, 在找到时, 就会进行 lru 字段的更新</p><pre class="language-C" data-language="C"><code class="language-C">robj *lookupKey(redisDb *db, robj *key, int flags) &#123;    &#x2F;&#x2F; 从字典中获取 key 对应的 dictEntry (字典的设计可以看一下后面的附录)    dictEntry *de &#x3D; dictFind(db-&gt;dict,key-&gt;ptr);    if (de) &#123;        &#x2F;&#x2F; 获取 key 对应的 dictEntry 的存在        &#x2F;&#x2F; 获取 dictEntry 的 value 也就是 redisObject 对象        robj *val &#x3D; dictGetVal(de);        if (server.rdb_child_pid &#x3D;&#x3D; -1 &amp;&amp; server.aof_child_pid &#x3D;&#x3D; -1 &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH)) &#123;            &#x2F;&#x2F; 没有在进行 RDB 或 AOF 操作, 并且 flags 没有设置 LOOKUP_NOTOUCH            &#x2F;&#x2F; 淘汰策略设置的的 LFU 策略            if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;                updateLFU(val);            &#125; else &#123;                &#x2F;&#x2F; 其他策略, 更新 lru 为全局的 lruclock                val-&gt;lru &#x3D; LRU_CLOCK();            &#125;        &#125;    &#125; else &#123;        &#x2F;&#x2F; key 不存在, 返回 null        return NULL;    &#125;&#125;unsigned int LRU_CLOCK(void) &#123;    unsigned int lruclock;    &#x2F;&#x2F; LRU_CLOCK_RESOLUTION &#x3D; 1000    &#x2F;&#x2F; 1000&#x2F;server.hz 就是上面定时任务 serverCron 的执行时间    &#x2F;&#x2F; &lt;&#x3D; 1000 说明 serverCron 的执行时间小于 1 秒, 直接获取 server.lruclock 的值    &#x2F;&#x2F; 如果大于 1000, 就调用 getLRUClock() 实时获取当前的时间, 因为频率太低了, 会造成更多的对象的访问时间一样    if (1000&#x2F;server.hz &lt;&#x3D; LRU_CLOCK_RESOLUTION) &#123;        atomicGet(server.lruclock,lruclock);    &#125; else &#123;        lruclock &#x3D; getLRUClock();    &#125;    return lruclock;&#125;</code></pre><h5 id="3-3-3-lfu-策略-对象的访问频率设计"><a href="#3-3-3-lfu-策略-对象的访问频率设计" class="headerlink" title="3.3.3 lfu 策略, 对象的访问频率设计"></a>3.3.3 lfu 策略, 对象的访问频率设计</h5><p>对象的 lfu 同样是存放在 redisObject 的 <strong>lru:LRU_BITS</strong> 字段。 这个 24 bits 字段, 被分为两部分</p><blockquote><ol><li>高 16 位用来记录访问时间 (单位为分钟，ldt, last decrement time)</li><li>低 8 位用来记录相对的访问次数, 简称 counter (logc, logistic counter)</li></ol></blockquote><p>Redis 中对 LFU 的实现比较特殊, 通过时间衰减的方式近似达到了 LFU 的效果。<br>大体的思路如下:</p><blockquote><ol><li>对象创建时, 初始访问次数为 5 (避免刚创建出来, 对象就被回收), 同时记录下当前时间, 单位分钟</li><li>对象被访问时, 获取当前时间, 单位分钟, 当前时间 - 对象本身记录的时间, 得到相差多少分钟, 访问次数就减少多少</li><li>然后对象的访问次数 + 1, 再次记录下当前时间</li></ol></blockquote><p>这样对象在单位分钟内, 访问越频繁, 访问次数越大, 同时随着时间的推移, 没有进行访问, 访问次数会逐渐减少, 从而达到了 LFU 的效果。</p><p>ldt 记录的是最近一次访问的时间, 16 位, 所以最大值为 65535, 单位是分钟, 差不多 45 天左右。<br>也就是一个对象如果一直被访问, 到了第 45 天后, 这个值又会重新回到 0 开始计算。</p><p>ldt 的计算</p><pre class="language-C" data-language="C"><code class="language-C">unsigned long LFUGetTimeInMinutes(void) &#123;  &#x2F;&#x2F; &amp; 65535 保证时间的范围在 0 ~ 65535 之间, 不会超过 16 数值的大小     return (server.unixtime&#x2F;60) &amp; 65535;&#125;</code></pre><p>同 lru 一样, lruclock 的计算, 后面的时间比前面的时间小,<br>说明后面的时间到了下一轮的重新开始了, 这时只需要后面的时间 + 65535 - 前面的时间, 就能得到 2 个时间的差值了。</p><p>logc 记录的是一个相对的访问次数。<br>本身只有 8 位, 也就是最大值为 255, 也就是一个对象只能保存 255 次访问次数, 这个基本不同满足日常的使用。<br>所以 Redis 内部设计了一个随机公式, 控制访问次数的增长, 即每次访问, 访问次数加不加一, 通过随机判断。</p><pre class="language-C" data-language="C"><code class="language-C">uint8_t LFULogIncr(uint8_t counter) &#123;    &#x2F;&#x2F; 当前的访问次数已经达到了最大值了    if (counter &#x3D;&#x3D; 255)         return 255;    &#x2F;&#x2F; 产生一个随机数    double r &#x3D; (double)rand()&#x2F;RAND_MAX;    &#x2F;&#x2F; 获取一个基础值, 当前的次数 - 对象初始化的默认次数 (LFU_INIT_VAL &#x3D; 5)    double baseval &#x3D; counter - LFU_INIT_VAL;    if (baseval &lt; 0) baseval &#x3D; 0;    &#x2F;&#x2F; 1.0 &#x2F; 基础值 * server.lfu_log_factor (默认值, 10, 可配置) + 1, 得到一个数    double p &#x3D; 1.0&#x2F;(baseval*server.lfu_log_factor+1);    &#x2F;&#x2F; 得到的数大于随机出来的数, 访问次数 + 1    if (r &lt; p) counter++;    return counter;&#125;</code></pre><p>官方的测试数据 (可以简单看成, counter &#x3D; 5, 在 100 - 1000w 次的调用, lfu_log_factor 不同取值下, 最终的 counter 的值)</p><table><thead><tr><th align="center">lfu_log_factor 取值</th><th align="center">100 次</th><th align="center">1000 次</th><th align="center">10w 次</th><th align="center">100w 次</th><th align="center">1000w 次</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">104</td><td align="center">255</td><td align="center">255</td><td align="center">255</td><td align="center">255</td></tr><tr><td align="center">1</td><td align="center">18</td><td align="center">49</td><td align="center">255</td><td align="center">255</td><td align="center">255</td></tr><tr><td align="center">10</td><td align="center">10</td><td align="center">18</td><td align="center">142</td><td align="center">255</td><td align="center">255</td></tr><tr><td align="center">100</td><td align="center">8</td><td align="center">11</td><td align="center">49</td><td align="center">143</td><td align="center">255</td></tr></tbody></table><p>lfu_log_factor 设置为 10 的情况下, 在 100w 次的访问中, 访问次数才达到为 255, 也就是最大值。<br>基本可以满足 10w 次的使用</p><h6 id="3-3-3-1-counter-衰减机制"><a href="#3-3-3-1-counter-衰减机制" class="headerlink" title="3.3.3.1 counter 衰减机制"></a>3.3.3.1 counter 衰减机制</h6><p>每个对象被返回时, counter 都会先进行一个衰减操作, 然后再通过上面的随机公式进行判断次数是否需要增加。</p><p>衰减的过程如下</p><pre class="language-C" data-language="C"><code class="language-C">unsigned long LFUDecrAndReturn(robj *o) &#123;    &#x2F;&#x2F; 右移 8 为, 也就是得的了高位的 16 位, 即 ldt, 得到上次记录的时间    unsigned long ldt &#x3D; o-&gt;lru &gt;&gt; 8;    &#x2F;&#x2F; 得到当前保存的次数    unsigned long counter &#x3D; o-&gt;lru &amp; 255;    &#x2F;&#x2F; lfu_decay_time 衰减时间, 默认 1, 单位分钟    &#x2F;&#x2F; 如果没有配置 lfu_decay_time, 则默认不进行衰减, counter 当前是多少就是多少    &#x2F;&#x2F; 获取 2 次访问的时间差 &#x2F; lfu_decay_time, 得到经过了多少个时间段       unsigned long num_periods &#x3D; server.lfu_decay_time ? LFUTimeElapsed(ldt) &#x2F; server.lfu_decay_time : 0;    if (num_periods)        &#x2F;&#x2F; 最新的次数 &#x3D; 当前的次数 - 经过了多少个时间段, 小于 0 时, 设置为 0         counter &#x3D; (num_periods &gt; counter) ? 0 : counter - num_periods;    return counter;&#125;&#x2F;&#x2F; 距离上次访问相差多少分钟unsigned long LFUTimeElapsed(unsigned long ldt) &#123;    unsigned long now &#x3D; LFUGetTimeInMinutes();    if (now &gt;&#x3D; ldt) return now-ldt;    return 65535-ldt+now;&#125;</code></pre><h6 id="3-3-3-2-对象的访问频率设计"><a href="#3-3-3-2-对象的访问频率设计" class="headerlink" title="3.3.3.2 对象的访问频率设计"></a>3.3.3.2 对象的访问频率设计</h6><p>Redis 每次通过 key 在数据库中查询对应的 value 时, 在找到时, 就会进行 lru 字段的更新</p><pre class="language-C" data-language="C"><code class="language-C">robj *lookupKey(redisDb *db, robj *key, int flags) &#123;        dictEntry *de &#x3D; dictFind(db-&gt;dict,key-&gt;ptr);    if (de) &#123;        robj *val &#x3D; dictGetVal(de);        if (server.rdb_child_pid &#x3D;&#x3D; -1 &amp;&amp; server.aof_child_pid &#x3D;&#x3D; -1 &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH)) &#123;            &#x2F;&#x2F; 淘汰策略设置的的 LFU 策略            if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;                updateLFU(val);            &#125; else &#123;                val-&gt;lru &#x3D; LRU_CLOCK();            &#125;        &#125;    &#125; else &#123;        return NULL;    &#125;&#125;void updateLFU(robj *val) &#123;    &#x2F;&#x2F; 通过衰减机制, 得到最新的 counter    unsigned long counter &#x3D; LFUDecrAndReturn(val);    &#x2F;&#x2F; 通过随机公式, 得到最新的 counter    counter &#x3D; LFULogIncr(counter);    &#x2F;&#x2F; 将最新的 counter 和 当前时间保存到 lru 字段中    val-&gt;lru &#x3D; (LFUGetTimeInMinutes()&lt;&lt;8) | counter;&#125;</code></pre><h3 id="3-4-Redis-内存淘汰策略的实现"><a href="#3-4-Redis-内存淘汰策略的实现" class="headerlink" title="3.4 Redis 内存淘汰策略的实现"></a>3.4 Redis 内存淘汰策略的实现</h3><p>Redis 的内存的实现方式都是通过<strong>随机采样 + 比较 lru 值决定是否淘汰</strong>的方式实现的。</p><p>大体过程如下:</p><blockquote><ol><li>Redis 启动时, 会初始一个默认容量为 16 的待淘汰数据池 <strong>evictionPoolEntry (本质就是一个数组)</strong></li><li>每个存入到 Redis 的对象 (redisObject) 都会在初始其 24 位的 lru 字段 (lru: 一个相对的访问时间, lfu: 一个相对的访问次数)</li><li>后面每次访问 Redis 的对象时, 更新其 lru 字段的值</li><li>同时每次执行一个 Redis 命令时, 就会判断一下当前的内存是否足够, 如果不够, 就计算出需要释放多少内存, 然后进行内存淘汰</li></ol></blockquote><p>内存淘汰的过程如下: </p><p><strong>4.1 首次淘汰</strong><br>从数据字典或过期字典 (由配置的淘汰策略决定) 中随机抽样选出<strong>最多 N 个数据</strong>放入到一个<strong>样例池</strong>。<br>数据量 N: 由 redis.conf 配置的 maxmemory-samples 决定, 默认值是 5。 配置为 10 将非常接近真实 LRU 效果。<br>采样参数 maxmemory-samples 配置的数值越大, 就越能精确的查找到待淘汰的缓存数据, 但是也消耗更多的 CPU 计算, 执行效率降低。<br>同时为了避免长时间找不到足够的数据填充<strong>样例池</strong>, 强制写死了单次寻找数据的最大次数是 maxsteps &#x3D; N*10。  </p><p><strong>4.2 再次淘汰</strong><br>遍历整个<strong>样例池</strong>, 遍历的对象通过 lru 计算处理的值, 只要比<strong>待淘汰数据池</strong>中的<strong>任意一条</strong>数据的小, 就将该数据填充至<strong>待淘汰数据池</strong>。<br>第一次淘汰时, <strong>待淘汰数据池</strong>为空, 所以第一次淘汰时, 会将所有的样例数据填充到<strong>待淘汰数据池</strong>中, 这个池子后面就都会有数据, 一直存在着。<br>后续的淘汰时, <strong>样例池</strong> 中的数据就有可能进入到<strong>待淘汰数据池</strong>中, 也有可能不进入。</p><p><strong>4.3 执行淘汰</strong><br>从<strong>待淘汰数据池</strong>的尾部向前找到第一个可以删除的 key (此时找到的 key 就是值最小&#x2F;大的, 既空闲时间最大&#x2F;访问次数最小&#x2F;存活时间最小), 对其进行淘汰</p><p><strong>4.4 继续淘汰</strong><br>计算删除了一个 key 后内存释放了多少, 如果没达到要求的释放量, 就回到步骤 <strong>4.1</strong> 继续淘汰</p><h4 id="3-4-1-Redis-内存淘汰策略的代码实现"><a href="#3-4-1-Redis-内存淘汰策略的代码实现" class="headerlink" title="3.4.1 Redis 内存淘汰策略的代码实现"></a>3.4.1 Redis 内存淘汰策略的代码实现</h4><p>入口: 每个命令的执行处</p><pre class="language-C" data-language="C"><code class="language-C">int processCommand(client *c) &#123;    ...    &#x2F;&#x2F; 有设置最大内存 同时当前没有 lua 脚本超时的情况    if (server.maxmemory &amp;&amp; !server.lua_timedout) &#123;        &#x2F;&#x2F; 有必要时, 尝试释放内存        int out_of_memory &#x3D; freeMemoryIfNeededAndSafe() &#x3D;&#x3D; C_ERR;        &#x2F;&#x2F; 内存不够 同时执行的命令是变更命令 或者 当前的客户端开启了事务, 同时执行的命令不是 exec         if (out_of_memory &amp;&amp; (c-&gt;cmd-&gt;flags &amp; CMD_DENYOOM || (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp; c-&gt;cmd-&gt;proc !&#x3D; execCommand))) &#123;            flagTransaction(c);            &#x2F;&#x2F; 响应 -OOM command not allowed when used memory &gt; &#39;maxmemory’            addReply(c, shared.oomerr);            return C_OK;        &#125;    &#125;    ...&#125;int freeMemoryIfNeededAndSafe(void) &#123;    &#x2F;&#x2F; 当前有 lua 脚本执行超时或者真正加载数据, 返回成功    if (server.lua_timedout || server.loading) return C_OK;    &#x2F;&#x2F; 是否内存如果有必要的话    return freeMemoryIfNeeded();&#125;</code></pre><p>释放内存的核心函数</p><pre class="language-C" data-language="C"><code class="language-C">int freeMemoryIfNeeded(void) &#123;    &#x2F;&#x2F; 如果是从节点同时配置了从节点忽略内存配置, 直接返回    if (server.masterhost &amp;&amp; server.repl_slave_ignore_maxmemory) return C_OK;    &#x2F;&#x2F; mem_reported 保存了整个 Redis 已经使用的内存    &#x2F;&#x2F; mem_tofree 经过计算本次应该释放的内存, 等于当前已经使用的内存 - 用于主从复制的复制缓冲区大小 - 配置的 maxmemory    &#x2F;&#x2F; mem_freed 已经释放了多少内存    size_t mem_reported, mem_tofree, mem_freed;    long long delta;    &#x2F;&#x2F; 从节点个数    int slaves &#x3D; listLength(server.slaves);    &#x2F;&#x2F; 判断当前的内存状态, 如果足够, 直接返回    if (getMaxmemoryState(&amp;mem_reported,NULL,&amp;mem_tofree,NULL) &#x3D;&#x3D; C_OK)        return C_OK;    &#x2F;&#x2F; 如果配置的策略为  noeviction    if (server.maxmemory_policy &#x3D;&#x3D; MAXMEMORY_NO_EVICTION)        goto cant_free;    mem_freed &#x3D; 0;    &#x2F;&#x2F; 没有达到需要的内存大小, 继续循环    while (mem_freed &lt; mem_tofree) &#123;        static unsigned int next_db &#x3D; 0;        sds bestkey &#x3D; NULL;        int bestdbid;        redisDb *db;        dict *dict;        dictEntry *de;                if (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) || server.maxmemory_policy &#x3D;&#x3D; MAXMEMORY_VOLATILE_TTL) &#123;            &#x2F;&#x2F; LRU + LFU + TTL 策略            &#x2F;&#x2F; 淘汰池            struct evictionPoolEntry *pool &#x3D; EvictionPoolLRU;            while(bestkey &#x3D;&#x3D; NULL) &#123;                                &#x2F;&#x2F; 遍历 16 个数据库                for (i &#x3D; 0; i &lt; server.dbnum; i++) &#123;                    db &#x3D; server.db+i;                    &#x2F;&#x2F; 根据 volatile 或 all 选择对应的数据字典                    dict &#x3D; (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ? db-&gt;dict : db-&gt;expires;                    &#x2F;&#x2F; 获取字典的数据大小, keys 为当前数据库的 key 的数量                    if ((keys &#x3D; dictSize(dict)) !&#x3D; 0) &#123;                        evictionPoolPopulate(i, dict, db-&gt;dict, pool);                        total_keys +&#x3D; keys;                    &#125;                &#125;                &#x2F;&#x2F; 没有可以处理的 keys                if (!total_keys) break;                &#x2F;&#x2F; EVPOOL_SIZE &#x3D;  16                for (k &#x3D; EVPOOL_SIZE-1; k &gt;&#x3D; 0; k--) &#123;                    if (pool[k].key &#x3D;&#x3D; NULL) continue;                    bestdbid &#x3D; pool[k].dbid;                    &#x2F;&#x2F; 从数据库中获取对应的节点                    if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) &#123;                        de &#x3D; dictFind(server.db[pool[k].dbid].dict, pool[k].key);                    &#125; else &#123;                        de &#x3D; dictFind(server.db[pool[k].dbid].expires, pool[k].key);                    &#125;                    &#x2F;&#x2F; 释放缓存                    if (pool[k].key !&#x3D; pool[k].cached)                        sdsfree(pool[k].key);                    pool[k].key &#x3D; NULL;                    pool[k].idle &#x3D; 0;                    &#x2F;&#x2F; 找到的释放对象存在, 先跳出这次循环                    if (de) &#123;                        bestkey &#x3D; dictGetKey(de);                        break;                    &#125; else &#123;                        &#x2F;&#x2F; 不存在, 进行循环查找                    &#125;                &#125;            &#125;        &#125; else if (server.maxmemory_policy &#x3D;&#x3D; MAXMEMORY_ALLKEYS_RANDOM || server.maxmemory_policy &#x3D;&#x3D; MAXMEMORY_VOLATILE_RANDOM) &#123;            &#x2F;&#x2F; random 策略        &#125;        &#x2F;&#x2F; 删除找到的 key        if (bestkey) &#123;                        db &#x3D; server.db+bestdbid;            &#x2F;&#x2F; 将 key 封装为 redisObject 对象            robj *keyobj &#x3D; createStringObject(bestkey,sdslen(bestkey));            &#x2F;&#x2F; 传播 key 过期信息到主从复制和 AOF 文件            propagateExpire(db,keyobj,server.lazyfree_lazy_eviction);            &#x2F;&#x2F; 获取当前的内存大小            delta &#x3D; (long long) zmalloc_used_memory();            &#x2F;&#x2F; 同步删除或异步删除 key            if (server.lazyfree_lazy_eviction) &#123;                dbAsyncDelete(db,keyobj);            else                dbSyncDelete(db,keyobj);            &#125;            &#x2F;&#x2F; 计算本次释放的内存            delta -&#x3D; (long long) zmalloc_used_memory();            mem_freed +&#x3D; delta;            &#x2F;&#x2F; 释放创建的 key redisObject 对象            decrRefCount(keyobj);            keys_freed++;            &#x2F;&#x2F; 如果有从节点, 推送缓冲区的数据            if (slaves) flushSlavesOutputBuffers();            &#x2F;&#x2F; 支持异步清除 同时 清除了 16 个 key            if (server.lazyfree_lazy_eviction &amp;&amp; !(keys_freed % 16)) &#123;                &#x2F;&#x2F; 再次判断内存情况, 如果内存足够了                if (getMaxmemoryState(NULL,NULL,NULL,NULL) &#x3D;&#x3D; C_OK) &#123;                    &#x2F;&#x2F; 更新已经释放的缓存大小 &#x3D; 需要释放的缓存大小                    mem_freed &#x3D; mem_tofree;                &#125;            &#125;        &#125;        &#x2F;&#x2F; 本次释放没有处理成功任何一个 key        if (!keys_freed) &#123;            goto cant_free;         &#125;    &#125;    return C_OK;cant_free:    &#x2F;&#x2F; 没有内存可以分配了, 做唯一可以做的一件事: 检查是否有 lazyfree 线程在执行释放内存任务, 有进行等待    &#x2F;&#x2F; 知道没有任务或者已有的内存达到了需要释放的内存    while(bioPendingJobsOfType(BIO_LAZY_FREE)) &#123;        &#x2F;&#x2F; 当前的内存达到了现在需要的释放的内存, 结束检查        if (((mem_reported - zmalloc_used_memory()) + mem_freed) &gt;&#x3D; mem_tofree)            break;        usleep(1000);    &#125;    return C_ERR;  </code></pre><p>淘汰池的填充</p><pre class="language-C" data-language="C"><code class="language-C">void evictionPoolPopulate(int dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool) &#123;    int j, k, count;    &#x2F;&#x2F; 采样结果数组, 最大容量为 mamemory_samples 的大小    dictEntry *samples[server.maxmemory_samples];    &#x2F;&#x2F; 从 sampledict 字典中采样 server.maxmemory_samples 个 key 存放到 samples, 同时返回总共采样的多少个    count &#x3D; dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);    for (j &#x3D; 0; j &lt; count; j++) &#123;        unsigned long long idle;        sds key;        robj *o;        dictEntry *de;        de &#x3D; samples[j];        key &#x3D; dictGetKey(de);               if (server.maxmemory_policy !&#x3D; MAXMEMORY_VOLATILE_TTL) &#123;            if (sampledict !&#x3D; keydict) de &#x3D; dictFind(keydict, key);            o &#x3D; dictGetVal(de);        &#125;        if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU) &#123;            &#x2F;&#x2F; LRU 算法            idle &#x3D; estimateObjectIdleTime(o);        &#125; else if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;            &#x2F;&#x2F; LRU 算法            idle &#x3D; 255 - LFUDecrAndReturn(o);        &#125; else if (server.maxmemory_policy &#x3D;&#x3D; MAXMEMORY_VOLATILE_TTL) &#123;            &#x2F;&#x2F; TTL 算法            idle &#x3D; ULLONG_MAX - (long)dictGetVal(de);        &#125; else &#123;            serverPanic(&quot;Unknown eviction policy in evictionPoolPopulate()&quot;);        &#125;        k &#x3D; 0;        &#x2F;&#x2F; 从 evictionPoolEntry 淘汰池中找到第一个闲置时间比当前淘汰 key 大的        while (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key &amp;&amp; pool[k].idle &lt; idle)             k++;                if (k &#x3D;&#x3D; 0 &amp;&amp; pool[EVPOOL_SIZE-1].key !&#x3D; NULL) &#123;            &#x2F;&#x2F; 如果找到的 key 比淘汰池中闲置时间最小的 key 还小, 同时淘汰池没有空间了, 则跳过这个 key            continue;        &#125; else if (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key &#x3D;&#x3D; NULL) &#123;            &#x2F;&#x2F; 插入的位置为空, 直接进入到下面的赋值节点        &#125; else &#123;            &#x2F;&#x2F; 核心就是将找到的位置 k 空出来            &#x2F;&#x2F; 最后的位置为空            if (pool[EVPOOL_SIZE-1].key &#x3D;&#x3D; NULL) &#123;                &#x2F;&#x2F; 将原本 k 位置和后面的数据向后移动 1 位                 sds cached &#x3D; pool[EVPOOL_SIZE-1].cached;                memmove(pool+k+1, pool+k, sizeof(pool[0])*(EVPOOL_SIZE-k-1));                pool[k].cached &#x3D; cached;            &#125; else &#123;                &#x2F;&#x2F; 插入的位置不为空                 &#x2F;&#x2F; 将原本 k 位置前面的数据往前移动 1 位, 原本的第一位丢弃                k--;                sds cached &#x3D; pool[0].cached;                if (pool[0].key !&#x3D; pool[0].cached) sdsfree(pool[0].key);                memmove(pool,pool+1,sizeof(pool[0])*k);                pool[k].cached &#x3D; cached;            &#125;        &#125;        &#x2F;&#x2F; 把找到的 key 放到 k 的位置        int klen &#x3D; sdslen(key);        &#x2F;&#x2F; EVPOOL_CACHED_SDS_SIZE &#x3D; 255        if (klen &gt; EVPOOL_CACHED_SDS_SIZE) &#123;            &#x2F;&#x2F; 创建一个新的 key 赋值给 pool[k].key            pool[k].key &#x3D; sdsdup(key);        &#125; else &#123;            &#x2F;&#x2F; 从 key 中拷贝 klen + 1 的长度到 pool[k].cached            memcpy(pool[k].cached,key,klen+1);            sdssetlen(pool[k].cached,klen);            pool[k].key &#x3D; pool[k].cached;        &#125;        pool[k].idle &#x3D; idle;        pool[k].dbid &#x3D; dbid;    &#125;&#125;unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count) &#123;    unsigned long j;     unsigned long tables;    unsigned long stored &#x3D; 0, maxsizemask;    unsigned long maxsteps;    &#x2F;&#x2F; 字典中的数据量小于需要的个数, 取的个数变为字典的数据大小    if (dictSize(d) &lt; count) count &#x3D; dictSize(d);    &#x2F;&#x2F; 最大次数 &#x3D; 次数 * 10    maxsteps &#x3D; count*10;    &#x2F;* 如果字典在 rehash 中, 尝试 count 一样次数的 rehash *&#x2F;    for (j &#x3D; 0; j &lt; count; j++) &#123;        if (dictIsRehashing(d))            _dictRehashStep(d);        else            break;    &#125;    &#x2F;&#x2F; 获取总的 HashTable 个数, 如果在 rehash 中就是 2 个, 否则 1 个    tables &#x3D; dictIsRehashing(d) ? 2 : 1;    &#x2F;&#x2F; 获取数组大小的掩码, 用于计算索引值    maxsizemask &#x3D; d-&gt;ht[0].sizemask;    if (tables &gt; 1 &amp;&amp; maxsizemask &lt; d-&gt;ht[1].sizemask)        maxsizemask &#x3D; d-&gt;ht[1].sizemask;    &#x2F;&#x2F; 随机获取一个位置    unsigned long i &#x3D; random() &amp; maxsizemask;    unsigned long emptylen &#x3D; 0;    &#x2F;&#x2F; 获取到的个数没达到需要的个数 或者尝试的次数还没达到 0     while(stored &lt; count &amp;&amp; maxsteps--) &#123;        for (j &#x3D; 0; j &lt; tables; j++) &#123;                &#x2F;&#x2F; 如果字典在 rehash 中, 同时当前处理的是第一个字典, 处理的位置小于 rehash 下次处理的位置,             &#x2F;&#x2F; 则跳过这个位置, 直接到 rehash 下次处理的位置            &#x2F;&#x2F; 因为第一个字典 rehash 下次处理的位置前的数据都迁移到第二个字典中了            if (tables &#x3D;&#x3D; 2 &amp;&amp; j &#x3D;&#x3D; 0 &amp;&amp; i &lt; (unsigned long) d-&gt;rehashidx) &#123;                &#x2F;&#x2F; 防止获取数据的位置 i 超过第二个字典的大小                if (i &gt;&#x3D; d-&gt;ht[1].size)                    i &#x3D; d-&gt;rehashidx;                else                    continue;            &#125;            &#x2F;&#x2F; 超过了数组的长度            if (i &gt;&#x3D; d-&gt;ht[j].size) continue;            &#x2F;&#x2F; 获取对应位置的数据            dictEntry *he &#x3D; d-&gt;ht[j].table[i];            &#x2F;&#x2F; 对应的位置为 null            if (he &#x3D;&#x3D; NULL) &#123;                emptylen++;                &#x2F;&#x2F; 获取 null 数据的次数大于 5 次 同时 大于需要的过期 key 的个数                if (emptylen &gt;&#x3D; 5 &amp;&amp; emptylen &gt; count) &#123;                    &#x2F;&#x2F; 重新计算获取的位置 i, 重新获取                    i &#x3D; random() &amp; maxsizemask;                    emptylen &#x3D; 0;                &#125;            &#125; else &#123;                emptylen &#x3D; 0;                while (he) &#123;                    &#x2F;&#x2F; he 本身是链表, 计算从链表中获取到的个数, 够了结束, 不够就 i+1, 从字典的下一个位置继续获取                    *des &#x3D; he;                    des++;                    he &#x3D; he-&gt;next;                    stored++;                    if (stored &#x3D;&#x3D; count) return stored;                &#125;            &#125;        &#125;        i &#x3D; (i+1) &amp; maxsizemask;    &#125;    return stored;&#125;</code></pre><p>dictGetSomeKeys 函数简单理解就是, 通过 random() 得到一个随机数, 这个随机数 &amp; 数组大小的掩码, 得到一个位置, 从这个位置向后获取 count 个过期 key。<br>这个处理的过程中</p><blockquote><ol><li>有可能字典在 rehash 中, 数据分布在 2 个字典中, 所以有时第一个字典获取不到需要到第二个字典获取</li><li>需要的过期 key 的个数小于等于 5 个, 通过计算得到的位置获取到的数据连续都为 null, 则重新通过 random() 计算一个新的位置</li><li>为了防止长时间的需要, 在外面还计算了最大的循环次数</li></ol></blockquote><p>从上面的代码实现可以看出, Redis 内部对 LRU + LFU 的实现都是不是很正式的实现, 带有一定的误差和随机性。</p><p>其本身考虑主用是从性能上做的折中。比如传统的 LRU 算法, 需要将所有的数据维护一个双向链表</p><blockquote><ol><li>访问节点, 如果节点存在, 则将该节点移动到链表的头节点, 并返回节点值, 不存在就返回 null</li><li>新增节点, 节点不存在, 就在链表的头部新增节点, 如果节点存在, 则更新节点数据, 然后将节点移动到链表的头节点</li></ol></blockquote><p>需要消耗的内存在维护链表的 + 节点的挑战, 对于一个大规模的数据, 这个消耗是非常大的。<br>所以 Redis 采用了其思想, 通过另外的方式达到类似的效果。</p><h2 id="4-附录-Redis-几个对象的介绍"><a href="#4-附录-Redis-几个对象的介绍" class="headerlink" title="4 附录: Redis 几个对象的介绍"></a>4 附录: Redis 几个对象的介绍</h2><h3 id="4-1-Redis-中的字典"><a href="#4-1-Redis-中的字典" class="headerlink" title="4.1 Redis 中的字典"></a>4.1 Redis 中的字典</h3><h4 id="4-2-1-HashTable"><a href="#4-2-1-HashTable" class="headerlink" title="4.2.1 HashTable"></a>4.2.1 HashTable</h4><p>存储在 Redis 中的基本都是键值对, 而这种键值对存储, 同时可以通过 key 快速查询到对应的 value, 最合适的实现就是 HashTable 了。<br>而实现 HashTable 的底层结构，基本就是一个数组或者链表, 同时为了解决 hash 冲突, 数组或链表的每个节点定义为一个链表。</p><p>Redis 中对 HashTable 的实现也是如此, 大体如下</p><p><img src="https://pic.imgdb.cn/item/66714d06d9c307b7e93742a9.png" alt="Alt &#39;dictht 设计&#39;"></p><p>Redis 中实现的 HastTable 叫做 dictht (Dictionary Hash Table)</p><p>对应的定义如下:</p><pre class="language-C" data-language="C"><code class="language-C">typedef struct dictht &#123;    &#x2F;&#x2F; 存放节点的数组    dictEntry **table;    &#x2F;&#x2F; HashTable 的大小, 2 的幂次方    unsigned long size;    &#x2F;&#x2F; HashTable 的大小掩码, 用于计算索引值    unsigned long sizemask;    &#x2F;&#x2F; HashTable 中已经使用的节点个数    unsigned long used;&#125; dictht;</code></pre><p>真实存储数据的链表节点的定义如下:  </p><pre class="language-C" data-language="C"><code class="language-C">typedef struct dictEntry &#123;    &#x2F;&#x2F; 存储的键值对的 key    void *key;    &#x2F;&#x2F; 存储的键值对的 value    union &#123;        void *val;        uint64_t u64;        int64_t s64;        double d;    &#125; v;    &#x2F;&#x2F; 指向下一个节点    struct dictEntry *next;&#125; dictEntry;</code></pre><p>key + v(value) + next 一个简单的链表定义。<br>有点特殊的就是对应着 value 属性的 v 的定义是一个联合体, 会在不同场景下使用不同的字段,<br>比如一个键值对的过期时间就存放在 <strong>s64</strong> 中, 这个 value 存放的值就放在 <strong>val</strong> 中。</p><p>一个 dictEntry 的字段存放内容大体如下:</p><p><img src="https://pic.imgdb.cn/item/66714a82d9c307b7e93175bd.png" alt="Alt &#39;dictEntry 内容&#39;"></p><h4 id="4-2-2-字典"><a href="#4-2-2-字典" class="headerlink" title="4.2.2 字典"></a>4.2.2 字典</h4><p>在使用 HashTable 时, 都需要提前声明好容量, 而随着程序的运行, 存放到 HashTable 的数据会越来越多, 最终达到上限, 这时就需要进行扩容了。<br>在 Java 的 HashMap 的扩容过程</p><blockquote><ol><li>创建一个更大容量的数组</li><li>将 HashMap 中旧数组一次性迁移到新的数组中</li><li>清除掉旧数组</li></ol></blockquote><p>这个扩容没多大问题, 但是放到 Redis 中合适吗?</p><blockquote><ol><li>Redis 是一个存内存的数据库, 所有的数据都存放在内存中, 基本是 GB 级别的数据量, 每次扩容迁移的数据量很多</li><li>Redis 是一个单线程的数据库, 一次只能处理一个事情, 如果全力在做扩容, 那么其他的请求将无法处理</li></ol></blockquote><p>所以 Redis 采用了一种 <strong>渐进式 rehash</strong> 的方法解决扩容缩容的问题, 过程如下</p><blockquote><ol><li>维护 2 个 dictht, 一个是真实存储数据的 HashTable A, 一个是扩容后存储数据的 TableTable B + 一个 rehash 位置的索引, 初始值为 0</li><li>在 rehash &gt;&#x3D;0 期间, 每次对 HashTable 进行操作, 除了正常的操作外, 还会将 A rehash 位置的数据都迁移到 B, 然后 rehash + 1</li><li>随着对 HashTable 的不断操作, 最终 A 中的数据都会迁移到 B, 这时将 rehash 设置为 -1</li></ol></blockquote><p>基于上面的渐进式 rehash 分析, 实际是需要 2 个 dictht, 所以 Redis 在此至上多封装了一层</p><pre class="language-C" data-language="C"><code class="language-C">typedef struct dict &#123;    dictType *type;    void *privdata;    dictht ht[2];   &#x2F;&#x2F; 2 个 HashTable    long rehashidx; &#x2F;&#x2F; rehash 的索引    unsigned long iterators;&#125; dict;</code></pre><p>这个就是 Redis 中的字典, 用于存储键值对的结构。</p><p>在将这个结构放到一个 redisDb 就是我们常见的 Redis 数据库了</p><pre class="language-C" data-language="C"><code class="language-C">typedef struct redisDb &#123;    dict *dict;     dict *expires;    ....&#125; redisDb;</code></pre><p>redisDb 就是我们常说的 Redis 16 个数据库的定义了。 每个数据库中都有 2 个字典</p><blockquote><ol><li>dict 正常的字典, 存储没有设置过期时间的键值对</li><li>expires 过期字典, 存储设置了过期时间的键值对</li></ol></blockquote><h3 id="4-2-Redis-的内存待淘汰池"><a href="#4-2-Redis-的内存待淘汰池" class="headerlink" title="4.2 Redis 的内存待淘汰池"></a>4.2 Redis 的内存待淘汰池</h3><pre class="language-C" data-language="C"><code class="language-C">struct evictionPoolEntry &#123;    unsigned long long idle;    &#x2F;&#x2F; 对象空闲时间 (使用的算法是 LFU 则是逆频率)    sds key;                    &#x2F;&#x2F; 待淘汰的键值对的 key    sds cached;                 &#x2F;&#x2F; 缓存的 key 名称 SDS 对象    int dbid;                   &#x2F;&#x2F; 待淘汰键值对的 key 所在的数据库 ID&#125;;</code></pre><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><a href="https://www.cnblogs.com/ltaodream/p/16299107.html">Redis源码解析-LRU</a><br><a href="https://www.cnblogs.com/reim/p/17422410.html#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">Redis内存兜底策略——内存淘汰及回收机制</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次 CPU 占用率过高的问题排查 (不断创建线程和线程上下文频繁切换)</title>
      <link href="/article/2023/608272343/"/>
      <url>/article/2023/608272343/</url>
      
        <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p><img src="https://pic.imgdb.cn/item/65753aa3c458853aef8e62da.png" alt="Alt &#39;项目初始架构&#39;"></p><p>如图是生产中系统的架构图</p><blockquote><ol><li>主服务会在核心表数据变更后, 将变更记录的数据推送到 MQ </li><li>下游有不同的业务系统, 订阅了对应的 MQ 消息</li></ol></blockquote><p>而本人负责的服务 A 在消费消息时, 有以下的特点</p><blockquote><ol><li>上游推送的数据有不同的业务类型和不同的状态值</li><li>不同的业务类型的数据只有在达到某个指定状态前, 才需要处理</li></ol></blockquote><p>比如某条记录有个业务类型, 取值为 A, B, C, 同时有 1 个状态值 X, Y, Z, 当业务类型为 A 的记录, 只有在 Y 状态, 才需要处理。</p><p>这个特点决定了上游推送的消息, 在服务 A 是<strong>暂时不关心</strong>的 (但是这些消息对于其他的业务系统, 却是关心的, 所以上游不会停止推送), 消费这些消息很浪费服务 A 的资源 (上游的数据变更推送每日的数据量在亿级别, 高峰 QPS 可达到 2000 以上),<br>为了不影响调用服务 A 的其他服务和用户的正常使用, 决定主服务和服务 A 中间加多一个<strong>过滤服务</strong>, 将原本服务 A 的过滤逻辑迁移到这个服务中, 新的架构图如下:  </p><p><img src="https://pic.imgdb.cn/item/65753aa6c458853aef8e6c7e.png" alt="Alt &#39;改造后的项目架构&#39;"></p><p>由<strong>过滤服务</strong>直接对接到主服务的 MQ 消息, 对消息进行过滤服务条件的在通过 MQ 推送给下游的服务 A。</p><p>经过改造后, 过滤服务部署到生产, 但是每次部署上去后, 没过多久, 就频繁的提示 CPU 占用率过高的告警, 不得不进行排查。</p><h2 id="2-结论"><a href="#2-结论" class="headerlink" title="2 结论"></a>2 结论</h2><p>按照惯例, 先把结论整理一下, 经过排查, 后面导致 CPU 占用率过高的原因, 有 2 个</p><blockquote><ol><li>没有经过任何配置, 通过 SpringBoot 的 <strong>@Async</strong> 进行异步, 导致应用一直在创建线程, 销毁线程</li><li>高频的打印日志, 日志内部有个锁, 导致线程频繁地进行上下文切换, 消耗 CPU 资源</li></ol></blockquote><h2 id="3-过程"><a href="#3-过程" class="headerlink" title="3 过程"></a>3 过程</h2><h3 id="3-1-告警"><a href="#3-1-告警" class="headerlink" title="3.1 告警"></a>3.1 告警</h3><p>过滤服务预发验收没问题后, 逐步切流量进入过滤服务, 但是在流量切完, 几分钟后, 触发告警 <strong>xxx 服务 CPU 超过警戒线, 当前 CPU xxx</strong>。<br>打开 Grafana 进行查看, 发现几个实例 CPU 都在 150% 以上, 看起来不是某个特例触发了什么 bug。</p><h3 id="3-2-异常线程发现"><a href="#3-2-异常线程发现" class="headerlink" title="3.2 异常线程发现"></a>3.2 异常线程发现</h3><ol><li><p>先获取一下当前 Java 程序的进程 Id  </p><pre class="language-bash" data-language="bash"><code class="language-bash">jps <span class="token parameter variable">-l</span></code></pre></li><li><p>查看应用当前的线程栈信息</p></li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">jstack 上一步获取到的进程 Id</code></pre><p>通过观察基本线程都是 <strong>RUNNABLE</strong>, 初步看不出是什么问题。</p><ol start="3"><li>多次导出线程栈信息, 进行比较</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">jstack 上一步获取到的进程 Id <span class="token operator">>></span> stack-1.txt</code></pre><p>将当前应用的线程栈信息导出到 stack-1.txt 文件, 然后隔几秒, 再导出一次到 stack-2.txt, 重复 3 次。<br>此时本地有 3 个线程栈信息 stack-1.txt, stack-2.txt, stack-3.txt, 对三个文件的堆栈信息进行对比分析。  </p><p>stack-1 文件内容</p><pre class="language-stack" data-language="stack"><code class="language-stack">&quot;SimpleAsyncTaskExecutor-1&quot; #182 daemon prio&#x3D;5 os_prio&#x3D;31 tid&#x3D;0x00007f93aeaa0000 nid&#x3D;0x1b203 runnable [0x0000000314bbd000]  省略&quot;MqConsumer-1&quot; #104 daemon prio&#x3D;5 os_prio&#x3D;31 tid&#x3D;0x00007f93b12c6800 nid&#x3D;0xf203 runnable [0x000000030fcd4000]    省略&quot;Reference Handler&quot; #2 daemon prio&#x3D;10 os_prio&#x3D;31 tid&#x3D;0x00007f939e80b800 nid&#x3D;0x4723 in Object.wait() [0x000000030a6c7000]  省略&quot;VM Thread&quot; os_prio&#x3D;31 tid&#x3D;0x00007f93ae020800 nid&#x3D;0x4803 runnable &quot;GC task thread#0 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007f93b0809000 nid&#x3D;0x524f runnable     省略</code></pre><p>通过第一个文件 stack-1.txt 整体的线程可以分为 3 组</p><blockquote><ol><li>SimpleAsyncTaskExecutor-x SpringBoot 异步处理任务的线程</li><li>MqConsumer-x 消费 MQ 消息的线程</li><li>其他</li></ol></blockquote><p>查看第二个文件 stack-2.txt, 发现以 SimpleAsyncTaskExecutor 开头的线程有好几个消失了, 但是多了几个新的以  SimpleAsyncTaskExecutor 开头的线程, 就是编号不一致。<br>通过堆栈信息, 发现他们是使用 <strong>@Async</strong> 注解的异步处理方法, 怀疑是不是一直<strong>在创建线程处理任务</strong>, 任务处理完成就释放。  </p><ol start="4"><li>在对应的方法处, 打一个断点, 启动项目, 调用这个方法</li></ol><p><img src="https://pic.imgdb.cn/item/65753a9fc458853aef8e5660.png" alt="Alt &#39;断点排查方式&#39;"></p><p>如图, 这样就能获取整个线程栈信息, 通过线程栈查看。 按照我们怀疑的地方, 找到提交任务的地方, 也就是 <strong>org.springframework.aop.interceptor.AsyncExecutionAspectSupport#doSubmit</strong>。<br>发现线程池是有参数传入的, 那么继续往前走, 也就是 <strong>org.springframework.aop.interceptor.AsyncExecutionInterceptor#invoke</strong>, 在里面获取线程池的方法如下</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Nullable</span><span class="token keyword">protected</span> <span class="token class-name">AsyncTaskExecutor</span> <span class="token function">determineAsyncExecutor</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 在缓存 Map 中获取异步方法, 执行对应的线程池 </span>    <span class="token comment">// Map&lt;Method, AsyncTaskExecutor> executors</span>    <span class="token class-name">AsyncTaskExecutor</span> executor <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">AsyncTaskExecutor</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>executors<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 1. 在缓存中获取不到</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>executor <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1.1 获取当前方法上面的 @Async 注解里面的 value 值 (可以通过这个指定异步方法执行的线程池)</span>        <span class="token class-name">String</span> qualifier <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getExecutorQualifier</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Executor</span> targetExecutor<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">hasLength</span><span class="token punctuation">(</span>qualifier<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 1.1.1 从当前的 Spring 容器中获取 @Async 指定名称的线程池</span>            targetExecutor <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">findQualifiedExecutor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">,</span> qualifier<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 1.1.2 没有 @Async 或 @Async 没有配置 value 值</span>            <span class="token comment">// 在声明 AsyncExecutionAspectSupport 时, 可以设置一个默认的线程池, 存放在 defaultExecutor 这个属性</span>            <span class="token comment">// 一般我们也不会自己主动去声明 AsyncExecutionAspectSupport, 所以这个 defaultExecutor 为空</span>            targetExecutor <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultExecutor<span class="token punctuation">;</span>            <span class="token comment">// 1.1.3 获取不到默认配置的线程池</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>targetExecutor <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>executors<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>defaultExecutor <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 1.1.4 通过 getDefaultExecutor 方法获取执行线程池</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>defaultExecutor <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getDefaultExecutor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    targetExecutor <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultExecutor<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 1.2 经过尝试还是获取不到对应的执行线程池</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>targetExecutor <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        executor <span class="token operator">=</span> targetExecutor <span class="token keyword">instanceof</span> <span class="token class-name">AsyncListenableTaskExecutor</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token class-name">AsyncListenableTaskExecutor</span><span class="token punctuation">)</span>targetExecutor <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">TaskExecutorAdapter</span><span class="token punctuation">(</span>targetExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1.3 保存缓存</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>executors<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> executor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 2. 缓存中获取到, 直接返回</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">AsyncTaskExecutor</span><span class="token punctuation">)</span>executor<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">protected</span> <span class="token class-name">Executor</span> <span class="token function">getDefaultExecutor</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">BeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用父类的 getDefaultExecutor 获取线程池</span>    <span class="token class-name">Executor</span> defaultExecutor <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getDefaultExecutor</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 父类获取不到线程池, 那么就默认为 SimpleAsyncTaskExecutor</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Executor</span><span class="token punctuation">)</span><span class="token punctuation">(</span>defaultExecutor <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> defaultExecutor <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">SimpleAsyncTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">protected</span> <span class="token class-name">Executor</span> <span class="token function">getDefaultExecutor</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">BeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 1. 在当前的 Spring 容器中获取 TaskExecutor 的实例</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Executor</span><span class="token punctuation">)</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">TaskExecutor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoUniqueBeanDefinitionException</span> var6<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Could not find unique TaskExecutor bean"</span><span class="token punctuation">,</span> var6<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 2. 获取到了多个, 尝试获取名称为 taskExecutor 的 Executor 实例</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Executor</span><span class="token punctuation">)</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"taskExecutor"</span><span class="token punctuation">,</span> <span class="token class-name">Executor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchBeanDefinitionException</span> var4<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">isInfoEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"More than one TaskExecutor bean found within the context, and none is named 'taskExecutor'. Mark one of them as primary or name it 'taskExecutor' (possibly as an alias) in order to use it for async processing: "</span> <span class="token operator">+</span> var6<span class="token punctuation">.</span><span class="token function">getBeanNamesFound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchBeanDefinitionException</span> var7<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Could not find default TaskExecutor bean"</span><span class="token punctuation">,</span> var7<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 3. 尝试获取名称为 taskExecutor 的 Executor 实例</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Executor</span><span class="token punctuation">)</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"taskExecutor"</span><span class="token punctuation">,</span> <span class="token class-name">Executor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchBeanDefinitionException</span> var5<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"No task executor bean found for async processing: no bean of type TaskExecutor and no bean named 'taskExecutor' either"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上面的获取线程池的逻辑概括为</p><blockquote><ol><li>从 Spring 容器中获取 TaskExecutor 的实例, 获取到唯一一个, 那么就用这个执行这个异步方法</li><li>从 Spring 容器中获取 TaskExecutor 的实例有多个或一个都没有, 在从容器中尝试获取 bean 名为 taskExecutor 的 Executor 的实例, 获取到就用这个执行这个异步方法</li><li>兜底方法, 通过 SimpleAsyncTaskExecutor 这个线程池执行异步方法</li><li>补充一点, 如果项目没有通过 @EnableAsync 注解启动异步功能的话, @Async 是不会其作用的</li></ol></blockquote><p>在整个 SpringBoot 项目中如果没有创建 TasekExecutor 的实例或名为 taskExecutor 的 Executor 实例, 那么就会用 SimpleAsyncTaskExecutor 执行异步任务 (本文的情况)。</p><p>而 里面执行任务的逻辑如下</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doExecute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 通过线程工程创建一个线程, 执行任务 (这里 2 处都是通过线程工程创建线程, 区别是一个用用户指定的线程工厂, 一个内置默认的线程工厂)</span>    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory<span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createThread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>到了这里, 大体可以确定问题了</p><blockquote><ol><li>每消费一条 MQ 消息的过程中, 都会创建一个线程去处理一部分逻辑</li><li>上游并发的推送消息, 导致下游一直在创建线程和销毁线程, 消耗大量的 CPU 资源</li></ol></blockquote><p>本地尝试模拟不断创建线程和消耗线程的情况<br><img src="https://pic.imgdb.cn/item/65753a88c458853aef8e08ff.png" alt="Alt &#39;线程创建对 CPU 的影响&#39;"></p><p>绿色的线条是应用本身的 CPU 情况, 而蓝色的的是整个系统的 CPU 情况, 这个频繁创建和消耗线程的操作消耗了 30% 以上的 CPU。<br>至于解决方法, 就在上面获取线程池的逻辑里面, 自己定义了一个 TaskExecutor 的线程池, 并交给 Spring 容器即可。</p><h3 id="3-3-线程上下文频繁切换发现"><a href="#3-3-线程上下文频繁切换发现" class="headerlink" title="3.3 线程上下文频繁切换发现"></a>3.3 线程上下文频繁切换发现</h3><p>通过自定义线程池解决频繁创建线程的问题, 修改好代码后, 重新发布上线, 本以为解决了。<br>但是没过多久, 告警 <strong>xxx 服务 CPU 超过警戒线, 当前 CPU xxx</strong> 还是没有消失。  </p><p>通过</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">top</span> <span class="token parameter variable">-Hp</span> 进程 Id</code></pre><p>观察, 占用高 CPU 的线程 Id 一直在变化, 不是固定的几个。</p><p>再次通过 <strong>jstack</strong>, 获取线程栈信息, 通过观察, 发现少量的线程是 <strong>RUNNABLE</strong> 状态, 业务相关的就一个线程在输出日志,<br>很多线程都是 <strong>WAITING</strong> 状态, 线程栈都是很一致的在输出日志的地方阻塞住了。</p><pre class="language-stack" data-language="stack"><code class="language-stack">&quot;MqConsumer-2&quot; #178 daemon prio&#x3D;5 os_prio&#x3D;31 tid&#x3D;0x00007f93aea9f800 nid&#x3D;0x1ac03 waiting on condition [0x00000003147b2000]   java.lang.Thread.State: WAITING (parking)at sun.misc.Unsafe.park(Native Method)- parking to wait for  &lt;0x00000006c0142820&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:870)at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1199)at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLock.java:209)at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:285)at ch.qos.logback.core.OutputStreamAppender.writeBytes(OutputStreamAppender.java:197)at ch.qos.logback.core.OutputStreamAppender.subAppend(OutputStreamAppender.java:231)at ch.qos.logback.core.OutputStreamAppender.append(OutputStreamAppender.java:102)at ch.qos.logback.core.UnsynchronizedAppenderBase.doAppend(UnsynchronizedAppenderBase.java:84)at ch.qos.logback.core.spi.AppenderAttachableImpl.appendLoopOnAppenders(AppenderAttachableImpl.java:51)at ch.qos.logback.classic.Logger.appendLoopOnAppenders(Logger.java:270)at ch.qos.logback.classic.Logger.callAppenders(Logger.java:257)at ch.qos.logback.classic.Logger.buildLoggingEventAndAppend(Logger.java:421)at ch.qos.logback.classic.Logger.filterAndLog_1(Logger.java:398)at ch.qos.logback.classic.Logger.info(Logger.java:583)</code></pre><p>通过堆栈信息定位到 <strong>ch.qos.logback.core.OutputStreamAppender.writeBytes</strong> 处</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeBytes</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> byteArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>byteArray <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> byteArray<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 此处加锁, 会导致线程挂起</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 日志写入</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>outputStream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>byteArray<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>immediateFlush<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>outputStream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>到这里已经有个推测了, <strong>线程基本都是阻塞状态, 但是 CPU 很高</strong>, 有可能是线程频繁地上下文切换导致的 (日志的打印挺快的, 忽略这操作, 每个线程可以看做是在获取锁，释放锁的过程)。<br>线程上下文切换导致 CPU 升高的分析, 可以看一下这篇<a href="https://heapdump.cn/article/2677994">文章</a>。<br>而根据堆栈信息都是在日志处阻塞的, 应该是上游打印日志太过频繁了 (新上的项目, 为了方便定位问题, 输出了很多日志)。</p><p>为了验证这个可能, 删除部分无用的日志, 在几个高频的日志打印处, 加上一个开关</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>logSwitch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>然后通过 Apollo 控制这个开发, 重新发布项目到生产。<br>开关依旧是打开状态, CPU 依旧是在升高, 通过 Apollo 将开关关闭, 停止高频日志的打印, 没过多久日志顺利下降, 验证了猜想。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>至此, 整个 CPU 占用率高的排查过程就结束了, 后面再对整个过程做个总结</p><blockquote><ol><li>通过比较线程栈的信息, 定位到了 @Async 注解的实现中, 通过不断创建线程执行任务的, 这个行为会导致 CPU 消耗资源在重量级对象 Thread 的创建和消毁中</li><li>第二次通过观察线程栈信息, 定位到大量的线程阻塞在日志输出处, 执行的任务也是在输出日志, 猜测是频繁的日志打印, 导致线程上下文切换, 通过减少日志打印进行验证结论</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 生产记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次简单的 Http 请求异常处理 (请求 url 太长, Nginx 返回 400, 导致请求服务异常)</title>
      <link href="/article/2023/3866295214/"/>
      <url>/article/2023/3866295214/</url>
      
        <content type="html"><![CDATA[<h2 id="1-结论"><a href="#1-结论" class="headerlink" title="1 结论"></a>1 结论</h2><p>按照惯例直接说结论。</p><p>后台服务 A 有一个 Http 接口, 代码如下:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/user"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserInfoVo</span><span class="token punctuation">></span></span> <span class="token function">getUserInfoByUserIds</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"userIds"</span><span class="token punctuation">)</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> userIds<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span></code></pre><p>没错, 一个 Get 请求, 入参是一个 **List<String>**。</p><p>同时有另一个后台服务 B, 里面有段逻辑会通过 RestTemplate 调用服务  A 的这个接口, 代码如下:  </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserInfoVo</span><span class="token punctuation">></span></span> <span class="token function">batchGetUserInfo</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> userIds<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s/user?userIds=%s"</span><span class="token punctuation">,</span> remoteHost<span class="token punctuation">,</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>userIds<span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> returnResult <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span></code></pre><p>在服务 B 中, 通过 batchGetUserInfo 方法请求服务 A 时, 传入了一个长度为 122 的 <strong>List<String></strong>, List 中每一项是一个 32 位的 UUID。<br><strong>结果导致调用服务  A  的 url 长度太长, Nginx 认为这时一个异常的请求格式, 直接返回状态码 400, 结构导致服务 B 逻辑异常</strong>。  </p><h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2 过程"></a>2 过程</h2><h3 id="2-1-反馈"><a href="#2-1-反馈" class="headerlink" title="2.1 反馈"></a>2.1 反馈</h3><p>下午, 突然收到用户反馈: 进入某个页面后, 直接白屏。</p><h3 id="2-2-定位到直接原因"><a href="#2-2-定位到直接原因" class="headerlink" title="2.2 定位到直接原因"></a>2.2 定位到直接原因</h3><p>直接通过 Nginx 请求日志, 发现用户反馈的操作时间段内, 有一个接口一直返回 400 的错误。<br>根据客户端反馈这个错误的确会导致页面白屏。  </p><p>知道了直接原因了, 但是没有解决, 还是需要定位到根本原因。</p><h3 id="2-3-Arthas-排查"><a href="#2-3-Arthas-排查" class="headerlink" title="2.3 Arthas 排查"></a>2.3 Arthas 排查</h3><p>通过错误的 url, 定位到对应的代码, 然后通过 Kibana 查看日志, 发现只有一个简单的异常提示, 没输出任何堆栈信息。  </p><p>因为是一个查询接口, 所以本地通过拼接参数, 尝试请求这个接口, 发现是逻辑正常的, 应该是数据问题, 这就尴尬了。  </p><p>通过分析代码逻辑, 看不出什么异常的。<br>在没有日志, 复现不出反馈情况, 代码逻辑分析不出异常时, 决定通过 <strong>Arthas</strong> 协助排查了。</p><p>在生产环境中, 启动了一个预发版本, 通过 url 模拟用户请求。</p><p>同时启动 Arthas, watch 对应的接口</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">watch</span> com.aaa.bbb.TestController testMethod <span class="token string">"&#123;params,returnObj,throwExp&#125;"</span> <span class="token parameter variable">-x</span> <span class="token number">4</span></code></pre><p>定位到以下异常: </p><pre class="language-log" data-language="log"><code class="language-log"><span class="token exception javastacktrace language-javastacktrace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span>HttpClientErrorException<span class="token punctuation">:</span> 400 <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span>DefaultResponseErrorHandler<span class="token punctuation">.</span><span class="token function">handleError</span><span class="token punctuation">(</span>DefaultResponseErrorHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>91<span class="token punctuation">)</span> ~[spring-web-4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE<span class="token punctuation">.</span>jar<span class="token punctuation">:</span>4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE]<span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span>RestTemplate<span class="token punctuation">.</span><span class="token function">handleResponse</span><span class="token punctuation">(</span>RestTemplate<span class="token punctuation">.</span>java<span class="token punctuation">:</span>700<span class="token punctuation">)</span> ~[spring-web-4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE<span class="token punctuation">.</span>jar<span class="token punctuation">:</span>4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE]<span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span>RestTemplate<span class="token punctuation">.</span><span class="token function">doExecute</span><span class="token punctuation">(</span>RestTemplate<span class="token punctuation">.</span>java<span class="token punctuation">:</span>653<span class="token punctuation">)</span> ~[spring-web-4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE<span class="token punctuation">.</span>jar<span class="token punctuation">:</span>4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE]<span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span>RestTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>RestTemplate<span class="token punctuation">.</span>java<span class="token punctuation">:</span>613<span class="token punctuation">)</span> ~[spring-web-4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE<span class="token punctuation">.</span>jar<span class="token punctuation">:</span>4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE]<span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span>RestTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>RestTemplate<span class="token punctuation">.</span>java<span class="token punctuation">:</span>287<span class="token punctuation">)</span> ~[spring-web-4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE<span class="token punctuation">.</span>jar<span class="token punctuation">:</span>4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE]<span class="token keyword">at</span> com<span class="token punctuation">.</span>aaa<span class="token punctuation">.</span>bbb<span class="token punctuation">.</span><span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>RemoteServiceImpl<span class="token punctuation">.</span><span class="token function">batchGetUserInfo</span><span class="token punctuation">(</span>RemoteServiceImpl<span class="token punctuation">.</span>java<span class="token punctuation">:</span>206<span class="token punctuation">)</span> ~[classes/<span class="token punctuation">:</span>?]<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span></code></pre><p>根据堆栈信息定位到代码</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">StudentVo</span><span class="token punctuation">></span></span> <span class="token function">batchGetUserInfo</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> userIds<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s/user?userIds=%s"</span><span class="token punctuation">,</span> remoteHost<span class="token punctuation">,</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>userIds<span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> returnResult <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span></code></pre><p>看逻辑没多大的异常, 唯一比较惊讶的就是 Get 请求, 入参确实是一个 <strong>List<String></strong>, 不过 Http 本身就支持这样操作。</p><p>继续通过 Arthas, watch 对应的接口, 不过这次 watch 上面的代码:</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">watch</span> com.aaa.bbb<span class="token punctuation">..</span>service.impl.RemoteServiceImpl batchGetUserInfo <span class="token string">"&#123;params,returnObj,throwExp&#125;"</span> <span class="token parameter variable">-x</span> <span class="token number">4</span></code></pre><p>继续通过 url 模拟用户请求。  </p><p>发现堆栈信息同样的 <strong>HttpClientErrorException: 400</strong> 异常, 但是通过打印的<strong>参数列表</strong>发现, 入参竟然是 123 个的 String。  </p><p>第一时间感觉到: 参数太多, 拼接的 url 太长, 导致请求失败。<br>但是转念一下, Get 请求 url 的长度限制是<strong>浏览器的行为</strong>, <strong>Http 协议没有对传输的数据大小进行限制</strong>。<br>现在是 2 个后台服务的 Http 请求, 没有经过任什么浏览器, 理论上是这个长度无限制的。</p><h3 id="2-4-Nginx-直接返回-400-错误码"><a href="#2-4-Nginx-直接返回-400-错误码" class="headerlink" title="2.4 Nginx 直接返回 400 错误码"></a>2.4 Nginx 直接返回 400 错误码</h3><p>请求  url 感觉没什么问题?<br>既然这样, 会不会是结果响应方处理有什么异常吗? </p><p>同样通过 Kibana 查看日志, 发现对应的接口, 没有当前用户的请求日志。也就是说, 对应的请求没有到达服务 A。  </p><p>不是被调用方的问题, 那么会不会是 RestTemplate 这个框架内部做了限制呢?</p><p>从 <strong>restTemplate.getForObject</strong> 出发, 进入到源码, 发现内部也是没有对 url 长度做限制的, 同时定位到抛出异常的位置如下</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultResponseErrorHandler</span> <span class="token keyword">implements</span> <span class="token class-name">ResponseErrorHandler</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleError</span><span class="token punctuation">(</span><span class="token class-name">ClientHttpResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 从响应里面获取到状态码</span>    <span class="token class-name">HttpStatus</span> statusCode <span class="token operator">=</span> <span class="token function">getHttpStatusCode</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>statusCode<span class="token punctuation">.</span><span class="token function">series</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 状态码 4xx</span>      <span class="token keyword">case</span> <span class="token constant">CLIENT_ERROR</span><span class="token operator">:</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">HttpClientErrorException</span><span class="token punctuation">(</span>statusCode<span class="token punctuation">,</span> response<span class="token punctuation">.</span><span class="token function">getStatusText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            response<span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getResponseBody</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getCharset</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 状态码 5xx</span>      <span class="token keyword">case</span> <span class="token constant">SERVER_ERROR</span><span class="token operator">:</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">HttpServerErrorException</span><span class="token punctuation">(</span>statusCode<span class="token punctuation">,</span> response<span class="token punctuation">.</span><span class="token function">getStatusText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             response<span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getResponseBody</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getCharset</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">default</span><span class="token operator">:</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RestClientException</span><span class="token punctuation">(</span><span class="token string">"Unknown status code ["</span> <span class="token operator">+</span> statusCode <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>抛出异常的结果是根据请求返回的状态码来决定的。 也就是服务 B 有发起请求, 同时收到了一个 400 的错误码, restTemplate 将其封装为一个 HttpClientErrorException。</p><p>调用方有发起请求, 被调用方没有请求日志, 2 者之间通过通过 Http 请求, 那么有问题的的地方应该就是 2 者中间的 Nginx 了。</p><h3 id="2-5-验证"><a href="#2-5-验证" class="headerlink" title="2.5 验证"></a>2.5 验证</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">StudentVo</span><span class="token punctuation">></span></span> <span class="token function">batchGetUserInfo</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> userIds<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s/user?userIds=%s"</span><span class="token punctuation">,</span> remoteHost<span class="token punctuation">,</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>userIds<span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> returnResult <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span></code></pre><p>将上面的 remoteHost 替换为一个具体的 ip 地址, 直接请求对应的容器, 绕过 Nginx。<br>重新部署, 通过 url 模拟用户请求, 正常响应。  </p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>服务 A 的请求先经过 Nginx, 再由 Nginx 转发到 B。<br>而异常的用户的请求到了 Nginx, Nginx 直接返回了 400, 从而导致用户请求异常。</p><p>通过查询资料, Nginx 报 400 的场景如下</p><blockquote><ol><li>request_uri 过长超过 nginx 配置大小</li><li>cookie 或者 header 过大超过 nginx 配置大小</li><li>空 HOST 头</li><li>content_length 和 body 长度不一致</li></ol></blockquote><p>我们遇到的情况就是第一种。<br>Nginx 处理时认为客户端请求格式错误, 于是直接返回 400, 不会向 upstream server (也就是下游服务) 转发请求, 因而 upstream server 对这些错误请求其实完全是无感知的。</p><p>至此结束。</p><p>碎碎念:<br>其实对 Http 响应码有一点了解, 结合上面获取到的请求参数太多和堆栈的信息的 400, 基本可以推导出问题了, 不用像我一样, 一步步猜测验证。<br>而本身通过这次, 对 Http 的响应码和 Nginx 也算是多了一点了解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生产记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次 MQ 堆积的解决 (并发地从数据库中查询出大量数据导致数据库繁忙最终宕机)</title>
      <link href="/article/2023/4068506469/"/>
      <url>/article/2023/4068506469/</url>
      
        <content type="html"><![CDATA[<p><strong>这次事故实际的借鉴意义不大, 只是整个解决过程比较有趣, 所以记录一下。</strong></p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>为了应对旺季的到来, 加上一些重要的接口的性能未知, 所以决定对这些接口进行压测并优化。 </p><p>但是生产和测试环境的机器性能等差距很大, 为了准确性, 所以决定在生产环境进行压测。<br>先通过特定的账号进行压测, 然后删除这批账号产生的数据, 通过这种方式得到最准确的结果。</p><h2 id="2-结论"><a href="#2-结论" class="headerlink" title="2 结论"></a>2 结论</h2><p>压测的接口中有一个的功能, 高度概括如下:  </p><blockquote><ol><li>一次 Http 请求, 会产生 n 条数据库记录, 发送出 n 条 MQ 消息</li><li>每条 MQ 消息会从数据库中查询出所有的记录, 然后处理这些记录</li></ol></blockquote><p>对这个接口进行压测时, 随着请求量的增加</p><blockquote><ol><li>数据库记录越来越多 </li><li>MQ 消费时, 查询数据库时越来越慢, 消费能力随之下降, 最终导致 MQ 堆积</li></ol></blockquote><p>发现堆积时, 在不了解具体逻辑时, 本着先解决问题再定位原因的原则, 我们选择了不断提高 MQ 消费能力, 最终导致</p><blockquote><ol><li>数据库的查询压力越来越大, 先是触发了主从切换, 然后没多久整个库还是挂了</li><li>应用这边有的卡在等待数据库响应全部数据, 有的是查询到了大量数据, 进入了 GC</li></ol></blockquote><h2 id="3-过程"><a href="#3-过程" class="headerlink" title="3 过程"></a>3 过程</h2><h3 id="3-1-反馈"><a href="#3-1-反馈" class="headerlink" title="3.1 反馈"></a>3.1 反馈</h3><p>20:00, 测试开始压测。<br>20:30, 测试说明压测结束。<br>20:35, 测试反馈生产出现 MQ 堆积。</p><p><img src="https://pic.imgdb.cn/item/6549fa6fc458853aef785a69.png" alt="Alt &#39;MQ 堆积告警图&#39;"></p><h3 id="3-2-解决"><a href="#3-2-解决" class="headerlink" title="3.2 解决"></a>3.2 解决</h3><h4 id="3-2-1-启动新的实例-先解决堆积"><a href="#3-2-1-启动新的实例-先解决堆积" class="headerlink" title="3.2.1 启动新的实例, 先解决堆积"></a>3.2.1 启动新的实例, 先解决堆积</h4><p>这种 MQ 堆积的情况, 个人习惯都会先确定一下对应的消费线程的状态, 确定是消费慢, 还是消费阻塞等原因。</p><p>进入到某个生产实例, 执行 </p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">## 获取到当前 Java 程序的进程号</span>jps <span class="token parameter variable">-l</span> <span class="token comment">## 查看 MQ 消费线程堆栈的情况, ConsumeMessageThread 是我们定义的 MQ 消费线程的名称前缀</span>jstack <span class="token number">74</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"ConsumeMessageThread"</span> <span class="token parameter variable">-C</span> <span class="token number">50</span></code></pre><p>情况如下:</p><pre class="language-log" data-language="log"><code class="language-log"><span class="token string">"ConsumeMessageThread_20"</span> <span class="token operator">#</span><span class="token number">36030</span> prio<span class="token operator">=</span><span class="token number">5</span> os_prio<span class="token operator">=</span><span class="token operator">@</span> tid<span class="token operator">=</span><span class="token number">0x00007f1648035000</span> nid<span class="token operator">=</span>®x4b59b waiting on condition <span class="token operator">(</span><span class="token number">0x00007f1c0e9f0000</span><span class="token punctuation">]</span>    java<span class="token punctuation">.</span> lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>State<span class="token operator">:</span> WAITING <span class="token operator">(</span>parking<span class="token operator">)</span>    at sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">.</span>park <span class="token operator">(</span>Native Method<span class="token operator">)</span>    <span class="token operator">-</span> parking to wait for    <span class="token operator">&lt;</span><span class="token number">0x00000000c3a23938</span><span class="token operator">></span> <span class="token operator">(</span>a java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>AbstractQueuedSynchronizer<span class="token operator">$</span>Condition0bject<span class="token operator">)</span>    at java<span class="token punctuation">.</span>til<span class="token punctuation">.</span> concurrent<span class="token punctuation">.</span> locks<span class="token punctuation">.</span> LockSupport<span class="token punctuation">.</span>park<span class="token operator">(</span>LockSupport<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">175</span><span class="token operator">)</span>    at java<span class="token punctuation">.</span>til<span class="token punctuation">.</span> concurrent<span class="token punctuation">.</span> locks<span class="token punctuation">.</span>AbstractQueuedSynchronizer<span class="token operator">$</span>Condition0bject<span class="token punctuation">.</span>await <span class="token operator">(</span>AbstractQueuedSynchronizer<span class="token punctuation">.</span> java<span class="token operator">:</span> <span class="token number">2039</span><span class="token operator">)</span>    at java<span class="token punctuation">.</span>til<span class="token punctuation">.</span> concurrent<span class="token punctuation">.</span>LinkedBlockingQueue<span class="token punctuation">.</span>take <span class="token operator">(</span>LinkedBlockingQueue<span class="token punctuation">.</span> java<span class="token operator">:</span><span class="token number">442</span><span class="token operator">)</span>    at java<span class="token punctuation">.</span>til<span class="token punctuation">.</span> concurrent<span class="token punctuation">.</span> ThreadPoolExecutor<span class="token punctuation">.</span>getTask<span class="token operator">(</span>ThreadPoolExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1074</span><span class="token operator">)</span>    at java<span class="token punctuation">.</span>til<span class="token punctuation">.</span> concurrent<span class="token punctuation">.</span> ThreadPoolExecutor<span class="token punctuation">.</span>runWorker<span class="token operator">(</span>ThreadPoolExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1134</span><span class="token operator">)</span>    at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token operator">$</span>Worker<span class="token punctuation">.</span>run<span class="token operator">(</span>ThreadPoolExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">624</span><span class="token operator">)</span>    at java<span class="token punctuation">.</span> lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>run <span class="token operator">(</span>Thread<span class="token punctuation">.</span>java<span class="token operator">:</span> <span class="token number">748</span><span class="token operator">)</span></code></pre><p>所有的消费线程都是进入 WAITING 状态, 失去了消费能力, 连续抽查了几台生产实例, 都是相同的情况。</p><p>这种全局的等待, 初步怀疑是全局锁导致的, 比如数据库等 (实际上, 这时应该是在 FullGC, 全部线程都阻塞了)。<br>本着先解决问题, 再定位原因。所以先预发起了另一个版本实例, 然后切换流量过去。  </p><p>同样通过 jstack 查看, 消费线程都是 Runnable 状态, 默认是解决了, 等消息消费完就行了, 回到旧版本, 定位原因。</p><h4 id="3-2-2-加大生产实例-提高消费能力"><a href="#3-2-2-加大生产实例-提高消费能力" class="headerlink" title="3.2.2 加大生产实例, 提高消费能力"></a>3.2.2 加大生产实例, 提高消费能力</h4><p>20:50, 运维群各种反馈 MQ 堆积。<br>通过监控平台查看, 发现 MQ 堆积加重 (应该是正常业务的消息 + 重试的消息)</p><p>通过 jstack 查看线程有的在 Runable, 有的 WAITING, 而不是一开始的 WAITING。<br>所以先将应用是实例增加, 从 10 个增加到了 16 个, 提高一些消费能力, 看看能否降下来。</p><h4 id="3-2-3-增加堆内存-防止应用-GC-overhead-limit-exceeded"><a href="#3-2-3-增加堆内存-防止应用-GC-overhead-limit-exceeded" class="headerlink" title="3.2.3 增加堆内存, 防止应用 GC overhead limit exceeded"></a>3.2.3 增加堆内存, 防止应用 GC overhead limit exceeded</h4><p>通过观察监控平台, 堆积的情况没有好转。<br>这时告警平台不断的提示应用有异常, 进入到实例的日志, 发现  </p><pre class="language-log" data-language="log"><code class="language-log"><span class="token punctuation">[</span>xxxx<span class="token operator">-</span>xx<span class="token operator">-</span>xx <span class="token time number">21:05:53.978</span><span class="token punctuation">]</span><span class="token punctuation">[</span>ConsumeMessageThread_19<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token level error important">ERROR</span><span class="token punctuation">]</span><span class="token punctuation">[</span>com<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>qqq<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>service<span class="token punctuation">.</span>TodoSubscriber<span class="token operator">:</span><span class="token number">49</span><span class="token punctuation">]</span><span class="token punctuation">[</span>ConsumeMessageThread_19raceId<span class="token punctuation">]</span> TodoSubscriber<span class="token operator">:</span>onMessage<span class="token operator">:</span><span class="token exception javastacktrace language-javastacktrace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>SerializationException<span class="token punctuation">:</span> Cannot serialize; nested exception is org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>support<span class="token punctuation">.</span>SerializationFailedException<span class="token punctuation">:</span> Failed to serialize object using DefaultSerializer; nested exception is java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>OutOfMemoryError<span class="token punctuation">:</span> GC overhead limit exceeded<span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>JdkSerializationRedisSerializer<span class="token punctuation">.</span><span class="token function">serialize</span><span class="token punctuation">(</span>JdkSerializationRedisSerializer<span class="token punctuation">.</span>java<span class="token punctuation">:</span>93<span class="token punctuation">)</span><span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>core<span class="token punctuation">.</span>AbstractOperations<span class="token punctuation">.</span><span class="token function">rawValue</span><span class="token punctuation">(</span>AbstractOperations<span class="token punctuation">.</span>java<span class="token punctuation">:</span>117<span class="token punctuation">)</span><span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>core<span class="token punctuation">.</span>DefaultValueOperations<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>DefaultValueOperations<span class="token punctuation">.</span>java<span class="token punctuation">:</span>168<span class="token punctuation">)</span><span class="token keyword">at</span> com<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>qqq<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>ProtoCacheServiceImpl<span class="token punctuation">.</span><span class="token function">addTodoIds</span><span class="token punctuation">(</span>ProtoCacheServiceImpl<span class="token punctuation">.</span>kt<span class="token punctuation">:</span>154<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Caused by<span class="token punctuation">:</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>support<span class="token punctuation">.</span>SerializationFailedException<span class="token punctuation">:</span> Failed to serialize object using DefaultSerializer; nested exception is java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>OutOfMemoryError<span class="token punctuation">:</span> GC overhead limit exceeded<span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>support<span class="token punctuation">.</span>SerializingConverter<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>SerializingConverter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>68<span class="token punctuation">)</span><span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>support<span class="token punctuation">.</span>SerializingConverter<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>SerializingConverter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>35<span class="token punctuation">)</span><span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>JdkSerializationRedisSerializer<span class="token punctuation">.</span><span class="token function">serialize</span><span class="token punctuation">(</span>JdkSerializationRedisSerializer<span class="token punctuation">.</span>java<span class="token punctuation">:</span>91<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 23 moreCaused by<span class="token punctuation">:</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>OutOfMemoryError<span class="token punctuation">:</span> GC overhead limit exceeded</span></code></pre><p>出现该问题的原因：当 GC 为释放很小空间占用大量时间时会抛出此异常 (Sun 官方对此的定义, 超过 98% 的时间用来做 GC 并且回收了不到 2% 的堆内存时会抛出此异常)。<br>一般是因为堆太小, 导致异常的原因：没有足够的内存。</p><p>查看堆内存设置为 2G (-Xmx2G, 小堆多实例的配置), 先尝试将堆内存设置为 4G (-Xmx4G), 解决上面的异常, 让应用能够继续消费。</p><h4 id="3-2-4-消费能力提高-数据库压力增大"><a href="#3-2-4-消费能力提高-数据库压力增大" class="headerlink" title="3.2.4 消费能力提高, 数据库压力增大"></a>3.2.4 消费能力提高, 数据库压力增大</h4><p>通过切版本 + 增加实例 + 增加堆内存, 一步步加大了消费能力。</p><p>然而没多久, 运维群反馈主库挂了, 从库切换为主库了。<br>通过运维反馈, 虽然切换了, 但是整个库的查询压力还是很大, 一直在 100%。  </p><p><img src="https://pic.imgdb.cn/item/6549fceac458853aef7f7ab3.png" alt="Alt &#39;数据库高负载图&#39;"></p><p>同时, 数据库中大量的 SQL 语句处于 SendingData 状态 (这个状态一般是结果集太大, 数据库服务端一直在往客户端推送数据中)。</p><p>果然没过多久, 从库也挂了。</p><h4 id="3-2-5-减少实例-删除压测数据"><a href="#3-2-5-减少实例-删除压测数据" class="headerlink" title="3.2.5 减少实例, 删除压测数据"></a>3.2.5 减少实例, 删除压测数据</h4><p>到了这一步, 继续加大消费能力已经没有意义了。消息可以先堆积, 但是数据库影响着整个应用。  </p><p>所以在重启数据库后, 立即将实例减少到 10 个。</p><p>同时从测试获取到涉及压测的用户 id, 查询情况, 一个用户就产生了近 4 万的数据。 </p><p>因为是测试数据, 直接将所有压测的用户的数据清除。   </p><p>MQ 消费一波, 就清除一波, 整个堆积的情况也随着下来。</p><h2 id="4-回顾"><a href="#4-回顾" class="headerlink" title="4 回顾"></a>4 回顾</h2><p>在 MQ 堆积时, 我们的解决方案: 逐渐的增大消费能力。<br>最终没有解决堆积, 而是导致了数据库的宕机, 应用本身也进入了 GC。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生产记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次接口大量异常的排查 (大对象强引用, 无法回收, 导致一直在 GC)</title>
      <link href="/article/2023/4219406402/"/>
      <url>/article/2023/4219406402/</url>
      
        <content type="html"><![CDATA[<h2 id="1-结论"><a href="#1-结论" class="headerlink" title="1 结论"></a>1 结论</h2><p>先说一下结论:  </p><blockquote><ol><li>有一个方法分批的从数据库中查询数据, 然后放到一个 ArrayList 中, 最后拿着这个全量数据的 ArrayList 再做其他的操作</li><li>而这次事故中, 在分批查询过程中, 查询出了大量的数据, 触发了 GC, 但因为强引用无法回收, 结果整个应用一直都在 GC</li></ol></blockquote><h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2 过程"></a>2 过程</h2><h3 id="2-1-告警"><a href="#2-1-告警" class="headerlink" title="2.1 告警"></a>2.1 告警</h3><p>下午, 运维提示线上出现了大量的 50000 告警 (响应结果里面的状态码, 50000 在我们系统中, 基本都是非业务异常)。  </p><p>登上网关日志平台, 发现的确有大量的错误:<br><img src="https://pic.imgdb.cn/item/654ccbb1c458853aef9528cb.png" alt="Alt &#39;接口异常图示&#39;"></p><h3 id="2-2-排查"><a href="#2-2-排查" class="headerlink" title="2.2 排查"></a>2.2 排查</h3><h3 id="2-2-1-接口异常直接原因"><a href="#2-2-1-接口异常直接原因" class="headerlink" title="2.2.1 接口异常直接原因"></a>2.2.1 接口异常直接原因</h3><p>通过网关请求日志发现异常基本集中在几个动态相关的接口上,  于是随机抽出一个接口, 从代码中得到对应的 Controller 和方法。</p><p>进入到 APM 平台(应用性能监控平台), 搜索对应时间范围内 + 对应的 Controller 和方法的异常日志。<br>这里也可以直接通过请求的 traceId 到应用日志平台搜索, 这种非业务异常的日志, 通常都会打印到日志中。</p><p>发现异常日志如下:   </p><p><img src="https://pic.imgdb.cn/item/654ccc28c458853aef96a4b3.png" alt="Alt &#39;报错日志图示&#39;"></p><p>大体的意思: 调用 192.168.1.2 机器上应用的 Dubbo 接口超时了。</p><h3 id="2-2-2-接口提供方超时原因定位"><a href="#2-2-2-接口提供方超时原因定位" class="headerlink" title="2.2.2 接口提供方超时原因定位"></a>2.2.2 接口提供方超时原因定位</h3><p>根据日志上的地址 + 接口找到对应的应用。  </p><p>直接进入到应用日志, 看看能找到什么信息, 发现整个日志都停在了 15:14 (也是大量告警出现的时间点), 后面没有任何的日志输出。<br>日志无收获, 只能从<strong>应用自身</strong>的入手了。</p><ol><li>先获取一下当前 Java 程序的进程 Id  <pre class="language-bash" data-language="bash"><code class="language-bash">jps <span class="token parameter variable">-l</span></code></pre></li></ol><p><img src="https://pic.imgdb.cn/item/654ccd53c458853aef9ab9e7.png" alt="Alt &#39;Jps 进程 Id&#39;">  </p><p>可以得到当前的进程 Id 为 74。</p><ol start="2"><li>通过 top, 查看一下当前机器的 CPU 情况<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">top</span></code></pre></li></ol><p><img src="https://pic.imgdb.cn/item/654ccde5c458853aef9c951c.png" alt="Alt &#39;CPU 情况&#39;"></p><p>发现当前 CPU 很高, 达到了 248, 进程 ID 为 74, 和我们应用的进程 Id 一致。</p><ol start="3"><li>进一步查看当前进程的线程情况:</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">top</span> <span class="token parameter variable">-Hp</span> 进程 Id</code></pre><p><img src="https://pic.imgdb.cn/item/65502ac6c458853aef28e815.png" alt="Alt &#39;线程资源占用情况&#39;"></p><p>发现有 4 个线程的 CPU 都很高, 其他的几乎为 0 (当时没截图, 上面的数据凭印象造的, 主要的 CPU 和 PID, 不会有很大偏差)。</p><ol start="4"><li>抽取一个线程 Id, 查看当前它的堆栈信息进行分析:</li></ol><p>因为 Java JVM 中线程 Id 是 16 进制的, 而 <strong>top -Hp</strong> 查看到的是 10 进制的, 所以需要先转转换一下</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">printf</span> <span class="token string">"%x<span class="token entity" title="\n">\n</span>"</span> 抽取的线程 Id</code></pre><p>得到线程 Id  <strong>108</strong> 对应的 16 进制 Id 为 <strong>6c</strong></p><ol start="5"><li>通过 jstack 查看当前线程的堆栈信息</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">jstack 进程 Id <span class="token operator">|</span> <span class="token function">grep</span> 上面的线程 <span class="token number">16</span> 进制 Id <span class="token parameter variable">-C</span> <span class="token number">10</span></code></pre><p><img src="https://pic.imgdb.cn/item/65502bb1c458853aef2bd995.png" alt="Alt &#39;线程的堆栈信息&#39;"></p><p>找到 <strong>nid&#x3D;</strong> 处, 发现是 gc 线程。<br>查看另外 3 个高 CPU 的线程, 发现也是 gc 线程。 </p><p>到这里, 原因基本可以确定了: <strong>当前应用一直在 GC, 导致其他线程无法调度, 从而导致了大量的接口超时。</strong></p><h3 id="2-2-3-GC-原因定位"><a href="#2-2-3-GC-原因定位" class="headerlink" title="2.2.3 GC 原因定位"></a>2.2.3 GC 原因定位</h3><p>那么为什么会一直在 GC 呢? 可以通过当前的堆栈信息进行分析。</p><ol><li>先通过 jmap 获取当前的堆栈信息</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">jmap <span class="token parameter variable">-dump:format</span><span class="token operator">=</span>b,file<span class="token operator">=</span>heapdump.hprof 进程 Id</code></pre><p>获取到堆栈信息的文件: heapdump.hprof, 将其下载到本地, 然后导入到堆栈分析工具中查看, 这里使用的是 <strong>JProfile</strong>。</p><ol start="2"><li>导入后,一进来界面的是这样的</li></ol><p><img src="https://pic.imgdb.cn/item/65502c7fc458853aef2def60.png" alt="Alt &#39;JProfile 初始界面&#39;"></p><ol start="3"><li>直接选择最大对象</li></ol><p><img src="https://pic.imgdb.cn/item/65502d09c458853aef2f4501.png" alt="Alt &#39;JProfile 大对象&#39;"></p><p>发现最大对象的前几个中, 有 2 个 ArrayList, 结合当前应用一直在 GC 中, 选择其中一个的 ArrayList, 查看里面的内容。</p><p>查看内容的步骤大体如下:<br>选中查看的对象 -&gt; 右键 -&gt; 使用选定对象</p><p><img src="https://pic.imgdb.cn/item/65502e24c458853aef3250cd.png" alt="Alt &#39;JProfile 查看大对象第一步&#39;"></p><hr><p>在弹窗中, 选择引用 -&gt; 传出引用 -&gt; 确定</p><p><img src="https://pic.imgdb.cn/item/65502ed4c458853aef340bb3.png" alt="Alt &#39;JProfile 查看大对象第二步&#39;"></p><hr><p>发现里面的内容是业务数据, 有 15 万多条数据。</p><p><img src="https://pic.imgdb.cn/item/65502f7bc458853aef35b70d.png" alt="Alt &#39;JProfile 第一个大对象 ArrayList&#39;"></p><hr><p>查看另一个 ArrayList, 发现里面的内容是也是业务的家长打卡数据, 有 4 万多条数据。</p><p><img src="https://pic.imgdb.cn/item/65503031c458853aef37bae6.png" alt="Alt &#39;JProfile 第二个大对象 ArrayList&#39;"></p><hr><p>备注:<br>下面有用户对应的操作步骤, 可以点击对应的步骤, 回到上一次操作的界面。 </p><p><img src="https://pic.imgdb.cn/item/6550308cc458853aef38a6ee.png" alt="Alt &#39;JProfile 步骤回退&#39;"></p><p>到这一步可以确定问题出在了这 2 个 ArrayList 了。<br>程序一直往这 2 个 ArrayList 里面塞数据, 内存逐渐不够用, 触发了 GC, 而 ArrayList 中的数据又无法回收。</p><ol start="3"><li>定位 ArrayList 数据产生的位置</li></ol><p>将上面的传出引用, 变为传入引用</p><p><img src="https://pic.imgdb.cn/item/65503145c458853aef3aaa29.png" alt="Alt &#39;JProfile 线程栈定位第一步&#39;"></p><p>拖到最右边, 选择显示更多</p><p><img src="https://pic.imgdb.cn/item/655031bec458853aef3c27d3.png" alt="Alt &#39;JProfile 线程栈定位第二步&#39;"></p><hr><p>这样就可以查看到堆栈信息</p><p><img src="https://pic.imgdb.cn/item/65503255c458853aef3e5626.png" alt="Alt &#39;JProfile 线程栈信息&#39;"></p><p>最终定位到实际代码位置: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>yyyy<span class="token punctuation">.</span>broadcast<span class="token punctuation">.</span>service<span class="token punctuation">.</span>api<span class="token punctuation">.</span>impl<span class="token punctuation">.</span></span>SchoolStudentArchiveServiceApiImpl</span><span class="token punctuation">.</span><span class="token function">getClassPunchAnswerWithPhoto</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span><span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token punctuation">)</span></code></pre><p>分析代码发现是一个汇总分析的方法, 里面会查询出某个时间段的全部的数据, 然后汇总分析。</p><p>解决方案: 就根据具体业务进行分析解决。 </p><p>至此, 结束。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生产记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 线上服务假死, CPU 内存正常, 什么情况</title>
      <link href="/article/2023/2603194288/"/>
      <url>/article/2023/2603194288/</url>
      
        <content type="html"><![CDATA[<p>转载信息:<br>作者: <strong>小码农叔叔</strong><br>来源: CSDN<br>原文链接: <a href="https://blog.csdn.net/zhangcongyi420/article/details/131139599">SpringBoot线上服务假死, CPU内存正常, 什么情况？</a><br>版权声明: 本文为 CSDN 博主「小码农叔叔」的原创文章, 遵循 CC 4.0 BY-SA 版权协议, 转载请附上原文出处链接及本声明。</p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>开发小伙伴都知道线上服务挂掉, 基本都是因为 CPU 或者内存不足, 出现 GC 频繁 OOM 之类的情况。本篇文章区别以上的情况给小伙伴们带来不一样的服务挂掉。<br>还记得哔哩哔哩 713 事故中那场诡计多端的 0 吗？</p><p><img src="https://pic.imgdb.cn/item/65587d1ac458853aef47a792.png" alt="Alt &#39;哔哩哔哩 713 事故原因代码&#39;"></p><p>对就是这个0, 和本次事故没关系, 但深受启发。</p><h2 id="2-问题排查"><a href="#2-问题排查" class="headerlink" title="2 问题排查"></a>2 问题排查</h2><p>老规矩在集群环境中同一个服务几个节点无响应。如不及时解决会可能形成雪崩效应。</p><p>优先查看服务日志是否有报错, 礼貌习惯性查看服务 CPU 及内存情况。先复习下, 若服务无报错。CPU 或内存出现异常, 按如下步骤排查。</p><h3 id="2-1-常规排查"><a href="#2-1-常规排查" class="headerlink" title="2.1 常规排查"></a>2.1 常规排查</h3><blockquote><p>1、 查看服务进程中线程情况</p></blockquote><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">top</span> <span class="token parameter variable">-H</span> <span class="token parameter variable">-p</span> pid或<span class="token function">ps</span> <span class="token parameter variable">-mp</span> pid <span class="token parameter variable">-o</span> THREAD,tid,time</code></pre><blockquote><p>2、 查看系统异常线程 16 进制</p></blockquote><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">printf</span> “%x<span class="token punctuation">\</span>n” nid</code></pre><blockquote><p>3、查看异常线程堆栈信息</p></blockquote><pre class="language-bash" data-language="bash"><code class="language-bash">jstack pid <span class="token operator">|</span> <span class="token function">grep</span> number</code></pre><blockquote><p>4、查看占用最大内存对象前一百</p></blockquote><pre class="language-bash" data-language="bash"><code class="language-bash">jmap <span class="token parameter variable">-histo</span> pid<span class="token operator">|</span><span class="token function">head</span> <span class="token parameter variable">-100</span></code></pre><blockquote><p>5、导出到文件</p></blockquote><pre class="language-bash" data-language="bash"><code class="language-bash">jstack <span class="token parameter variable">-l</span> PID <span class="token operator">>></span> a.log</code></pre><blockquote><p>6、或 dump 信息使用工具 Mat 或 JProfiler 查看</p></blockquote><pre class="language-bash" data-language="bash"><code class="language-bash">jmap -dump:live,format<span class="token operator">=</span>b,file<span class="token operator">=</span>/dump.bin pid</code></pre><p>经过上面一通手法操作, 足以解决此类常规报错了, 通常大多是原因各种循环递归、或数据库慢查询等。</p><h3 id="2-2-Mat-使用"><a href="#2-2-Mat-使用" class="headerlink" title="2.2 Mat 使用"></a>2.2 Mat 使用</h3><p>在 MAT 中, 会有两种大小表示：</p><blockquote><p>Shallow Size：表示对象自身占用的内存大小, 不包括它引用的对象。<br>Retained size：当前对象内存大小 + 当前对象直接或间接引用的对象大小, 全部的总和, 简单理解, 就是当前对象被 GC 后, 总共能释放的内存大小。</p></blockquote><p>Histogram 视图<br><strong>以 Class Name 为维度, 分别展示各个类的对象数量。它默认是以 byte 为单位的</strong></p><p><img src="https://pic.imgdb.cn/item/65587d1ec458853aef47b3ba.png" alt="Alt &#39;MAT Histogram 图&#39;"></p><p>要显示让单位展示出来, 点击 Window -&gt; Preferences 选择最后一项, 点击 Apply and Close。</p><p><img src="https://pic.imgdb.cn/item/65587d20c458853aef47b9ea.png" alt="Alt &#39;MAT Histogram 显示单位配置界面&#39;"></p><p>再重新打开 Histogram 视图, 就会生效了。</p><p>Leak Suspects<br><strong>报表很直观地展现了一个饼图, 图中颜色深的部分表示可能存在内存泄漏的嫌疑。</strong></p><p>通过这个指标可以快速定位内存泄漏地方出现在哪个类方法里的哪行代码。</p><h3 id="2-3-本次问题排查"><a href="#2-3-本次问题排查" class="headerlink" title="2.3 本次问题排查"></a>2.3 本次问题排查</h3><blockquote><p>1、 信息收集分析</p></blockquote><p>因服务健康监测无响应, CPU 及内存情况正常, 直接查看堆栈信息, 看看线程都在干什么</p><pre class="language-bash" data-language="bash"><code class="language-bash">jstack <span class="token parameter variable">-l</span> PID <span class="token operator">>></span> a.log</code></pre><p>Jstack 的输出中, Java 线程状态主要是以下几种: </p><ul><li>RUNNABLE 线程运行中或 I&#x2F;O 等待</li><li>BLOCKED 线程在等待 monitor 锁 (synchronized 关键字)</li><li>TIMED_WAITING 线程在等待唤醒, 但设置了时限</li><li>WAITING 线程在无限等待唤醒</li></ul><p>发现都是 WAITING 线程。</p><pre class="language-log" data-language="log"><code class="language-log"><span class="token string">"http-nio-8888-exec-6666"</span> <span class="token operator">#</span><span class="token number">8833</span> daemon prio<span class="token operator">=</span><span class="token number">5</span> os_prio<span class="token operator">=</span><span class="token number">0</span> tid<span class="token operator">=</span><span class="token number">0x00001f2f0016e100</span> nid<span class="token operator">=</span><span class="token number">0x667d</span> waiting on condition <span class="token punctuation">[</span><span class="token number">0x00002f1de3c5200</span><span class="token punctuation">]</span><span class="token property">java.lang.Thread.State:</span> WAITING <span class="token operator">(</span>parking<span class="token operator">)</span>at sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">.</span>park<span class="token operator">(</span>Native Method<span class="token operator">)</span><span class="token operator">-</span> parking to wait for  <span class="token operator">&lt;</span><span class="token number">0x00000007156a29c8</span><span class="token operator">></span> <span class="token operator">(</span>a java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>AbstractQueuedSynchronizer<span class="token operator">$</span>ConditionObject<span class="token operator">)</span>at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>LockSupport<span class="token punctuation">.</span>park<span class="token operator">(</span>LockSupport<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">175</span><span class="token operator">)</span>at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>AbstractQueuedSynchronizer<span class="token operator">$</span>ConditionObject<span class="token punctuation">.</span>await<span class="token operator">(</span>AbstractQueuedSynchronizer<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">2039</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>DruidDataSource<span class="token punctuation">.</span>takeLast<span class="token operator">(</span>DruidDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1897</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>DruidDataSource<span class="token punctuation">.</span>getConnectionInternal<span class="token operator">(</span>DruidDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1458</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>DruidDataSource<span class="token punctuation">.</span>getConnectionDirect<span class="token operator">(</span>DruidDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1253</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>FilterChainImpl<span class="token punctuation">.</span>dataSource_connect<span class="token operator">(</span>FilterChainImpl<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">4619</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>stat<span class="token punctuation">.</span>StatFilter<span class="token punctuation">.</span>dataSource_getConnection<span class="token operator">(</span>StatFilter<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">680</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>FilterChainImpl<span class="token punctuation">.</span>dataSource_connect<span class="token operator">(</span>FilterChainImpl<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">4615</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>DruidDataSource<span class="token punctuation">.</span>getConnection<span class="token operator">(</span>DruidDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1231</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>DruidDataSource<span class="token punctuation">.</span>getConnection<span class="token operator">(</span>DruidDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1223</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>DruidDataSource<span class="token punctuation">.</span>getConnection<span class="token operator">(</span>DruidDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">90</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>dynamic<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>ds<span class="token punctuation">.</span>ItemDataSource<span class="token punctuation">.</span>getConnection<span class="token operator">(</span>ItemDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">56</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>dynamic<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>ds<span class="token punctuation">.</span>AbstractRoutingDataSource<span class="token punctuation">.</span>getConnection<span class="token operator">(</span>AbstractRoutingDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">48</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>DataSourceUtils<span class="token punctuation">.</span>doGetConnection<span class="token operator">(</span>DataSourceUtils<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">111</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>DataSourceUtils<span class="token punctuation">.</span>getConnection<span class="token operator">(</span>DataSourceUtils<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">77</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>mybatis<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span>SpringManagedTransaction<span class="token punctuation">.</span>openConnection<span class="token operator">(</span>SpringManagedTransaction<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">82</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>mybatis<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span>SpringManagedTransaction<span class="token punctuation">.</span>getConnection<span class="token operator">(</span>SpringManagedTransaction<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">68</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>BaseExecutor<span class="token punctuation">.</span>getConnection<span class="token operator">(</span>BaseExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">336</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>SimpleExecutor<span class="token punctuation">.</span>prepareStatement<span class="token operator">(</span>SimpleExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">84</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>SimpleExecutor<span class="token punctuation">.</span>doQuery<span class="token operator">(</span>SimpleExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">62</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>BaseExecutor<span class="token punctuation">.</span>queryFromDatabase<span class="token operator">(</span>BaseExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">324</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>BaseExecutor<span class="token punctuation">.</span>query<span class="token operator">(</span>BaseExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">156</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>CachingExecutor<span class="token punctuation">.</span>query<span class="token operator">(</span>CachingExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">109</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>github<span class="token punctuation">.</span>pagehelper<span class="token punctuation">.</span>PageInterceptor<span class="token punctuation">.</span>intercept<span class="token operator">(</span>PageInterceptor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">143</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>plugin<span class="token punctuation">.</span>Plugin<span class="token punctuation">.</span>invoke<span class="token operator">(</span>Plugin<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">61</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span><span class="token operator">$</span>Proxy571<span class="token punctuation">.</span>query<span class="token operator">(</span>Unknown Source<span class="token operator">)</span></code></pre><blockquote><p>2、定位关键信息, 追踪源代码</p></blockquote><pre class="language-log" data-language="log"><code class="language-log">at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>AbstractQueuedSynchronizer<span class="token operator">$</span>ConditionObject<span class="token punctuation">.</span>await<span class="token operator">(</span>AbstractQueuedSynchronizer<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">2039</span><span class="token operator">)</span>  at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>DruidDataSource<span class="token punctuation">.</span>takeLast<span class="token operator">(</span>DruidDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1897</span><span class="token operator">)</span></code></pre><pre class="language-Java" data-language="Java"><code class="language-Java">DruidConnectionHolder takeLast() throws InterruptedException, SQLException &#123;try &#123;   while (poolingCount &#x3D;&#x3D; 0) &#123;      emptySignal(); &#x2F;&#x2F; send signal to CreateThread create connection              if (failFast &amp;&amp; isFailContinuous()) &#123;                  throw new DataSourceNotAvailableException(createError);              &#125;              notEmptyWaitThreadCount++;              if (notEmptyWaitThreadCount &gt; notEmptyWaitThreadPeak) &#123;                  notEmptyWaitThreadPeak &#x3D; notEmptyWaitThreadCount;              &#125;              try &#123;                  &#x2F;&#x2F; 数据库的连接都没有释放且被占用, 连接池中无可用连接, 导致请求被阻塞                  notEmpty.await(); &#x2F;&#x2F; signal by recycle or creator              &#125; finally &#123;                  notEmptyWaitThreadCount--;              &#125;              notEmptyWaitCount++;              if (!enable) &#123;                  connectErrorCountUpdater.incrementAndGet(this);                  throw new DataSourceDisableException();              &#125;          &#125;      &#125; catch (InterruptedException ie) &#123;          notEmpty.signal(); &#x2F;&#x2F; propagate to non-interrupted thread          notEmptySignalCount++;          throw ie;      &#125;      decrementPoolingCount();      DruidConnectionHolder last &#x3D; connections[poolingCount];      connections[poolingCount] &#x3D; null;      return last;&#125;</code></pre><p>结合日志报错定位到问题代码。因报错可用连接没有正常释放, 导致一直 await 卡死。</p><p>问题代码如下:</p><pre class="language-Java" data-language="Java"><code class="language-Java">try &#123;  SqlSession sqlSession &#x3D; sqlSessionFactory.openSession(ExecutorType.BATCH);  TestMapper mapper &#x3D; sqlSession.getMapper(TestMapper.class);  mapper.insetList(list);  sqlSession.flushStatements();&#125; catch (Exception e) &#123;   e.printStackTrace();&#125;</code></pre><h2 id="3-问题复现"><a href="#3-问题复现" class="headerlink" title="3 问题复现"></a>3 问题复现</h2><p>按照以上信息在多活环境复现。因线程被打满且都在等待导致监控检查无响应。  </p><p>Tomcat 线程被打满: </p><p><img src="https://pic.imgdb.cn/item/65587d22c458853aef47c101.png" alt="Alt &#39;Tomcat 线程池打满情况&#39;"></p><p>Tomcat 默认参数: </p><pre class="language-config" data-language="config"><code class="language-config">server.tomcat.max-threads&#x3D;200</code></pre><p>最大连接数默认是 10000</p><pre class="language-config" data-language="config"><code class="language-config">server.tomcat.max-connections&#x3D;10000</code></pre><p>等待队列长度, 默认 100。</p><pre class="language-config" data-language="config"><code class="language-config">server.tomcat.accept-count&#x3D;100</code></pre><p>最小工作空闲线程数, 默认 10。</p><pre class="language-config" data-language="config"><code class="language-config">server.tomcat.min-spare-threads&#x3D;100</code></pre><p>Druid 连接池的默认参数如下: </p><p><img src="https://pic.imgdb.cn/item/65587d29c458853aef47db45.png" alt="Alt &#39;Druid 连接池配置情况&#39;"></p><p>Druid 连接池的配置参数如下: </p><table><thead><tr><th align="center">属性</th><th align="center">说明</th><th align="center">建议值</th></tr></thead><tbody><tr><td align="center">username</td><td align="center">登录数据库的用户名</td><td align="center"></td></tr><tr><td align="center">password</td><td align="center">登录数据库的用户密码</td><td align="center"></td></tr><tr><td align="center">initialSize</td><td align="center">默认 0, 启动程序时, 在连接池中初始化多少个连接</td><td align="center">10-50 足够</td></tr><tr><td align="center">maxActive</td><td align="center">默认 8, 连接池中最多支持多少个活动会话</td><td align="center"></td></tr><tr><td align="center">maxWait</td><td align="center">默认 -1, 程序向连接池中请求连接时, 超过 maxWait 的值后, 认为本次请求失败, 即连接池, 没有可用连接, 单位毫秒, 设置 -1 时表示无限等待</td><td align="center">100</td></tr><tr><td align="center">minEvictableldleTimeMillis</td><td align="center">池中某个连接的空闲时长达到 N 毫秒后, 连接池在下次检查空闲连接时, 将回收该连接, 要小于防火墙超时设置 net.netflter.nf_conntrack_tcp_timeout_established</td><td align="center">见说明部分</td></tr><tr><td align="center">timeBetweenEvictionRunsMillis</td><td align="center">检查空闲连接的频率, 单位毫秒, 非正整数时表示不进行检查</td><td align="center"></td></tr><tr><td align="center">keepAlive</td><td align="center">程序没有 close 连接且空闲时长超过 minEvictableldleTimeMillis, 则会执, 行validationQuery 指定的 SQL, 以保证该程序连接不会池 kill 掉, 其范围不超过 minldle 指定的连接个数</td><td align="center">true</td></tr><tr><td align="center">minidle</td><td align="center">默认 8, 回收空闲连接时, 将保证至少有 minldle 个连接</td><td align="center">与 initialSize 相同</td></tr><tr><td align="center">removeAbandoned</td><td align="center">要求程序从池中 get 到连接后, N 秒后必须 close, 否则 druid 会强制回收该连接, 不管该连接中是活动还是空闲, 以防止进程不会进行 close 而霸占连接</td><td align="center">false, 当发现程序有未正常 close 连接时设置为 true</td></tr><tr><td align="center">removeAbandonedTimeout</td><td align="center">设置 druid 强制回收连接的时限, 当程序从池中 get 到连接开始算起, 超过此值后, druid 将强制回收该连接, 单位秒</td><td align="center">应大于业务运行最长时间</td></tr><tr><td align="center">logAbandoned</td><td align="center">当 druid 强制回收连接后, 是否将 stack trace 记录到日志中</td><td align="center">true</td></tr><tr><td align="center">testWhileldle</td><td align="center">当程序请求连接, 池在分配连接时, 是否先检查该连接是否有效。（高效）</td><td align="center">true</td></tr><tr><td align="center">validationQuery</td><td align="center">检查池中的连接是否仍可用的 SQL 语句, druid 会连接到数据库执行该 SQL, 如果正常返回, 则表示连接可用, 否则表示连接不可用</td><td align="center"></td></tr><tr><td align="center">testOnBorrow</td><td align="center">程序申请连接时, 进行连接有效性检查（低效, 影响性能）</td><td align="center">false</td></tr><tr><td align="center">testOnReturn</td><td align="center">程序返还连接时, 进行连接有效性检查（低效, 影响性能）</td><td align="center">false</td></tr><tr><td align="center">poolPreparedStatements</td><td align="center">缓存通过以下两个方法发起的 SQL: public PreparedStatement prepareStatement(String sql) 和 public PreparedStatement prepareStatement（String sql, int resultSetType, int resultSetConcurrency）</td><td align="center">true</td></tr><tr><td align="center">maxPoolPrepareStatementPerConnectionSize</td><td align="center">每个连接最多缓存多少个 SQL</td><td align="center">20</td></tr><tr><td align="center">filters</td><td align="center">这里配置的是插件, 常用的插件有: 监控统计: flter: stat, 日志监控: flter: log4j 或者 slf4j, 防御 SQL 注入: flter: wall</td><td align="center">stat, wall, slf4j</td></tr><tr><td align="center">connectProperties</td><td align="center">连接属性。比如设置一些连接池統计方面的配置。druid.stat.mergeSql&#x3D;true;druid.stat.slowSqIMillis&#x3D;5000 比如设置一些数据库连接庽性</td><td align="center"></td></tr></tbody></table><h2 id="4-解决"><a href="#4-解决" class="headerlink" title="4 解决"></a>4 解决</h2><blockquote><p>1、Druid 连接池的配置超时参数</p></blockquote><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>   <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>    <span class="token key atrule">password</span><span class="token punctuation">:</span>   <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">druid</span><span class="token punctuation">:</span>      <span class="token key atrule">stat-view-servlet</span><span class="token punctuation">:</span>        <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>        <span class="token key atrule">loginUsername</span><span class="token punctuation">:</span> admin        <span class="token key atrule">loginPassword</span><span class="token punctuation">:</span> <span class="token number">123456</span>    <span class="token key atrule">dynamic</span><span class="token punctuation">:</span>      <span class="token key atrule">druid</span><span class="token punctuation">:</span>        <span class="token key atrule">initial-size</span><span class="token punctuation">:</span> <span class="token number">5</span>        <span class="token key atrule">min-idle</span><span class="token punctuation">:</span> <span class="token number">5</span>        <span class="token key atrule">maxActive</span><span class="token punctuation">:</span> <span class="token number">20</span>        <span class="token key atrule">maxWait</span><span class="token punctuation">:</span> <span class="token number">60000</span>        <span class="token key atrule">timeBetweenEvictionRunsMillis</span><span class="token punctuation">:</span> <span class="token number">60000</span>        <span class="token key atrule">minEvictableIdleTimeMillis</span><span class="token punctuation">:</span> <span class="token number">300000</span>        <span class="token key atrule">validationQuery</span><span class="token punctuation">:</span> SELECT 1 FROM DUAL        <span class="token key atrule">testWhileIdle</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>        <span class="token key atrule">testOnBorrow</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>        <span class="token key atrule">testOnReturn</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>        <span class="token key atrule">poolPreparedStatements</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>        <span class="token key atrule">maxPoolPreparedStatementPerConnectionSize</span><span class="token punctuation">:</span> <span class="token number">20</span>        <span class="token key atrule">filters</span><span class="token punctuation">:</span> stat<span class="token punctuation">,</span>slf4j<span class="token punctuation">,</span>wall        <span class="token key atrule">connectionProperties</span><span class="token punctuation">:</span> druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000</code></pre><blockquote><p>2、异常及时关闭连接</p></blockquote><pre class="language-Java" data-language="Java"><code class="language-Java">sqlSession.close();</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 生产记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java.io.IOError: java.io.FileNotFoundException: Invalid file path 的问题定位</title>
      <link href="/article/2023/1066841748/"/>
      <url>/article/2023/1066841748/</url>
      
        <content type="html"><![CDATA[<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1 环境"></a>1 环境</h2><table><thead><tr><th align="center">环境</th><th align="center">版本</th></tr></thead><tbody><tr><td align="center">OS</td><td align="center">window 10</td></tr><tr><td align="center">jdk</td><td align="center">JDK-8u331</td></tr><tr><td align="center">SpringBoot</td><td align="center">2.0.0.RELEASE</td></tr></tbody></table><h2 id="2-现象"><a href="#2-现象" class="headerlink" title="2 现象"></a>2 现象</h2><p>一个 SpringBoot 的项目, 使用了 undertown 作为 web 容器的项目。<br>项目启动成功后, 第一次发起 http 请求接口, 任意一个接口都可以, 会直接抛出如下异常:<br><strong>nested exception is java.io.IOError: java.io.FileNotFoundException: Invalid file path</strong>  </p><pre class="language-log" data-language="log"><code class="language-log"><span class="token exception javastacktrace language-javastacktrace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>util<span class="token punctuation">.</span>NestedServletException<span class="token punctuation">:</span> Handler dispatch failed; nested exception is java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOError<span class="token punctuation">:</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileNotFoundException<span class="token punctuation">:</span> Invalid file path <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>DispatcherServlet<span class="token punctuation">.</span><span class="token function">doDispatch</span><span class="token punctuation">(</span>DispatcherServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>982<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>DispatcherServlet<span class="token punctuation">.</span><span class="token function">doService</span><span class="token punctuation">(</span>DispatcherServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>901<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>FrameworkServlet<span class="token punctuation">.</span><span class="token function">processRequest</span><span class="token punctuation">(</span>FrameworkServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>970<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>FrameworkServlet<span class="token punctuation">.</span><span class="token function">doPost</span><span class="token punctuation">(</span>FrameworkServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>872<span class="token punctuation">)</span> <span class="token keyword">at</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServlet<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>HttpServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>707<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>FrameworkServlet<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>FrameworkServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>846<span class="token punctuation">)</span> <span class="token keyword">at</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServlet<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>HttpServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>790<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>85<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>129<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>ApplicationContextHeaderFilter<span class="token punctuation">.</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>ApplicationContextHeaderFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>55<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>OncePerRequestFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>OncePerRequestFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>107<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>actuate<span class="token punctuation">.</span>trace<span class="token punctuation">.</span>WebRequestTraceFilter<span class="token punctuation">.</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>WebRequestTraceFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>110<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>OncePerRequestFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>OncePerRequestFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>107<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> com<span class="token punctuation">.</span>lcn29<span class="token punctuation">.</span>framework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>CustomTraceFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>CustomTraceFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>116<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> com<span class="token punctuation">.</span>lcn29<span class="token punctuation">.</span>framework<span class="token punctuation">.</span>tracer<span class="token punctuation">.</span>sofa<span class="token punctuation">.</span>springmvc<span class="token punctuation">.</span>SpringMvcSofaTracerFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>SpringMvcSofaTracerFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>153<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>CharacterEncodingFilter<span class="token punctuation">.</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>CharacterEncodingFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>197<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>OncePerRequestFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>OncePerRequestFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>107<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>actuate<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>MetricsFilter<span class="token punctuation">.</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>MetricsFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>106<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>OncePerRequestFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>OncePerRequestFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>107<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>84<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>ServletSecurityRoleHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletSecurityRoleHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>62<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletDispatchingHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletDispatchingHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>36<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>SSLInformationAssociationHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>SSLInformationAssociationHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>ServletAuthenticationCallHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletAuthenticationCallHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>57<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>PredicateHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>PredicateHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>security<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>AbstractConfidentialityHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>AbstractConfidentialityHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>46<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>ServletConfidentialityConstraintHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletConfidentialityConstraintHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>64<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>security<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>AuthenticationMechanismsHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>AuthenticationMechanismsHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>60<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>CachedAuthenticatedSessionHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>CachedAuthenticatedSessionHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>77<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>security<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>AbstractSecurityContextAssociationHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>AbstractSecurityContextAssociationHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>PredicateHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>PredicateHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>PredicateHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>PredicateHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler<span class="token punctuation">.</span><span class="token function">handleFirstRequest</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>292<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler<span class="token punctuation">.</span><span class="token function">access$100</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>81<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler$2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>138<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler$2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>135<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ServletRequestContextThreadSetupAction$1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ServletRequestContextThreadSetupAction<span class="token punctuation">.</span>java<span class="token punctuation">:</span>48<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ContextClassLoaderSetupAction$1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ContextClassLoaderSetupAction<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler<span class="token punctuation">.</span><span class="token function">dispatchRequest</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>272<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler<span class="token punctuation">.</span><span class="token function">access$000</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>81<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler$1<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>104<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>Connectors<span class="token punctuation">.</span><span class="token function">executeRootHandler</span><span class="token punctuation">(</span>Connectors<span class="token punctuation">.</span>java<span class="token punctuation">:</span>211<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>HttpServerExchange$1<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>HttpServerExchange<span class="token punctuation">.</span>java<span class="token punctuation">:</span>809<span class="token punctuation">)</span> <span class="token keyword">at</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">runWorker</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span> <span class="token keyword">at</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor$Worker<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span> <span class="token keyword">at</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span></span></code></pre><p>后续无论发送多少次请求, 则都是抛出另一个异常:<br><strong>nested exception is java.lang.NoClassDefFoundError: Could not initialize class org.xnio.channels.Channels</strong></p><pre class="language-log" data-language="log"><code class="language-log"><span class="token exception javastacktrace language-javastacktrace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>util<span class="token punctuation">.</span>NestedServletException<span class="token punctuation">:</span> Handler dispatch failed; nested exception is java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>NoClassDefFoundError<span class="token punctuation">:</span> Could not initialize class org<span class="token punctuation">.</span>xnio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>Channels <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>DispatcherServlet<span class="token punctuation">.</span><span class="token function">doDispatch</span><span class="token punctuation">(</span>DispatcherServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>982<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>DispatcherServlet<span class="token punctuation">.</span><span class="token function">doService</span><span class="token punctuation">(</span>DispatcherServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>901<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>FrameworkServlet<span class="token punctuation">.</span><span class="token function">processRequest</span><span class="token punctuation">(</span>FrameworkServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>970<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>FrameworkServlet<span class="token punctuation">.</span><span class="token function">doPost</span><span class="token punctuation">(</span>FrameworkServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>872<span class="token punctuation">)</span> <span class="token keyword">at</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServlet<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>HttpServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>707<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>FrameworkServlet<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>FrameworkServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>846<span class="token punctuation">)</span> <span class="token keyword">at</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServlet<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>HttpServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>790<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>85<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>129<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>ApplicationContextHeaderFilter<span class="token punctuation">.</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>ApplicationContextHeaderFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>55<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>OncePerRequestFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>OncePerRequestFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>107<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>actuate<span class="token punctuation">.</span>trace<span class="token punctuation">.</span>WebRequestTraceFilter<span class="token punctuation">.</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>WebRequestTraceFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>110<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>OncePerRequestFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>OncePerRequestFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>107<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> com<span class="token punctuation">.</span>lcn29<span class="token punctuation">.</span>framework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>CustomTraceFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>CustomTraceFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>116<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> com<span class="token punctuation">.</span>lcn29<span class="token punctuation">.</span>framework<span class="token punctuation">.</span>tracer<span class="token punctuation">.</span>sofa<span class="token punctuation">.</span>springmvc<span class="token punctuation">.</span>SpringMvcSofaTracerFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>SpringMvcSofaTracerFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>153<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>CharacterEncodingFilter<span class="token punctuation">.</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>CharacterEncodingFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>197<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>OncePerRequestFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>OncePerRequestFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>107<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>actuate<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>MetricsFilter<span class="token punctuation">.</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>MetricsFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>106<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>OncePerRequestFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>OncePerRequestFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>107<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>84<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>ServletSecurityRoleHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletSecurityRoleHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>62<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletDispatchingHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletDispatchingHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>36<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>SSLInformationAssociationHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>SSLInformationAssociationHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>ServletAuthenticationCallHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletAuthenticationCallHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>57<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>PredicateHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>PredicateHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>security<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>AbstractConfidentialityHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>AbstractConfidentialityHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>46<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>ServletConfidentialityConstraintHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletConfidentialityConstraintHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>64<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>security<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>AuthenticationMechanismsHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>AuthenticationMechanismsHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>60<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>CachedAuthenticatedSessionHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>CachedAuthenticatedSessionHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>77<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>security<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>AbstractSecurityContextAssociationHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>AbstractSecurityContextAssociationHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>PredicateHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>PredicateHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>PredicateHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>PredicateHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler<span class="token punctuation">.</span><span class="token function">handleFirstRequest</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>292<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler<span class="token punctuation">.</span><span class="token function">access$100</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>81<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler$2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>138<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler$2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>135<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ServletRequestContextThreadSetupAction$1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ServletRequestContextThreadSetupAction<span class="token punctuation">.</span>java<span class="token punctuation">:</span>48<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ContextClassLoaderSetupAction$1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ContextClassLoaderSetupAction<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler<span class="token punctuation">.</span><span class="token function">dispatchRequest</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>272<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler<span class="token punctuation">.</span><span class="token function">access$000</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>81<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler$1<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>104<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>Connectors<span class="token punctuation">.</span><span class="token function">executeRootHandler</span><span class="token punctuation">(</span>Connectors<span class="token punctuation">.</span>java<span class="token punctuation">:</span>211<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>HttpServerExchange$1<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>HttpServerExchange<span class="token punctuation">.</span>java<span class="token punctuation">:</span>809<span class="token punctuation">)</span> <span class="token keyword">at</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">runWorker</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span> <span class="token keyword">at</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor$Worker<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span> <span class="token keyword">at</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span></span></code></pre><p>这里面有 2 个问题</p><blockquote><ol><li>请求进来后, 为什么会导致异常</li><li>第一次异常为 FileNotFoundException, 第二次及后续相同的请求, 抛出的则是 NoClassDefFoundError, 2 种不同的异常, 第一次特殊了</li></ol></blockquote><h2 id="3-第一个问题"><a href="#3-第一个问题" class="headerlink" title="3 第一个问题"></a>3 第一个问题</h2><p>通过异常日志定位到出现异常的地方为</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Conduits</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token constant">NULL_FILE_CHANNEL</span> <span class="token operator">=</span> <span class="token class-name">AccessController</span><span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">FileChannel</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">public</span> <span class="token class-name">FileChannel</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">final</span> <span class="token class-name">String</span> osName <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"os.name"</span><span class="token punctuation">,</span> <span class="token string">"unknown"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token class-name">Locale</span><span class="token punctuation">.</span><span class="token constant">US</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>osName<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"windows"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 抛出异常的位置</span>                        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"NUL:"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"/dev/null"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IOError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>抛出异常的位置 new FileOutputStream(“NUL:”).getChannel()。 这一行代码, 大体的逻辑为: 在 windows 系统中, 打开 NUL: 这个文件, 获取到其通道。<br>经过查询, 这里的 NUL:, 所在的文件路径为 C:\Windows\System32\drivers\null.sys。</p><pre class="language-log" data-language="log"><code class="language-log"><span class="token domain constant">null.sys</span> 文件的作用<span class="token operator">:</span> It allows a user to trivially throw away program output<span class="token punctuation">,</span> or to supply empty input<span class="token punctuation">.</span> 和 Linux 的 <span class="token file-path string">/dev/null作用类似</span><span class="token punctuation">,</span> 可以接收任意的输入<span class="token punctuation">,</span> 不产生输出。Linux 中经常将一下无用的日志都指向这个位置<span class="token operator">!</span></code></pre><p>初步怀疑是 <strong>null.sys</strong> 这个文件有异常, 从网上下载了一个正常的, 进行替换后, 还是同样的问题, 也就是 <strong>null.sys</strong> 文件正常。<br>排除是 null.sys 文件的问题后。 猜测是否为 new FileOutput(“NUL:”), JDK 在实现上有问题。</p><p>最终在 StackOverflow 的 <a href="https://stackoverflow.com/questions/71966064/java-fileoutputstreamnul-not-working-after-java-upgrade">“Java: FileOutputStream(“NUL:”) not working after Java upgrade “</a> 这篇文章中找到了问题的解决方案。  </p><p>同时顺藤摸瓜定位到官网中, 找到了问题所在, 的确是 JDK-8u331 这个版本的一个 bug。<br>bug 详情可以看这里 <a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8285445">“JDK-8285445 : cannot open file “NUL:””</a></p><p>总结一下,  JDK-8u331 中尝试避免去访问 ADS (alternate data streams), 而在代码实现上同时造成了 JDK 对设备文件的访问受阻。</p><p>解决方案:</p><blockquote><ol><li>在系统属性中添加 jdk.io.File.enableADS, 值为 false, 停用这个新特性即可</li><li>JDK-8u333 会对这种情况进行修复, 也就是更换 JDK 版本</li></ol></blockquote><p>到此第一个问题解决了。</p><h2 id="4-第二个问题"><a href="#4-第二个问题" class="headerlink" title="4 第二个问题"></a>4 第二个问题</h2><p>第二个问题, 为什么第二次及后面报的异常会和第一次的不同。</p><p>在上面的流程中, 2 次请求出现不同的异常:</p><blockquote><p>第一次请求抛出的是 FileNotFoundException<br>第二次后的所有请求抛出的是 NoClassDefFoundError</p></blockquote><p>NoClassDefFoundError 异常可以简单的理解为 Java 编译期能够找得到对应的 Class, 而到了运行时, 找不到合适的 Class。<br>抛出这个异常的线程会直接被停止, 即使 try-catch 住了异常, 线程也会被终止掉。</p><p>导致 NoClassDefFoundError 的原因有总的来说有 2 种</p><blockquote><ol><li>运行中找不到对应的类 (可能是 classpath 中没有这个 class, 存在多个类加载器等情况), 抛出的异常一般为 java.lang.NoClassDefFoundError: 没有找到的类的路径</li><li>类加载中初始化失败, 即 class 的 ＜clinit＞(), 也就是类的静态属性和静态代码出现了异常, 抛出的异常一般为 NoClassDefFoundError: Could not initialize class 类的路径</li></ol></blockquote><p>前者是真的在运行中没有找到这个类, 后者是加载类失败。</p><p>结合上面出现异常的位置的代码, 可以很快的知道第二次及后续出现的异常是因为第一次加载 Conduits 类执行其静态代码块失败了, 后续加载这个 Conduits 类, 直接不加载, 抛出 NoClasseDefFoundError 这个异常了</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><a href="https://segmentfault.com/a/1190000023381403">java.io.FileNotFoundException: NUL: (系统找不到指定的文件。)</a><br><a href="http://leybreeze.com/blog/?p=77885">Java 运行时发生 NoClassDefFoundError: Could not initialize class 的解决方法</a><br><a href="https://stackoverflow.com/questions/71966064/java-fileoutputstreamnul-not-working-after-java-upgrade">Java: FileOutputStream(“NUL:”) not working after Java upgrade</a><br><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8285445">JDK-8285445 : cannot open file “NUL:”</a>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 开发问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何计算 MySQL 单表中能存放多少条数据</title>
      <link href="/article/2022/277668067/"/>
      <url>/article/2022/277668067/</url>
      
        <content type="html"><![CDATA[<p>转载信息:<br>作者: <strong>敲代码的小小酥</strong><br>来源: CSDN<br>原文链接: <a href="https://blog.csdn.net/qq1309664161/article/details/124032981">如何计算Mysql单表中能存放多少条数据</a><br>版权声明: 本文为 CSDN 博主「敲代码的小小酥」的原创文章, 遵循 CC 4.0 BY-SA 版权协议, 转载请附上原文出处链接及本声明。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>常听有人说, MySQL 数据库单张表的数据, 最多不要超过千万级别, 否则需要分表处理。那这个结论是如何来的呢, 是否正确呢？今天来探讨一番。</p><h2 id="一、页的结构"><a href="#一、页的结构" class="headerlink" title="一、页的结构"></a>一、页的结构</h2><p>前面讲过, Mysql在读取数据时, 是一页一页的读数据, 称之为预读。那页的结构到底是怎样的呢？<br>MySQL 表中的数据, 在硬盘上存成了 .ibd文件, 这个文件, 专业名词叫表空间。 在 .ibd 文件的内部, 把表数据分成了很多份的数据页, 每份大小 16k。类似于下图所示: </p><p><img src="https://pic.imgdb.cn/item/655039d0c458853aef539a12.png" alt="Alt &#39;MySQL 数据页&#39;"></p><p>每页中, 不仅只有表数据, 还有一些其他信息, 具体如下: </p><p><img src="https://pic.imgdb.cn/item/65503acec458853aef565544.png" alt="Alt &#39;MySQL 数据页结构&#39;"></p><p>页头: 页头占120字节大小, 里面包括页号(ibd文件里的偏移量), 指针(指向前一页和后一页)等信息。<br>页尾: 页尾占8字节, 包含校验码等信息。<br>页目录: 行数据太多的话, 进入每页中, 挨个遍历, 效率也不高, 页目录是提高页内数据搜索的效率。<br>剩下的就是表数据的区域。  </p><h2 id="二、B-tree-索引与页"><a href="#二、B-tree-索引与页" class="headerlink" title="二、B+tree 索引与页"></a>二、B+tree 索引与页</h2><p>MySQL 索引也是一个文件, 在索引文件的内部, 也会按页, 进行数据的切分。<br>每页的大小固定都是 16k。以主键索引为例, 在主键索引中, 非叶子节点, 只存放了数据的主键 id, 不存放数据的其他信息。<br>因此, 在非叶子节点的每个页中, 就能存放更多的索引信息。<br>因为索引是树形结构, 所以在非叶子节点的页中, 还会有指向下级节点的指针, 专业名词叫扇出。<br>B+tree 索引每个非叶子都扇出到下一级节点, 直到叶子节点的页中。 </p><p>叶子节点的页里, 存放的就是完整的行数据了 (仅针对主键索引, 二级索引叶子节点是索引列+id)。</p><p>如下图所示：<br><img src="https://pic.imgdb.cn/item/65503fa9c458853aef65db31.png" alt="Alt &#39;B+tree 数据存储&#39;"></p><h2 id="三、单表最多行数的计算"><a href="#三、单表最多行数的计算" class="headerlink" title="三、单表最多行数的计算"></a>三、单表最多行数的计算</h2><p><img src="https://pic.imgdb.cn/item/6550410cc458853aef6b6730.png" alt="Alt &#39;行数计算演示图&#39;"></p><p>上图中,<br>x 表示非叶子节点, 每页中的数据行数。<br>y 表示叶子节点, 每页中的数据行数。<br>z 表示 B+tree 树的高度。<br>那么, 这个 B+tree 的行数总量就是: (x ^ (z-1)) * y。</p><p><strong>x 的计算</strong><br>页 16k, 页头 120b, 页尾 8b, 剩余大约 15k 的空间来存索引数据。主键索引包括主键列和页号两部分组成。主键假设是 bigint 类型, 占 8b, 页号专业名词是 FIL_PAGE_OFFSET, 占4b, 也就是索引数据大约 12b。<br>剩余的 15k 里, 每条索引数据 12b, 那么就可以放 1280 条索引数据, 即每个非叶子节点有1280 个扇出。</p><p><strong>y 的计算</strong><br>叶子节点与非叶子节点页的结构一样, 所以也有 15k 的空间存放数据, 在主键索引中, 叶子节点存放的是整条记录, 这里假设整条记录是 1kb, 所以叶子节点每个页就能存放 15 条完整数据, 即 y &#x3D; 15。</p><p><strong>z 的计算</strong><br>z 代表树的高度, 树越高, 查询效率就越低, 所以, 一般维持树在三层高度。这样, 查询数据时, 最多进行 3 次 IO, 就可以查询到数据。即 z &#x3D; 3。</p><p>x &#x3D; 1280, y &#x3D; 15, z &#x3D; 3, 套入上述公式, 得:<br>(x ^ (z-1)) * y &#x3D; (1280 ^ (3-1)) * 15 ≈ 2.5kw。</p><p>所以, 单表最多可以存放 2.5kw 数据。</p><p>计算 y 时, 我们假设的一条数据 1kb。而单条数据达到 1kb, 算是比较大的数据了。 一般一条数据也就 300b 左右。如果按 300b 一条计算, 则 y &#x3D; 45。那么总行数就是: 2.5kw * 3 &#x3D; 7.5kw。即单表可以存七八千万条数据。</p><h2 id="四、联合索引的情况考虑"><a href="#四、联合索引的情况考虑" class="headerlink" title="四、联合索引的情况考虑"></a>四、联合索引的情况考虑</h2><p>上面的计算方式, 是按照主键索引来计算的。而真实生产中, 肯定会涉及到多条件查询。大数据量的情况下, 肯定要创建联合索引。那么考虑到联合索引, 如何计算单表最大行数呢？</p><p>假设一条多条件查询 SQL 命中了索引, 则首先是在联合索引中查询数据, 分两种情况讨论.  </p><h3 id="索引覆盖情况"><a href="#索引覆盖情况" class="headerlink" title="索引覆盖情况"></a>索引覆盖情况</h3><p>即通过联合索引, 就可以返回 SQL 所需的字段, 无需回表查询。</p><p><strong>x 的计算</strong><br>索引数据的空间还是剩余 15k 大小, 但是, 与主键索引不同的是, 联合索引每个非叶子节点, 会把索引列所有的字段都存起来, 其大小肯定比主键索引的 id 要大。我们假设联合索引有三个字段, 每个字段都是 varchar 类型, 且每个字段的值都是 5 个字 (utf8 编码), 那么每个字段就是 15b, 三个字段就是 45b。<br>所以, 一条数据的索引大小为 45b, 那么 15k, 能存 300 条数据, 也就是 300 个扇出。</p><p><strong>y 的计算</strong><br>联合索引的叶子节点, 存放的还是那几个联合索引列 +id 列。这里看成和 x 值相等, 45b, 一个页也能存 300 条数据。</p><p><strong>z 还按 3 计算</strong><br>那么总数是: (x ^ (z-1)) * y&#x3D; 300^2 * 300 &#x3D; 2.7kw。</p><p>这是按照联合索引 3 个字段, 每个字段 5 个汉字计算的。如果按照 3 个索引列, 每个字段 10个汉字计算, 10 个 utf8 编码的汉字占用字节为: 103 &#x3D; 30b。三个字段就是 90b。15k 就能存 150 条数据, 即 x &#x3D; y &#x3D; 150。  </p><p>z 还按 3 计算, 则总条数为: 150^2150 &#x3D; 330w。</p><p><strong>由此可见, 在索引覆盖的情况下, 一张表能存多少数据, 跟索引列大小有直接关系。索引列小时, 千万级别数据没问题, 索引列大时, 能存百万级别数据。</strong></p><h3 id="索引回表情况"><a href="#索引回表情况" class="headerlink" title="索引回表情况"></a>索引回表情况</h3><p>在联合索引需要回表的情况下, 需要先联合索引需要几次回表, 然后主键索引需要几次回表。这些确定了, 才能计算有多少数据量, 这里情况复杂, 不再详细计算。</p><h2 id="五、buffer-pool-size参数考虑"><a href="#五、buffer-pool-size参数考虑" class="headerlink" title="五、buffer_pool_size参数考虑"></a>五、buffer_pool_size参数考虑</h2><p>关于 Innodb_buffer_pool_size:《深入浅出 MySQL 》一文中这样描述 Innodb_buffer_pool_size:<br>该参数定义了 InnoDB 存储引擎的表数据和索引数据的最大内存缓冲区大小。和 MyISAM 存储引擎不同,  MyISAM 的<br>key_buffer_size 只缓存索引键,  而 innodb_buffer_pool_size 却是同时为数据块和索引块做缓存,<br>这个特性和 Oracle 是一样的。这个值设得越高, 访问表中数据需要的磁盘 I&#x2F;O 就越少。在一个专用的数据库<br>服务器上, 可以设置这个参数达机器物理内存大小的 80%。尽管如此, 还是建议用户不要把它设置得太大, 因为对物理内存的竞争可能在操作系统上导致内存调度。</p><p>可见, MySQL 的索引, 是可以在 bufferpool 中缓存的, 所以, 并不是每个节点, 都需要进行一次 IO 的。这也是为何上面的联合索引, 需要回表的情况, 我没有进一步讨论的原因。考虑到缓存等, 情况很复杂。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>综上所述, 对于单条数据量小, 涉及字段少的表, 存千万级别的数据, 是没问题的, 多者可以达到七八千万条数据。而对于单条数据量大, 字段多的表, 百万级别的量, 是可以承受的, 至于能不能存放千万级别的数据, 能存放几千万的数据, 这就需要根据实际情况, 进行性能的判断和判别了。无法通过理论的计算, 来获得一个很准确的值。</p><p>参考文章:<br><a href="https://mp.weixin.qq.com/s/mLosK11gCTFEzQlUjSPgtA">https://mp.weixin.qq.com/s/mLosK11gCTFEzQlUjSPgtA</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis AOF 源码</title>
      <link href="/article/2021/4102538023/"/>
      <url>/article/2021/4102538023/</url>
      
        <content type="html"><![CDATA[<p>在上篇, 我们已经从使用 &#x2F; 机制 &#x2F; AOF 过程中涉及的辅助功能等方面简单了解了 Redis AOF。<br>这篇将从源码的形式, 进行深入的了解。</p><h2 id="1-Redis-整个-AOF-主要功能"><a href="#1-Redis-整个-AOF-主要功能" class="headerlink" title="1 Redis 整个 AOF 主要功能"></a>1 Redis 整个 AOF 主要功能</h2><p>Redis 的 AOF 功能概括起来就 2 个功能</p><blockquote><ol><li>AOF 同步: 将客户端发送的变更命令, 保存到 AOF 文件中</li><li>AOF 重写: 随着 Redis 的运行, AOF 文件会不断变大, 在文件达到配置的条件时, 触发重写机制, 缩小文件的大小</li></ol></blockquote><h2 id="2-AOF-同步-将变更命令写入到文件"><a href="#2-AOF-同步-将变更命令写入到文件" class="headerlink" title="2 AOF 同步 - 将变更命令写入到文件"></a>2 AOF 同步 - 将变更命令写入到文件</h2><p><img src="https://pic.imgdb.cn/item/65a3caec871b83018a0217d0.png" alt="Alt &#39;AOF 同步过程&#39;"></p><p>如图 Redis AOF 同步过程</p><blockquote><ol><li>Redis 收到客户端发送的变更命令, 执行这个命令, 其间会修改在内存中数据库的数据</li><li>Redis 将这个变更命令同步到一个 <strong>AOF 缓冲区</strong></li><li>Redis 将 <strong>AOF 缓冲区</strong>中的数据同步到 AOF 文件中</li></ol></blockquote><p>整个 AOF 同步过程, 我们拆成 2 个部分进行分析</p><blockquote><ol><li>命令写入 AOF 缓冲区</li><li>AOF 缓冲区写入 AOF 文件</li></ol></blockquote><h3 id="2-1-变更命令写入-AOF-缓冲区"><a href="#2-1-变更命令写入-AOF-缓冲区" class="headerlink" title="2.1 变更命令写入 AOF 缓冲区"></a>2.1 变更命令写入 AOF 缓冲区</h3><h4 id="2-1-1-前置知识梳理"><a href="#2-1-1-前置知识梳理" class="headerlink" title="2.1.1 前置知识梳理"></a>2.1.1 前置知识梳理</h4><p>在 AOF 同步过程中, 在客户端的变更命令和 AOF 文件中, 有一个 <strong>AOF 缓冲区</strong>的存在。<br>主要作用是在 AOF 过程中, 可以缓冲客户端发送的命令, 后面可以将这些命令一次性多条写入到 AOF 文件中。</p><p>其本身的定义很简单, 就是一个字符串, 也就是 sds。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 很简单就是一个字符串, 后面的命令追加到这个字符串的后面</span>    sds aof_buf<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre><p>客户端发送的变更命令转为 RESP 协议格式的字符串, 然后追加到已有的字符串后面即可, 这样就形成了一个命令的缓冲区。</p><h4 id="2-1-2-逻辑触发入口"><a href="#2-1-2-逻辑触发入口" class="headerlink" title="2.1.2 逻辑触发入口"></a>2.1.2 逻辑触发入口</h4><p>在 AOF 开启过程中, 客户端的命令会在执行完成后, 再保存一份到 <strong>AOF 缓冲区</strong>, 这个保存的入口就是在 Redis 执行所有命令的 call 函数中。<br>可以简单理解为, Redis 接收到了客户端的命令后, 就会调用 call 函数, call 函数里面会在<strong>命令执行前</strong>做一些处理, 然后执行命令, 最后在<strong>命令执行后</strong>再做一些处理。</p><pre class="language-c" data-language="c"><code class="language-c">call 函数的逻辑如下<span class="token operator">:</span> ```c<span class="token comment">/** * Redis 命令执行过程 * @param c 客户端 * @param flags 一个标识, 通过二进制的形式封装了很多功能的标识, 比如当前命令是否需要 AOF 传播, 是否需要记录日志等 */</span><span class="token keyword">void</span> <span class="token function">call</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 执行对应的客户端命令</span>    c<span class="token operator">-></span>cmd<span class="token operator">-></span><span class="token function">proc</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 入参的 flags 设置了 CMD_CALL_PROPAGATE 标识, 表示当前的命令需要传播</span>    <span class="token comment">// 同时对应的客户端内部的标识不是 CLIENT_PREVENT_PROP (客户端的命令阻止传播)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> CMD_CALL_PROPAGATE <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_PREVENT_PROP<span class="token punctuation">)</span> <span class="token operator">!=</span> CLIENT_PREVENT_PROP<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>        <span class="token comment">// 命令传播标识, 默认为 none, 即什么都不做</span>        <span class="token keyword">int</span> propagate_flags <span class="token operator">=</span> PROPAGATE_NONE<span class="token punctuation">;</span>                <span class="token comment">// 命令导致数据脏了, 也就是修改了数据, 需要 aof 和 repl 传播 (repl 也就是主从复制, 同步给从节点)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dirty<span class="token punctuation">)</span>             <span class="token comment">// 修改命令传播标识为需要 AOF 和 repl 传播</span>            propagate_flags <span class="token operator">|=</span> <span class="token punctuation">(</span>PROPAGATE_AOF<span class="token operator">|</span>PROPAGATE_REPL<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 当前的客户端设置了需要强制同步传播, 更新命令传播标识为需要 repl 传播</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_FORCE_REPL<span class="token punctuation">)</span>             propagate_flags <span class="token operator">|=</span> PROPAGATE_REPL<span class="token punctuation">;</span>                       <span class="token comment">// 当前的客户端设置了需要强制 AOF 传播, 更新命令传播标识为需要 AOF 传播</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_FORCE_AOF<span class="token punctuation">)</span>             propagate_flags <span class="token operator">|=</span> PROPAGATE_AOF<span class="token punctuation">;</span>                   <span class="token comment">// CLIENT_PREVENT_REPL_PROP  这个标识表示当前的客户端的命令不需要 repl 传播          </span>        <span class="token comment">// 命令的执行过程 (上面的 proc 函数就是调用各个命令各自的执行逻辑), 内部可以通过 preventCommandPropagation() 等函数</span>        <span class="token comment">// 给当前的客户端的 flags 设置 CLIENT_PREVENT_REPL_PROP 等标识, 也就是不需要主从复制的标识</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_PREVENT_REPL_PROP <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> CMD_CALL_PROPAGATE_REPL<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment">// 取消 命令传播标识 中的命令复制传播标识    </span>            propagate_flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>PROPAGATE_REPL<span class="token punctuation">;</span>             <span class="token comment">// 同上一步的取消主从复制传播标识</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_PREVENT_AOF_PROP <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> CMD_CALL_PROPAGATE_AOF<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment">// 取消 命令传播标识 中的 AOF 保存标识    </span>            propagate_flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>PROPAGATE_AOF<span class="token punctuation">;</span>                      <span class="token comment">//  命令传播标识 不为 none, 且当前的命令不是模块命令</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>propagate_flags <span class="token operator">!=</span> PROPAGATE_NONE <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-></span>cmd<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CMD_MODULE<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment">// 调用 propagate 进行命令的传播</span>            <span class="token function">propagate</span><span class="token punctuation">(</span>c<span class="token operator">-></span>cmd<span class="token punctuation">,</span>c<span class="token operator">-></span>db<span class="token operator">-></span>id<span class="token punctuation">,</span>c<span class="token operator">-></span>argv<span class="token punctuation">,</span>c<span class="token operator">-></span>argc<span class="token punctuation">,</span>propagate_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * Redis 命令传播 * @param cmd Redis 命令 * @param dbid Redis 命令执行的数据库号 * @param argv Redis 命令的参数 * @param argc Redis 命令的参数个数 * @param flags 命令标识 */</span><span class="token keyword">void</span> <span class="token function">propagate</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">,</span> <span class="token keyword">int</span> dbid<span class="token punctuation">,</span> robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// AOF 开启了, 同时命令传播标识为 需要 AOF 传播</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_state <span class="token operator">!=</span> AOF_OFF <span class="token operator">&amp;&amp;</span> flags <span class="token operator">&amp;</span> PROPAGATE_AOF<span class="token punctuation">)</span>        <span class="token comment">// 将当前的命令保存到 AOF 缓冲区</span>        <span class="token function">feedAppendOnlyFile</span><span class="token punctuation">(</span>cmd<span class="token punctuation">,</span>dbid<span class="token punctuation">,</span>argv<span class="token punctuation">,</span>argc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 命令传播标识为 需要 repl 传播  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> PROPAGATE_REPL<span class="token punctuation">)</span>        <span class="token comment">// 将当前的没拿过来同步给从节点</span>        <span class="token function">replicationFeedSlaves</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span>dbid<span class="token punctuation">,</span>argv<span class="token punctuation">,</span>argc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上面就是<strong>命令写入 AOF 缓冲区</strong>的触发入口, 而真正的<strong>命令写入 AOF 缓冲区</strong> 的过程的话就是 feedAppendOnlyFile 函数了。</p><h4 id="2-1-3-具体的实现逻辑"><a href="#2-1-3-具体的实现逻辑" class="headerlink" title="2.1.3 具体的实现逻辑"></a>2.1.3 具体的实现逻辑</h4><p>feedAppendOnlyFile 函数的定义如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 命令写入 AOF 缓冲区 * * @param cmd Redis 命令 * @param dictid Redis 命令执行的数据库号 * @param argv Redis 命令的参数 * @param argc Redis 命令的参数个数 */</span><span class="token keyword">void</span> <span class="token function">feedAppendOnlyFile</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">,</span> <span class="token keyword">int</span> dictid<span class="token punctuation">,</span> robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">int</span> argc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 缓存字符串, 用于临时存放命令的文本</span>    sds buf <span class="token operator">=</span> <span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    robj <span class="token operator">*</span>tmpargv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 命令写入的数据库和当前 AOF 选中的数据库不是配置的, 手动加入一段, select 对应的数据库</span>    <span class="token comment">// 后面通过 AOF 文件恢复数据, 才能恢复到正确的数据库中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dictid <span class="token operator">!=</span> server<span class="token punctuation">.</span>aof_selected_db<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> seldb<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">// 将当前命令选中的数据库号数 (0, 1, 2, 3) 写入到字符数组 seldb 中</span>        <span class="token function">snprintf</span><span class="token punctuation">(</span>seldb<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>seldb<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"%d"</span><span class="token punctuation">,</span>dictid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 拼接出一个 select 数据库号 的语句, 这个语句是遵守 RESP 协议 </span>        buf <span class="token operator">=</span> <span class="token function">sdscatprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token string">"*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>seldb<span class="token punctuation">)</span><span class="token punctuation">,</span>seldb<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 修改 aof 当前的选中的数据库号数</span>        server<span class="token punctuation">.</span>aof_selected_db <span class="token operator">=</span> dictid<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// expire / pexpire / expireat 这三个命令, 在 AOF 保存的时候, 会转为 expireat key 具体的过期时间 (单位毫秒) 的格式存入到 AOF 文件中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd<span class="token operator">-></span>proc <span class="token operator">==</span> expireCommand <span class="token operator">||</span> cmd<span class="token operator">-></span>proc <span class="token operator">==</span> pexpireCommand <span class="token operator">||</span> cmd<span class="token operator">-></span>proc <span class="token operator">==</span> expireatCommand<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 转为过期对应的文本, 同时追加到 buf 中</span>        buf <span class="token operator">=</span> <span class="token function">catAppendOnlyExpireAtCommand</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span>cmd<span class="token punctuation">,</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd<span class="token operator">-></span>proc <span class="token operator">==</span> setexCommand <span class="token operator">||</span> cmd<span class="token operator">-></span>proc <span class="token operator">==</span> psetexCommand<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// setnx / psetex 2 个命令拆分为 set 和 expireat 2 个命令进行处理</span>        tmpargv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">createStringObject</span><span class="token punctuation">(</span><span class="token string">"SET"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tmpargv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        tmpargv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">// 往 buf 中追加 set 命令</span>        buf <span class="token operator">=</span> <span class="token function">catAppendOnlyGenericCommand</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>tmpargv<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 创建的对象手动修改引用计数, 便于内存回收</span>        <span class="token function">decrRefCount</span><span class="token punctuation">(</span>tmpargv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 往 buf 中追加 expireat 命令, 同理会转弯为 expireat key 具体的过期时间 (单位毫秒) 的格式</span>        buf <span class="token operator">=</span> <span class="token function">catAppendOnlyExpireAtCommand</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span>cmd<span class="token punctuation">,</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd<span class="token operator">-></span>proc <span class="token operator">==</span> setCommand <span class="token operator">&amp;&amp;</span> argc <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// set 命令同时参数大于 3 个, 也就是带有超时时间了</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>        robj <span class="token operator">*</span>exarg <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">*</span>pxarg <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                <span class="token comment">// 同样是, 先写入 set 命令</span>        buf <span class="token operator">=</span> <span class="token function">catAppendOnlyGenericCommand</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 计算后面的超时时间</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span> <span class="token string">"ex"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> exarg <span class="token operator">=</span> argv<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span> <span class="token string">"px"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> pxarg <span class="token operator">=</span> argv<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">serverAssert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>exarg <span class="token operator">&amp;&amp;</span> pxarg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 根据计算出来的超时时间, 转为 RESP 协议的文本</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>exarg<span class="token punctuation">)</span>            buf <span class="token operator">=</span> <span class="token function">catAppendOnlyExpireAtCommand</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span>server<span class="token punctuation">.</span>expireCommand<span class="token punctuation">,</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> exarg<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>pxarg<span class="token punctuation">)</span>            buf <span class="token operator">=</span> <span class="token function">catAppendOnlyExpireAtCommand</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span>server<span class="token punctuation">.</span>pexpireCommand<span class="token punctuation">,</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pxarg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 其他的命令直接转为 RESP 协议的字符串进行追加</span>        buf <span class="token operator">=</span> <span class="token function">catAppendOnlyGenericCommand</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span>argc<span class="token punctuation">,</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>    <span class="token comment">// 如果 AOF 功能开启中, 则将命令追加到 AOF 缓冲区中</span>    <span class="token comment">// 后续在进入事件循环之前，这些命令会被保存到磁盘上，并向给对应的 client 回复执行结果</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_state <span class="token operator">==</span> AOF_ON<span class="token punctuation">)</span>        <span class="token comment">// 3 个缓冲区中的一个, AOF 缓冲区, 保存变更的 Redis 命令</span>        server<span class="token punctuation">.</span>aof_buf <span class="token operator">=</span> <span class="token function">sdscatlen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果后台正在进行重写，那么将命令再追加一份到重写缓冲区中，以便我们记录重写时 AOF 文件和当前数据库的差异</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">// 这里不展开, 后面聊</span>        <span class="token function">aofRewriteBufferAppend</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>buf<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span></code></pre><p>变更命令到 <strong>AOF 命令缓冲区</strong>的过程到这里结束了, 接下来就是 AOF 缓冲区到 AOF 文件的过程了。</p><h3 id="2-2-AOF-缓冲区写入-AOF-文件"><a href="#2-2-AOF-缓冲区写入-AOF-文件" class="headerlink" title="2.2 AOF 缓冲区写入 AOF 文件"></a>2.2 AOF 缓冲区写入 AOF 文件</h3><h4 id="2-2-1-前置知识梳理"><a href="#2-2-1-前置知识梳理" class="headerlink" title="2.2.1 前置知识梳理"></a>2.2.1 前置知识梳理</h4><p><strong>1. write + fsync 函数</strong>  </p><p>在操作系统中, 将应用的内存数据保存到真正的磁盘文件中, 实际需要通过 2 个函数</p><blockquote><ol><li>write 函数, 将缓冲区中的数据写入到<strong>系统缓冲</strong>中, 一般是达到一定数量或者时间, 才会真正的写入到磁盘中, 单独的通过 write 函数, 无法 100% 保证数据的完整性</li><li>fsync 函数, 一个比较耗时的操作, 可以立刻将<strong>系统缓冲</strong>中的数据写入到磁盘中</li></ol></blockquote><p><strong>2. Redis 线程池 RIO</strong></p><p>因为 fsync 函数比较耗时, 所以 Redis 维护了一个线程池 (Redis 内部叫做 BIO), 用来处理一些比较耗时的操作。<br>现在 Redis 这个线程池只处理 3 种任务类型</p><blockquote><ol><li>close 函数, 也就是关闭文件</li><li>fsync 函数, 立即刷新系统缓冲到磁盘</li><li>Redis 内部的延长删除无用内存</li></ol></blockquote><p>所以在 AOF 缓存区写入到 AOF 文件中, 会先通过 write 将里面的数据写入到<strong>系统缓冲</strong>,<br>然后根据当前的 AOF 保存策略, 决定是否需要执行 fsync 函数和 fsync 的执行能否交给线程池。</p><p><strong>3. AOF 文件同步策略</strong><br>将 AOF 缓冲区中的数据写入到 AOF 文件, Redis 提供了 3 种策略</p><blockquote><ol><li>no: 不进行同步, 由操作系统自己决定, 也就是只执行 write 函数</li><li>always: 每次 write 后, 都立即执行 fsync</li><li>everysec: 每次 write 后, 不会立即执行 fsync, 理论是每秒执行一次 fsync, 同时内部会将 fysnc 的执行交由线程池执行</li></ol></blockquote><p><strong>4. everysec 的特殊性</strong><br>同步策略为 everysec 时, 为了性能, fsync 函数的执行不是由 Redis 的主线程处理的, 而是通过向线程池提交一个 fsync 的任务, 由后台线程池执行。<br>那么就存在一种特殊情况</p><blockquote><ol><li>主线程在 flushAppendOnlyFile (AOF 缓存区写入到文件的函数) 完了 write, 提交了一个任务到后台线程, 假设此时的数据量很大, fsync 需要执行很长时间</li><li>主线程又执行到了 flushAppendOnlyFile 了, 而上一次的 fsync 函数还没执行完, Redis 会选择<strong>延迟执行</strong>, 将一个变量 aof_flush_postponed_start 设置为当前时间, 结束</li><li>后面主线程执行到定时任务时, 会判断这个变量是否大于 0, 是的话, 会再次执行 flushAppendOnlyFile, 也就是这次 AOF 同步延迟到定时处进行执行</li><li>但是延迟到定时任务处触发, 还是无法保证后台线程一定执行完了 fsync 了, 所以 flushAppendOnlyFile, 会根据当前的时间和变量里面存储的时间进行比较, 还是在 2 秒内, 不做任何处理, 而大于 2 秒, 立即执行 AOF 缓冲区写入文件的逻辑</li></ol></blockquote><p>理解了上面 3 个点, 下面 AOF 缓冲区的数据写入到 AOF 文件的过程就简单很多了。</p><h4 id="2-2-2-逻辑触发入口"><a href="#2-2-2-逻辑触发入口" class="headerlink" title="2.2.2 逻辑触发入口"></a>2.2.2 逻辑触发入口</h4><p>将缓冲区中的数据写入到文件的函数为 <strong>flushAppendOnlyFile</strong>, 而在 Redis 中会触发这个函数的有 5 个地方</p><blockquote><ol><li>通过命令动态地关闭 AOF 功能时, 会进行一次保存, 即动态的将 appendonly yes 设置为 appendonly no</li><li>Redis 服务器正常关闭之前, 会执行一次</li><li>在 AE 事件循环中配置的 beforesleep 函数中就会调用一次, 这个是 AOF 功能的主要的保存入口</li><li>Redis 的定时器函数 serverCron  (默认为 100 毫秒执行一次), 会判断上次执行的 flushAppendOnlyFile 是不是延迟执行, 是会调一次 (这个延迟的行为, 在 flushAppendOnlyFile 中有分析)</li><li>最后一个就是定时器函数 serverCron (默认为 1000 毫秒执行一次), 判断上次 AOF 写入状态, 失败就执行一次</li></ol></blockquote><p>后面 2 种都是在 serverCron 中, 代码如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 上次的 AOF 写文件时, 没有执行, 而是将 aof_flush_postponed_start 设置为 true, 表示需要延迟处理, 则在这里进行判断出来 </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_flush_postponed_start<span class="token punctuation">)</span>         <span class="token function">flushAppendOnlyFile</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">run_with_period</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 上次的写文件失败了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_last_write_status <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span>            <span class="token function">flushAppendOnlyFile</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span></code></pre><h4 id="2-2-3-具体的实现逻辑"><a href="#2-2-3-具体的实现逻辑" class="headerlink" title="2.2.3 具体的实现逻辑"></a>2.2.3 具体的实现逻辑</h4><p>整个 AOF 缓冲区的数据写入到 AOF 文件的实现函数就是 flushAppendOnlyFile, 定义如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * AOF 缓冲区数据写入文件 * * 当持久策略被设置为 everysec, 实际上会由后台线程进行处理, 那么当前这次刷新写入时, 后台可能有线程还在写入, 所以这时的操作会延迟写入 *  * @param force 1：表示无视后台的 fsync, 直接写入, 0: 表示可以延迟, 一般 AOF 过程都是 0 */</span><span class="token keyword">void</span> <span class="token function">flushAppendOnlyFile</span><span class="token punctuation">(</span><span class="token keyword">int</span> force<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ssize_t</span> nwritten<span class="token punctuation">;</span>    <span class="token keyword">int</span> sync_in_progress <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">mstime_t</span> latency<span class="token punctuation">;</span>    <span class="token comment">// 缓冲区没有数据, 正常缓冲区没有数据, 就可以结束了</span>    <span class="token comment">// 但是 Redis 在里面对一个极端情况的兼容, 有点绕, 有兴趣可以了解一下, 也可以跳过</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sdslen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 即使在缓冲区数据为空的情况下, 也需要检查一次是否需要执行 fsync 操作 (fsync: 将缓冲区数据写回磁盘)</span>        <span class="token comment">// 因为在 everysec 模式下, fsync 仅在 AOF 缓冲区不为空时调用</span>        <span class="token comment">// 如果在一秒钟调用一次的 fsync 之前, 用户停止了写命令 (stop write commands, 也就是没有发送任何变更的命令), 将会导致缓冲中的数据无法及时刷新</span>        <span class="token comment">// 这种情况的分析, 个人的猜测在后面的备注中进行分析</span>        <span class="token comment">// 1. 配置的持久化策略为 everysec 每秒执行一次 fsync </span>        <span class="token comment">// 2. 已经同步到磁盘的内容大小 != 当前 AOF 文件的内容大小</span>        <span class="token comment">// 3. 当前的时间 > 上次 AOF fsync 的时间</span>        <span class="token comment">// 4. 当前没有请求 fsync 的任务在线程池中</span>        <span class="token comment">// 4 个条件都符合, 尝试进行 fsync, 否则直接返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_EVERYSEC <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>aof_fsync_offset <span class="token operator">!=</span> server<span class="token punctuation">.</span>aof_current_size             <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>unixtime <span class="token operator">></span> server<span class="token punctuation">.</span>aof_last_fsync <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>sync_in_progress <span class="token operator">=</span> <span class="token function">aofFsyncInProgress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">goto</span> try_fsync<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 持久策略为每秒 fsync 一次, 判断后台的线程池是否有线程在执行 fsync </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_EVERYSEC<span class="token punctuation">)</span>        <span class="token comment">// aofFsyncInProgress 返回值为 true, 表示当前有 BIO 线程在执行 fsync </span>        sync_in_progress <span class="token operator">=</span> <span class="token function">aofFsyncInProgress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 持久策略为每秒 fsync 一次, 同时不需要强制写入文件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_EVERYSEC <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>force<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 当前有 BIO 线程在执行 fsync</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sync_in_progress<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 0 表示当前没有延迟执行</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_flush_postponed_start <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 当前有后台线程在执行 fsync, 那么先延长一下, 设置 aof_flush_postponed_start 为当前时间， 然后结束, 后面定时器执行到了, 判断这个值大于 0, </span>                <span class="token comment">// 重新进入 flushAppendOnlyFile 函数进行 AOF 缓冲区保存, 也就是延迟执行</span>                server<span class="token punctuation">.</span>aof_flush_postponed_start <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>                        <span class="token comment">// 如果之前有设置延迟执行, 然后又进入到这个函数(大部分场景是定时器触发), 此次后台还是有线程在执行 fsync,</span>            <span class="token comment">// 但是当前时间和上一次设置的延迟时间小于 2 秒, 可以接受, 暂时还是不做任何处理</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>unixtime <span class="token operator">-</span> server<span class="token punctuation">.</span>aof_flush_postponed_start <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 直接返回</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                         <span class="token comment">// 上面的情况分析</span>            <span class="token comment">// 第一次执行完 flushAppendOnlyFile 后, 但是数据量很大, 导致 fsync 很耗时, </span>            <span class="token comment">// 那么第二次 flushAppendOnlyFile 极端情况需要在 2 秒后才会进行</span>            <span class="token comment">// 延迟 fsync 的次数 + 1</span>            <span class="token comment">// 到了这一步表示线程池中有请求 fsync 的任务, 同时上次延迟距离当前时间超过 2 秒了</span>            server<span class="token punctuation">.</span>aof_delayed_fsync<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">// 记录日志</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>              <span class="token comment">// 下面的 latency 开头的函数基本都是延迟统计相关的, 不影响具体的逻辑, 可以跳过</span>    <span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 步骤 BB, 后面备注分析在缓存区没有数据还需要执行 fsync 用到</span>    <span class="token comment">// 调用 write 函数将缓冲区中的数据写入到文件 (此时还在系统级缓存, 还没写入到磁盘, 可以通过 fsync 强制刷入到磁盘)</span>    nwritten <span class="token operator">=</span> <span class="token function">aofWrite</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fd<span class="token punctuation">,</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sync_in_progress<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"aof-write-pending-fsync"</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"aof-write-active-child"</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"aof-write-alone"</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"aof-write"</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将缓冲区中的数据 write 到系统后, 可以把延迟执行设置为 0</span>    server<span class="token punctuation">.</span>aof_flush_postponed_start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 写入到系统的数据长度不等于当前 AOF 缓冲区的长度, 进入异常处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token class-name">ssize_t</span><span class="token punctuation">)</span><span class="token function">sdslen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">static</span> <span class="token class-name">time_t</span> last_write_error_log <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> can_log <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 上次记录错误日志的时间距离现在 30 秒了, 需要再记录多一次移除日志</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>unixtime <span class="token operator">-</span> last_write_error_log<span class="token punctuation">)</span> <span class="token operator">></span> AOF_WRITE_LOG_ERROR_RATE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            can_log <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            last_write_error_log <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// -1, 没有写入任何数据, 就直接失败了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 写入失败</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>can_log<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Error writing to the AOF file: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 保存错误到 redisServer 的 aof_last_write_errno</span>                server<span class="token punctuation">.</span>aof_last_write_errno <span class="token operator">=</span> errno<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 大于 -1 但是不等于缓冲区的大小, 写入成功了一部分, </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>can_log<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 记录日志</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 将 AOF 的文件大小修改为 aof_current_size 的大小, 返回值 0 成功, -1 失败</span>            <span class="token comment">// 也就是恢复回写入前的文件内容</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ftruncate</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fd<span class="token punctuation">,</span> server<span class="token punctuation">.</span>aof_current_size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 记录日志</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 设置为 -1, 表示 AOF 中没有写入成功的部分数据</span>                nwritten <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            server<span class="token punctuation">.</span>aof_last_write_errno <span class="token operator">=</span> ENOSPC<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 同步策略为 always</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_ALWAYS<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 这种情况无法处理了, 已经告知客户端写入成功了, 但是当前写入失败了, 直接退出程序。</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 设置上一次写入状态为异常, 在定时器中会判断这个状态, 再次触发 flushAppendOnlyFile </span>            server<span class="token punctuation">.</span>aof_last_write_status <span class="token operator">=</span> C_ERR<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 更新当前 aof 文件的大小 = 当前的大小 + 写入部分的大小, 同时将缓冲区中这部分大小的数据移除</span>                <span class="token comment">// 表示这部分写入成功了, 剩余部分下次调用继续</span>                server<span class="token punctuation">.</span>aof_current_size <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>                <span class="token function">sdsrange</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">,</span>nwritten<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 写入成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_last_write_status <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 最新最近一次写的状态为 C_OK</span>            server<span class="token punctuation">.</span>aof_last_write_status <span class="token operator">=</span> C_OK<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 更新当前 AOF 文件的大小</span>    server<span class="token punctuation">.</span>aof_current_size <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>    <span class="token comment">// 如果当前 AOF 缓冲区足够小，小于 4K，那么重用这个缓存，否则释放 AOF 缓冲区, 然后重新分配一个</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">sdslen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">sdsavail</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">4000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sdsclear</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>aof_buf <span class="token operator">=</span> <span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>try_fsync<span class="token operator">:</span>    <span class="token comment">// no-appendfsync-on-rewrite (正在重写, 不执行 fsync) 被设置为 yes</span>    <span class="token comment">// 正在执行 后台保存 RDB  或者 后台保存 AOF, 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_no_fsync_on_rewrite <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token comment">// 持久策略为 always </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_ALWAYS<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 宏定义, 在 Linux 系统中执行 fdatasync 函数, 其他系统执行 fsync 函数</span>        <span class="token function">redis_fsync</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"aof-fsync-always"</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新 aof_fsync_offset 为当前的 AOF 文件大小</span>        server<span class="token punctuation">.</span>aof_fsync_offset <span class="token operator">=</span> server<span class="token punctuation">.</span>aof_current_size<span class="token punctuation">;</span>        <span class="token comment">// 上次 fsync 为当前的时间</span>        server<span class="token punctuation">.</span>aof_last_fsync <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_EVERYSEC <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>unixtime <span class="token operator">></span> server<span class="token punctuation">.</span>aof_last_fsync<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 持久策略为 everysec 同时当前的时间大于上次 fsync 的时间</span>        <span class="token comment">// 步骤 AA, 后面备注分析在缓存区没有数据还需要执行 fsync 用到</span>        <span class="token comment">// 当前没有请求 fsync 的任务在线程池中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sync_in_progress<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 提交一个任务, 最终就是一个后台线程执行一次 redis_fsync 函数</span>            <span class="token function">aof_background_fsync</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 更新 aof_fsync_offset 为当前的页的大小</span>            server<span class="token punctuation">.</span>aof_fsync_offset <span class="token operator">=</span> server<span class="token punctuation">.</span>aof_current_size<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        server<span class="token punctuation">.</span>aof_last_fsync <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token comment">// 返回 true, 如果当前已经有一个请求 fsync 的任务了, 返回 true</span><span class="token keyword">int</span> <span class="token function">aofFsyncInProgress</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">bioPendingJobsOfType</span><span class="token punctuation">(</span>BIO_AOF_FSYNC<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// Redis 的 BIO 更像是一个线程池, 下面的方法是提交一个任务到对应任务链表</span><span class="token comment">// 同时会尝试唤醒线程池对应的线程去执行任务, 具体的实现可以看一下 bio.c 这个文件</span><span class="token keyword">void</span> <span class="token function">aof_background_fsync</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">bioCreateBackgroundJob</span><span class="token punctuation">(</span>BIO_AOF_FSYNC<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>fd<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 调用 write 函数, 写入数据到文件</span><span class="token class-name">ssize_t</span> <span class="token function">aofWrite</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ssize_t</span> nwritten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> totwritten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 调用 write 函数将 server.aof_buf 中的数据写入到系统级缓存中</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> totwritten <span class="token operator">?</span> totwritten <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        len <span class="token operator">-=</span> nwritten<span class="token punctuation">;</span>        buf <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>        totwritten <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 写入的内容大小</span>    <span class="token keyword">return</span> totwritten<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上面就是一个将 AOF 缓冲区中的数据写入到系统的过程, 一个<strong>正常</strong>的流程如下：</p><blockquote><ol><li>如果当前同步策略是每秒 fsync, 同时有 BIO 线程在后台处理 fsync 了, 设置 redisServer 的延迟 AOF 时间 aof_flush_postponed_start 为当前时间, 等待下次执行, 结束</li><li>调用 write 把 AOF 缓冲区的数据写入到系统级缓存中</li><li>获取写入到系统级缓存的数据长度</li><li>写入到系统级缓存的数据长度不等于 AOF 缓冲区的数据长度, 进行异常处理, 结束</li><li>长度一样, 更新 redisServer 的最新 AOF 写入状态 aof_last_write_status 为成功状态</li><li>更新当前 AOF 文件的大小 aof_current_size 为 aof_current_size + 最新写入的数据长度</li><li>清空 AOF 缓冲区的数据</li><li>如果配置的持久策略为 always, 立即执行 fsync</li><li>如果配置的持久策略为 everysec, 当前的时间大于上次 fsync 的时间, 同时线程池中没有 fsync 任务, 提交一个到线程池, 更新当前的 fsync 写入量的 aof_fsync_offset 为当前的 AOF 文件大小</li><li>更新最新的 AOF fsync 时间为当前时间</li></ol></blockquote><p>备注:<br>在上面的代码中, 在 AOF 缓冲区没有数据的情况下, 还会进行条件的判断后, 尝试进行 fsync 的操作, 需要进行这种情况的情景, 个人猜测如下</p><blockquote><ol><li>第一次走入这个方法, sync_in_progress 为 false, 走到下面的步骤 AA, 开启了一个后台 BIO 线程进行 fsync, 假设当前的 aof_fsync_offset &#x3D; aof_current_size &#x3D; xx</li><li>第二次走入到这个方法, sync_in_progress 为 true, 走到步骤 BB 时, 后台的 BIO 线程已经完成任务, 结束了, 所以这时候 sync_in_progress 理论应该为 false 了, 但是此时还是为 true</li><li>第二次同样走到了下面的步骤 AA, 这是 aof_current_size 已经是追加到了最新的大小了, 设为 yy, 因为 sync_in_progress 为 true, aof_fsync_offset 还是 xx, 最新的数据已经 write 到系统级缓存了, 但是没有 fsync</li><li>如果这时候用户没有在向 Redis 中进行更改命令, AOF 缓冲区就会一直为空, 无论走几次到这个方法, 都不会走到下面的逻辑, 这时候就存在 AOF 文件中的数据和真正的数据有偏差</li><li>所以在 AOF 缓冲区为空的情况下, 还要进行多一次判断, 进行 fsync</li></ol></blockquote><h2 id="3-AOF-重写-AOF-文件瘦身"><a href="#3-AOF-重写-AOF-文件瘦身" class="headerlink" title="3 AOF 重写 - AOF 文件瘦身"></a>3 AOF 重写 - AOF 文件瘦身</h2><p>整个 AOF 重写过程, 会稍微复杂一些, 因为涉及到 2 个进程。</p><p><img src="https://pic.imgdb.cn/item/65a3caf0871b83018a022af8.png" alt="Alt &#39;AOF 重写过程&#39;"></p><p>如图是整个 AOF 重写过程</p><p>当 Redis 服务端发现整个 AOF 文件达到配置的重写条件了</p><blockquote><ol><li>立即创建出 6 个 Pipe 通道 (这些通道主要用于父子进程的通信)</li><li>父进程通过 fork 操作, 创建出子进程 (fork 可以理解为克隆, 此时子进程和父进程完全一样, 拥有父进程所有数据的快照), 由子进程会执行 AOF 重写的过程</li></ol></blockquote><p>fork 操作后, 父进程将继续运行</p><blockquote><ol><li>在收到客户端的变更命令后, 处理完同步到内存数据库中, 写入到 <strong>AOF 缓冲区</strong>, 此时还会写入一份到 <strong>AOF 重写缓冲区</strong>中</li><li>后面不断将 <strong>AOF 重写缓冲区</strong>中的数据通过 Pipe 通道同步给子进程</li></ol></blockquote><p>备注: 在子进程重写的这段过程, 命令还是会写入到 AOF 缓冲区中, 并同步写入 AOF 文件中</p><p>fork 出来的子进程, 此时不会有任何的数据变更了</p><blockquote><ol start="3"><li>根据自身<strong>内存数据库</strong>, 将里面的数据写入到一个新的 AOF 临时文件</li><li>在将内存数据写入到 AOF 临时文件中, 会按照每写入 10m 数据到文件时, 就通过 Pipe 将父进程同步过来的差异命令保存到自身的 <strong>AOF 子进程差异缓冲区</strong>中</li><li>当内存数据库中的数据全部写入到 AOF 临时文件后, 通过 Pipe 向父级发送一个 !, 通知父进程停止同步差异命令</li><li>父进程收到子进程发送过来的 !, 会停止向子进程同步差异命令, 并通过 Pipe 发送一个 !, 进行响应</li><li>子进程收到父进程发送过来的 ! 后, 会将自身的 <strong>AOF 子进程差异缓冲区</strong> 中的数据写入到 AOF 临时文件中</li></ol></blockquote><p>备注: 此时子进程任务完成 </p><p>父进程运行过程中, 会不断检查 AOF 子进程的状态</p><blockquote><ol start="8"><li>当发现子进程已经停止了, 父进程进行将 <strong>AOF 重写缓冲区</strong>中的省略的数据写入到 AOF 临时文件中</li><li>写入完成后, 将 AOF 临时文件替换掉旧的 AOF 文件, AOF 重写过程完成, 后面收到的 Redis 命令, 会写入到新的 AOF 文件中</li></ol></blockquote><p>至此, 这个 AOF 重写过程就完成了。</p><p>将上面的过程, 再概括一下就是</p><blockquote><ol><li>fork 出来的子进程, 拥有了和父进程一样的内存数据, 子进程先把这些内存数据写入到一个 AOF 临时文件</li><li>父进程在子进程同步内存数据到文件的过程中, 还在处理客户端请求, 将这段时间的变更命令保存下来</li><li>子进程内存数据同步到临时文件完成了, 将父进程这段时间保存下来的变更命令拿过来, 继续追加到 AOF 临时文件中</li><li>父进程在子进程将变更命令追加到临时文件的过程中, 继续把这段时间的变更命令保存下来</li><li>子进程将第一次同步过来的的变更命令追加到 AOF 临时文件后, 完成任务, 结束</li><li>父进程在子进程结束后, 自己剩余的变更命令同步到 AOF 临时文件，这个 AOF 临时文件就是完整的数据了</li></ol></blockquote><h3 id="3-1-前置知识梳理"><a href="#3-1-前置知识梳理" class="headerlink" title="3.1 前置知识梳理"></a>3.1 前置知识梳理</h3><h4 id="3-1-1-AOF-重写过程中涉及到的-Pipe-通道"><a href="#3-1-1-AOF-重写过程中涉及到的-Pipe-通道" class="headerlink" title="3.1.1 AOF 重写过程中涉及到的 Pipe 通道"></a>3.1.1 AOF 重写过程中涉及到的 Pipe 通道</h4><p>整个 AOF 重写的过程是需要父子 2 个进程共同合作完成的, 那么这个过程就涉及到通讯, 在 Redis 中, 通讯的方式是通过 Pipe 管道来实现的。<br>从 Redis 对 Pipe 的使用可以得出下面的特点,</p><blockquote><ol><li>Pipe 需要两两配合使用, 比如 A 和 B 2个 Pipe 组成一对, 父进程向 A Pipe 写入数据, 子进程可通过 B Pipe 读取到父进程同步过来的数据</li><li>一对 Pipe 组合的数据同步方向是不可逆的, 父进程通过 A Pipe 同步给子进程, 子进程没法反着过来通过 B  Pipe 同步数据给父进程</li></ol></blockquote><p>从上面的流程图中可以看到有 6 个 Pipe, 共 3 组</p><blockquote><ol><li>aof_pipe_write_data_to_child 和 aof_pipe_read_data_from_parent, 主要是父进程将子进程重写过程中产生的变更命令同步给子进程</li><li>aof_pipe_write_ack_to_parent 和 aof_pipe_read_ack_from_child, 主要是用于子进程通知父进程停止同步变更命令</li><li>aof_pipe_write_ack_to_child 和 aof_pipe_read_ack_from_parent, 主要用于父进程响应子进程的停止同步变更命令的请求</li></ol></blockquote><h4 id="3-1-2-AOF-重写过程涉及到的-2-个缓冲区"><a href="#3-1-2-AOF-重写过程涉及到的-2-个缓冲区" class="headerlink" title="3.1.2 AOF 重写过程涉及到的 2 个缓冲区"></a>3.1.2 AOF 重写过程涉及到的 2 个缓冲区</h4><p><strong>1. AOF 重写缓冲区</strong>  </p><p>AOF 重写缓冲区, 主要是在 AOF 重写过程中, 缓冲这段时间修改了内存数据的命令。<br>fork 出来的子进程, 根据自身的内存数据库快照, 生成一个新的 AOF 临时文件后。<br>生成的过程中, 父进程还在处理客户端的命令, 这些命令会导致数据变更, 需要把这些命令追加到 AOF 临时文件, 才是最终完整的数据。<br>而这个缓存区中就是父进程保存子进程重写过程中, 导致数据变更的命令。</p><p>那么这个缓冲区是什么样的呢？</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 重写缓存链表, 当前正在进行重写时, 会把命令写入到这个列表, 待重写完成后, 再追加到文件</span>    list <span class="token operator">*</span>aof_rewrite_buf_blocks<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">/** * AOF 重写缓存列表的节点定义 */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aofrwblock</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 下面的缓存数组已经使用的空间和剩余的空间</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">,</span> free<span class="token punctuation">;</span>    <span class="token comment">// 用来缓存需要写入到文件的命令文本内容, 当数组所有空间使用完了, 会新建一个新的缓存节点</span>    <span class="token comment">// AOF_RW_BUF_BLOCK_SIZE = 1024*1024*10</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>AOF_RW_BUF_BLOCK_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> aofrwblock<span class="token punctuation">;</span></code></pre><p>一个链表, 链表的节点就是一个 10kb 的字节数组, 即每个节点可以存储 10kb 的数据, 写满了就再新建一个节点。</p><p>这个缓冲区的作用和写入的时机, 实际在上面的 AOF 重写同步中已经有遇到了, 这里对数据写入的时机和逻辑进行一个代码级别的整理。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 在上面 AOF 命令写入缓冲区中, 可以知道, 在执行命令执行后, 会有个命令传播的逻辑, 里面会调用到这个 feedAppendOnlyFile 函数 * 这个函数会判断当前是否正在进行 AOF 重写, 如果是, 会将命令追加一份到 AOF 重写缓冲区中, 保存子进程重写过程中, 主进程这段时间处理的变更命令 */</span><span class="token keyword">void</span> <span class="token function">feedAppendOnlyFile</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">,</span> <span class="token keyword">int</span> dictid<span class="token punctuation">,</span> robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">int</span> argc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 如果后台正在进行重写，那么将命令追加到重写缓冲区中，以便我们记录重写时 AOF 文件和当前数据库的差异</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">// 这里就是将变更命令写入到 AOF 重写缓冲区</span>        <span class="token function">aofRewriteBufferAppend</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>buf<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * @param s: 需要写入的数据 * @param len: 需要写入的数据长度 */</span><span class="token keyword">void</span> <span class="token function">aofRewriteBufferAppend</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取重写缓冲区列表</span>    listNode <span class="token operator">*</span>ln <span class="token operator">=</span> <span class="token function">listLast</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_rewrite_buf_blocks<span class="token punctuation">)</span><span class="token punctuation">;</span>    aofrwblock <span class="token operator">*</span>block <span class="token operator">=</span> ln <span class="token operator">?</span> ln<span class="token operator">-></span>value <span class="token operator">:</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 重写缓冲列表已经有数据了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>block<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 当前列表的最后一个节点需要分配多少的长度出来</span>            <span class="token comment">// 剩余的空间 &lt; 需要的空间 ? 剩余多少分配多少 : 存储内容需要的长度</span>            <span class="token keyword">unsigned</span> <span class="token keyword">long</span> thislen <span class="token operator">=</span> <span class="token punctuation">(</span>block<span class="token operator">-></span>free <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token operator">?</span> block<span class="token operator">-></span>free <span class="token operator">:</span> len<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>thislen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 当前的节点空间还有剩余的</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>block<span class="token operator">-></span>buf<span class="token operator">+</span>block<span class="token operator">-></span>used<span class="token punctuation">,</span> s<span class="token punctuation">,</span> thislen<span class="token punctuation">)</span><span class="token punctuation">;</span>                block<span class="token operator">-></span>used <span class="token operator">+=</span> thislen<span class="token punctuation">;</span>                block<span class="token operator">-></span>free <span class="token operator">-=</span> thislen<span class="token punctuation">;</span>                s <span class="token operator">+=</span> thislen<span class="token punctuation">;</span>                <span class="token comment">// 计算出还需要多少空间</span>                len <span class="token operator">-=</span> thislen<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// len > 0, 说明还需要空间, 但是当前的节点没有空间了, 需要新建一个节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 还需要空间</span>            <span class="token keyword">int</span> numblocks<span class="token punctuation">;</span>            <span class="token comment">// 分配以新的缓存节点, 同时放到列表的尾部</span>            block <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>block<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            block<span class="token operator">-></span>free <span class="token operator">=</span> AOF_RW_BUF_BLOCK_SIZE<span class="token punctuation">;</span>            block<span class="token operator">-></span>used <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token function">listAddNodeTail</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_rewrite_buf_blocks<span class="token punctuation">,</span>block<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 获取当前的重写缓存列表的节点长度</span>            numblocks <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_rewrite_buf_blocks<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 加 1 后是 10 的倍数</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>numblocks<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 记录日志</span>                <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>numblocks<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> LL_WARNING <span class="token operator">:</span> LL_NOTICE<span class="token punctuation">;</span>                <span class="token function">serverLog</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span><span class="token string">"Background AOF buffer size: %lu MB"</span><span class="token punctuation">,</span> <span class="token function">aofRewriteBufferSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 回到循环的头部, 再来一次循环</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 注册一个文件事件, 用来将缓冲区的数据写入到 aof_pipe_write_data_to_child 中, 然后在 Pipe 的作用下, 可以同步到 aof_pipe_read_data_from_parent</span>    <span class="token comment">// 只需要注册一个就可以了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeGetFileEvents</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>server<span class="token punctuation">.</span>aof_pipe_write_data_to_child<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> server<span class="token punctuation">.</span>aof_pipe_write_data_to_child<span class="token punctuation">,</span> AE_WRITABLE<span class="token punctuation">,</span> aofChildWriteDiffData<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 把当前的 AOF 缓冲区同步到 aof_pipe_write_data_to_child, 在 Pipe 的作用下间接同步到 aof_pipe_read_data_from_parent</span><span class="token keyword">void</span> <span class="token function">aofChildWriteDiffData</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>    aofrwblock <span class="token operator">*</span>block<span class="token punctuation">;</span>    <span class="token class-name">ssize_t</span> nwritten<span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>privdata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 获取头节点</span>        ln <span class="token operator">=</span> <span class="token function">listFirst</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_rewrite_buf_blocks<span class="token punctuation">)</span><span class="token punctuation">;</span>        block <span class="token operator">=</span> ln <span class="token operator">?</span> ln<span class="token operator">-></span>value <span class="token operator">:</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token comment">// 停止同步或者没有 AOF 缓冲区时, 删除这个事件</span>        <span class="token comment">// 后续如果停止同步的标识还是 true, 又有缓冲区数据, 在 aofRewriteBufferAppend 会重新新建一个这个事件, 可以重新开始执行</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_stop_sending_diff <span class="token operator">||</span> <span class="token operator">!</span>block<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 删除这个事件</span>            <span class="token function">aeDeleteFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>server<span class="token punctuation">.</span>aof_pipe_write_data_to_child<span class="token punctuation">,</span> AE_WRITABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>block<span class="token operator">-></span>used <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 把 block 的数据写入到 aof_pipe_write_data_to_child</span>            nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_pipe_write_data_to_child<span class="token punctuation">,</span> block<span class="token operator">-></span>buf<span class="token punctuation">,</span> block<span class="token operator">-></span>used<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token function">memmove</span><span class="token punctuation">(</span>block<span class="token operator">-></span>buf<span class="token punctuation">,</span>block<span class="token operator">-></span>buf<span class="token operator">+</span>nwritten<span class="token punctuation">,</span>block<span class="token operator">-></span>used<span class="token operator">-</span>nwritten<span class="token punctuation">)</span><span class="token punctuation">;</span>            block<span class="token operator">-></span>used <span class="token operator">-=</span> nwritten<span class="token punctuation">;</span>            block<span class="token operator">-></span>free <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>block<span class="token operator">-></span>used <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token function">listDelNode</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_rewrite_buf_blocks<span class="token punctuation">,</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>看起来很长的一段逻辑, 实际概括起来就 2 个步骤。</p><p><img src="https://pic.imgdb.cn/item/65a3caf2871b83018a0233a0.png" alt="Alt &#39;AOF 重写缓冲区写入过程&#39;"></p><blockquote><ol><li>将客户端的命令转为 RESP 协议格式的字符串</li><li>将 RESP 协议格式的字符串写入到 AOF 缓冲区中<blockquote><p>2.1 写入的 AOF 缓冲区本质是一个链表, 尾节点还有空间, 那么尾结点能写多少就写多少<br>2.2 尾节点写完了, 就重新分配一个节点, 然后继续写入, 直到现在的命令字符串写完</p></blockquote></li></ol></blockquote><p><strong>2. AOF 子进程差异缓冲区</strong>  </p><p>通过上面的简单流程, 我们知道: 整个 AOF 重写过程是在通过 fork 函数, 克隆出一个子进程进行操作。<br>因为正常整个 Redis 的内存会很大, 重写的时间会很长, 如果把这个过程放在父进程, 过程会影响到 Redis 的正常运行,</p><p>同理, 整个 Redis 的内存很大, 所以整个 AOF 重写的过程不会很快, 那么这段时间产生的新的变更命令 (存放在上面的 AOF 重写缓冲区), 可能也会很多。<br>如果这些命令追加到新的 AOF 文件中放在父进程, 也可能会影响到 Redis 的正常运行。  </p><p>所以 Redis 重写过程中，会通过 Pipe 通道, 将这些命令同步给子进程自己的一个缓存区。<br>子进程在根据内存数据库重写完成后, 随便将这个缓冲区的数据追加到新的 AOF 文件中, 即把这段重写过程中产生的变更命令还是让子进程来处理。  </p><p>而这个缓冲区就是 <strong>AOF 子进程差异缓冲区</strong>，定义如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// AOF 子进程差异缓冲区</span>    sds aof_child_diff<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre><p>同样是一个字符串 sds。</p><p>子进程通过 Pipe 将 AOF 重写缓存区的数据同步到这个 AOF 子进程差异缓冲区的逻辑如下:</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 将 aof_pipe_read_data_from_parent 中的数据读取到 server.aof_child_diff 中</span><span class="token class-name">ssize_t</span> <span class="token function">aofReadDiffFromParent</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">65536</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">ssize_t</span> nread<span class="token punctuation">,</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 将 aof_pipe_read_data_from_parent 中的数据读取到 buf 中</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nread <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_pipe_read_data_from_parent<span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 把 buf 的数据拼接到 aof_child_diff 中</span>        server<span class="token punctuation">.</span>aof_child_diff <span class="token operator">=</span> <span class="token function">sdscatlen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_diff<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>nread<span class="token punctuation">)</span><span class="token punctuation">;</span>        total <span class="token operator">+=</span> nread<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> total<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>备注: 这里还有个问题, 子进程将重写过程 AOF 变更命令追加到 AOF 文件的过程中, 还是会产生新的变更命令 (此时还是存放在 AOF 重写缓冲区中),<br>Redis 将这段时间的变更命令的写入文件放在了父进程执行了。</p><p>整个 AOF 重写的过程, 需要的了解的前提知识大概就这些了, 后面进入代码的逻辑分析。</p><h3 id="3-2-逻辑触发入口"><a href="#3-2-逻辑触发入口" class="headerlink" title="3.2 逻辑触发入口"></a>3.2 逻辑触发入口</h3><p>在 Redis 触发重写机制的方式有 2 个</p><blockquote><ol><li>通过 bgrewriteaof 命令</li><li>定时器, 定时检查 AOF 文件, 如果满足配置文件里面设置的条件, 就触发</li></ol></blockquote><p>bgrewriteaof 命令方式对应的逻辑函数为 <strong>bgrewriteaofCommand</strong>, 里面的逻辑如下</p><blockquote><ol><li>如果已经在执行重写中了, 返回错误提示</li><li>如果当前正在执行 RDB 保存时, 只会先将 redisServer 中的 aof_rewrite_scheduled 属性设置为 true, 返回提示后, 结束, 后面通过定时器判断这个状态确定是否需要触发</li><li>调用 rewriteAppendOnlyFileBackground 执行重写</li></ol></blockquote><p>而定时器的触发代码如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 代码省略</span>    <span class="token comment">// 后台没有进程在 RDB 和 AOF, 同时通过 bgrewriteaof 命令设置了定时刷新重写 AOF  </span>    <span class="token comment">// 当用户调用 bgrewriteaof 命令时, Redis 正在 RDB, 会先将 aof_rewrite_scheduled 设置为 true, 然后返回, 而不是执行 AOF </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>aof_rewrite_scheduled<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">rewriteAppendOnlyFileBackground</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 后台有进程在 RDB 或者 AOF</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token function">ldbPendingChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 代码省略</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 代码省略</span>        <span class="token comment">// 1. 开启了 AOF 功能</span>        <span class="token comment">// 2. 后台没有进程在 RDB 和 AOF</span>        <span class="token comment">// 3. 配置了目前 AOF 文件大小超过上次重写的 AOF 文件的百分比</span>        <span class="token comment">// 4. 当前的 AOF 文件大小超过了配置的需要触发重写的最小大小</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_state <span class="token operator">==</span> AOF_ON <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span>            server<span class="token punctuation">.</span>aof_rewrite_perc <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>aof_current_size <span class="token operator">></span> server<span class="token punctuation">.</span>aof_rewrite_min_size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 计算当前的文件增长的比例</span>            <span class="token keyword">long</span> <span class="token keyword">long</span> base <span class="token operator">=</span> server<span class="token punctuation">.</span>aof_rewrite_base_size <span class="token operator">?</span> server<span class="token punctuation">.</span>aof_rewrite_base_size <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> <span class="token keyword">long</span> growth <span class="token operator">=</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_current_size<span class="token operator">*</span><span class="token number">100</span><span class="token operator">/</span>base<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">100</span><span class="token punctuation">;</span>              <span class="token comment">// 超过了就调用 rewriteAppendOnlyFileBackground 进行重写</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>growth <span class="token operator">>=</span> server<span class="token punctuation">.</span>aof_rewrite_perc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">rewriteAppendOnlyFileBackground</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 代码省略</span><span class="token punctuation">&#125;</span></code></pre><p>上面就是 AOF 重写触发的入口了, 而 AOF 重写的逻辑最终都是统一到了 <strong>rewriteAppendOnlyFileBackground</strong> 函数。</p><h3 id="3-3-具体的实现逻辑"><a href="#3-3-具体的实现逻辑" class="headerlink" title="3.3 具体的实现逻辑"></a>3.3 具体的实现逻辑</h3><h4 id="3-3-1-父进程执行-rewriteAppendOnlyFileBackground-函数-AOF-重写前的操作"><a href="#3-3-1-父进程执行-rewriteAppendOnlyFileBackground-函数-AOF-重写前的操作" class="headerlink" title="3.3.1 父进程执行 rewriteAppendOnlyFileBackground 函数, AOF 重写前的操作"></a>3.3.1 父进程执行 rewriteAppendOnlyFileBackground 函数, AOF 重写前的操作</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">rewriteAppendOnlyFileBackground</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> childpid<span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> start<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token comment">// 创建 Pipe 通道, 用于父子进程之间通信</span>    <span class="token comment">// 内部会创建父子通讯需要的 6 个 Pipe</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aofCreatePipes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span>         <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>      <span class="token comment">// 开通另一组通道, 不涉及主流程</span>    <span class="token comment">// 用于子进程向父子进程通讯, 在 AOF 中主要用于通知父进程, 子进程此次重写使用了多少额外内存</span>    <span class="token function">openChildInfoPipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取当前时间</span>    start <span class="token operator">=</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>childpid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 子进程 </span>        <span class="token comment">// fork 完成, 子进程, 从这里开始执行逻辑</span>        <span class="token comment">// 清除子进程不需要的资源</span>        <span class="token function">closeClildUnusedResourceAfterFork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置标题</span>        <span class="token function">redisSetProcTitle</span><span class="token punctuation">(</span><span class="token string">"redis-aof-rewrite"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 创建临时文件, 文件名 temp-rewriteaof-bg-进程ID.aof</span>        <span class="token function">snprintf</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">,</span><span class="token string">"temp-rewriteaof-bg-%d.aof"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 执行 rewriteAppendOnlyFile 函数, 进行 AOF 文件的重写 </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rewriteAppendOnlyFile</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 子进程重写完成的一些收尾工作, 基本不涉及主流程, 通知父进程过程中子进程修改了多少数据</span>            <span class="token comment">// 计算当前进程使用修改了多少内存</span>            <span class="token class-name">size_t</span> private_dirty <span class="token operator">=</span> <span class="token function">zmalloc_get_private_dirty</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>private_dirty<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span> <span class="token string">"AOF rewrite: %zu MB of memory used by copy-on-write"</span><span class="token punctuation">,</span> private_dirty<span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            server<span class="token punctuation">.</span>child_info_data<span class="token punctuation">.</span>cow_size <span class="token operator">=</span> private_dirty<span class="token punctuation">;</span>            <span class="token comment">// 子进程的信息发送给父进程, 也就是拷贝到 server.child_info_pipe[2] 中</span>            <span class="token function">sendChildInfo</span><span class="token punctuation">(</span>CHILD_INFO_TYPE_AOF<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 结束</span>            <span class="token function">exitFromChild</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token function">exitFromChild</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 父进程</span>        <span class="token comment">// fork 完成, 父进程, 从这里开始执行逻辑</span>        <span class="token comment">// 计算 fork 消耗的时间</span>        server<span class="token punctuation">.</span>stat_fork_time <span class="token operator">=</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start<span class="token punctuation">;</span>        <span class="token comment">// 计算 fork 的速率，GB/每秒</span>        server<span class="token punctuation">.</span>stat_fork_rate <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000000</span> <span class="token operator">/</span> server<span class="token punctuation">.</span>stat_fork_time <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 延迟统计</span>        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">,</span>server<span class="token punctuation">.</span>stat_fork_time<span class="token operator">/</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>childpid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// fork 失败 关闭通道</span>            <span class="token function">closeChildInfoPipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Can't rewrite append only file in background: fork: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">aofClosePipes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"Background append only file rewriting started by pid %d"</span><span class="token punctuation">,</span>childpid<span class="token punctuation">)</span><span class="token punctuation">;</span>                server<span class="token punctuation">.</span>aof_rewrite_scheduled <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>aof_rewrite_time_start <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">=</span> childpid<span class="token punctuation">;</span>        <span class="token comment">// 和 RDB 类似, 更新全局的 dict.dict_can_resize 进行字典扩容的控制, 控制存储数据的 dict 扩容</span>        <span class="token function">updateDictResizePolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>aof_selected_db <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 清空 redisServer 的 repl_scriptcache_dict 字典和 repl_scriptcache_fifo 这个列表</span>        <span class="token comment">// 和主从复制相关</span>        <span class="token function">replicationScriptCacheFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="3-3-2-子进程执行的-rewriteAppendOnlyFile-函数就是-AOF-重写真正过程"><a href="#3-3-2-子进程执行的-rewriteAppendOnlyFile-函数就是-AOF-重写真正过程" class="headerlink" title="3.3.2 子进程执行的 rewriteAppendOnlyFile 函数就是 AOF 重写真正过程"></a>3.3.2 子进程执行的 rewriteAppendOnlyFile 函数就是 AOF 重写真正过程</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 这里的入参 filename 格式为 temp-rewriteaof-bg-进程 ID, 而不是真正的 AOF 文件名</span><span class="token keyword">int</span> <span class="token function">rewriteAppendOnlyFile</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    rio aof<span class="token punctuation">;</span>    FILE <span class="token operator">*</span>fp<span class="token punctuation">;</span>    <span class="token keyword">char</span> tmpfile<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> byte<span class="token punctuation">;</span>    <span class="token comment">// 重新根据进程ID 获取一个文件名 temp-rewriteaof-进程ID.aof 的文件</span>    <span class="token comment">// 数据先写入到这个文件, 后面在重命名为入参的 filename</span>    <span class="token function">snprintf</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">,</span><span class="token string">"temp-rewriteaof-%d.aof"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 清空 aof_child_diff 的数据, 这个就是 AOF 子进程差异缓冲区</span>    server<span class="token punctuation">.</span>aof_child_diff <span class="token operator">=</span> <span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 初始 rio 流, 也就是 IO 流, 用于写入数据到文件</span>    <span class="token function">rioInitWithFile</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>aof<span class="token punctuation">,</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置文件自动同步</span>    <span class="token comment">// 当写入的字节数达到了 REDIS_AUTOSYNC_BYTES (1024*1024*32) 的倍数, 就执行一次 fsync,</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_rewrite_incremental_fsync<span class="token punctuation">)</span>        <span class="token function">rioSetAutoSync</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>aof<span class="token punctuation">,</span>REDIS_AUTOSYNC_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Redis 4.0 的特性, AOF 和 RDB 混用</span>    <span class="token comment">// 先将当前的数据以 RDB 的格式存储下来, 添加的这段时间, 在缓冲区的再以 AOF 的方式存储</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_use_rdb_preamble<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> error<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveRio</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>error<span class="token punctuation">,</span>RDB_SAVE_AOF_PREAMBLE<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            errno <span class="token operator">=</span> error<span class="token punctuation">;</span>            <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 将当前 Redis 内存数据库中的数据写入到 AOF 文件中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rewriteAppendOnlyFileRio</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>aof<span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// 当前的内存数据库的数据都写入完成</span>    <span class="token comment">// 执行 fflush 函数, 更新缓存中的数据到文件中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fflush</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>      <span class="token comment">// 执行 fsync 函数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fsync</span><span class="token punctuation">(</span><span class="token function">fileno</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token keyword">int</span> nodata <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">mstime_t</span> start <span class="token operator">=</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 尽量 将内存数据写入到 AOF 临时文件过程中 产生的差异命令同步过来</span>    <span class="token comment">// 当前时间和重写的开始时间差在 1 秒内, 同时没有连续 20 次读取到空数据</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start <span class="token operator">&lt;</span> <span class="token number">1000</span> <span class="token operator">&amp;&amp;</span> nodata <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 尝试从通道 aof_pipe_read_data_from_parent 也就是重写缓冲区中读取数据, 每次阻塞 1 毫秒</span>        <span class="token comment">// 读取到的数据长度小于等于 0, 进入下一次循环, 为读取到数据次数 + 1</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeWait</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_pipe_read_data_from_parent<span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            nodata<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        nodata <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment">// 从重写缓冲区读数据到 aof_child_diff</span>        <span class="token function">aofReadDiffFromParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 写入一个 ！ 到 aof_pipe_write_ack_to_parent, 通过通道间接同步到父级的 aof_pipe_read_ack_from_child</span>    <span class="token comment">// 请求父进程停止发送差异数据, 也就是重写缓冲区</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">write</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_pipe_write_ack_to_parent<span class="token punctuation">,</span><span class="token string">"!"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token comment">// 将从父级读取 ack 的 aof_pipe_read_ack_from_parent 设置为非阻塞的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">anetNonBlock</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>server<span class="token punctuation">.</span>aof_pipe_read_ack_from_parent<span class="token punctuation">)</span> <span class="token operator">!=</span> ANET_OK<span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token comment">// 在 5000ms 之内，从 aof_pipe_read_ack_from_parent 读取 1 个字节的数据保存在 byte 中, 同时判断 byte 是否为 '!'</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">syncRead</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_pipe_read_ack_from_parent<span class="token punctuation">,</span><span class="token operator">&amp;</span>byte<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5000</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span> <span class="token operator">||</span> byte <span class="token operator">!=</span> <span class="token char">'!'</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"Parent agreed to stop sending diffs. Finalizing AOF..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 此时父进程不会在同步差异命令过来了, 再做最后一次同步, 将 Pipe 通道中残留的数据同步过来</span>    <span class="token comment">// 再次从父级中读取差异数据</span>    <span class="token function">aofReadDiffFromParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span> <span class="token string">"Concatenating %.2f MB of AOF diff received from parent."</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_diff<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将 aof_child_diff 中的数据写入到 aof 文件中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>aof<span class="token punctuation">,</span>server<span class="token punctuation">.</span>aof_child_diff<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_diff<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fflush</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fsync</span><span class="token punctuation">(</span><span class="token function">fileno</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token comment">// 重命名文件名</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rename</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span>filename<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Error moving temp append only file on the final destination: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">unlink</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"SYNC append only file rewrite performed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>werr<span class="token operator">:</span>    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Write error writing append only file on disk: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unlink</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span></code></pre><p><strong>子进程将自身内存数据库中的数据写入到 AOF 临时文件的逻辑</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 将 Redis 数据库中的数据都写入到文件 * 原理就是变量数据库中的数据, 然后将每个 key 和 key 对应的 value 写入到文件中 * 同时为较小文件的大小, 会使用批量相关的命令来替代单个命令 * 比如向 list 类型的结构添加数据, 可以通过 lset 一个一个元素的添加, 也可以通过 RPUSH 一次添加多个 * 所以 Redis AOF 文件能缩小的原因就是这个 *  * 同时内部为了安全性, 单个批量命令内部的元素会控制不超过 AOF_REWRITE_ITEMS_PER_CMD 64 个 */</span><span class="token keyword">int</span> <span class="token function">rewriteAppendOnlyFileRio</span><span class="token punctuation">(</span>rio <span class="token operator">*</span>aof<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    dictIterator <span class="token operator">*</span>di <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> processed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token comment">// 逐个遍历所有的数据库</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> selectcmd<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"*2\r\n$6\r\nSELECT\r\n"</span><span class="token punctuation">;</span>        redisDb <span class="token operator">*</span>db <span class="token operator">=</span> server<span class="token punctuation">.</span>db<span class="token operator">+</span>j<span class="token punctuation">;</span>        dict <span class="token operator">*</span>d <span class="token operator">=</span> db<span class="token operator">-></span>dict<span class="token punctuation">;</span>        <span class="token comment">// 对应的数据库没有数据, 跳过</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dictSize</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token comment">// 字典迭代器</span>        di <span class="token operator">=</span> <span class="token function">dictGetSafeIterator</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 向文件中写入 *2\r\n$6\r\nSELECT\r\n数据库的编号的长度\r\n数据库的编号, 也就是 select 数据库</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWrite</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span>selectcmd<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>selectcmd<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkLongLong</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>de <span class="token operator">=</span> <span class="token function">dictNext</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                sds keystr<span class="token punctuation">;</span>            robj key<span class="token punctuation">,</span> <span class="token operator">*</span>o<span class="token punctuation">;</span>            <span class="token keyword">long</span> <span class="token keyword">long</span> expiretime<span class="token punctuation">;</span>            keystr <span class="token operator">=</span> <span class="token function">dictGetKey</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>            o <span class="token operator">=</span> <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 将字符串的 key 转为 redisObject 对象, 编码 encoding 默认为 OBJ_ENCODING_RAW, 引用次数 refcount 为 1</span>            <span class="token function">initStaticStringObject</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>keystr<span class="token punctuation">)</span><span class="token punctuation">;</span>                    expiretime <span class="token operator">=</span> <span class="token function">getExpire</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>type <span class="token operator">==</span> OBJ_STRING<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">char</span> cmd<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"*3\r\n$3\r\nSET\r\n"</span><span class="token punctuation">;</span>                <span class="token comment">// 写入上面的文本</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWrite</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span>cmd<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>                <span class="token comment">// 写入 key </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>                <span class="token comment">// 写入 value</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span>o<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>type <span class="token operator">==</span> OBJ_LIST<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rewriteListObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">,</span>o<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>type <span class="token operator">==</span> OBJ_SET<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 下面的几个写入和 list 类型跳过</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rewriteSetObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">,</span>o<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>type <span class="token operator">==</span> OBJ_ZSET<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rewriteSortedSetObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">,</span>o<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>type <span class="token operator">==</span> OBJ_HASH<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rewriteHashObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">,</span>o<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>type <span class="token operator">==</span> OBJ_STREAM<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rewriteStreamObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">,</span>o<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>type <span class="token operator">==</span> OBJ_MODULE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rewriteModuleObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">,</span>o<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">"Unknown object type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                        <span class="token comment">// 如果 key 设置了过期时间, 写入过期时间</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>expiretime <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">char</span> cmd<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"*3\r\n$9\r\nPEXPIREAT\r\n"</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWrite</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span>cmd<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkLongLong</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span>expiretime<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// AOF_READ_DIFF_INTERVAL_BYTES = 1024*10</span>            <span class="token comment">// 重写文件每写入 10 M,  就通过通道从父级中读取差异</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>aof<span class="token operator">-></span>processed_bytes <span class="token operator">></span> processed <span class="token operator">+</span> AOF_READ_DIFF_INTERVAL_BYTES<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 更新已写的字节数</span>                processed <span class="token operator">=</span> aof<span class="token operator">-></span>processed_bytes<span class="token punctuation">;</span>                <span class="token comment">// 通过通道 aof_pipe_read_data_from_parent 将重写缓冲区中的数据读取到 aof_child_diff 中</span>                <span class="token function">aofReadDiffFromParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>werr<span class="token operator">:</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>di<span class="token punctuation">)</span>        <span class="token function">dictReleaseIterator</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// list 类型的数据写入</span><span class="token keyword">int</span> <span class="token function">rewriteListObject</span><span class="token punctuation">(</span>rio <span class="token operator">*</span>r<span class="token punctuation">,</span> robj <span class="token operator">*</span>key<span class="token punctuation">,</span> robj <span class="token operator">*</span>o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> items <span class="token operator">=</span> <span class="token function">listTypeLength</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>encoding <span class="token operator">==</span> OBJ_ENCODING_QUICKLIST<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            quicklist <span class="token operator">*</span>list <span class="token operator">=</span> o<span class="token operator">-></span>ptr<span class="token punctuation">;</span>        quicklistIter <span class="token operator">*</span>li <span class="token operator">=</span> <span class="token function">quicklistGetIterator</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> AL_START_HEAD<span class="token punctuation">)</span><span class="token punctuation">;</span>        quicklistEntry entry<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">quicklistNext</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span><span class="token operator">&amp;</span>entry<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token comment">// 获取当前  rpush 的元素个数, 最大为 AOF_REWRITE_ITEMS_PER_CMD 64 个</span>                <span class="token keyword">int</span> cmd_items <span class="token operator">=</span> <span class="token punctuation">(</span>items <span class="token operator">></span> AOF_REWRITE_ITEMS_PER_CMD<span class="token punctuation">)</span> <span class="token operator">?</span>  AOF_REWRITE_ITEMS_PER_CMD <span class="token operator">:</span> items<span class="token punctuation">;</span>                <span class="token comment">// 写入参数个数 *参数个数</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkCount</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span><span class="token char">'*'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">+</span>cmd_items<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">// 写入 rpush 命令</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkString</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span><span class="token string">"RPUSH"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">// 写入 key 值</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkObject</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 依次写入元素</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkString</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>entry<span class="token punctuation">.</span>value<span class="token punctuation">,</span>entry<span class="token punctuation">.</span>sz<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkLongLong</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>entry<span class="token punctuation">.</span>longval<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 写入一次 count + 1 次, 当 count == 上限的 64 个, 重新值为 0</span>            <span class="token comment">// 从而可以重新写入一个 rpush</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>count <span class="token operator">==</span> AOF_REWRITE_ITEMS_PER_CMD<span class="token punctuation">)</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            items<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">quicklistReleaseIterator</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">"Unknown list encoding"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>整个 AOF 重写的因为涉及到了子进程, 所以复杂度就上去了, 整理如下:</p><p>父进程</p><blockquote><ol><li>定时器判断满足重写条件或者执行了 bgrewriteaof 命令, 触发 AOF 重写</li><li>父进程创建出 6 个文件描述符, 用来创建 6 个通道, 分别用于: 父进程将数据写给子进程, 子进程通知父进程 ack, 父进程通知子进程 ack</li><li>创建完通道后, 设置 aof_stop_sending_diff 为 0, 也就是 false, 表示可以将重写缓冲区的数据继续推送给子进程</li><li>父进程 fork 出一个子进程, 然后进行一些统计相同的配置后, 进行处理其他的命令 (此处是子进程的开始地方)</li><li>父进程处理到修改性质的命令时, 依旧是会进行把当前命令的变更写的已有的 AOF 文件中, 同时判断到当前在进行 AOF 重写, 会把当前命令对应的文本保存到 AOF 重写缓存区  aof_rewrite_buf_blocks</li><li>判断当前的 AE 循环中是否有 aof_pipe_write_data_to_child 这个文件描述符 (这个就是上面 6 个文件描述符之一) 对应的文件, 没有则创建 1 个文件, 执行的逻辑为 aofChildWriteDiffData</li><li>因为有事件存在, 每次 AE 循环时, 都会执行到 aofChildWriteDiffData 函数, 逻辑就是将 AOF 重写缓存区 aof_rewrite_buf_blocks 中的数据全部写到 aof_pipe_write_data_to_child 中, 同时在 aof_stop_sending_diff 为 true 或者 aof_rewrite_buf_blocks 中的数据转移完成时, 删除这个事件。写入到 aof_pipe_write_data_to_child 的数据在通道的作用下, 会自动同步到子进程的 aof_pipe_read_data_from_parent 中</li></ol></blockquote><p>上面就是父进程的逻辑, 下面的子进程的逻辑  </p><blockquote><ol><li>因为子进程是通过 fork 操作创建出来的, 所以子进程和父进程是完全一样的, 也就是当前子进程拥有着和父进程一样的字典, 存放着所有键值对的数据, 同时不受父进程的影响, 也就是快照</li><li>临时创建出一个 temp-rewriteaof-bg-进程ID.aof 文件, 用来保存当前的数据</li><li>判断 server.aof_use_rdb_preamble 是否为 true, 也就是是否开启了 RDB 和 AOF 混用的功能, 开启了, 就先将当前的数据字典的数据以 RDB 的方式进行保存, 否则就是根据数据字典执行命令重写</li><li>命令重写的逻辑: 用批量相关的命令来替代单个命令, 同时在执行的过程中不断的将 aof_pipe_read_data_from_parent 中的数据读取到自身的 aof_child_diff 中</li><li>数据字典中的数据都处理完成后, 子进程向 aof_pipe_write_ack_to_parent 写入一个 !, 在通道的同步下, 同步到父进程的 aof_pipe_read_ack_from_child 中 (父级收到了, 先将 aof_stop_sending_diff 设置为 true, 向 aof_pipe_write_ack_to_child 写入了一个 ！, 同样在管道的同步下, 最终到了子进程的 aof_pipe_read_ack_from_parent, 最后删除这个 aof_pipe_read_ack_from_child 描述符的事件)</li><li>向 aof_pipe_write_ack_to_parent 写入 ! 后, 等待 5000ms, 从 aof_pipe_read_ack_from_parent 中读取数据, 超时读取, 读取到的不是 !, 异常处理, 结束</li><li>从 aof_pipe_read_ack_from_parent 读取到了 ！, 表示读取到了父级的确认 ack, 最后一次从 aof_pipe_read_data_from_parent 读取数据到 aof_child_diff, 确保在文件描述符中没有父进程写向子进程的数据了</li><li>把 aof_child_diff 中的数据追加到临时的 AOF 文件中</li><li>通过 rename 函数将临时文件重命名为配置的入参的文件名 (AOF 重写入参的文件名为: temp-rewriteaof-bg-进程ID.aof,  rename 函数会先将同名的文件, 文件夹删除)</li></ol></blockquote><p>从上面的过程中看起来, 好像完美了, 但是别忘了这里涉及到了并发, 在父子进程互相 ack 确认时, 父进程收到 ack 时, 只是把 aof_stop_sending_diff 设置为 true, 也就是确保 AOF 重写缓存区的数据不会再写给子进程。<br>而子进程收到 ack, 只是把当前所有的 AOF 重写缓存区中的数据写入到文件中, 子进程自己的任务到此就结束了。  </p><p>而这个过程, 父进程还会继续处理其他的命令, 这些新的命令只能由父进程自己处理</p><blockquote><ol><li>将当前 AOF 重写缓存区中的数据写入到 AOF 临时文件</li><li>重命名 AOF 临时文件, 整个 AOF 重写正式完成</li></ol></blockquote><h4 id="3-3-3-父进程监听子进程结束-AOF-重写收尾"><a href="#3-3-3-父进程监听子进程结束-AOF-重写收尾" class="headerlink" title="3.3.3 父进程监听子进程结束, AOF 重写收尾"></a>3.3.3 父进程监听子进程结束, AOF 重写收尾</h4><p>首先入口, 还是在定时器 serveCron 中, 定时的检查子进程的状态是否为结束了, 是的话, 执行结束逻辑</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 检查是否有 RDB 子进程或者 AOF 重写子进程结束了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token function">ldbPendingChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> statloc<span class="token punctuation">;</span>        <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>                <span class="token comment">// wait3 可以获取所有的进程是否有一个进程退出状态的, 有的话, 进行彻底的销毁，同时返回其进程 id</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">wait3</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>statloc<span class="token punctuation">,</span>WNOHANG<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> exitcode <span class="token operator">=</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>statloc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> bysignal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFSIGNALED</span><span class="token punctuation">(</span>statloc<span class="token punctuation">)</span><span class="token punctuation">)</span>                 bysignal <span class="token operator">=</span> <span class="token function">WTERMSIG</span><span class="token punctuation">(</span>statloc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 异常情况, 打印日志</span>                <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"wait3() returned an error: %s. rdb_child_pid = %d, aof_child_pid = %d"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> server<span class="token punctuation">.</span>rdb_child_pid<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> server<span class="token punctuation">.</span>aof_child_pid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> server<span class="token punctuation">.</span>rdb_child_pid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// rdb 进程逻辑省略</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> server<span class="token punctuation">.</span>aof_child_pid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 进程 id 为 AOF 重写进程 id</span>                <span class="token comment">// 执行最终的清除逻辑</span>                <span class="token function">backgroundRewriteDoneHandler</span><span class="token punctuation">(</span>exitcode<span class="token punctuation">,</span>bysignal<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bysignal <span class="token operator">&amp;&amp;</span> exitcode <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                     <span class="token comment">// 获取子进程发送给父进程的信息</span>                    <span class="token function">receiveChildInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 其他的情况</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ldbRemoveChild</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Warning, detected child with unmatched pid: %ld"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>              <span class="token comment">// 重新设置字典的可以扩容标识为 true</span>            <span class="token function">updateDictResizePolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 关闭 Pipe </span>            <span class="token function">closeChildInfoPipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 判断是否需要进行 RDB 或者 AOF 重写</span>        <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span><span class="token comment">// 父进程对 AOF 重写最后的处理</span><span class="token keyword">void</span> <span class="token function">backgroundRewriteDoneHandler</span><span class="token punctuation">(</span><span class="token keyword">int</span> exitcode<span class="token punctuation">,</span> <span class="token keyword">int</span> bysignal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// exitcode == 0 表示子进程是执行完逻辑后, 主动退出的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bysignal <span class="token operator">&amp;&amp;</span> exitcode <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> newfd<span class="token punctuation">,</span> oldfd<span class="token punctuation">;</span>        <span class="token keyword">char</span> tmpfile<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">mstime_t</span> latency<span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span> <span class="token string">"Background AOF rewrite terminated with success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 再次通过子进程的进程 ID 获取到 AOF 重写的临时文件名 temp-rewriteaof-bg-进程ID.aof, 也就是 AOF 重写临时文件</span>        <span class="token function">snprintf</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">,</span><span class="token string">"temp-rewriteaof-bg-%d.aof"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span>aof_child_pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打开文件</span>        newfd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span>O_WRONLY<span class="token operator">|</span>O_APPEND<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newfd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Unable to open the temporary AOF produced by the child: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 把最后剩余的信息从 aof_rewrite_buf_blocks 写入到指定的文件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aofRewriteBufferWrite</span><span class="token punctuation">(</span>newfd<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Error trying to flush the parent diff to the rewritten AOF: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">close</span><span class="token punctuation">(</span>newfd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"aof-rewrite-diff-write"</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"Residual parent diff successfully flushed to the rewritten AOF (%.2f MB)"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token function">aofRewriteBufferSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// aof_fd 为当前的 AOF 文件的文件描述符, 等于 -1, 应该是 AOF 功能停用了</span>        <span class="token comment">// 这时为了下面的流程能走下去, 从配置文件中获取到配置的文件名, 尝试打开禁用前的文件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            oldfd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_filename<span class="token punctuation">,</span>O_RDONLY<span class="token operator">|</span>O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            oldfd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将临时文件重命名为配置的文件名</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rename</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span>server<span class="token punctuation">.</span>aof_filename<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Error trying to rename the temporary AOF file %s into %s: %s"</span><span class="token punctuation">,</span> tmpfile<span class="token punctuation">,</span> server<span class="token punctuation">.</span>aof_filename<span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">close</span><span class="token punctuation">(</span>newfd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldfd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">close</span><span class="token punctuation">(</span>oldfd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"aof-rename"</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">close</span><span class="token punctuation">(</span>newfd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            oldfd <span class="token operator">=</span> server<span class="token punctuation">.</span>aof_fd<span class="token punctuation">;</span>            server<span class="token punctuation">.</span>aof_fd <span class="token operator">=</span> newfd<span class="token punctuation">;</span>            <span class="token comment">// 根据同步策略进行 fsync</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_ALWAYS<span class="token punctuation">)</span>                <span class="token function">redis_fsync</span><span class="token punctuation">(</span>newfd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_EVERYSEC<span class="token punctuation">)</span>                <span class="token function">aof_background_fsync</span><span class="token punctuation">(</span>newfd<span class="token punctuation">)</span><span class="token punctuation">;</span>            server<span class="token punctuation">.</span>aof_selected_db <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>             <span class="token comment">// 更新当前 AOF 文件的大小</span>            <span class="token function">aofUpdateCurrentSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 更新最新的 AOF 文件大小和重写大小</span>            server<span class="token punctuation">.</span>aof_rewrite_base_size <span class="token operator">=</span> server<span class="token punctuation">.</span>aof_current_size<span class="token punctuation">;</span>            server<span class="token punctuation">.</span>aof_fsync_offset <span class="token operator">=</span> server<span class="token punctuation">.</span>aof_current_size<span class="token punctuation">;</span>               <span class="token function">sdsfree</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            server<span class="token punctuation">.</span>aof_buf <span class="token operator">=</span> <span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>        server<span class="token punctuation">.</span>aof_lastbgrewrite_status <span class="token operator">=</span> C_OK<span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span> <span class="token string">"Background AOF rewrite finished successfully"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_state <span class="token operator">==</span> AOF_WAIT_REWRITE<span class="token punctuation">)</span>            server<span class="token punctuation">.</span>aof_state <span class="token operator">=</span> AOF_ON<span class="token punctuation">;</span>        <span class="token comment">// 关闭打开的文件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldfd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token function">bioCreateBackgroundJob</span><span class="token punctuation">(</span>BIO_CLOSE_FILE<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>oldfd<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_VERBOSE<span class="token punctuation">,</span><span class="token string">"Background AOF rewrite signal handler took %lldus"</span><span class="token punctuation">,</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bysignal <span class="token operator">&amp;&amp;</span> exitcode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 非正常退出</span>        server<span class="token punctuation">.</span>aof_lastbgrewrite_status <span class="token operator">=</span> C_ERR<span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Background AOF rewrite terminated with error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 非正常退出</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bysignal <span class="token operator">!=</span> SIGUSR1<span class="token punctuation">)</span>            server<span class="token punctuation">.</span>aof_lastbgrewrite_status <span class="token operator">=</span> C_ERR<span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Background AOF rewrite terminated by signal %d"</span><span class="token punctuation">,</span> bysignal<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>cleanup<span class="token operator">:</span>    <span class="token comment">// 清除工作</span>    <span class="token function">aofClosePipes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">aofRewriteBufferReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">aofRemoveTempFile</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>aof_rewrite_time_last <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token operator">-</span>server<span class="token punctuation">.</span>aof_rewrite_time_start<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>aof_rewrite_time_start <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_state <span class="token operator">==</span> AOF_WAIT_REWRITE<span class="token punctuation">)</span>        server<span class="token punctuation">.</span>aof_rewrite_scheduled <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">// AOF 重写缓冲区数据写入文件</span><span class="token class-name">ssize_t</span> <span class="token function">aofRewriteBufferWrite</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>    listIter li<span class="token punctuation">;</span>    <span class="token class-name">ssize_t</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_rewrite_buf_blocks<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        aofrwblock <span class="token operator">*</span>block <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ssize_t</span> nwritten<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>block<span class="token operator">-></span>used<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>block<span class="token operator">-></span>buf<span class="token punctuation">,</span>block<span class="token operator">-></span>used<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token class-name">ssize_t</span><span class="token punctuation">)</span>block<span class="token operator">-></span>used<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> errno <span class="token operator">=</span> EIO<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            count <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>到了这一步, 整个 AOF 的重写过程才真正的结束了。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><a href="https://blog.csdn.net/men_wen/article/details/71375513">Redis源码剖析和注释（十八）— Redis AOF持久化机制</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis AOF 基础</title>
      <link href="/article/2021/3668008816/"/>
      <url>/article/2021/3668008816/</url>
      
        <content type="html"><![CDATA[<p>因为 Redis AOF 的实现有些绕, 就分成 2 篇进行分析, 本篇主要是介绍一下 AOF 的一些特性和依赖的其他函数的逻辑,为下一篇 (Redis AOF 源码) 源码分析做一些铺垫。</p><p>AOF 全称: Append Only File, 是 Redis 提供了一种数据保存模式, Redis 默认不开启。<br>AOF 采用日志的形式来记录每个写操作, 并追加到文件。开启后, 执行更改 Redis 数据的命令时, 就会把命令写入到 AOF 文件中。<br>Redis 重启时会根据日志文件的内容把写指令从前到后执行一次以完成数据的恢复工作。</p><h2 id="1-AOF-相关的配置"><a href="#1-AOF-相关的配置" class="headerlink" title="1 AOF 相关的配置"></a>1 AOF 相关的配置</h2><pre class="language-bash" data-language="bash"><code class="language-bash">appendonly no                   <span class="token comment"># AOF 开关, 默认为关闭</span>appendfilename <span class="token string">"appendonly.aof"</span> <span class="token comment"># 保存的文件名</span>appendfsync everysec            <span class="token comment"># AOF 持久化策略 (硬盘缓存写入到硬盘) </span></code></pre><p>AOF 简单使用的话就这 3 个配置, 前 2 个就是字面的意思, 理解其他比较简单。<br>我们说明一下第三个配置的使用。</p><p>开启 AOF 后, 每次修改的命令都会存到 Redis 的一个<strong>缓存区</strong>。<br>缓存区的数据最终是需要写入到磁盘的, 而 Redis 是通过 <strong>write</strong> 函数, 将缓存中的数据写入到磁盘中。<br>但是 <strong>write</strong> 函数实际是先将数据先保存到<strong>系统层级的缓存</strong>, 后续由系统自身将数据保存到磁盘, 系统默认为 30 秒保存一次。这样的话, 可能有风险, 如果系统直接宕机了<br>可能会丢失 30 秒左右的数据, 所以系统提供了一个 <strong>fsync</strong> 函数, 可以把系统层级的缓存立即写入到磁盘中, 但是这是一个阻塞且缓慢的操作, 会影响到执行的线程。</p><p>所以上面的配置的第 3 项就是控制这个 Redis 缓存到磁盘的行为</p><blockquote><ol><li>everysec: AOF 默认的持久化策略。每秒执行一次 fsync, 可能导致丢失 1s 数据, 这种策略兼顾了安全性和效率</li><li>no: 表示不执行 fsync, 由操作系统保证数据同步到磁盘, 速度最快, 但是不太安全</li><li>always: 表示每次写入到执行 fsync, 保证数据同步到磁盘, 效率很低</li></ol></blockquote><p>除了上面的 3 个基础配置, 还有几个关于 AOF 执行中的行为配置</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 默认为 100</span><span class="token comment"># 当目前 AOF 文件大小超过上次重写的 AOF 文件的百分之多少进行重写 (重写的含义可以看下面的重写机制), 即当 AOF 文件增长到一定大小的时候, Redis 能够调用 bgrewriteaof 对日志文件进行重写</span>auto-aof-rewrite-percentag  <span class="token number">100</span><span class="token comment"># 默认为 64m</span><span class="token comment"># 设置允许重写的最小 AOF 文件大小, 避免达到约定百分比但占用的容量仍然很小的情况就重写</span>auto-aof-rewrite-min-size  64mb<span class="token comment"># 默认为 no</span><span class="token comment"># 在 AOF 重写时, 是否不要执行 fsync, 将缓存写入到磁盘, 默认为 no。</span><span class="token comment"># 如果对低延迟要求很高的应用, 这里可以设置为 yes, 否则设置为 no, 这样对持久化特性来说这是更安全的选择</span><span class="token comment"># 设置为 yes 表示重写期间对新的写操作不 fsync, 暂时存在内存中, 等重新操作完成后再写入</span><span class="token comment"># 默认为 no, 建议改为 yes, 因为 Linux 的默认 fsync 策略为 30 秒, 所以可能丢失 30 秒数据</span>no-appendfsync-on-rewrite  no<span class="token comment"># 默认为 yes</span><span class="token comment"># 当 Redis 启动的时候, AOF 文件的数据会被重新载入内存</span><span class="token comment"># 但是 AOF 文件可能在尾部是不完整的, 比如突然的断电宕机什么的, 可能导致 AOF 文件数据不完整</span><span class="token comment"># 对于不完整的 AOF 文件如何处理</span><span class="token comment"># 配置为 yes, 当截断的 AOF 文件被导入的时候, 会自动发布一个 log 给客户端, 然后继续加载文件中的数据</span><span class="token comment"># 配置为 no, 用户必须手动 redis-check-aof 修复 AOF 文件才可以</span>aof-load-truncated <span class="token function">yes</span></code></pre><h2 id="2-AOF-重写机制"><a href="#2-AOF-重写机制" class="headerlink" title="2 AOF 重写机制"></a>2 AOF 重写机制</h2><p>上面的配置中有好几个提示到<strong>重写</strong>的概念, 那么什么是重写呢?  </p><p>由于 AOF 持久化是 Redis 不断将写命令记录到 AOF 文件中, 随着 Redis 不断的运行, AOF 文件将会越来越大, 占用服务器磁盘越来越大, 同时 AOF 恢复要求时间越长。  </p><p>为了解决这个问题, Redis 新增了重写机制, 当 AOF 文件的大小超过了所设定的阈值时, Redis 就会自动启动 AOF 文件的内容压缩, 只保留可以恢复数据的最小指令集。<br>AOF 文件不是对原文件进行整理, 而是直接读取服务器现有的键值对, 然后用一条命令去代替之前记录这个键值对的多条命令, 生成一个新的文件替换原来的 AOF 文件。  </p><p>用户可以通过 <strong>bgrewriteaof</strong> 命令来手动触发 AOF 文件的重写, 这个重写的过程也是通过子进程实现的。<br>在子进程进行 AOF 重写时, 主线程需要保证</p><blockquote><ol><li>处理客户端的请求</li><li>将新增和更新命令追加到现有的 AOF 文件中</li><li>将新增和更新命令追加到 AOF 重写缓存中</li></ol></blockquote><h2 id="3-AOF-文件的优势和劣势"><a href="#3-AOF-文件的优势和劣势" class="headerlink" title="3 AOF 文件的优势和劣势"></a>3 AOF 文件的优势和劣势</h2><p>优势  </p><blockquote><ol><li>AOF 持久化的方法提供了多种的同步频率, 即使使用默认的同步频率每秒同步一次, Redis 最多也就丢失 1 秒的数据而已</li><li>AOF 日志文件以 append-only 模式写入, 所以没有任何磁盘寻址的开销, 写入性能非常高, 而且文件不容易受损, 即使文件尾部受损, 也能很容易恢复, 打开文件, 把后面损坏的数据删除即可</li></ol></blockquote><p>劣势  </p><blockquote><ol><li>对于具有相同数据的的 Redis, AOF 文件通常会比 RDF 文件体积更大 (RDB 存的是数据快照) </li><li>虽然 AOF 提供了多种同步的频率, 默认情况下, 每秒同步一次的频率也具有较高的性能。但是在高并发的情况下, RDB 比 AOF 具好更好的性能保证</li></ol></blockquote><h2 id="4-AOF-和-RDB-两种方案比较"><a href="#4-AOF-和-RDB-两种方案比较" class="headerlink" title="4 AOF 和 RDB  两种方案比较"></a>4 AOF 和 RDB  两种方案比较</h2><p>如果可以忍受一小段时间内数据的丢失, 使用 RDB 是最好的, 定时生成 RDB 快照 (snapshot) 非常便于进行数据库备份, 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快, 否则使用 AOF。  </p><p>但是一般情况下建议不要单独使用某一种持久化机制, 而是应该两种一起用, 在这种情况下, 当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据, 因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</p><p>在 Redis 4.0 带来了一个新的持久化选项 —— 混合持久化。将 RDB 文件的内容和增量的 AOF 日志文件存在一起。<br>这里的 AOF 日志不再是全量的日志, 而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志, 通常这部分 AOF 日志很小。</p><p>在 Redis 重启的时候, 可以先加载 RDB 的内容, 然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放, 重启效率因此大幅得到提升。</p><h2 id="5-AOF-的过程"><a href="#5-AOF-的过程" class="headerlink" title="5 AOF 的过程"></a>5 AOF 的过程</h2><p>高度概括如下: </p><blockquote><ol><li>所有的修改命令会追加到 Redis 的一个 AOF 缓存区</li><li>AOF 缓存区根据配置的策略向硬盘做同步操作</li><li>随着 AOF 文件越来越大, 达到配置的条件, 对 AOF 文件进行重写, 达到压缩的目的</li></ol></blockquote><p>到此, AOF 的理论知识就没了, 下面是介绍几个比较重要的函数的逻辑。</p><h2 id="6-AOF-文件结构"><a href="#6-AOF-文件结构" class="headerlink" title="6 AOF 文件结构"></a>6 AOF 文件结构</h2><p>如果现在向 Redis 中写入一个 key 为 redis-key, value 为 redis-value 的字符串键值对后, 这对键值对会以下面的格式保存在 AOF 文件中:</p><pre class="language-none"><code class="language-none">*3\r\n$3\r\nset\r\n$9\r\nredis-key\r\n$11\r\nredis-value\r\n</code></pre><p>以 <code>*数字</code> 的格式开始, 表示后面的命令的参数个数, 然后通过 <code>$数字</code> 表示后面参数的长度, 然后各个分隔之间通过 <code>\r\n</code> 进行分隔。 </p><p>整体的格式就是 Redis 自定义的 RESP 协议, 具体的 RESP 介绍, 可以看一下这篇<a href="https://blog.csdn.net/ldw201510803006/article/details/126093440">文章</a>。</p><p>可以看到这种文本格式具有很高的可读性, 同时可以直接进行修改。</p><p>注: Redis 中有多个数据库, 写入的数据是保存在哪个数据库的?<br>在写入对应的数据库数据时, 内部会自动插入一条 <strong>select 数据库的编号</strong> 的命令到 AOF 文件, 表明对应的数据库, 解析时也是通过这条命令切换到对应的数据库。</p><p>源码中将 key 和 value 转换为上面的文件格式的实现是由 2 个函数实现的: catAppendOnlyGenericCommand 和 catAppendOnlyExpireAtCommand, 前者处理的是正常的命令, 而后者处理的是命令的过期时间。</p><h3 id="6-1-catAppendOnlyGenericCommand-没有过期时间的命令"><a href="#6-1-catAppendOnlyGenericCommand-没有过期时间的命令" class="headerlink" title="6.1 catAppendOnlyGenericCommand - 没有过期时间的命令"></a>6.1 catAppendOnlyGenericCommand - 没有过期时间的命令</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 将入参的参数转为 RESP 格式写入到入参的 dst * @param dst 当前未写入到文件的命令文本, 新的命令会追加到这个的后面 * @param argc 命令参数的个数 * @param argv 命令参数, 比如 set key value */</span>sds <span class="token function">catAppendOnlyGenericCommand</span><span class="token punctuation">(</span>sds dst<span class="token punctuation">,</span> <span class="token keyword">int</span> argc<span class="token punctuation">,</span> robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    robj <span class="token operator">*</span>o<span class="token punctuation">;</span>    <span class="token comment">// 上面的 set redis-key redis-value, 按照 RESP 协议转换的内容如下</span>    <span class="token comment">// *3\r\n$3\r\nset\r\n$9\r\nredis-key\r\n$11\r\nredis-value\r\n</span>    <span class="token comment">// 这里面可以拆为 2 部分处理 </span>    <span class="token comment">// 1. *3\r\n  --> 命令的参数个数</span>    <span class="token comment">// 2. $3\r\nset\r\n$9\r\nredis-key\r\n$11\r\nredis-value\r\n  --> 具体的命令</span>    <span class="token comment">// 1. 处理命令的参数个数部分</span>        <span class="token comment">// 命令开始的前缀为 *</span>    buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'*'</span><span class="token punctuation">;</span>    <span class="token comment">// argc 表示的是写入命令的个数, 经过这一步 buf = *参数个数</span>    len <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">+</span><span class="token function">ll2string</span><span class="token punctuation">(</span>buf<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>argc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 追加 \r\n, 到了这一步 经过这一步 buf = *参数个数\r\n</span>    buf<span class="token punctuation">[</span>len<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\r'</span><span class="token punctuation">;</span>    buf<span class="token punctuation">[</span>len<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>    <span class="token comment">// 先将处理的文本第一步拼接到 dst 的后面, 此时 dst = *参数个数\r\n</span>    dst <span class="token operator">=</span> <span class="token function">sdscatlen</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 处理具体的命令</span>    <span class="token comment">// 拼接参数列表</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 将对应的参数转为字符串类型</span>        o <span class="token operator">=</span> <span class="token function">getDecodedObject</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'$'</span><span class="token punctuation">;</span>        <span class="token comment">// 将命令的长度写入到 buf 中</span>        len <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">+</span><span class="token function">ll2string</span><span class="token punctuation">(</span>buf<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>o<span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 继续在后面拼接 \r\n, 到这一步 buf = $命令的长度\r\n</span>        buf<span class="token punctuation">[</span>len<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\r'</span><span class="token punctuation">;</span>        buf<span class="token punctuation">[</span>len<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>        <span class="token comment">// 同样将 $命令的长度\r\n 写入到 dst</span>        dst <span class="token operator">=</span> <span class="token function">sdscatlen</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将当前的命令具体的内容 写入到 dst</span>        dst <span class="token operator">=</span> <span class="token function">sdscatlen</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span>o<span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>o<span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 在 dist 后面追加一个 \r\n</span>        dst <span class="token operator">=</span> <span class="token function">sdscatlen</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span><span class="token string">"\r\n"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 经过一次循环, dist 里面多了一段 $命令的长度\r\n命令\r\n 的内容</span>        <span class="token comment">// 引用此数 - 1</span>        <span class="token function">decrRefCount</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dst<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 如果入参的对象是 raw 或者 embstr 编码, 引用次数 + 1 * 如果为 int 编码, 根据这个整数创建出一个字符串, 同时返回这个字符串 * 其他类型不会处理 */</span>robj <span class="token operator">*</span><span class="token function">getDecodedObject</span><span class="token punctuation">(</span>robj <span class="token operator">*</span>o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    robj <span class="token operator">*</span>dec<span class="token punctuation">;</span>    <span class="token comment">// 判断一个对象的编码是否为 OBJ_ENCODING_EMBSTR 或者 OBJ_ENCODING_RAW</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sdsEncodedObject</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 对象的引用次数还没达到最大值时, 进行引用次数 + 1</span>        <span class="token function">incrRefCount</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> o<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 是字符串类型同时编码为 OBJ_ENCODING_INT</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>type <span class="token operator">==</span> OBJ_STRING <span class="token operator">&amp;&amp;</span> o<span class="token operator">-></span>encoding <span class="token operator">==</span> OBJ_ENCODING_INT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 整形转为 char 数组</span>        <span class="token function">ll2string</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>o<span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 转为字符串</span>        dec <span class="token operator">=</span> <span class="token function">createStringObject</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dec<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">"Unknown encoding type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-7-2-catAppendOnlyExpireAtCommand-带过期时间的命令"><a href="#2-7-2-catAppendOnlyExpireAtCommand-带过期时间的命令" class="headerlink" title="2.7.2 catAppendOnlyExpireAtCommand - 带过期时间的命令"></a>2.7.2 catAppendOnlyExpireAtCommand - 带过期时间的命令</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 将入参的过期时间转为 RESP 格式的字符串并存入 buf * @param buf 当前未写入到文件的命令文本, 新的命令会追加到这个的后面, 同时将命令修改为 pexpireat 的格式 * @param cmd 执行的命令 * @param key redis 的 key 值 * @param second 过期的时间, 单位秒 */</span>sds <span class="token function">catAppendOnlyExpireAtCommand</span><span class="token punctuation">(</span>sds buf<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">,</span> robj <span class="token operator">*</span>key<span class="token punctuation">,</span> robj <span class="token operator">*</span>seconds<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> when<span class="token punctuation">;</span>    robj <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 转为字符串类型, 以便使用 strtoll 函数</span>    seconds <span class="token operator">=</span> <span class="token function">getDecodedObject</span><span class="token punctuation">(</span>seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 根据指定的进制将入参的 char 数组转为一个整数, 10 --> 10 进制</span>    <span class="token comment">// 得到过期的时间</span>    when <span class="token operator">=</span> <span class="token function">strtoll</span><span class="token punctuation">(</span>seconds<span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 当前执行的命令为 expire, setex expireat 将参数的秒转换成毫秒</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd<span class="token operator">-></span>proc <span class="token operator">==</span> expireCommand <span class="token operator">||</span> cmd<span class="token operator">-></span>proc <span class="token operator">==</span> setexCommand <span class="token operator">||</span> cmd<span class="token operator">-></span>proc <span class="token operator">==</span> expireatCommand<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        when <span class="token operator">*=</span> <span class="token number">1000</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将 expire, setex expireat 命令的参数，从相对时间设置为绝对时间</span>    <span class="token comment">// 以前可能是 10s 后过期, 经过这一步，得到的是 xxx 年 yyy 月 的具体时间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd<span class="token operator">-></span>proc <span class="token operator">==</span> expireCommand <span class="token operator">||</span> cmd<span class="token operator">-></span>proc <span class="token operator">==</span> pexpireCommand <span class="token operator">||</span> cmd<span class="token operator">-></span>proc <span class="token operator">==</span> setexCommand <span class="token operator">||</span> cmd<span class="token operator">-></span>proc <span class="token operator">==</span> psetexCommand<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        when <span class="token operator">+=</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 减少 second 的引用次数, 便于回收</span>    <span class="token function">decrRefCount</span><span class="token punctuation">(</span>seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 拼接为 pexpireat key 超时时间 的命令格式</span>    argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">createStringObject</span><span class="token punctuation">(</span><span class="token string">"PEXPIREAT"</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>    argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">createStringObjectFromLongLong</span><span class="token punctuation">(</span>when<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将上面的 pexpireat key 过期时间 的命令通过 catAppendOnlyGenericCommand 转为 RESP 格式的字符串</span>    buf <span class="token operator">=</span> <span class="token function">catAppendOnlyGenericCommand</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">decrRefCount</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">decrRefCount</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回buf</span>    <span class="token keyword">return</span> buf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="7-代码中涉及的几个模块"><a href="#7-代码中涉及的几个模块" class="headerlink" title="7 代码中涉及的几个模块"></a>7 代码中涉及的几个模块</h2><p>在 Redis 的 AOF 中涉及了几个模块功能, 这些功能辅助着整个 AOF 的功能, 这里对这些功能进行一个简单的讲解, 需要说明的时, 这些功能具体的实现可以不用去深入理解, 到了 AOF 源码时, 知道对应的函数的功能就行了。</p><p>这里也只是简单的介绍一下, 感兴趣了解一下大体的思路而已, 可以在后面 AOF 源码分析后, 再回来看一下。</p><h3 id="7-1-延迟统计"><a href="#7-1-延迟统计" class="headerlink" title="7.1 延迟统计"></a>7.1 延迟统计</h3><p>Redis 中会对一些比较耗时的操作做一下统计, 便于后面的性能分析。<br>而在 AOF 中在调用 write 函数等操作也会进行延迟操作的统计。<br>大体的延迟统计实现如下:</p><p><strong>统计延迟信息的配置</strong></p><pre class="language-C" data-language="C"><code class="language-C">#define CONFIG_DEFAULT_LATENCY_MONITOR_THRESHOLD 0struct redisServer &#123;    &#x2F;&#x2F; 延迟监视的阈值, 默认值为 0, 如果配置为大于 0 的值, 表示开启延迟监控, 同时超过了这个时间就进行延迟记录    long long latency_monitor_threshold;    &#x2F;&#x2F; 字典, 也就是延迟记录的保存地方, 保存的格式是 延迟记录的事件名 和 latencyTimeSeries (一个数组)    dict *latency_events;&#125;</code></pre><p><strong>统计延迟样本对象的定义</strong></p><pre class="language-C" data-language="C"><code class="language-C">struct latencyTimeSeries &#123;    &#x2F;&#x2F; 用于记录的下一个延迟样本的位置, 超过了数组的长度, 会重新被赋值为 0     int idx;    &#x2F;&#x2F; 最大的延时    uint32_t max;    &#x2F;&#x2F; 最近的延时记录样本数组    struct latencySample samples[LATENCY_TS_LEN];&#125;struct latencySample &#123;    &#x2F;&#x2F; 延时样本创建的时间    int32_t time;     &#x2F;&#x2F; 延迟样本的延迟时间, 单位毫秒    uint32_t latency;&#125;</code></pre><p><strong>统计延迟样本的函数定义</strong></p><pre class="language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 下面的函数做了小改动, 逻辑一样的&#x2F;&#x2F; 获取延迟事件的时间void latencyStartMonitor(var) &#123;     &#x2F;&#x2F; mstime() 获取到当前的时间    var &#x3D; server.latency_monitor_threshold ? mstime() : 0;&#125;void latencyEndMonitor(var) &#123;    if (server.latency_monitor_threshold) &#123;        var &#x3D; mstime() - var;    &#125;&#125;&#x2F;** * 判断是否需要记录延迟时间  * @param event 事件名 * @param var 延迟事件的耗时时间 *&#x2F;void latencyAddSampleIfNeeded(event,var) &#123;    if (server.latency_monitor_threshold &amp;&amp;  (var) &gt;&#x3D; server.latency_monitor_threshold)        latencyAddSample((event),(var));&#125;&#x2F;** * 添加延迟事件到 redisServer 的 latency_events 字典 *&#x2F; void latencyAddSample(char *event, mstime_t latency) &#123;    &#x2F;&#x2F; 找出 event 对应的延时事件记录结构体    struct latencyTimeSeries *ts &#x3D; dictFetchValue(server.latency_events,event);    time_t now &#x3D; time(NULL);    int prev;    &#x2F;&#x2F; 没有对应事件的 latencyTimeSeries, 添加一个    if (ts &#x3D;&#x3D; NULL) &#123;        ts &#x3D; zmalloc(sizeof(*ts));        ts-&gt;idx &#x3D; 0;        ts-&gt;max &#x3D; 0;        memset(ts-&gt;samples,0,sizeof(ts-&gt;samples));        dictAdd(server.latency_events,zstrdup(event),ts);    &#125;    &#x2F;&#x2F; 获取存储的位置    prev &#x3D; (ts-&gt;idx + LATENCY_TS_LEN - 1) % LATENCY_TS_LEN;    &#x2F;&#x2F; 数组对应位置的样本的创建时间等于当前时间    if (ts-&gt;samples[prev].time &#x3D;&#x3D; now) &#123;        &#x2F;&#x2F; 当前的延迟时间大于样本里面的延迟时间, 更新为当前时间        if (latency &gt; ts-&gt;samples[prev].latency)            ts-&gt;samples[prev].latency &#x3D; latency;        return;    &#125;    &#x2F;&#x2F; 修改对应位置的样本的时间信息    ts-&gt;samples[ts-&gt;idx].time &#x3D; time(NULL);    ts-&gt;samples[ts-&gt;idx].latency &#x3D; latency;    &#x2F;&#x2F; 如果大于当前所有样本的时间, 更新最大延迟时间为当前的延迟时间    if (latency &gt; ts-&gt;max)         ts-&gt;max &#x3D; latency;    ts-&gt;idx++;    &#x2F;&#x2F; 超过了上限, 重新设置为 0     if (ts-&gt;idx &#x3D;&#x3D; LATENCY_TS_LEN)         ts-&gt;idx &#x3D; 0;    &#125;</code></pre><p>上面就是延迟事件的创建和保存, 至于在哪里使用的, 如何汇总分析, AOF 这里没有涉及, 就跳过了, 如果需要继续研究可以查看 <strong>latency.h</strong> 和 <strong>latency.c</strong> 这 2 个文件。</p><h3 id="7-2-BIO-后台线程"><a href="#7-2-BIO-后台线程" class="headerlink" title="7.2 BIO - 后台线程"></a>7.2 BIO - 后台线程</h3><p>在上面的介绍中可以知道 fsync 是一个很耗时的过程, 如果把这个过程同样放在 Redis 的主线程中, 那么可能影响到整个 Redis 的性能, 所以 Redis 将 fsync 的过程交给了后台的线程处理。<br>Reids 将后台相关耗时的操作封装为了一个 BIO 的功能, 可以看出是一个线程池, 线程池在启动时初始了几个线程, 然后生产者向这个池中添加任务。<br>而 Redis 主线程在执行到 fsync 时, 会提交一个 fsync 的任务到 BIO 中, 完成结束。真正的 fsync 由后台线程处理。</p><p>大体的实现如下:</p><p><strong>任务类型定义</strong></p><pre class="language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 执行 close 函数, 也就是文件的关闭#define BIO_CLOSE_FILE    0 &#x2F;&#x2F; 执行 redis_fsync 函数, 也就是 fsync 函数#define BIO_AOF_FSYNC     1&#x2F;&#x2F; 延迟对象释放#define BIO_LAZY_FREE     2 &#x2F;&#x2F; 任务类型的总数#define BIO_NUM_OPS       3</code></pre><p><strong>BIO 的初始化</strong></p><pre class="language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 存放声明的线程数组static pthread_t bio_threads[BIO_NUM_OPS];&#x2F;&#x2F; 线程锁, 这里是多线程场景了, 所以有并发问题static pthread_mutex_t bio_mutex[BIO_NUM_OPS];&#x2F;&#x2F; 添加任务相关的 condition, 简单的理解就是, 线程会被阻塞在这个 condition, 另一个线程可以唤醒这个 condition 上的线程static pthread_cond_t bio_newjob_cond[BIO_NUM_OPS];&#x2F;&#x2F; 执行过程相关的 conditionstatic pthread_cond_t bio_step_cond[BIO_NUM_OPS];&#x2F;&#x2F; 任务列表static list *bio_jobs[BIO_NUM_OPS];&#x2F;&#x2F; 存放对应的任务类型还有多少个任务等待执行static unsigned long long bio_pending[BIO_NUM_OPS];void bioInit(void) &#123;    pthread_attr_t attr;    pthread_t thread;    size_t stacksize;    int j;    &#x2F;&#x2F; 初始锁, condition, 任务列表    for (j &#x3D; 0; j &lt; BIO_NUM_OPS; j++) &#123;        pthread_mutex_init(&amp;bio_mutex[j],NULL);        pthread_cond_init(&amp;bio_newjob_cond[j],NULL);        pthread_cond_init(&amp;bio_step_cond[j],NULL);        bio_jobs[j] &#x3D; listCreate();        bio_pending[j] &#x3D; 0;    &#125;    &#x2F;&#x2F;设置线程栈空间    pthread_attr_init(&amp;attr);    pthread_attr_getstacksize(&amp;attr,&amp;stacksize);     if (!stacksize)         stacksize &#x3D; 1;     while (stacksize &lt; REDIS_THREAD_STACK_SIZE)         stacksize *&#x3D; 2;    pthread_attr_setstacksize(&amp;attr, stacksize);    &#x2F;&#x2F; 创建线程, 并存放到 bio_threads 这个线程数组    for (j &#x3D; 0; j &lt; BIO_NUM_OPS; j++) &#123;        void *arg &#x3D; (void*)(unsigned long) j;        &#x2F;&#x2F; 创建线程, 线程执行的逻辑为 bioProcessBackgroundJobs        if (pthread_create(&amp;thread,&amp;attr,bioProcessBackgroundJobs,arg) !&#x3D; 0) &#123;            serverLog(LL_WARNING,&quot;Fatal: Can&#39;t initialize Background Jobs.&quot;);            exit(1);        &#125;        bio_threads[j] &#x3D; thread;    &#125;&#125;</code></pre><p><strong>线程执行的逻辑</strong></p><pre class="language-C" data-language="C"><code class="language-C">void *bioProcessBackgroundJobs(void *arg) &#123;    struct bio_job *job;    unsigned long type &#x3D; (unsigned long) arg;    sigset_t sigset;    &#x2F;&#x2F; 任务类型校验    if (type &gt;&#x3D; BIO_NUM_OPS) &#123;        serverLog(LL_WARNING, &quot;Warning: bio thread started with wrong type %lu&quot;,type);        return NULL;    &#125;    &#x2F;&#x2F; 配置 thread 能够在任何时候被杀掉    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);    &#x2F;&#x2F; 获取锁    pthread_mutex_lock(&amp;bio_mutex[type]);    sigemptyset(&amp;sigset);    sigaddset(&amp;sigset, SIGALRM);    if (pthread_sigmask(SIG_BLOCK, &amp;sigset, NULL))        serverLog(LL_WARNING, &quot;Warning: can&#39;t mask SIGALRM in bio.c thread: %s&quot;, strerror(errno));    &#x2F;&#x2F; 线程主逻辑    while(1) &#123;        listNode *ln;         &#x2F;&#x2F; 没有任务, 进行等待,         if (listLength(bio_jobs[type]) &#x3D;&#x3D; 0) &#123;            pthread_cond_wait(&amp;bio_newjob_cond[type],&amp;bio_mutex[type]);            continue;        &#125;          &#x2F;&#x2F; 获取列表的第一个任务        ln &#x3D; listFirst(bio_jobs[type]);        job &#x3D; ln-&gt;value;         &#x2F;&#x2F; 释放锁, 这个锁的功能主要是为了确保任务的获取        pthread_mutex_unlock(&amp;bio_mutex[type]);        if (type &#x3D;&#x3D; BIO_CLOSE_FILE) &#123;            close((long)job-&gt;arg1);        &#125; else if (type &#x3D;&#x3D; BIO_AOF_FSYNC) &#123;            redis_fsync((long)job-&gt;arg1);        &#125; else if (type &#x3D;&#x3D; BIO_LAZY_FREE) &#123;            if (job-&gt;arg1)                lazyfreeFreeObjectFromBioThread(job-&gt;arg1);            else if (job-&gt;arg2 &amp;&amp; job-&gt;arg3)                lazyfreeFreeDatabaseFromBioThread(job-&gt;arg2,job-&gt;arg3);            else if (job-&gt;arg3)                lazyfreeFreeSlotsMapFromBioThread(job-&gt;arg3);        &#125; else &#123;            serverPanic(&quot;Wrong job type in bioProcessBackgroundJobs().&quot;);        &#125;        zfree(job);        &#x2F;&#x2F; 获取锁        pthread_mutex_lock(&amp;bio_mutex[type]);        &#x2F;&#x2F; 删除任务        listDelNode(bio_jobs[type],ln);        &#x2F;&#x2F; 需要执行的任务减 1        bio_pending[type]--;        &#x2F;&#x2F; 唤醒所有等待在 bio_step_cond 上的线程        pthread_cond_broadcast(&amp;bio_step_cond[type]);    &#125;      &#125;</code></pre><p><strong>添加任务</strong></p><pre class="language-C" data-language="C"><code class="language-C">void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3) &#123;    struct bio_job *job &#x3D; zmalloc(sizeof(*job));    job-&gt;time &#x3D; time(NULL);    job-&gt;arg1 &#x3D; arg1;    job-&gt;arg2 &#x3D; arg2;    job-&gt;arg3 &#x3D; arg3;        &#x2F;&#x2F; 获取锁    pthread_mutex_lock(&amp;bio_mutex[type]);    &#x2F;&#x2F; 添加任务    listAddNodeTail(bio_jobs[type],job);    bio_pending[type]++;    &#x2F;&#x2F; 通知等待在 bio_newjob_cond 的线程    pthread_cond_signal(&amp;bio_newjob_cond[type]);    &#x2F;&#x2F; 释放锁    pthread_mutex_unlock(&amp;bio_mutex[type]);&#125;</code></pre><h3 id="7-3-pipe-父子进程通信"><a href="#7-3-pipe-父子进程通信" class="headerlink" title="7.3 pipe - 父子进程通信"></a>7.3 pipe - 父子进程通信</h3><p>Redis 的 AOF 重写机制和 RDB 类型, 也是通过 fork 创建子进程, 将整个 AOF 重写过程交给子进程处理。<br>不同的时: AOF 重写过程中会不断和父进程通信获取父进程的命令缓存。 父子进程之间就是通过 pipe 进行通讯的。</p><p>这里只做一下简单的了解。</p><pre class="language-C" data-language="C"><code class="language-C">#include &lt;unistd.h&gt;int Pipe(int pipefd[2]);</code></pre><p>通过 pipe 的函数可以在 2 个文件描述符之间建立一个通道, 第一个用来读 <strong>read(fd[0])</strong>, 第二个用来写 **write(fd[1])**。</p><p>具体的分析可以看一下这篇文章 <a href="https://blog.csdn.net/men_wen/article/details/59131762">APUE读书笔记—进程间通信(IPC)之管道和有名管道（FIFO）</a></p><p>而 Redis 中建立了 3 套通道</p><pre class="language-C" data-language="C"><code class="language-C">int aofCreatePipes(void) &#123;    int fds[6] &#x3D; &#123;-1, -1, -1, -1, -1, -1&#125;;    int j;    &#x2F;&#x2F;  parent -&gt; children data    if (pipe(fds) &#x3D;&#x3D; -1) goto error;    &#x2F;&#x2F; children -&gt; parent ack    if (pipe(fds+2) &#x3D;&#x3D; -1) goto error;     &#x2F;&#x2F; parent -&gt; children ack    if (pipe(fds+4) &#x3D;&#x3D; -1) goto error;     &#x2F;&#x2F; 同步非阻塞    if (anetNonBlock(NULL,fds[0]) !&#x3D; ANET_OK) goto error;    if (anetNonBlock(NULL,fds[1]) !&#x3D; ANET_OK) goto error;    &#x2F;&#x2F; 注册一个事件, 执行的函数为 aofChildPipeReadable, 里面的逻辑就是读取 aof_pipe_read_ack_from_child 的数据到 aof_pipe_write_ack_to_child    if (aeCreateFileEvent(server.el, fds[2], AE_READABLE, aofChildPipeReadable, NULL) &#x3D;&#x3D; AE_ERR) goto error;    &#x2F;&#x2F; 6 个通道    server.aof_pipe_write_data_to_child &#x3D; fds[1];    server.aof_pipe_read_data_from_parent &#x3D; fds[0];    server.aof_pipe_write_ack_to_parent &#x3D; fds[3];    server.aof_pipe_read_ack_from_child &#x3D; fds[2];    server.aof_pipe_write_ack_to_child &#x3D; fds[5];    server.aof_pipe_read_ack_from_parent &#x3D; fds[4];    server.aof_stop_sending_diff &#x3D; 0;    return C_OK;&#125;</code></pre><p>最终形成的效果如下：<br><img src="https://pic.imgdb.cn/item/657ead7bc458853aefbc4aea.png" alt="Alt &#39;AOF 创建的通道&#39;"></p><p>父进程写入到 aof_pipe_read_data_from_parent 的数据会自动同步到子进程的 aof_pipe_read_data_from_parent, 另外 2 个类似。</p><p>至此, AOF 的一些概念和源码中相关的一些代码就介绍完了, 下篇开始真正的 AOF 源码分析。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis RDB</title>
      <link href="/article/2021/2629732721/"/>
      <url>/article/2021/2629732721/</url>
      
        <content type="html"><![CDATA[<p>基于内存的 Redis, 数据都是存储在内存中的。 那么如果重启的话, 数据就会丢失。 为了解决这个问题, Redis 提供了 2 种数据持久化的方案: RDB 和 AOF。<br>RDB 是 Redis 默认的持久化方案。当满足一定条件的时候, 会把当前内存中的数据写入磁盘, 生成一个快照文件 <strong>dump.rdb</strong>。Redis 重启会通过加载 dump.rdb 文件恢复数据。</p><h2 id="1-触发-RDB-的方式"><a href="#1-触发-RDB-的方式" class="headerlink" title="1  触发 RDB 的方式"></a>1  触发 RDB 的方式</h2><h3 id="1-1-RDB-文件相关的配置"><a href="#1-1-RDB-文件相关的配置" class="headerlink" title="1.1 RDB 文件相关的配置"></a>1.1 RDB 文件相关的配置</h3><pre class="language-c" data-language="c"><code class="language-c">dir    <span class="token punctuation">.</span><span class="token operator">/</span>               # RDB 文件路径<span class="token punctuation">,</span> 默认在启动目录下dbfilename  dump<span class="token punctuation">.</span>rdb    # REB 文件名称rdbcompression yes      # 开启 LZF 压缩<span class="token punctuation">,</span> 这样可以节省存储空间<span class="token punctuation">,</span> 但是会消耗一些 CPU 的计算时间<span class="token punctuation">,</span> 默认开启rdbchecksum  yes        # 使用 CRC64 算法来进行数据校验<span class="token punctuation">,</span> 但是这样会增加大约 <span class="token number">10</span><span class="token operator">%</span> 的性能消耗<span class="token punctuation">,</span> 默认开启stop<span class="token operator">-</span>writes<span class="token operator">-</span>on<span class="token operator">-</span>bgsave<span class="token operator">-</span>error yes # 在 RDB 持久化操作失败时<span class="token punctuation">,</span> Redis 则会停止接受更新操作<span class="token punctuation">,</span> 让用户知道异常的出现<span class="token punctuation">,</span> 否则无感知的话<span class="token punctuation">,</span> 会造成大的存储问题<span class="token punctuation">,</span> 默认开启</code></pre><p>以上是 RDB 开启的默认一些配置, 在这些配置的基础下, 有 2 种方式可以触发 RDB 的进行, 也就是数据持久化的触发。</p><h3 id="1-2-通过配置规则触发"><a href="#1-2-通过配置规则触发" class="headerlink" title="1.2 通过配置规则触发"></a>1.2 通过配置规则触发</h3><p>在 redis.conf 的 SNAPSHOTING 配置中, 定义了触发把数据保存到磁盘的触发频率 (如果不需要 RDB 默认方案, 注释掉 save 或配置成空字符串 “” 即可)。</p><pre class="language-c" data-language="c"><code class="language-c">save <span class="token number">900</span> <span class="token number">1</span>      # <span class="token number">900</span> 秒内至少有一个 key 被修改 <span class="token punctuation">(</span>包括添加<span class="token punctuation">)</span>save <span class="token number">300</span> <span class="token number">10</span>     # <span class="token number">300</span> 秒内至少有 <span class="token number">10</span> 个 key 被修改save <span class="token number">60</span> <span class="token number">100</span>     # <span class="token number">60</span> 秒内至少有 <span class="token number">100</span> 个 key 被修改</code></pre><p>上面的配置是不冲突的, 只要满足任意一个都会触发。</p><h3 id="1-3-通过命令触发"><a href="#1-3-通过命令触发" class="headerlink" title="1.3 通过命令触发"></a>1.3 通过命令触发</h3><p>Redis 提供了 2 条命令 <strong>save</strong> 和 <strong>bgsave</strong> 可以用来手动触发数据保存。</p><p>save: 在生成快照的时候会阻塞当前 Redis 服务器, Redis 不能处理其他命令。如果内存中的数据比较多, 会造成 Redis 长时间阻塞。 生产中不建议使用这个命令。<br>bgsave: Redis 进程通过 fork 函数, 创建出一个子进程 (copy-on-write)。 RDB 持久化过程由子进程负责, 完成后自动结束。它不会记录 fork 之后的命令, 阻塞只发生在 fork 阶段, 一般时间很短。</p><p>Redis 提供了 <strong>lastsave</strong> 命令, 用来查看最近一次生成快照的时间。</p><p>当然通过 <strong>shutdown</strong> 命令关闭 Redis, 也会触发 RDB 持久化的发生, 以确保服务器正常关闭和后面启动数据能正常准确地重新加载。</p><h2 id="2-RDB-文件的优势和劣势"><a href="#2-RDB-文件的优势和劣势" class="headerlink" title="2 RDB 文件的优势和劣势"></a>2 RDB 文件的优势和劣势</h2><p>优势</p><blockquote><ol><li>RDB 是一个非常紧凑 (compact) 的文件, 它保存了 Redis 在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复</li><li>生成 RDB 文件的时候, Redis 进程会 fork 一个子进程来处理所有的保存工作, 主进程不需要进行任何磁盘 IO 操作</li><li>RDB 在恢复大数据集时的速度比 AOF 恢复速度快</li></ol></blockquote><p>劣势</p><blockquote><ol><li>RDB 方式数据没办法做到实时持久化或秒级持久化。因为 bgsave 每次运行都要执行 fork 函数, 创建子进程, 频繁执行成本高</li><li>在一定间隔时间做一次备份, 所以如果 Redis 意外 down 掉的话, 就会丢失最后一次快照之后的修改 (数据丢失)</li></ol></blockquote><p>如果数据相对来说比较重要, 希望将损失降到最小, 则可以使用 AOF 方式进行持久化。</p><h2 id="3-RDB-持久化的过程"><a href="#3-RDB-持久化的过程" class="headerlink" title="3 RDB 持久化的过程"></a>3 RDB 持久化的过程</h2><blockquote><ol><li>配置的规则条件达到或者收到了 bgsave &#x2F; save 命令, 持久化开始</li><li>主进程通过 fork 函数, 创建出一个子进程</li><li>父进程进行一些统计状态和指标的保存, 然后可以进行处理其他的命令</li><li>fork 出的子进程, 创建出一个临时文件, 将数据库中的数据写入到临时文件中</li><li>整个数据库的数据都写入完成了, 通过 rename 函数将临时文件命名为配置的 RDB 文件名 (如果重命名的文件已经存在, 会先被删除, 再进行重命名)</li><li>子进程在 RDB 文件持久完成后, 把持久化中的一些信息通知给父级, 然后退出子进程, 整个持久化就完成了</li></ol></blockquote><p>到此, RDB 的理论知识就没了, 下面是从源码进行分析。</p><p>注: 下面的分析都是以 <strong>Redis 5.x 版本</strong>进行分析的, 跨大版本可能会有一些不一样。</p><h2 id="4-RDB-文件结构"><a href="#4-RDB-文件结构" class="headerlink" title="4 RDB 文件结构"></a>4 RDB 文件结构</h2><p>要了解 RDB 的过程, 其中有一个绕不开的点: RDB 文件的结构。</p><p><img src="https://pic.imgdb.cn/item/656ace2bc458853aef650fd0.png" alt="Alt &#39;RDB 文件内容格式&#39;"></p><p>如图是 RDB 的<strong>逻辑文件结构</strong> (当前这个图片中显示的结构和真正的 RDB 文件有些差距的, 但是差距不大), 整个文件的内容如下:</p><ol><li><strong>REDIS</strong>, 文件开头的前 5 个字符的内容固定为 <strong>REDIS</strong>, 占用 5 个字节, 标识这是一个 Redis 可以处理的文件  </li><li>RDB_VERSION, 标识当前的 RDB 文件的版本号, 占用 4 个字节  </li><li>AUX_FIELD_KEY_VALUE_PAIRS, 这个属性不是简单的属性, 可以看成是 8 个 key-value 公共组成的一个属性值</li></ol><ul><li>3.1. key 为 <strong>redis-ver</strong>, value 为<strong>当前 Redis 的版本</strong>, 比如 5.0.0 版本  </li><li>3.2. key 为 <strong>redis-bit</strong>, value 为<strong>当前 Redis 的位数</strong>, 64 位 &#x2F; 32 位   </li><li>3.3. key 为 <strong>ctime</strong>, value 为 <strong>RDB 创建时的时间戳</strong>   </li><li>3.4. key 为 <strong>used-mem</strong>, value 为 <strong>dump 时 Redis 占的内存</strong>, 单位字节   </li><li>3.5. key 为 <strong>repl-steam-db</strong>,  和<strong>主从复制相关</strong>, 在 server.master 客户端中选择的数据库, 这个不一定有, 只有在当前的 RDB 文件是用作主从复制时才有值, 数据持久化时, 没有这个属性   </li><li>3.6. key 为 <strong>repl-id</strong>, 和<strong>主从复制相关</strong>, 当前实例 replication ID, 这个不一定有, 只有当前的 RDB 文件是用作主从复制时, 不是数据持久化时, 才有  </li><li>3.7. key 为 <strong>repl-offset</strong>, 和<strong>主从复制相关</strong>, 当前实例复制的偏移量, 这个不一定有, 只有当前的 RDB 文件是用作主从复制时, 不是数据持久化时, 才有  </li><li>3.8. key 为 <strong>aof-preamble</strong>, value 为<strong>是否开启了 aof&#x2F;rdb 的混合使用</strong></li></ul><ol start="4"><li>DB_NUM, 当前后面的数据是存储在哪个数据库的, Redis 中有 16 个数据库</li><li>DB_DIC_SIZE, 当前数据库键值对散列表的大小。Redis 的每个数据库是一个散列表, 这个字段指明当前数据库散列表的大小。这样在加载时可以直接将散列表扩展到指定大小, 提升加载速度  </li><li>EXPIRE_DIC_SIZE, 当前数据库过期时间散列表的大小。Redis 数据的过期时间也是保存为一个散列表, 该字段指明当前数据库过期时间散列表的大小</li><li>KEY_VALUE_PAIRS, 这个部分就是 Redis 中真正存储的数据了<br><strong>我们知道 Redis 中有 16 个数据库, 所以在多个数据库都有数据的情况下, 第四, 五, 六, 七这 4 个部分可能有多套的</strong>。</li><li>固定为 <strong>EOF</strong>, 一个常量, 文件结束标志</li><li>CHECK_NUM, 8 字节的校验码, 用来确保文件的正确性</li></ol><p>这 9 个部分就是 RDB 文件的内容了。<br>从上图中, 我们还可以知道, RDB 文件中的 KEY_VALUE_PAIRS 中, 实际存储了多个 KEY_VALUE_PAIR。 这些键值对就是我们存储在 Redis 里面的数据。<br>而我们存储在 Redis 里面的键值对除了单纯的 key-value 外, 还包含了其他的信息, 比如过期时间, 过期策略等。  </p><p>所以代表真正数据的 KEY_VALUE_PAIR 可以划分出 5 部分</p><blockquote><ol><li>EXPIRE_TIME, 当前这个键值对过期时间, 占 8 个字节, 如果 key 没有过期时间, 这一项可以没有</li><li>LRU 或 LFU, 当前这个键值对过期的方式, 同样是可选项, 如果 key 没有过期配置, 这一项也可以没有</li><li>VALUE_TYPE, 当前这个键值对的值的存储类型, 比如是字符串, 整数, 列表等, 取值看下面</li><li>KEY, 键值对的 KEY 值</li><li>VALUE, 键值对的 VALUE 值</li></ol></blockquote><p>VALUE_TYPE 就是存储 VALUE 的类型, 具体的取值如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_STRING</span>             <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_LIST</span>               <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_SET</span>                <span class="token expression"><span class="token number">2</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_ZSET</span>               <span class="token expression"><span class="token number">3</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_HASH</span>               <span class="token expression"><span class="token number">4</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_ZSET_2</span>             <span class="token expression"><span class="token number">5</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_MODULE</span>             <span class="token expression"><span class="token number">6</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_MODULE_2</span>           <span class="token expression"><span class="token number">7</span>   </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_HASH_ZIPMAP</span>        <span class="token expression"><span class="token number">9</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_LIST_ZIPLIST</span>       <span class="token expression"><span class="token number">10</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_SET_INTSET</span>         <span class="token expression"><span class="token number">11</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_ZSET_ZIPLIST</span>       <span class="token expression"><span class="token number">12</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_HASH_ZIPLIST</span>       <span class="token expression"><span class="token number">13</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_LIST_QUICKLIST</span>     <span class="token expression"><span class="token number">14</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_STREAM_LISTPACKS</span>   <span class="token expression"><span class="token number">15</span></span></span></code></pre><p>这几个就是<strong>数据类型的定义</strong></p><h2 id="5-数据以什么格式存入二进制文件"><a href="#5-数据以什么格式存入二进制文件" class="headerlink" title="5 数据以什么格式存入二进制文件"></a>5 数据以什么格式存入二进制文件</h2><p>在进入到 Redis 是如何写数据到 RDB 文件前, 我们先看一个例子吧。</p><p>将设现在我有一个备忘录, 里面有内容如下</p><blockquote><p>123 4567 8900 (手机号码)<br>021-3000 9000 (座机号码)<br>123456789012345678 (18 位的身份证)<br>60606060606060606 (银行卡号, 17位, 银行卡实际的长度不定, 但是长度在 15-19 位之间)</p></blockquote><p>现在需要将他们写入到一个文件中, 并且期望</p><blockquote><ol><li>尽可能的省空间</li><li>后面还能正常的读取出来</li></ol></blockquote><p>现在最直接的省空间的, 当然直接将他们拼接在一起, 最终就是这样了: <strong>123 4567 8900021-3000 12345678901234567860606060606060606</strong>    </p><p>但是后面的如何正确的读取呢? 我们先对备忘录里面的内容做个分类</p><blockquote><ol><li>普通的手机号码, 固定长度 13 位</li><li>座机号码, 固定长度 11 位 </li><li>身份证号, 固定长度为 18 位</li><li>中国银行卡号, 长度不定, 但是长度在 15-19 位之间</li></ol></blockquote><p>概括为</p><blockquote><ol><li>内容的长度是固定的, 比如手机号 13 位, 身份证 18 位</li><li>内容长度是不固定的, 比如银行卡号</li></ol></blockquote><p>那么我们是否可以指定一个规则, 写入文件时, 备忘录的每一个内容前面都会加入一个数字, 每个数字都代表了一种内容格式</p><ul><li>数字 1 表示后面的内容是手机号码, 长度固定为 13 位</li><li>数字 2 表示后面的内容是座机号, 长度固定为 11 位</li><li>数字 3 表示后面的内容为身份证号, 长度为 18 位</li><li>数字 4 表示后面的内容是特殊内容, 长度不确定</li></ul><p>通过这个规则, 我们的内容变成 <strong>1</strong>123 4567 8900<strong>2</strong>021-3000 9000<strong>3</strong>123456789012345678<strong>4</strong>60606060606060606</p><p>读取时, 我们都是先读取第一位, 确定后面的内容是什么, 得到需要读取多少位。<br>比如先读取到 <strong>1</strong>, 根据规则 <strong>1</strong>, 表示后面的内容为手机号, 需要一次性读取 13 位内容, 其他同理。<br>但是当读取到 <strong>4</strong>, 我们卡住了, 根据规则 <strong>4</strong>, 代表后面是特殊内容, 那需要读取多长的内容?</p><p>这时我们在指定一套<strong>表示整数</strong>的规则</p><blockquote><p>数字 1 表示后面的内容的长度为 15<br>数字 2 表示后面的内容的长度为 16<br>数字 3 表示后面的内容的长度为 17<br>数字 4 表示后面的内容的长度为 18<br>数字 5 表示后面的内容的长度为 19</p></blockquote><p>修改上面内容格式的规则, 将数字 4 修改为如下</p><ul><li>数字 4 表示后面的内容是特殊内容, 同时后面会紧跟一个一位数的整数, 表示后面的内容的长度</li></ul><p>最终通过修改后的规则, 我们的内容变成 <strong>1</strong>123 4567 8900<strong>2</strong>021-3000 9000<strong>3</strong>123456789012345678<strong>44</strong>60606060606060606</p><p>这时按照规则读取到数字 <strong>4</strong>, 知道后面的内容为特殊内容, 需要在往后读取 1 位, 得到特殊内容的长度, 这时读取到 <strong>4</strong>, 根据整数规则, 得到长度为 17。</p><p>上面就是 Redis 以二进制存储数据到文件的大体思路, 只是他设计得更巧妙一下, 没那么粗暴。<br>总体就是确定<strong>内容的长度</strong>, 而在确定内容的长度, 有 2 种方式</p><blockquote><ol><li>内容的长度是<strong>定长</strong>的, 我们就给他制定特有的<strong>内容类型</strong>, 这个<strong>内容类型</strong>本身就代表了后面<strong>内容的长度</strong></li><li>内容的长度是<strong>不定长</strong>的, 就通过自定义的一套<strong>整数规则</strong>, 在内容前面加上一个符合<strong>整数规则</strong>的数字, 表示内容的长度</li></ol></blockquote><h3 id="5-1-自定义的整数的规则"><a href="#5-1-自定义的整数的规则" class="headerlink" title="5.1 自定义的整数的规则"></a>5.1 自定义的整数的规则</h3><p><strong>备注: 下面二进制之间每 8 位就手动空了一个空格, 只是为了方便理解, 真正写入文件时, 中间是不会有空格的</strong></p><p>在实际中, Reids 会将数据以二进制的形式写入到文件中, 格式可能如下</p><pre class="language-none"><code class="language-none">00010000 11000011 11011010 01010101 .....</code></pre><p>在开始介绍 Redis 自定义的整数规则前, 先看一个 Redis <strong>将数据写入文件</strong>的伪代码</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rdbSaveContentString</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> content<span class="token punctuation">,</span> <span class="token keyword">long</span> contentLength<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1. 数据的长度在 11 个字节以内 (int 最大值, 21 亿, 10 位数)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>contentLength <span class="token operator">&lt;</span> <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 尝试转为 int 写入</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryWriteIntegerContent</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> contentLength<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 2. 开启了 LZF 压缩算法, 同时数据长度大于 20 个字节</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_compression <span class="token operator">&amp;&amp;</span> contentLength <span class="token operator">></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">saveLzfStringObject</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> contentLength<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 3. 兜底</span>    <span class="token function">writeContentLen</span><span class="token punctuation">(</span>contentLength<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">writeContent</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> contentLength<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>逻辑整理如下</p><blockquote><ol><li>输入的数据长度在 11 个字节内, 同时可以转为 int 时, 以<strong>整数 int</strong>的形式写入 rdb 文件</li><li>开启了 LZF 压缩功能, 同时数据长度在 20 个字节以上, 以<strong>LZF 压缩字符串</strong>的形式写入 rdb 文件</li><li>数据不能转为整数, 同时长度在 20 个字节内, 数据的长度在 11 到 20 个字节内或者没有开启 LZF 压缩功能, 以<strong>长度 + 数据</strong>的形式写入 rdb 文件</li></ol></blockquote><p>可以看到 Redis 对写入到 RDB 文件的数据有 3 中模式。</p><p><strong>模式一</strong><br>写入 RDB 文件的数据可以转为一个整数, 同时大小在 int 的取值范围内, 会以 **整数 int (这里可以看作是数据类型 + 内容模式)**的形式存储这个整数</p><p>长度的表示: <strong>11|XXXXXX</strong></p><blockquote><p>1 <strong>11|000000</strong> (十进制: 192), 表示后面的内容类型为 byte,  是一个长度为 1 个字节的整数<br>2 <strong>11|000001</strong> (十进制: 193), 表示后面的内容类型为 short, 是一个长度为 2 个字节的整数<br>3 <strong>11|000010</strong> (十进制: 194), 表示后面的内容类型为 int,   是一个长度为 4 个字节的整数<br>4 <strong>11|000011</strong> (十进制: 195), 表示后面为 FASTLZ 压缩算法压缩的字符串, 后面分析</p></blockquote><p>举个例子, 我们现在如果要向 RDB 文件写入内容: 10</p><blockquote><ol><li>内容 10 在程序中可以转为 1 个 byte 类型的 10 (00001010), </li><li>byte 类型的数据, 只需要 1 个字节, 可以用 Redis 定义的整数规则 <strong>11|000000</strong> 表示其数据的长度, 最终写入到 RDB 文件就是 <strong>11000000 00001010</strong></li></ol></blockquote><p>同理写入一个 257 (00000001 00000001), 需要用 2 个字节, 也就是 short 类型。可以用 <strong>11|000001</strong> 表示其数据的长度, 最终写入到 RDB 文件的就是 <strong>11000001 00000001 00000001</strong></p><p>这个模式就是我们备忘录里面的 <strong>直接数据类型, 这个数据类型就直接表示后面数据长度</strong>的模式。</p><p><strong>模式二</strong> </p><p>条件</p><blockquote><ol><li>数据不能转为整数, 同时长度在 20 个字节内, 比如 ’abc‘</li><li>数据的长度在 11 到 20 个字节之间 (也就是即使能转为整数, 但是整数大于 int 最大值, 也是按照这种方式处理), 比如 ‘abcdefghijkl’ 或 ‘2147483648’ (int 最大值 + 1)</li><li>没有开启 LZF 压缩功能<br>以<strong>长度 + 数据</strong>的形式存储数据</li></ol></blockquote><p>长度的表示有 4 种模式</p><ol><li><strong>00|XXXXXX</strong> &#x3D;&gt; 1 个字节, 前 2 位固定为 <strong>00</strong>, 后面 6 位表示具体的数字, <strong>最大值为 63, 也就是表示后面的数据长度为 64 个字节</strong></li><li><strong>01|XXXXXX XXXXXXXX</strong> &#x3D;&gt; 2 个字节, 前 2 位固定为 <strong>01</strong>, 后面 14 位表示具体的数字, <strong>最大值为 16383</strong></li><li><strong>10|000000 [32 bit integer]</strong> &#x3D;&gt; 5 个字节, 前 8 位固定为 <strong>10000000</strong>, 后面 32 位表示具体的数字, <strong>int 的最大值</strong></li><li><strong>10|000001 [64 bit integer]</strong> &#x3D;&gt; 9 个字节, 前 8 为固定为 <strong>10000001</strong>, 后面 64 位表示具体的数字, <strong>long 的最大值</strong></li></ol><p>举个例子, 我们现在如果要向 RDB 文件写入内容: a (a 不能转为整数, 所以跳过了模式一)</p><blockquote><ol><li>a 本身只需要一个字节存储就行了, 也就是表示长度的规则, 可以选 <strong>00|000001</strong>, a 本身的二进制为 01100001 (ASCII 码, 二进制),<br>那么最终写入到 RDB 文件的数据就是 <strong>00000001 01100001</strong></li></ol></blockquote><p>同理写入 65 个 ‘a’, 需要 65 个字节, 表示长度的规则为 <strong>01000000 01000001</strong> (00|XXXXXX 模式不够了), 后面接着 65 个 a 的二进制。  </p><p>这个模式就是我们备忘录里面的 <strong>内容类型 + 数据长度</strong>的模式 (内容长度, 看每个字节的前 2 位确定的)。</p><p><strong>模式三</strong><br>当 Redis 开启了 LZF 压缩功能时, 如果写入的数据的长度大于 20 个字节了, 会对存储的数据进行压缩后再存储,<br>存储的格式为: <strong>11|000011 + 压缩后的长度 + 原始的数据长度 + 压缩后的数据</strong>, 模式一中的特殊模式。</p><p>看起来有点绕吧，做个总结, Redis 为了能将内容准确地存储下来, 定义了一套<strong>整数规则</strong>  </p><blockquote><ol><li><strong>11|XXXXXX</strong> &#x3D;&gt; 表示整数编码<blockquote><p>1.1 如果后面的 XXXXXX 6 位的值为 0, 表示后面的内容长度为 1 个字节, 也就是一个 byte 整数<br>1.2 如果后面的 XXXXXX 6 位的值为 1, 表示后面的内容长度为 2 个字节, 同时是一个 short 整数<br>1.3 如果后面的 XXXXXX 6 位的值为 2, 表示后面的内容长度为 4 个字节, 同时是一个 int 整数<br>1.4 如果后面的 XXXXXX 6 位的值为 3, 表示后面为 FASTLZ 压缩算法压缩的字符串, 特殊处理, 内容的格式为 <strong>11|000011 压缩后的长度 (长度用上面的规则进行表示) + 原始的数据长度 (同理) + 压缩后的数据</strong>*  </p></blockquote></li><li><strong>00|XXXXXX</strong> &#x3D;&gt; 1 个字节, 前 2 位固定为 <strong>00</strong>, 后面 6 位表示具体的数字, <strong>最大值为 63</strong>, 表示后面紧接的内容长度</li><li><strong>01|XXXXXX XXXXXXXX</strong> &#x3D;&gt; 2 个字节, 前 2 位固定为 <strong>01</strong>, 后面 14 位表示具体的数字, 表示后面紧接的内容长度</li><li><strong>10|000000 [32 bit integer]</strong> &#x3D;&gt; 5 个字节, 前 8 位固定为 <strong>10000000</strong>, 后面 32 位表示具体的数字, 表示后面紧接的内容长度</li><li><strong>10|000001 [64 bit integer]</strong> &#x3D;&gt; 9 个字节, 前 8 为固定为 <strong>10000001</strong>, 后面 64 位表示具体的数字, 表示后面紧接的内容长度</li></ol></blockquote><p>在使用时, 可以直接根据第一个字节的前 2 位, 得到后面数据的解析方式。</p><h3 id="5-2-操作码"><a href="#5-2-操作码" class="headerlink" title="5.2 操作码"></a>5.2 操作码</h3><p>在分析上面的 RDB 文件的逻辑结构中, 可以发现有一些属性, 在某些情况下是没有的, 这会造成什么问题呢?<br>顺着二进制文件一直读下去, 虽然数据解析出来了, 但是我们不知道这个数据是什么。</p><p>比如存储具体数据的 KEY_VALUE_PAIRS 中, 过期时间 <strong>EXPIRE_TIME</strong> 是可以没有的。</p><p>这时如果顺着二进制文件, 假设这时读取到了 6, 这个数字, 那么他是 KEY_VALUE_PAIRS 中的过期时间 EXPIRE_TIME, 还是键值对的数据类型 VALUE_TYPE (没有过期时间, 也就没有过期策略, 下一位就是键值值类型)。</p><p>为了应对这种不一定存在的情况, Redis 定义了一套 <strong>操作码</strong>, 通过操作码表示后面的数据是什么, 让解析出来的数据能真正赋值到对应的属性。</p><p>操作码: </p><table><thead><tr><th align="center">变量名</th><th align="center">取值</th><th align="center">操作码后面数据的含义</th></tr></thead><tbody><tr><td align="center">RDB_OPCODE_MODULE_AUX</td><td align="center">247</td><td align="center">module 相关辅助字段</td></tr><tr><td align="center">RDB_OPCODE_IDLE</td><td align="center">248</td><td align="center">lru 空闲时间</td></tr><tr><td align="center">RDB_OPCODE_FREQ</td><td align="center">249</td><td align="center">lfu 频率</td></tr><tr><td align="center">RDB_OPCODE_AUX</td><td align="center">250</td><td align="center">辅助字段类型</td></tr><tr><td align="center">RDB_OPCODE_RESIZEDB</td><td align="center">251</td><td align="center">resized, 和 DB_DIC_SIZE 和 EXPIRE_DIC_SIZE 的散列表个数有个相关</td></tr><tr><td align="center">RDB_OPCODE_EXPIRETIME_MS</td><td align="center">252</td><td align="center">毫秒级别过期时间</td></tr><tr><td align="center">RDB_OPCODE_EXPIRETIME</td><td align="center">253</td><td align="center">秒级别过期时间</td></tr><tr><td align="center">RDB_OPCODE_SELECTDB</td><td align="center">254</td><td align="center">数据库序号, 也就是 DB_NUM 项</td></tr><tr><td align="center">RDB_OPCODE_EOF</td><td align="center">255</td><td align="center">结束标志, 即 EOF 项</td></tr></tbody></table><h3 id="5-3-例子"><a href="#5-3-例子" class="headerlink" title="5.3 例子"></a>5.3 例子</h3><p>上面聊了 RDB 文件的逻辑结构, 自定义的整数规则和操作码, 这里就举一个例子, 结合起来理解一下 (括号内为说明, 对应的内容自行转为二进制)</p><p>如果这时如果直接打开了一个 RDB 文件, 对应的内容如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token number">01010010</span> <span class="token number">01000101</span> <span class="token number">01000100</span> <span class="token number">01001001</span> <span class="token number">01010011</span> <span class="token punctuation">(</span>前 <span class="token number">5</span> 个字节<span class="token punctuation">,</span> 固定为 REDIS 字符串的二进制<span class="token punctuation">)</span><span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00001001</span>          <span class="token punctuation">(</span>固定 <span class="token number">4</span> 个字节的 RDB 版本<span class="token punctuation">,</span> Redis <span class="token number">5.0</span> 版本中默认为 <span class="token number">9</span><span class="token punctuation">)</span><span class="token number">11111010</span> <span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">,</span> 操作码<span class="token punctuation">,</span> 表示后面辅助字段<span class="token punctuation">)</span> <span class="token number">00001001</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">00</span><span class="token operator">|</span>XXXXXX<span class="token punctuation">,</span> 表示后面辅助字段 key 的长度<span class="token punctuation">)</span> redis<span class="token operator">-</span><span class="token function">ver</span> <span class="token punctuation">(</span>这里没有转为二进制<span class="token punctuation">)</span> <span class="token number">00000110</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">00</span><span class="token operator">|</span>XXXXXX 表示后面辅助字段 value 的长度<span class="token punctuation">)</span> <span class="token number">5.0</span><span class="token number">.10</span><span class="token punctuation">(</span>这里没有转为二进制<span class="token punctuation">)</span><span class="token number">11111010</span> <span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">,</span> 操作码<span class="token punctuation">,</span> 表示后面辅助字段<span class="token punctuation">)</span> <span class="token number">00001010</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">00</span><span class="token operator">|</span>XXXXXX<span class="token punctuation">,</span> 辅助字段 key 的长度<span class="token punctuation">)</span> redis<span class="token operator">-</span><span class="token function">bits</span> <span class="token punctuation">(</span>这里没有转为二进制<span class="token punctuation">)</span> <span class="token number">01000000</span> <span class="token number">01000000</span> <span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">01</span><span class="token operator">|</span>XXXXXX XXXXXXXX<span class="token punctuation">,</span> redis<span class="token operator">-</span>bits 后面的内容直接用整数表示即可<span class="token punctuation">)</span><span class="token number">11111010</span> <span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">,</span> 操作码<span class="token punctuation">,</span> 表示后面辅助字段<span class="token punctuation">)</span> <span class="token number">00000101</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">00</span><span class="token operator">|</span>XXXXXX<span class="token punctuation">)</span> <span class="token function">ctime</span> <span class="token punctuation">(</span>这里没有转为二进制<span class="token punctuation">)</span> <span class="token number">11000010</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">11</span><span class="token operator">|</span>XXXXXX<span class="token punctuation">)</span> <span class="token number">00101111</span> <span class="token number">11001001</span> <span class="token number">10111100</span> <span class="token number">01011111</span> <span class="token punctuation">(</span>时间戳<span class="token punctuation">,</span> 单位秒<span class="token punctuation">,</span> 小端存储<span class="token punctuation">,</span> 实际值<span class="token operator">:</span> <span class="token number">1606207791</span><span class="token punctuation">)</span> 其他的 AUX_FIELD_KEY_VALUE_PAIRS 键值对<span class="token number">11111001</span> <span class="token punctuation">(</span><span class="token number">254</span><span class="token punctuation">,</span> 操作码<span class="token punctuation">,</span> 数据库序号项<span class="token punctuation">)</span> <span class="token number">00000000</span> <span class="token punctuation">(</span><span class="token number">0</span> 号数据库<span class="token punctuation">,</span> 因为 Redis 的数据库最多 <span class="token number">16</span> 个<span class="token punctuation">,</span> 所以直接读取后面一个字节就行<span class="token punctuation">,</span> 不需要自定义的整数规则<span class="token punctuation">)</span>  <span class="token number">11111011</span> <span class="token punctuation">(</span><span class="token number">251</span><span class="token punctuation">,</span> 操作码<span class="token punctuation">,</span> RESIZED 项<span class="token punctuation">)</span> <span class="token number">00000001</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">00</span><span class="token operator">|</span>XXXXXX<span class="token punctuation">,</span> 当前数据库键值对散列表只有 <span class="token number">1</span> 个<span class="token punctuation">)</span> <span class="token number">00000010</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">00</span><span class="token operator">|</span>XXXXXX<span class="token punctuation">,</span> 当前数据库过期时间散列表有 <span class="token number">2</span> 个<span class="token punctuation">)</span><span class="token number">11111100</span> <span class="token punctuation">(</span><span class="token number">252</span><span class="token punctuation">,</span> 操作码<span class="token punctuation">,</span> 毫秒级别过期时间项<span class="token punctuation">,</span> 这一项不一定都有<span class="token punctuation">,</span> 如果 key 没有过期配置<span class="token punctuation">,</span> 这一项就没有的<span class="token punctuation">)</span> <span class="token number">11101101</span> <span class="token number">00001110</span> <span class="token number">10111010</span> <span class="token number">00111000</span> <span class="token number">01110110</span> <span class="token number">000000001</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token punctuation">(</span>固定的 <span class="token number">8</span> 个字节<span class="token punctuation">,</span> 时间戳<span class="token punctuation">,</span> 实际值<span class="token operator">:</span> <span class="token number">1607269486317</span><span class="token punctuation">,</span> 同样小端存储<span class="token punctuation">)</span><span class="token number">11111000</span> <span class="token punctuation">(</span><span class="token number">248</span><span class="token punctuation">,</span> 操作码<span class="token punctuation">,</span> 过期策略<span class="token punctuation">,</span> 这里也可能为 <span class="token number">249</span><span class="token punctuation">)</span> <span class="token number">00101111</span> <span class="token number">11001001</span> <span class="token number">10111100</span> <span class="token number">01011111</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token punctuation">(</span>固定 <span class="token number">8</span> 个字节<span class="token punctuation">,</span> 存储的是过期的时间<span class="token punctuation">,</span> 单位秒<span class="token punctuation">,</span> 如果配置是 lfu<span class="token punctuation">,</span> 即 <span class="token number">249</span><span class="token punctuation">,</span> 则这个为 <span class="token number">1</span> 个字节<span class="token punctuation">,</span> 表示引用次数<span class="token punctuation">,</span> 取值为 <span class="token number">0</span> <span class="token operator">-</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token number">00000000</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> 上面 RDB 文件结构中有说明<span class="token punctuation">,</span> 存储到里面数据类型的取值<span class="token punctuation">,</span> 这里 <span class="token number">0</span><span class="token punctuation">,</span> 表示为字符串<span class="token punctuation">)</span> <span class="token number">00000010</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">00</span><span class="token operator">|</span>XXXXXX<span class="token punctuation">,</span> 后面 key 的长度<span class="token punctuation">)</span> k1 <span class="token number">00000010</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">00</span><span class="token operator">|</span>XXXXXX<span class="token punctuation">,</span> 后面 value 的长度<span class="token punctuation">)</span> v1<span class="token number">11111111</span> <span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> 操作码<span class="token punctuation">,</span> 结束项<span class="token punctuation">)</span><span class="token number">000000001</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> 固定 <span class="token number">8</span> 个字节<span class="token punctuation">,</span> 文件的校验码<span class="token punctuation">)</span></code></pre><p>上面的 KEY_VALUE_PAIRS 举的例子为 String 类型, 所以比较简单。<br>而实际中, Redis 在 KEY_VALUE_PAIR 还会根据不同的值类型, 内部会做一下优化。<br>不同的数据类型, 会有不同的编码进行数据的组织, 而有些编号会在前面先保存一个当前编码数据的节点数, 然后在保存数据。<br>比如 quicklist, 组织的方式如下: <code>quicklist 中的节点数 | ziplist1 | ziplist2 | ziplist3</code>, 多了一个节点数的字段。</p><p>有这种行为的有: dict, qicklist, skiplist 等</p><p>到此就是 RDB 文件的内容, 很绕。</p><h2 id="6-代码实现"><a href="#6-代码实现" class="headerlink" title="6 代码实现"></a>6 代码实现</h2><p>在日常的使用中, RDB 一般都是通过配置文件, 配置规则触发的, 那么以这个为入口开始分析。</p><h3 id="6-1-配置规则封装对象"><a href="#6-1-配置规则封装对象" class="headerlink" title="6.1 配置规则封装对象"></a>6.1 配置规则封装对象</h3><pre class="language-none"><code class="language-none">save 900 1  # 900 秒内至少有一个 key 被修改 (包括添加)save 300 10 # 300 秒内至少有 10 个 key 被修改save 60 100 # 60 秒内至少有 100 个 key 被修改</code></pre><p>一般上面就是配置 RDB 的自动触发规则了, 每一条规则在代码中会被封装为如下一个对象</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">saveparam</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 秒数</span>    <span class="token class-name">time_t</span> seconds<span class="token punctuation">;</span>    <span class="token comment">// 修改的次数</span>    <span class="token keyword">int</span> changes<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h3 id="6-2-RDB-相关的配置的存储"><a href="#6-2-RDB-相关的配置的存储" class="headerlink" title="6.2 RDB 相关的配置的存储"></a>6.2 RDB 相关的配置的存储</h3><p>RDB 相关的配置的话, 比如是否启用, 是否使用压缩等, 都保存在 redisServer 这个结构体中</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">/** 上次保存后对数据库 key 的修改次数 */</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> dirty<span class="token punctuation">;</span>      <span class="token comment">/** 用于在 BGSAVE 失败时, 恢复 dirty */</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> dirty_before_bgsave<span class="token punctuation">;</span>      <span class="token comment">/** 保存 RDB 的子进程 ID */</span>    <span class="token class-name">pid_t</span> rdb_child_pid<span class="token punctuation">;</span>       <span class="token comment">/** 保存规则数组 */</span>    <span class="token keyword">struct</span> <span class="token class-name">saveparam</span> <span class="token operator">*</span>saveparams<span class="token punctuation">;</span>     <span class="token comment">/** RDB 文件名, 默认为 dump.rdb */</span>    <span class="token keyword">char</span> <span class="token operator">*</span>rdb_filename<span class="token punctuation">;</span>    <span class="token comment">/** 是否启用 LZF 压缩算法对 RDB 文件压缩, 默认 yes */</span>    <span class="token keyword">int</span> rdb_compression<span class="token punctuation">;</span>               <span class="token comment">/** 是否启用 RDB 文件校验, 默认 yes */</span>    <span class="token keyword">int</span> rdb_checksum<span class="token punctuation">;</span>     <span class="token comment">/** 上一次 save 成功的时间 */</span>    <span class="token class-name">time_t</span> lastsave<span class="token punctuation">;</span>              <span class="token comment">/** 上一次尝试 bgsave 的时间 */</span>    <span class="token class-name">time_t</span> lastbgsave_try<span class="token punctuation">;</span>     <span class="token comment">/** 上次 RDB save 使用的时间 */</span>    <span class="token class-name">time_t</span> rdb_save_time_last<span class="token punctuation">;</span>        <span class="token comment">/** 当前 RDB 开始 save 的时间 */</span>    <span class="token class-name">time_t</span> rdb_save_time_start<span class="token punctuation">;</span>        <span class="token comment">/** 激活的子进程当前执行的 RDB 类型 (Redis 主从复制也是有依赖 RDB 的), 当前的执行 RDB 是要写入磁盘, 还是写入 socket, 发送给从节点 */</span>    <span class="token keyword">int</span> rdb_child_type<span class="token punctuation">;</span>    <span class="token comment">/** 上次 bgsave 的执行结果  C_OK / C_ERR */</span>    <span class="token keyword">int</span> lastbgsave_status<span class="token punctuation">;</span>       <span class="token comment">/** 是否允许写入, 如果不能 BGSAVE, 则不允许写入 */</span>    <span class="token keyword">int</span> stop_writes_on_bgsave_err<span class="token punctuation">;</span>    <span class="token comment">/** 无磁盘同步, 通过管道向父级写数据 */</span>    <span class="token keyword">int</span> rdb_pipe_write_result_to_parent<span class="token punctuation">;</span>    <span class="token comment">/** 无磁盘同步, 通过管道从从节点读数据 */</span>    <span class="token keyword">int</span> rdb_pipe_read_result_from_child<span class="token punctuation">;</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><h3 id="6-3-功能的触发"><a href="#6-3-功能的触发" class="headerlink" title="6.3 功能的触发"></a>6.3 功能的触发</h3><p>要触发 RDB 的话, 可以通过 save 和 bgsave 2 个命令和配置的规则达到了。<br>虽然是不同的方式, 但是在底层最终还是走到了相同的方法, 所以这里以配置规则的方式进行讲解。</p><p>配置规则的触发同样是基于定时器的, 也就是 serverCron 这个 Redis 的定时函数。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 前面代码省略</span>    <span class="token comment">// 判断后台是否正在进行 RDB 或者 AOF 操作或者还有子进程阻塞在父级</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token function">ldbPendingChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 代码省略</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果没有后台 RDB/AOF 在进行中, 进行检查是否需要立即开启 RDB/AOF</span>        <span class="token comment">// 遍历我们的触发规则列表</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>saveparamslen<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 配置规则</span>            <span class="token keyword">struct</span> <span class="token class-name">saveparam</span> <span class="token operator">*</span>sp <span class="token operator">=</span> server<span class="token punctuation">.</span>saveparams<span class="token operator">+</span>j<span class="token punctuation">;</span>            <span class="token comment">// 当前 Redis 中修改过的 key 的数量 > 规则配置的 key 修改数量值 并且 当前的时间 - 上次保存的时间 > 规则配置的时间频率 (配置的条件达到了)</span>            <span class="token comment">// 当前的时间 - 上次 bgsave 的时间 > 5 秒 或者 上次的 bgsave 为成功状态 (内部的判断条件)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>dirty <span class="token operator">>=</span> sp<span class="token operator">-></span>changes <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>unixtime<span class="token operator">-</span>server<span class="token punctuation">.</span>lastsave <span class="token operator">></span> sp<span class="token operator">-></span>seconds                 <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>unixtime <span class="token operator">-</span> server<span class="token punctuation">.</span>lastbgsave_try <span class="token operator">></span> CONFIG_BGSAVE_RETRY_DELAY <span class="token operator">||</span> server<span class="token punctuation">.</span>lastbgsave_status <span class="token operator">==</span> C_OK<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token comment">//记录日志</span>                <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"%d changes in %d seconds. Saving..."</span><span class="token punctuation">,</span> sp<span class="token operator">-></span>changes<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>sp<span class="token operator">-></span>seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// rdbSaveIndo 用来存储从节点的信息</span>                <span class="token comment">// Redis 中主从节点的数据同步也有通过 RDB 的</span>                <span class="token comment">// 把数据保存为一个 RDB 文件, 发送给从节点, 我们这里研究的是主节点自身数据的保存, 所以这里把这里的逻辑省略</span>                rdbSaveInfo rsi<span class="token punctuation">,</span> <span class="token operator">*</span>rsiptr<span class="token punctuation">;</span>                rsiptr <span class="token operator">=</span> <span class="token function">rdbPopulateSaveInfo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rsi<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 开始 RDB 数据保存</span>                <span class="token function">rdbSaveBackground</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_filename<span class="token punctuation">,</span>rsiptr<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// AOF 判断</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_state <span class="token operator">==</span> AOF_ON <span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 代码省略</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>上面就是配置规则的触发了, 条件达到后, 最终会执行 rdbSaveBackground 函数。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">rdbSaveBackground</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> rdbSaveInfo <span class="token operator">*</span>rsi<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> childpid<span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> start<span class="token punctuation">;</span>    <span class="token comment">// 再次判断是否有子线程在 RDB/ AOF </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token comment">// 保存当前的 dirty 到 dirty_before_bgsave</span>    server<span class="token punctuation">.</span>dirty_before_bgsave <span class="token operator">=</span> server<span class="token punctuation">.</span>dirty<span class="token punctuation">;</span>    <span class="token comment">// 更新为当前的时间</span>    server<span class="token punctuation">.</span>lastbgsave_try <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 打开一个父子通道, 用于将 RDB/AOF 保存过程中的信息从子进程移动到父级</span>    <span class="token function">openChildInfoPipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 当前的时间</span>    start <span class="token operator">=</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// fork 一个子进程, 如果返回值是 0, 表示为子进程, 大于 0 表示为父进程, -1 则表示 fork 失败</span>    <span class="token comment">// fork 成功后, 子进程也会从这里继续执行</span>    <span class="token comment">// 这个 fork 操作, 可以理解为克隆, 从父类克隆了一个完全一样的子类, 克隆后子类持有和父类一样的数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>childpid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 子进程逻辑</span>        <span class="token comment">// 释放掉一些子进程不需要的资源</span>        <span class="token function">closeClildUnusedResourceAfterFork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置一个执行过程的标题</span>        <span class="token function">redisSetProcTitle</span><span class="token punctuation">(</span><span class="token string">"redis-rdb-bgsave"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 调用 rdbSave 真正的执行 RDB 备份</span>        retval <span class="token operator">=</span> <span class="token function">rdbSave</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span>rsi<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 执行成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 计算当前进程使用了多少额外的内存</span>            <span class="token class-name">size_t</span> private_dirty <span class="token operator">=</span> <span class="token function">zmalloc_get_private_dirty</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>private_dirty<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span> <span class="token string">"RDB: %zu MB of memory used by copy-on-write"</span><span class="token punctuation">,</span> private_dirty<span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            server<span class="token punctuation">.</span>child_info_data<span class="token punctuation">.</span>cow_size <span class="token operator">=</span> private_dirty<span class="token punctuation">;</span>            <span class="token comment">// 将子进程的信息发送给父进程, 也就是拷贝到 server.child_info_pipe[2] 中</span>            <span class="token function">sendChildInfo</span><span class="token punctuation">(</span>CHILD_INFO_TYPE_RDB<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 退出子进程</span>        <span class="token function">exitFromChild</span><span class="token punctuation">(</span><span class="token punctuation">(</span>retval <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 父进程逻辑</span>        <span class="token comment">// 父进程 fork 出子进程后, 就能继续执行自身的任务了</span>        <span class="token comment">// fork 消耗的时间</span>        server<span class="token punctuation">.</span>stat_fork_time <span class="token operator">=</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start<span class="token punctuation">;</span>        <span class="token comment">// 计算 fork 频率, 单位 GB/second</span>        server<span class="token punctuation">.</span>stat_fork_rate <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000000</span> <span class="token operator">/</span> server<span class="token punctuation">.</span>stat_fork_time <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 尝试添加延迟事件</span>        <span class="token comment">// 当后面的时间大于 server.latency_monitor_threshold, 会向 server.latency_events 添加一个延迟事件, 用于后面的延迟分析</span>        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">,</span>server<span class="token punctuation">.</span>stat_fork_time<span class="token operator">/</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// fork 失败</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>childpid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 关闭父子通道</span>            <span class="token function">closeChildInfoPipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 更新 上一次 bgsave_status 为失败状态</span>            server<span class="token punctuation">.</span>lastbgsave_status <span class="token operator">=</span> C_ERR<span class="token punctuation">;</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Can't save in background: fork: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 返回错误码</span>            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"Background saving started by pid %d"</span><span class="token punctuation">,</span>childpid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// RDB 开始的时间</span>        server<span class="token punctuation">.</span>rdb_save_time_start <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 子进程的进程 ID</span>        server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">=</span> childpid<span class="token punctuation">;</span>        <span class="token comment">// RDB 类型为写入磁盘类型</span>        server<span class="token punctuation">.</span>rdb_child_type <span class="token operator">=</span> RDB_CHILD_TYPE_DISK<span class="token punctuation">;</span>        <span class="token comment">// 更新全局的 dict.dict_can_resize 进行字典扩容的控制, 控制存储数据的 dict 扩容</span>        <span class="token function">updateDictResizePolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 更新 dict 的扩容行为 */</span><span class="token keyword">void</span> <span class="token function">updateDictResizePolicy</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 当前的没有 rdb 子进程 和 aof 子进程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">// 更新 dict.c 中的 dict_can_resize 为 1, 表示全部的 dict 可以进行扩容</span>        <span class="token function">dictEnableResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment">// 更新 dict.c 中的 dict_can_resize 为 0, 表示全部的 dict 不可以进行扩容, 但是这个配置在 dict 中的数据达到某个条件后, 还是能进行扩容的</span>        <span class="token function">dictDisableResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上面就是 rdbSaveBackgroud 方法的逻辑了, 其最重要的一点就是 fork 出一个子进程, 执行最终的 RDB 文件的保存, 也就是 <strong>rdbSave</strong> 函数。<br>补充一点, 通过 bgsave 命令, 最终会走到上面的 rdbSaveBackground 函数, 而直接的 save 命令则是直接走到了 rdbSave 函数。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 真正的 RDB 文件保存</span><span class="token keyword">int</span> <span class="token function">rdbSave</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> rdbSaveInfo <span class="token operator">*</span>rsi<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> tmpfile<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/** 错误消息的当前工作目录路径 */</span>    <span class="token keyword">char</span> cwd<span class="token punctuation">[</span>MAXPATHLEN<span class="token punctuation">]</span><span class="token punctuation">;</span>     FILE <span class="token operator">*</span>fp<span class="token punctuation">;</span>    rio rdb<span class="token punctuation">;</span>    <span class="token keyword">int</span> error <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">snprintf</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">,</span><span class="token string">"temp-%d.rdb"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 创建打开一个临时文件</span>    fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 打开临时文件失败</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>cwdp <span class="token operator">=</span> <span class="token function">getcwd</span><span class="token punctuation">(</span>cwd<span class="token punctuation">,</span> MAXPATHLEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Failed opening the RDB file %s (in server root dir %s) for saving: %s"</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> cwdp <span class="token operator">?</span> cwdp <span class="token operator">:</span> <span class="token string">"unknown"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 初始化一个 rio 对象, 该对象是一个文件对象 IO</span>    <span class="token function">rioInitWithFile</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rdb<span class="token punctuation">,</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 配置判断, 通过分批将数据 fsync 到硬盘, 用来缓冲 io</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_save_incremental_fsync<span class="token punctuation">)</span>        <span class="token function">rioSetAutoSync</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rdb<span class="token punctuation">,</span>REDIS_AUTOSYNC_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// RDB_SAVE_NONE = 0 </span>    <span class="token comment">// 向文件流里面写入内容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveRio</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rdb<span class="token punctuation">,</span><span class="token operator">&amp;</span>error<span class="token punctuation">,</span>RDB_SAVE_NONE<span class="token punctuation">,</span>rsi<span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        errno <span class="token operator">=</span> error<span class="token punctuation">;</span>        <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 将缓冲区中的数据写入到文件流中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fflush</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">EOF</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token comment">// 执行多一次 fsync, 确保数据都写入到文件中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fsync</span><span class="token punctuation">(</span><span class="token function">fileno</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token comment">// 关闭文件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">EOF</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token comment">// 原子性改变 rdb 文件的名字, 如果存在同名的文件会删除</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rename</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span>filename<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 改变名字失败, 则获得当前目录路径, 发送日志信息, 删除临时文件</span>        <span class="token keyword">char</span> <span class="token operator">*</span>cwdp <span class="token operator">=</span> <span class="token function">getcwd</span><span class="token punctuation">(</span>cwd<span class="token punctuation">,</span>MAXPATHLEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Error moving temp DB file %s on the final destination %s (in server root dir %s): %s"</span><span class="token punctuation">,</span> tmpfile<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> cwdp <span class="token operator">?</span> cwdp <span class="token operator">:</span> <span class="token string">"unknown"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">unlink</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"DB saved on disk"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 更新 RDB 的结构</span>    server<span class="token punctuation">.</span>dirty <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>lastsave <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>lastbgsave_status <span class="token operator">=</span> C_OK<span class="token punctuation">;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>werr<span class="token operator">:</span>    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Write error saving DB on disk: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unlink</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 向文件流里面写入内容</span><span class="token keyword">int</span> <span class="token function">rdbSaveRio</span><span class="token punctuation">(</span>rio <span class="token operator">*</span>rdb<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>error<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> rdbSaveInfo <span class="token operator">*</span>rsi<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    dictIterator <span class="token operator">*</span>di <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>    <span class="token keyword">char</span> magic<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> cksum<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> processed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 开启了 RDB 文件校验码功能</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_checksum<span class="token punctuation">)</span>        rdb<span class="token operator">-></span>update_cksum <span class="token operator">=</span> rioGenericUpdateChecksum<span class="token punctuation">;</span>    <span class="token comment">// RDB_VERSION = 9</span>    <span class="token comment">// magic = REDIS0009</span>    <span class="token function">snprintf</span><span class="token punctuation">(</span>magic<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>magic<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"REDIS%04d"</span><span class="token punctuation">,</span>RDB_VERSION<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 写入 REDIS0009</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbWriteRaw</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span>magic<span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token comment">// 写入辅助字段 redis-ver, redis-bits, ctime, used-mem, 如果入参的 rsi 不为空, 再写入 repl-stream-db repl-id repl-offset, 最后写入 aof-preamble</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveInfoAuxFields</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span>flags<span class="token punctuation">,</span>rsi<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token comment">// 写入 module 相关的信息, 新版本增加的, 暂时跳过, 操作码为上面的 247</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveModulesAux</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span> REDISMODULE_AUX_BEFORE_RDB<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token comment">// 遍历数据库数量</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                redisDb <span class="token operator">*</span>db <span class="token operator">=</span> server<span class="token punctuation">.</span>db<span class="token operator">+</span>j<span class="token punctuation">;</span>        dict <span class="token operator">*</span>d <span class="token operator">=</span> db<span class="token operator">-></span>dict<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dictSize</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token comment">// 迭代器</span>        di <span class="token operator">=</span> <span class="token function">dictGetSafeIterator</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 写入 254 操作码, 也就是数据库编号</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveType</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span>RDB_OPCODE_SELECTDB<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token comment">// 写入数据库编号</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveLen</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token class-name">uint64_t</span> db_size<span class="token punctuation">,</span> expires_size<span class="token punctuation">;</span>        <span class="token comment">// 数据库数据数量</span>        db_size <span class="token operator">=</span> <span class="token function">dictSize</span><span class="token punctuation">(</span>db<span class="token operator">-></span>dict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 数据库过期数量</span>        expires_size <span class="token operator">=</span> <span class="token function">dictSize</span><span class="token punctuation">(</span>db<span class="token operator">-></span>expires<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 写入 251 操作码, 也就是 resized 相关的内容</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveType</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span>RDB_OPCODE_RESIZEDB<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveLen</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span>db_size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveLen</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span>expires_size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token comment">// 遍历数据</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>de <span class="token operator">=</span> <span class="token function">dictNext</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// key</span>            sds keystr <span class="token operator">=</span> <span class="token function">dictGetKey</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// value</span>            robj key<span class="token punctuation">,</span> <span class="token operator">*</span>o <span class="token operator">=</span> <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">long</span> <span class="token keyword">long</span> expire<span class="token punctuation">;</span>            <span class="token comment">// 把一个 sds 解析为 robj</span>            <span class="token function">initStaticStringObject</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>keystr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 过期时间</span>            expire <span class="token operator">=</span> <span class="token function">getExpire</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 写入 KeyValuePair </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveKeyValuePair</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">,</span>o<span class="token punctuation">,</span>expire<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                 <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token comment">// RDB_SAVE_AOF_PREAMBLE = 1, AOF_READ_DIFF_INTERVAL_BYTES = 1024*10</span>            <span class="token comment">// 通过 rdbSaveBackground() 方法到这里的 flags = RDB_SAVE_NONE = 0, 所以下面的不会执行到</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> RDB_SAVE_AOF_PREAMBLE <span class="token operator">&amp;&amp;</span> rdb<span class="token operator">-></span>processed_bytes <span class="token operator">></span> processed<span class="token operator">+</span>AOF_READ_DIFF_INTERVAL_BYTES<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                processed <span class="token operator">=</span> rdb<span class="token operator">-></span>processed_bytes<span class="token punctuation">;</span>                <span class="token function">aofReadDiffFromParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 释放迭代器</span>        <span class="token function">dictReleaseIterator</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">;</span>        di <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// rsi 从节点信息, 正常的 RDB, rsi 为 null</span>    <span class="token comment">// Redis lua 预置脚本: Redis 提供了先将 lua 脚本保存到数据库中, 同时返回一个 SHA1 的字符串, 然后客户端调用这个 SHA1 字符串就能调用到对应的 lua 脚本</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rsi <span class="token operator">&amp;&amp;</span> <span class="token function">dictSize</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>lua_scripts<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 主从配置, 才会进入到这里, 正常的 RDB 保存不会</span>        di <span class="token operator">=</span> <span class="token function">dictGetIterator</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>lua_scripts<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>de <span class="token operator">=</span> <span class="token function">dictNext</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            robj <span class="token operator">*</span>body <span class="token operator">=</span> <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 写入 aux 配置, </span>            <span class="token comment">// 先写入 250 操作符, </span>            <span class="token comment">// 再 aux 属性, key 为 lua, Value 为 server.lua_scripts 的 lua 脚本</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveAuxField</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span><span class="token string">"lua"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>body<span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>body<span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">dictReleaseIterator</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">;</span>        di <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token comment">// 操作码 247</span>    <span class="token comment">// 同时将 module 的配置写入</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveModulesAux</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span> REDISMODULE_AUX_AFTER_RDB<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token comment">// EOF 结束操作码 写入</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveType</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span>RDB_OPCODE_EOF<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    cksum <span class="token operator">=</span> rdb<span class="token operator">-></span>cksum<span class="token punctuation">;</span>    <span class="token comment">// 校验码获取</span>    <span class="token function">memrev64ifbe</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cksum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 写入校验码</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWrite</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span><span class="token operator">&amp;</span>cksum<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>  <span class="token comment">// 写入错误</span>werr<span class="token operator">:</span>    <span class="token comment">// 保存错误码</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">*</span>error <span class="token operator">=</span> errno<span class="token punctuation">;</span>      <span class="token comment">// 如果没有释放迭代器, 则释放</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>di<span class="token punctuation">)</span> <span class="token function">dictReleaseIterator</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span></code></pre><p>上面就是整个 RDB 文件保存的过程了。至于 RDB 文件的读取, 则可以通过 rdbLoad 函数, 这里就不展开了。</p><p>从中可以看出</p><blockquote><ol><li>父进程 fork 出子进程后, 子进程里面的数据和父进程是一样的</li><li>后面在子进程将自身的数据写入到文件中, 父进程修改的数据，子进程是无感知的</li><li>基于第二步, 在子进程开始 RDB 和 RDB 结束的这段时间, Redis 宕机或者重启, 父级处理成功的部分数据会丢失</li><li>同时 RDB 不是实时触发的, 只有在某个时间段 key 变更了多少次 (配置文件配置的), 才会触发 RDB, 在没有触发的这段时间, Redis 宕机或者重启, 这部分的数据也会丢失</li></ol></blockquote><p>自此整个 Redis RDB 过程就结束了。  </p><blockquote><p>触发执行的整个过程很简单, 整段逻辑读下去基本没有什么烧脑的<br>唯一有的绕的就是数据写入时, 各种数据如何写入到文件中, 但是理解了上面的文件结构，整数规则和操作码基本可以猜测到里面的逻辑了</p></blockquote><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h2><p><a href="https://blog.csdn.net/men_wen/article/details/71248449">Redis源码剖析和注释 (十七) — RDB持久化机制</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 命令处理过程</title>
      <link href="/article/2021/1674753191/"/>
      <url>/article/2021/1674753191/</url>
      
        <content type="html"><![CDATA[<p>我们知道 Redis 是一个基于内存的高性能键值数据库, 它支持多种数据结构, 提供了丰富的命令, 可以用来实现缓存、消息队列、分布式锁等功能。<br>而在享受 Redis 带来的种种好处时, 是否曾好奇过 Redis 是如何处理我们发往它的命令的呢？</p><p>本文将以<strong>伪代码</strong>的形式简单分析一下 Redis 命令处理的过程, 探讨其背后的机制。</p><h2 id="1-例子"><a href="#1-例子" class="headerlink" title="1 例子"></a>1 例子</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> myKey myValueok</code></pre><p>上面是一个简单的 Redis 命令执行过程:  </p><blockquote><ol><li>用户借助 Redis 的<strong>客户端</strong> (redis-cli, 或者各种第三方的客户端) 向 Redis <strong>服务端</strong>发送了一个 set 命令</li><li>Redis <strong>服务端</strong>将其后面的 myKey 和 myValue 存储下来</li><li>Redis <strong>服务端</strong>再向客户端响应一个 ok 值, 表示处理成功。</li></ol></blockquote><p>下面我们就以这个为例子, 来分析一下 Redis 命令处理的过程。</p><p>备注:</p><blockquote><ol><li>下面的逻辑, 是按照 <strong>Redis 5.x</strong> 的版本进行分析的, 各个大版本之间可能会有出入</li><li>在伪代码分析过程中, 会将大部分无关的逻辑和异常场景进行省略</li><li>因为整个过程会涉及到大量 <strong>Redis 事件轮询</strong>的知识和以 set 为例, 会涉及 <strong>Redis String 编码</strong>的知识, 可以先看一下往期这 2 篇先了解一下</li></ol></blockquote><h2 id="2-认识一下-redisServer-和-client"><a href="#2-认识一下-redisServer-和-client" class="headerlink" title="2 认识一下 redisServer 和 client"></a>2 认识一下 redisServer 和 client</h2><p>在真正进行分析前, 有 2 个对象需要先介绍一下, 可以说他们贯穿了整个命令处理的过程。</p><h3 id="2-1-redisServer"><a href="#2-1-redisServer" class="headerlink" title="2.1 redisServer"></a>2.1 redisServer</h3><p>redisServer 可以看做是整个 Redis 服务端运行时的上下文, 保存着整个 Redis 的配置和运行中产生的数据。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> redisServer <span class="token punctuation">&#123;</span>        <span class="token comment">// Tcp 连接对应的文件描述符 fd 存放的数组</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ipfd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 所有存入到 Redis 中的数据, 都会存放到这里</span>    redisDb<span class="token punctuation">[</span><span class="token punctuation">]</span> db <span class="token operator">=</span> <span class="token keyword">new</span> redisDb<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 命令字典, 保存着 Redis 支持的所有命令</span>    <span class="token comment">// Redis 支持的所有命令和命令对应的执行函数, 都会存放到这里</span>    dict commands<span class="token punctuation">;</span>        <span class="token comment">// 一个双向链表, 所有连接到 Redis 的客户端, 都会存放到这里</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span>client<span class="token punctuation">></span></span> clients<span class="token punctuation">;</span>        <span class="token comment">// 向 Redis 发起请求的客户端, Redis 处理完成后, 如果需要响应客户端数据</span>    <span class="token comment">// 会将这个客户端先放到这里, 后面统一响应</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span>client<span class="token punctuation">></span></span> clients_pending_write<span class="token punctuation">;</span>        <span class="token comment">// 事件循环, Redis 的核心</span>    aeEventLoop el<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="2-1-1-int-ipfd"><a href="#2-1-1-int-ipfd" class="headerlink" title="2.1.1 int[] ipfd"></a>2.1.1 int[] ipfd</h4><pre class="language-config" data-language="config"><code class="language-config">bind 127.0.0.1 </code></pre><p>上面的配置应该很熟悉吧。<br>在 Redis 的配置文件中, 加上了这个配置, 就表示 Redis 只有本地可以访问, 因为他只会监听本地机器上的的连接, 当然也可以配置具体的 Ip 地址。 </p><p>在 Redis 服务端启动后, 会和<strong>bind 指定的 Ip 地址</strong> 建立对应的 Tcp 连接, 同时会获取到一个文件描述符 fd (可以理解代表当前 Tcp 连接的唯一 Id, 持有这个文件描述符, 代表了持有了对应的端口的监听能力),<br>并将连接的 fd 存放在这个 ipfd 数组中, 最大支持 16 个连接。</p><h4 id="2-1-2-redisDb-db"><a href="#2-1-2-redisDb-db" class="headerlink" title="2.1.2 redisDb[] db"></a>2.1.2 redisDb[] db</h4><p>Redis 本身默认支持 16 个数据库, 只是我们正常情况都是在使用 0 号数据库。 可以通过 <strong>select [0 到 15]</strong> 进行切换。<br>而这个 redisDb[] db 是一个长度为 16 的数组, 每个元素都是一个 redisDb 对象, 代表着一个 Redis 数据库。</p><p>redisDb 本身的定义很简单, 如下:  </p><p><img src="https://pic.imgdb.cn/item/6562e0fdc458853aeffe9db0.png" alt="Alt &#39;redisDb 定义&#39;"></p><p>其中 dict 是字典的意思, 本身就是一个 key-value 的数据结构, 可以直接看做是一个 Map (JDK 1.7 的 HashMap), 本质是一个数组, 数组中的每个元素是一个 dictEntry。<br>当发送了 <strong>set myKey myValue</strong> 到服务端, myKey, myValue 就会以键值对的形式存储在 redisDb 中的 dict 中。</p><h4 id="2-1-3-dict-commands"><a href="#2-1-3-dict-commands" class="headerlink" title="2.1.3 dict commands"></a>2.1.3 dict commands</h4><p>首先它也是一个 dict, 也就是一个 Map, 一个 key-value 的映射属性, 具体的含义就是命令字典。</p><p>在平时中执行的 Redis 命令, 这个命令对应的执行函数就是存放在这里, 格式如: Map&lt;命令的 key, redisCommand&gt;。<br>当发送了 <strong>set myKey myValue</strong> 到服务端, 服务端就用通过 <strong>set</strong> 这个命令 key 到这里找到对应的 setCommand, 然后执行里面的函数。</p><h4 id="2-1-4-List-clients"><a href="#2-1-4-List-clients" class="headerlink" title="2.1.4 List&lt;client&gt; clients"></a>2.1.4 List&lt;client&gt; clients</h4><p>客户端双向链表。<br>Redis 本身是支持多个客户端的, Redis 接收到客户端的连接后, Redis 内部会将其封装为 client, 然后维护在这个双向链表。<br>具体的属性下面讲解。</p><h4 id="2-1-5-List-clients-pending-write"><a href="#2-1-5-List-clients-pending-write" class="headerlink" title="2.1.5 List&lt;client&gt; clients_pending_write"></a>2.1.5 List&lt;client&gt; clients_pending_write</h4><p>待响应客户端双向链表。<br>服务端处理完客户端的请求后, 可能需要响应客户端结果, 也就是响应数据。<br>而 Redis 不是处理完就立即响应的, 而是先将响应结果放到客户端的<strong>输出缓存区</strong>, 然后再后面统一一起响应。<br>所以, 有数据需要响应的客户端, 会将其放到这个链表中。</p><h4 id="2-1-6-aeEventLoop-el"><a href="#2-1-6-aeEventLoop-el" class="headerlink" title="2.1.6 aeEventLoop *el"></a>2.1.6 aeEventLoop *el</h4><p>事件轮询对象: 本质就是一个包装了多路复用的死循环。</p><p>大体的实现如下:<br><img src="https://pic.imgdb.cn/item/6562e034c458853aeffbd257.png" alt="Alt &#39;aeEventLoop 定义&#39;"></p><h3 id="2-2-client"><a href="#2-2-client" class="headerlink" title="2.2 client"></a>2.2 client</h3><p>client 是理解 Redis 命令处理过程的另一个重要对象, 他代表着一个客户端连接。<br>Redis 客户端连接到服务端时, 服务端将这个客户端的封装成这个对象。</p><p>client 本身的属性如下:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> client <span class="token punctuation">&#123;</span>        <span class="token comment">// 同 redisServer 的 ipfd</span>    <span class="token comment">// 当 Redis 接收到客户端的连接后, 会获取到一个代表这个客户端 Tcp 连接的文件描述符 fd, 然后存放到这个属性中</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>        <span class="token comment">// 当前客户端的是否已经经过了密码认证, 0 代表未认证, 1 代表已认证</span>    <span class="token keyword">int</span> authenticated<span class="token punctuation">;</span>    <span class="token comment">// 输入缓存区, 客户端发送过来的数据会先存放在这里</span>    sds querybuf<span class="token punctuation">;</span>        <span class="token comment">// 命令参数的个数, 一个客户端发送过来的命令, 会被 Redis 拆分成多个参数</span>    <span class="token comment">// 比如 set myKey myValue, 总共 3 个参数</span>    <span class="token keyword">int</span> argc<span class="token punctuation">;</span>        <span class="token comment">// 命令参数, 一个客户端发送过来的命令, 会被 Redis 拆分成多个参数</span>    <span class="token comment">// 比如 set myKey myValue, 就会被拆分成 3 个参数, 3 个参数会存放在这个数组中</span>    robj<span class="token punctuation">[</span><span class="token punctuation">]</span> argv<span class="token punctuation">;</span>        <span class="token comment">// 一个数组, 固定输出缓冲区, 用来存放响应客户端的数据</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">16</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 一个链表, 动态输出缓冲区, 同样是用来存放响应客户端的数据</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span>clientReplyBlock<span class="token punctuation">></span></span> reply<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>下面介绍一下几个重要的属性。</p><h4 id="2-2-1-sds-querybuf"><a href="#2-2-1-sds-querybuf" class="headerlink" title="2.2.1 sds querybuf"></a>2.2.1 sds querybuf</h4><p>输入缓冲区。<br>客户端发送到服务端的数据, Redis 服务端收到了, 会先存放到这里。实现结构是一个 sds。 大体的定义如下:<br><img src="https://pic.imgdb.cn/item/6562e2b5c458853aef04f939.png" alt="Alt &#39;sds 定义&#39;"></p><h4 id="2-2-2-robj-argv"><a href="#2-2-2-robj-argv" class="headerlink" title="2.2.2 robj[] argv"></a>2.2.2 robj[] argv</h4><p>querybuf 中的数据进行解析后的数据存放的地方, 具体的属性是一个 redisObject 的数组。<br>而一个 sds 类型 redisObject 的结构如下:<br><img src="https://pic.imgdb.cn/item/6562e2b6c458853aef04ff46.png" alt="Alt ‘sds 类型的 redisObject&#39;"></p><h4 id="2-2-3-char-buf"><a href="#2-2-3-char-buf" class="headerlink" title="2.2.3 char[] buf"></a>2.2.3 char[] buf</h4><p>一个可以存放 16 * 1024 个字符的数组。 客户端发送的命令, Redis 服务端处理完成后, 需要进行响应, 而响应的内容会先存放到这里。<br>因为是一个长度固定的数组, 所以叫做<strong>固定输出缓冲区</strong>, 最多可以存放 16kb 的响应数据。</p><h4 id="2-2-4-List-reply"><a href="#2-2-4-List-reply" class="headerlink" title="2.2.4 List&lt;clientReplyBlock&gt; reply"></a>2.2.4 List&lt;clientReplyBlock&gt; reply</h4><p><strong>动态输出缓冲区</strong>。<br>当 Redis 服务端响应客户端数据大于上面的 char[] buf 的容量时, 就先放到这里 (双向链表理论上没有大小限制)。</p><p>本质是一个 clientReplyBlock 的双向链表。<br>clientReplyBlock 的定义也很简单。如下, 可以简单的看做是一个 char[] 的封装。<br><img src="https://pic.imgdb.cn/item/6562e2b2c458853aef04effc.png" alt="Alt &#39;clientReplyBlock 定义&#39;"></p><p>可以看出来, Redis 的响应缓存区是由一个固定大小的 <strong>char 数组</strong>加一个动态变化的 <strong>char 数组链表</strong>共同构成的。<br>这么组织的好处是: 16kb 的固定 buffer, 基本满足大部分的情况的使用, 提前声明好可以避免频繁分配、回收内存。<br>动态的响应链表则是起到一个兜底的作用, 保证大数据量时的响应。而本身在需要时进行再分配内存, 使用后释放, 可以起到节省内存的作用。</p><p>到此, Redis 命令处理过程中的 2 个重要对象: redisServer 和 client 就介绍完了, 只需要大体知道 2 个对象里面有哪些属性, 大体是干什么的即可,<br>怎么实现等都可以不用深入, 在开始前先介绍这 2 个对象, 只是是为了后面的分析更加清晰。</p><h2 id="3-Redis-服务端启动流程"><a href="#3-Redis-服务端启动流程" class="headerlink" title="3 Redis 服务端启动流程"></a>3 Redis 服务端启动流程</h2><pre class="language-bash" data-language="bash"><code class="language-bash">./redis-server ./redis.conf <span class="token parameter variable">--port</span> <span class="token number">6666</span> <span class="token parameter variable">--dbfilename</span> dump.rdb</code></pre><p>在服务器上可以通过上面的命令启动一个 Redis 服务端。<br>启动脚本 redis-server 后面紧跟的是 Redis 的配置文件, 再后面是用户想要指定的参数 (这里将端口修改为 6666)。</p><p>整个启动的过程如下:<br><img src="https://pic.imgdb.cn/item/6562e472c458853aef0b6a5f.png" alt="Alt &#39;Redis 服务端启动流程&#39;"></p><blockquote><ol><li>通过脚本启动 Redis 服务端</li><li>创建一个 redisServer 对象, 这时 redisServer 里面所有的配置都是默认值, 比如监听的端口, 连接超时等</li><li>读取配置文件和命令行参数并覆盖掉 redisServer 里面的默认配置, 比如这里的端口, 默认为 6379, 通过命令行参数覆盖为 6666, 在这个过程, 还会将 server.c 里面写好的命令和命令对应的函数从一个静态数组中加载到 redisServer 的 commands 字典中</li><li>将 redisServer 里面的事件轮询 aeEventLoop 创建出来</li><li>和配置文件里面的 <strong>bind 地址 + 启动端口</strong>建立起 Tcp 连接, 可以得到对应连接的文件描述 fd, 可以理解为一个 Id</li><li>为每一个文件描述符, 也就是 Tcp 连接, 在事件轮询中注册一个<strong>可读的文件事件</strong>, 执行函数为 <strong>acceptTcpHandler</strong> (可以理解为告诉多路复用, 关心对应的 Tcp 连接的连接事件, 触发了执行 acceptTcpHandler 函数)</li><li>从磁盘中将 Redis 上次运行的数据加载到 redisServer 的 16 个 redisDb 中 (如果有的话)</li><li>设置事件轮询的阻塞前和阻塞后执行的函数</li><li>启动事件轮询, 进入一个死循环, 整个 Redis 服务端启动成功</li></ol></blockquote><p>大体的伪代码逻辑如下: </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// server.c </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. redisServer 各个属性进行默认值设置</span>    <span class="token function">initServerConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 解析命令行参数</span>    <span class="token comment">// 启动脚本的参数会通过 main 方法的 argv 传递进来， 这里会对这些参数进行解析处理</span>    <span class="token function">parsingCommandLineArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3. 根据配置文件和命令行参数的配置覆盖掉 redisServer 的默认值</span>    <span class="token comment">// 内部会执行一个函数 populateCommandTable(), 将 Reids 所以支持的命令和对应的函数放到 redisServer.commands 中</span>    <span class="token function">loadServerConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 4. 初始化服务端</span>    <span class="token comment">// 4.1 创建事件轮询对象</span>    <span class="token comment">// 4.2 对所有绑定的 Ip 对应的 6666 端口(默认为 6379, 上面启动命令修改为了 6666) 开启 TCP 监听, 并得到对应的 Ip 文件描述符 fd, 存放到 redisServer 的 ipfd 中</span>    <span class="token comment">// 4.3 对 Redis 的 16 个数据库进行初始化</span>    <span class="token comment">// 4.4 向事件轮询注册 1 个时间事件: 100 毫秒执行一次, 执行函数 serverCron</span>    <span class="token comment">// 4.5 对每个 ipfd 向事件轮询注册 1 个可读的文件事件: 执行函数 acceptTcpHandler</span>    <span class="token comment">// 其他无法的省略</span>    <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 5. 从磁盘中加载数据到 redisServer 的 redisDB 中 (AOF, RDB)</span>    <span class="token function">loadDataFromDisk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 6. 向事件轮询注册 阻塞前调用函数 beforeSleep</span>    <span class="token function">aeSetBeforeSleepProc</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>beforeSleep<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 7. 向事件轮询注册 阻塞后调用函数 afterSleep</span>    <span class="token function">aeSetAfterSleepProc</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>afterSleep<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 8. 启动事件轮询, 这时进入了死循环, 整个服务端启动</span>    <span class="token function">aeMain</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 9. 从事件轮询中退出来，表示程序需要退出了, 删除事件轮询</span>    <span class="token function">aeDeleteEventLoop</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>启动后的 redisServer 的状态如下:<br><img src="https://pic.imgdb.cn/item/6562e87cc458853aef1ab4b2.png" alt="Alt &#39;Redis 服务端启动后 redisServer 的状态&#39;"></p><h2 id="4-Redis-客户端连接服务端"><a href="#4-Redis-客户端连接服务端" class="headerlink" title="4 Redis 客户端连接服务端"></a>4 Redis 客户端连接服务端</h2><p>Redis 服务端端启动后, 整个 Redis 就进入到事件轮询里面的死循环, 一直在执行下面的逻辑</p><p><img src="https://pic.imgdb.cn/item/6562e690c458853aef1391f4.png" alt="Alt &#39;Redis 服务端启动后事件轮询中执行的死循环逻辑&#39;"></p><p>这时有个客户端通过 <strong>Ip + 端口</strong>连接到 Redis 服务端, 多路复用观察到有上游关心的可读事件, 会保留下这个连接请求事件。<br>这时 redisServer 的事件轮询执行到了 <strong>从多路复用中获取事件</strong>, 获取到了客户端的连接事件, 接着触发了 acceptTcpHandler 函数。</p><p><img src="https://pic.imgdb.cn/item/6562e694c458853aef13a01d.png" alt="Alt &#39;Redis 服务端接收到客户端的连接&#39;"></p><p>触发的 acceptTcpHandler 函数的逻辑如下: </p><p><img src="https://pic.imgdb.cn/item/6562e9c3c458853aef1f6a84.png" alt="Alt &#39;Redis acceptTcpHandler 函数逻辑&#39;"> </p><blockquote><ol><li>将连接到  Redis 服务端的客户端封装为 client, 代表当前的客户端</li><li>将封装后的 client, 放到 redisServer 的客户端双写链表 List&lt;client&gt; clients 中</li><li>向事件轮询为这个客户端注册一个<strong>可读的文件事件</strong>, 触发执行的函数为 readQueryFromClient</li></ol></blockquote><p>大体的伪代码逻辑如下: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// networking.c</span><span class="token keyword">void</span> <span class="token function">acceptTcpHandler</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 1. 获取客户端 Tcp 连接对应的文件描述符</span>    <span class="token keyword">int</span> cfd <span class="token operator">=</span> <span class="token function">anetTcpAccept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 创建 client </span>    <span class="token function">createClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3. 向事件轮询注册一个当前客户端的可读的文件事件, 执行函数为: readQueryFromClient</span>    <span class="token function">registerClientFdReadFilesEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4. 初始化 client 的属性, 比如选中的数据库默认为第一个, 输入和输出缓存区创建</span>    <span class="token function">initClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 5. 将 client 添加到 redisServer 的 client 双向链表中</span>    <span class="token function">linkClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 6. 最大客户端数量检查, 如果超过了, 就关闭这个连接 (默认为 10000) </span>    <span class="token function">maxClientNumCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 7. 保护模式检查, 默认开启 (protected-mode yes)</span>    <span class="token comment">// 开启保护模式时, 没有配置 bind Ip 和密码, 同时客户端的 Ip 地址不是 127.0.0.1 或 ::1, 就关闭这个连接</span>    <span class="token function">protectedModeCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>接受了客户端的连接后的 redisServer 的状态如下:<br><img src="https://pic.imgdb.cn/item/6562ea80c458853aef221ddf.png" alt="Alt &#39;Redis 接收到客户端的连接后 redisServer 的状态&#39;"></p><h2 id="5-客户端发送命令到服务端"><a href="#5-客户端发送命令到服务端" class="headerlink" title="5 客户端发送命令到服务端"></a>5 客户端发送命令到服务端</h2><p>Redis 的客户端和服务端之间的数据的传输, 都是遵循内部自定义的一套协议: <strong>RESP</strong>。</p><h3 id="5-1-RESP-协议"><a href="#5-1-RESP-协议" class="headerlink" title="5.1 RESP 协议"></a>5.1 RESP 协议</h3><p>当用户在客户端输入对应的请求命令时, 比如 <strong>set myKey myValue</strong>, 客户端会将这个命令转换为 RESP 协议的格式, 然后发送到服务端。</p><p>RESP 介绍的具体介绍, 可以看一下这篇<a href="https://blog.csdn.net/ldw201510803006/article/details/126093440">文章</a></p><p>所有的内容通过 <strong>\r\n</strong> 进行分割, 然后定义了几个标识符, 如下:<br><code>+</code> 标识后面是一个简单的字符串<br><code>$</code> 表示后面的内容是一个二进制安全的字符串, 后面会紧跟着一个数字, 表示字符串的长度<br><code>*</code> 表示后面的内容是一个数组, 后面同样紧跟一个数字, 表示数组的长度<br>…… 后面省略  </p><p>比如:<br><strong>set myKey myValue</strong>   </p><ol><li>三个字符串 (set + myKey + myValue), 那么转换后就是 3 个二进制安全的字符串, 所以开头就是 <code>*3</code></li><li>跟后面的内容用 \r\n 分隔, 所以就是 <code>*3\r\n</code></li><li>第一个字符串是 set, 长度 3, 所以就是 <code>*3\r\n$3\r\nset\r\n</code>  </li><li>后面的 myKey 和 myValue 类似, 最终转换后的内容如下 <code>*3\r\n$3\r\nset\r\n$5\r\nmyKey\r\n$7\r\nmyValue\r\n</code></li></ol><h3 id="5-2-请求类型"><a href="#5-2-请求类型" class="headerlink" title="5.2 请求类型"></a>5.2 请求类型</h3><p>在 Redis 解析客户端的请求内容前, 还需要确定当前的请求的方式, 判断的逻辑如下: </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 请求内容以 * 开头, 那么请求类型为 mult bulk 请求, 否则是 inline 请求</span><span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>querybuf<span class="token punctuation">[</span>c<span class="token operator">-></span>qb_pos<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    c<span class="token operator">-></span>reqtype <span class="token operator">=</span> PROTO_REQ_MULTIBULK<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    c<span class="token operator">-></span>reqtype <span class="token operator">=</span> PROTO_REQ_INLINE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到  Redis 支持 2 种请求的类型 <strong>mult bulk 请求</strong>, 还是 <strong>inline 请求</strong>。<br>2 者的区别也很简单, 以请求内容的开头是否为 * 开头进行区分。<br>以 * 开头的内容, 可以看出就是遵循 REST 协议的请求, 而其他的请求就是 inline 请求。</p><p>之所以有 inline 请求, 其实是为了兼容一下特殊的客户端, 比如 Linux 的 telnet 等。</p><p>在 Linux 可以通过 <strong>telnet Ip 端口</strong> 连接到服务端, 然后直接发送请求到服务端, 而这些请求是直接发送到服务端的, 没有中间转为 RESP 协议的。<br>所以 Redis 选择了兼容这些特殊的情况, 并将这些请求称为 inline 请求。</p><p>所以客户端发送命令到服务端的过程如下<br><img src="https://pic.imgdb.cn/item/6562ead1c458853aef233f55.png" alt="Alt &#39;Redis 客户端按照 RESP 协议转换发送请求&#39;"></p><blockquote><ol><li>Redis 客户端接收用户的输入请求</li><li>将这些请求按照 RESP 协议进行转换 (inline 请求, 不会有这一步)</li><li>将转换后的请求内容发送给 Redis 服务端</li></ol></blockquote><h2 id="6-服务端接收到客户端发送的命令"><a href="#6-服务端接收到客户端发送的命令" class="headerlink" title="6 服务端接收到客户端发送的命令"></a>6 服务端接收到客户端发送的命令</h2><p>在上面客户端连接时, 向事件轮询中为当前的客户端注册了一个<strong>可读的文件事件</strong>, 触发函数为 <strong>readQueryFromClient</strong>。<br>而在客户端将请求发送到服务端后, 事件轮询从多路复用中获取到了这个<strong>文件事件</strong>后, 会执行里面的函数 readQueryFromClient 函数。</p><p>整个 redisQueryFromClient 可以拆分为 2 部分</p><blockquote><ol><li>请求参数处理</li><li>具体请求命令的执行</li></ol></blockquote><h3 id="6-1-请求参数处理"><a href="#6-1-请求参数处理" class="headerlink" title="6.1 请求参数处理"></a>6.1 请求参数处理</h3><p>在上面我们知道, 客户端向服务端发送了一段 RESP 格式的请求 *<strong>3\r\n$3\r\nset\r\n$5\r\nmyKey\r\n$7\r\nmyValue\r\n</strong>, 服务端会</p><blockquote><ol><li>将客户端发送过来的请求 <code>*3\r\n$3\r\nset\r\n$5\r\nmyKey\r\n$7\r\nmyValue\r\n</code>, 原封不动的存储到对应 client 的<strong>输入缓冲区</strong> queryBuf<br><img src="https://pic.imgdb.cn/item/6562ebe7c458853aef2735fd.png" alt="Alt &#39;Redis redaQueryFromCLient - 存储请求&#39;"></li><li>存储在 client querybuf 的内容 <code>*3\r\n$3\r\nset\r\n$5\r\nmyKey\r\n$7\r\nmyValue\r\n</code>, 按照 RESP 协议解析为 3 个 embstr 编码的 redisObject (String 的三种编码有讲解), 然后存储到 client 的 argv 数组中。<br><img src="https://pic.imgdb.cn/item/6562ebf0c458853aef27575d.png" alt="Alt &#39;Redis redaQueryFromCLient - 命令解析&#39;"></li><li>根据 client 的参数数组 argv 的第一个参数 (第一个参数一定是命令参数) 到 redisServer 的命令字典 commands 查找当前的命令<br><img src="https://pic.imgdb.cn/item/6562ebf8c458853aef277504.png" alt="Alt &#39;Redis redaQueryFromCLient  执行命令查询&#39;"></li><li>找到命令后, 当然是执行对应的命令里面的函数了</li></ol></blockquote><p>上面是 redisQueryFromClient 第一部分, 忽略<strong>请求命令的逻辑</strong>后的简化过程, 想要继续深入了解里面的其他判断可以看一下下面的伪代码</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// networking.c</span><span class="token keyword">void</span> <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1. 先将客户端的请求数据读取到 client 的 querybuf 中</span>    <span class="token function">putRequestContentIntoClientQueryBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 如果 querybuf 中的数据超过了 1GB, 就关闭这个连接</span>    <span class="token function">checkClientQueryBufferMoreThanOneGb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3. 临时暂停这次请求, 等待后面触发, 对应的状态有</span>    <span class="token comment">// 3.1 当前的 client 的为阻塞状态 (如果 querybuf 中的数据超过了 256MB, 就将这个 client 的状态设置为 REDIS_BLOCKED)</span>    <span class="token comment">// 3.2 当前有一个 lua 脚本在执行中</span>    <span class="token comment">// 3.3 当前的客户端是准备关闭状态</span>    <span class="token comment">// 3.4 客户端被暂停了</span>    <span class="token function">temporaryPaurseThisRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4. 根据请求参数的第一个字符是否为 *, 确定当前的请求是 mult bulk 请求还是 inline 请求</span>    <span class="token function">confirmThisRequestType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 5. 根据请求类型, 对 querybuf 的参数进行解析, 然后存放到 argv </span>    <span class="token function">parseRequestContentIntoClientArgvByRequestType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 6. 命令处理</span>    <span class="token function">processCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// server.c</span><span class="token keyword">int</span> <span class="token function">processCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1. 模块过滤器, 前置处理</span>    <span class="token comment">// https://redis.io/resources/modules/</span>    <span class="token function">moduleCallCommandFilters</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. argv[0] 为 quit (断开连接)</span>    <span class="token comment">// 将客户端的标识设置为 client_close_after_reply, 等待后面的处理, 然后返回</span>    <span class="token function">ifQuitCommandHandle</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3. 根据 argv[0], 也就是 key, 从 redisServer 的 commands 中找到对应的 redisCommand, 也就是执行命令</span>    c<span class="token operator">-></span>cmd <span class="token operator">=</span> c<span class="token operator">-></span>lastcmd <span class="token operator">=</span> <span class="token function">lookupCommand</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4. 命令 null 检查和命令需要的参数格个数和实际参数个数检查, 不符合就返回错误</span>    <span class="token function">commandNullAndArgumentsNumberCheck</span><span class="token punctuation">(</span>c<span class="token operator">-></span>cmd， c<span class="token operator">-></span>argc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 5. 服务端需要密码认证, 同时当前的客户端未认证, 并且执行的命令不是 auth 命令, 返回错误</span>    <span class="token function">requirePassCheckWhenCmdNotAuth</span><span class="token punctuation">(</span>c<span class="token operator">-></span>authenticated<span class="token punctuation">,</span> c<span class="token operator">-></span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 6. 开启了集群模式, 根据 key 计算出对应的执行服务端节点, 如果当前的服务端不是执行的服务端节点, 通知客户端重定向</span>    <span class="token function">redirectClientIfNeedByKeyWhenClusterEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 7. 如果设置了最大内存同时当前没有正在执行的 lua 脚本, 就尝试释放内存</span>    <span class="token function">tryToReleaseMemoryWhenSetMaxMemoryAndNoLuaScriptTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 8. 当前是主节点, 磁盘检测失败, 执行的命令具备变更属性(新增, 修改, 删除等)或者是 ping 命令,  返回错误</span>    <span class="token comment">// 磁盘检测失败的场景</span>    <span class="token comment">// 8.1 开启了 RDB, 上一次 RDB 失败了,  同时配置了 RDB 失败停止写操作 (stop_writes_on_bgsave_error yes)</span>    <span class="token comment">// 8.2 开启了 AOF, 上一次 AOF 失败了</span>    <span class="token function">pingAndWriteCommandsDeniedByDiskErrorByMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 9. 主从复制配置检查</span>    <span class="token comment">// 配置了 repl_min_slaves_to_write 和 repl_min_slaves_max_lag</span>    <span class="token comment">// 当前需要有多少个心跳正常的从节点存活, 否则变更属性的命令不执行, 返回错误</span>    <span class="token function">writeCommandsDeniedByMinSlavesNumberReply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 10. 当前的客户端是从节点, 并且配置了 slave_read_only, 并且执行的命令具备变更属性, 返回错误</span>    <span class="token function">writeCommandDeniedBySlaveReadOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 11. 当前的客户端是一个订阅客户端 (subscribe), 执行的命令不是 subscribe, unsubscribe, psubscribe, punsubscribe, ping, 返回错误</span>    <span class="token function">subscribeClientCanHandleCommandCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 12. 从节点和主节点失去了联系或者正在执行复制中, 同时 slave-serve-stale-data 设置为了 no, 执行的命令不是 stale 属性(info, slaveof), 返回错误</span>    <span class="token function">slaveSynchronizingOrConnectStateUnusualCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 13. 服务端正在从磁盘中加载数据, 执行的命令不是 loading 属性(info, subscribe, unsubscribe, psubscribe, punsubscribe, publish) , 返回错误</span>    <span class="token function">loadingFromDiskCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 14. 当前正在执行 lua 脚本, 执行的命令不是 auth, replconf, shutdown, script, 返回错误</span>    <span class="token function">luaScribtBusyCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 15. 开启了事务, 执行的命令不是 exec, discard, multi, watch, 返回错误</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">openTranscation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">commandIsNotExecAndDiscardAndMultiAndWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 15.1 命令入队列</span>        <span class="token function">queueMultiCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 17. 将要执行的命令, 发送给监控器</span>    <span class="token comment">// Redis 客户端可以成为服务端的监控器, 服务端执行的命令会同步传输给客户端</span>    <span class="token function">sendCommandToMonitors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 18. 对应 key 的命令函数执行, 后面会以 setCommand 为例进行分析</span>    c<span class="token operator">-></span>cmd<span class="token operator">-></span><span class="token function">proc</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 19. 如果需要，进行统计记录</span>    <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 20. 如果需要, 慢日志记录</span>    <span class="token function">slowlogPushEntryIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 21. 命令传播, 如果有必要进行命令替换</span>    <span class="token comment">// aof 和 主从复制需要当前执行的命令进行数据处理</span>    <span class="token comment">// 一些随机性的命令, 不能直接就传播出去, 需要根据当前的执行结果进行替换, 比如 SPOP key [count], 从 set 中随机弹出若干个元素</span>    <span class="token function">propagateCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="6-2-具体请求命令的执行"><a href="#6-2-具体请求命令的执行" class="headerlink" title="6.2 具体请求命令的执行"></a>6.2 具体请求命令的执行</h3><p>在 redisQueryFromClient 的逻辑中, 有一段代码</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">processCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">// 这一步就是具体的命令执行的地方, 以 set 命令为例, 了解一下 set 命令的执行过程</span>    c<span class="token operator">-></span>cmd<span class="token operator">-></span><span class="token function">proc</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><p>就是具体的请求命令的执行时机, 这里以 setCommand 为了, 这次直接看伪代码先</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// t_string.c</span><span class="token keyword">void</span> <span class="token function">setCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 上面的 c->cmd->proc(c), 最终执行到的函数就是这个</span>    <span class="token comment">// SET key value [NX] [XX] [EX &lt;seconds>] [PX &lt;milliseconds>] </span>    <span class="token comment">// 1. 根据参数计算超时时间</span>    robj <span class="token operator">*</span>expire <span class="token operator">=</span> <span class="token function">calExpireTime</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">,</span> c<span class="token operator">-></span>argc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 尝试对 value 进行字符串的编码优化</span>    <span class="token comment">// 2.1 编码不是 embstr 和 raw, 就直接返回原数据, 不是字符串类型, 没必要优化</span>    <span class="token comment">// 2.2 value 长度小于 20, 同时可以转为整数</span>    <span class="token comment">// 2.2.1 没有配置最大内存, 同时内存回收策略不是 MAXMEMORY_FLAG_NO_SHARED_INTEGERS (涉及 lru/lfu 这 2 种模式的回收策略), </span>    <span class="token comment">// 转换的数字大于等于 0, 小于 10000, 返回共享整数池中返回这个数字, 都不满足, 新建一个整数</span>    <span class="token comment">// 2.2.2 原本的 reidsObject 的编码为 raw, 将入参的 redisObject 转为 int 编码, *ptr 修改为转换后的整数值</span>    <span class="token comment">// 2.2.3 原本的 reidsObject 的编码为 embstr, 重新创建一个新的 int 编码的 redisObject</span>    <span class="token comment">// 2.2 逻辑结束 下面为 2.2 不满足情况</span>    <span class="token comment">// 2.3 入参的 redisObject 内容长度小于等于 44, 重新创建一个 embstr 的字符串, 将入参的 redisObject 转为 embstr 编码,  *ptr 修改为转换后的整数值</span>    <span class="token comment">// 2.3 逻辑结束 下面为 2.3 不满足情况</span>        <span class="token comment">// 2.4 到了这里, 说明客户端传过来的 value 大于 44, 只能用 raw 编码, 但是 raw 编码还可以 尝试进行 trim 优化, 也就是去空格</span>    c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">tryObjectEncoding</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3. 将 key 和 value 存放到 当前客户端选择的 redisDb[] db 中</span>    <span class="token function">putTheKeyAndValueToDb</span><span class="token punctuation">(</span>c<span class="token operator">-></span>db<span class="token punctuation">,</span> c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4. 如果设置了参数时间, 将更新 redisObject 的 expireTime</span>    <span class="token function">setExpireTimeIfNeed</span><span class="token punctuation">(</span>c<span class="token operator">-></span>db<span class="token punctuation">,</span> c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> expire<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 5. 如果需要, 将当前的客户端放到 redisServer 的 pending_write_clients 中, 表明当前的客户端有数据需要响应</span>    <span class="token function">putCurrentClientToClientsPendingWriteIfNeed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 6. 将响应内容 +OK\r\n (响应结果也遵循 RESP 协议) 写入到客户端的 buf 中, 无法写入就写入到客户端的 reply</span>    <span class="token function">tryWriteResponseToBufOrReply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 7. 当写入的内容是写入到 reply 中时, 需要检查当前客户端待响应的内容的大小是否超过了限制, 是的话, 关闭当前客户端</span>    <span class="token function">checkClientOutputBufferLimitsWhenWriteToReply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>逻辑概括如下:</p><blockquote><ol><li>根据参数计算超时时间, Redis 的 set 命令支持很多种参数格式, 需要根据这些参数计算出一个当前 String 的过期时间 (如果有设置的话)</li><li>参数数组 argv[2], 一定是要存入到 Redis 的 value, 当前的 value 虽然已经是 redisObject 了, 但如果它是 embstr 和 raw, 尝试寻找更合适的编码 (这一部分都是 Redis String 编码的内容)<br><img src="https://pic.imgdb.cn/item/6562ecbcc458853aef2a32dc.png" alt="Alt &#39;Redis setCommand  重编码尝试过程&#39;"></li><li>将处理好的 myKey 和 myValue 存到 redisServer 的 redisDb 数组中的第一个 (如果使用前, 通过 select 修改了使用的数据库, 那么存在对应的数据库, 默认为 0, 第一个)<br><img src="https://pic.imgdb.cn/item/6562ecc4c458853aef2a4d31.png" alt="Alt &#39;Redis setCommand  保存对象过程&#39;"></li><li>如果有必要, 对 redisObject 的过期时间的进行更新</li><li>数据处理完了, 当前的命令如果有数据需要响应客户端时, 需要将当前客户端放到 redisServer 的待响应客户端双向链表 clients_pending_write 中, set 命令处理完需要响应一个 ok, 所以当前 client 需要加入这个链表<br><img src="https://pic.imgdb.cn/item/6562eccdc458853aef2a6beb.png" alt="Alt &#39;Redis setCommand  客户端加入待响应客户端双向链表&#39;"></li><li>如果有数据需要响应, 将响应的数据放到 client 的固定输出缓冲区 <strong>char buf[]</strong> 中, 如果无法直接存放进去, 则存放到动态输出缓冲区 <strong>List<clientReplyBlock> reply</strong> 中, set 回应的是 ok, 经过 RESP 协议后假设可以直接放到固定输出缓冲区<br><img src="https://pic.imgdb.cn/item/6562ecd6c458853aef2a8bdb.png" alt="Alt &#39;Redis setCommand  响应结果写入缓冲区&#39;"></li></ol></blockquote><p>服务端接收到客户端发送的命令并处理后, redisServer 的状态如下:<br><img src="https://pic.imgdb.cn/item/6562efb8c458853aef3512b4.png" alt="Alt &#39;Redis 服务端接收到客户端发送的命令后 redisServer 状态&#39;"></p><p>此时 client 的状态如下:<br><img src="https://pic.imgdb.cn/item/6562f46ac458853aef458b27.png" alt="Alt &#39;Redis 服务端接收到客户端发送的命令后 client 状态&#39;"></p><h2 id="7-服务端响应客户端"><a href="#7-服务端响应客户端" class="headerlink" title="7 服务端响应客户端"></a>7 服务端响应客户端</h2><p>存放在 client 的输出缓冲区的数据, 是什么时候发送给客户端的呢?<br>在 Redis 里面是经过 2 个步骤实现的</p><blockquote><ol><li>为每一个待发送的客户端注册一个可写的文件事件, 执行函数为 sendReplyToClient</li><li>事件轮询获取这个可写事件并触发 sendReplyToClient 函数</li></ol></blockquote><h3 id="7-1-为待发送的客户端注册发送数据的文件事件"><a href="#7-1-为待发送的客户端注册发送数据的文件事件" class="headerlink" title="7.1 为待发送的客户端注册发送数据的文件事件"></a>7.1 为待发送的客户端注册发送数据的文件事件</h3><p>Redis 服务端端启动后, 整个 Redis 就进入到事件轮询里面的死循环, 一直在执行下面的逻辑</p><p>!<img src="https://pic.imgdb.cn/item/6562e690c458853aef1391f4.png" alt="Alt &#39;Redis 服务端启动后事件轮询中执行的死循环逻辑&#39;"></p><p>而这次在<strong>阻塞前 beforesleep 函数执行</strong> 时, 在 beforesleep 函数中会:<br>遍历 redisServer 的待响应客户端双向链表 clients_pending_write 中的所有客户端, </p><blockquote><ol><li>将对应的客户端从双向链表删除</li><li>删除的客户端如果有数据要发送, 为他在多路复用各注册一个可写的文件事件, 触发函数 sendReplyToClient</li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/6562f2d4c458853aef400eda.png" alt="Alt &#39;Redis 服务端注册发送数据文件事件&#39;"></p><p>对应的地方为 beforeSleep 函数逻辑如下:</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// server.c</span><span class="token keyword">void</span> <span class="token function">beforeSleep</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">// 处理带有输出缓冲区的客户端</span>    <span class="token function">handleClientsWithPendingWrites</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">handleClientsWithPendingWrites</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    client <span class="token operator">*</span>c    <span class="token comment">// 1. 遍历 redisServer 的 clients_pending_write </span>    <span class="token keyword">while</span><span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token function">getNextNodeFromLinkList</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 将当前的 client 从 clients_pending_write 链表中删除</span>        <span class="token function">removeTheClientFromeClientsPendingWrite</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 当前的客户端有数据需要发送 (client->buf 或 client->reply 不为空),</span>        <span class="token comment">// 向多路复用注册一个可写的文件事件, 执行函数为 sendReplyToClient</span>        <span class="token function">registFileEventForClientWhenClientHaveDataToWrite</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="7-2-触发发送数据的文件事件"><a href="#7-2-触发发送数据的文件事件" class="headerlink" title="7.2 触发发送数据的文件事件"></a>7.2 触发发送数据的文件事件</h3><p>事件轮询在执行完阻塞前函数后, 又进入到多路复用中获取文件事件, 这时会获取到刚刚注册的可写事件文件, 触发 sendReplyToClient 的逻辑, 过程如下:</p><p><img src="https://pic.imgdb.cn/item/6562f2dbc458853aef4026ca.png" alt="Alt &#39;Redis 服务端响应客户端过程&#39;"></p><blockquote><ol><li>逐步将 client 的缓冲区推送给客户端 (单次推送数据有上限要求, 超过的需要到下次事件轮询再推送)</li><li>client 推送数据完成, 将其对应的文件事件从多路复用中删除 (如果还有数据没推送, 事件不会被删除, 下次事件轮询还能触发, 推送剩下的)</li></ol></blockquote><p>具体的逻辑如下:</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// networking.c</span><span class="token keyword">void</span> <span class="token function">sendReplyToClient</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//  client 的输出缓冲区有数据需要发送</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// client 的 buf 有数据需要发送</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clientBufHasDataToSend</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">writeDataToClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果 client 的 reply 有数据, 获取链表的第一个节点, 将里面的数据发送给客户端, 同时从双写链表中删除这个节点</span>            <span class="token function">writeDataToClientIfClientReplyHasData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 当前已经发送的数据达到了单次发送的上线 1024*64</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">currentHaveSendMoreThanMaxLimit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 没有设置最大内存, 当前发送数据停止</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">noSetMaxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 设置了最大内存, 当前已经使用的内存大小小于最大内存, 当前发送数据停止</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">haveSetMaxMemoryAndCurrentUsedMemoryLessThanMaxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 设置了最大内存了, 当前使用的内存大于等于最大内存了, 继续循环, 尽量多发送一些, 释放内存</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 当前 client 没有数据需要发送了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 从事件轮询中删除当前的发送数据事件</span>        <span class="token function">delCurrentFileEventFromEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// client 还有数据, 那么不删除事件, 继续保留, 下次事件轮询执行, 继续执行</span></code></pre><p>需要留意的是执行一个 sendReplyToClient 函数, 给这个客户端推送数据</p><blockquote><ol><li>每次个客户端推送数据最大为 1024 * 64, 超过了会停止这次推送, 将剩下的留到下次再继续推送 (伪代码里面表明了一些特殊情况了)</li></ol></blockquote><p>至此</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> myKey myValueok</code></pre><p>一个完整的流程就结束了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis SkipList 编码</title>
      <link href="/article/2021/3671033365/"/>
      <url>/article/2021/3671033365/</url>
      
        <content type="html"><![CDATA[<h2 id="1-跳表的特点"><a href="#1-跳表的特点" class="headerlink" title="1 跳表的特点"></a>1 跳表的特点</h2><p>在 <strong>Redis 5.x</strong> 的源码中,  zset (order set) 的编码为 ziplist 或 skiplist (Redis 6.0 后变为 listpack 或 dict + skiplist)。</p><p>skiplist 的特点</p><blockquote><ol><li>本身是一种<strong>空间换时间</strong>的<strong>有序</strong>数据结构</li><li>本身可以达到了<strong>二分查找</strong>的效果, 时间复杂度在 O(log n), 最坏 O(n), 和平衡树一样</li><li>实现逻辑简单, 数据变更时, 数据的再平衡 (有序) 比平衡树简单很多</li></ol></blockquote><p>而 skiplist 本质可以看作是一个<strong>有序链表</strong>, 保留着链表的变更简单, 同时通过空间换时间的方式提升查询的效率。</p><p>注: 下面的分析也是按照 <strong>Redis 5.x</strong> 进行分析。</p><h2 id="2-跳表的查询"><a href="#2-跳表的查询" class="headerlink" title="2 跳表的查询"></a>2 跳表的查询</h2><p>既然 skiplist 是本质是一个有序链表, 我们先简单的了解一下有序链表。</p><p><img src="https://pic.imgdb.cn/item/655382f8c458853aefbf63a9.png" alt="Alt &#39;有序链表&#39;"></p><p>如上图, 是一个简单的有序链表。<br>所有的数据按照升序&#x2F;降序的方式组织在一起, 每个节点都有一个指向下一个节点的指针, 最后一个节点指向了 null。</p><p>如果需要从当前的链表中查找 22, 从第一个节点开始一直往下找 1 -&gt; 4 -&gt; 6 -&gt; 19 -&gt; 22, 需要经过 5 个节点。</p><p>有没有办法加速这个查询的过程吗?   </p><p>制定一个这样的规则: </p><blockquote><ol><li>从当前的链表随机选择几个节点重新构成一个新的有序链表</li><li>第一个节点必定被选中</li></ol></blockquote><p>假设, 原本的有序链表, 变成了如下:  </p><p><img src="https://pic.imgdb.cn/item/65538443c458853aefc4c1cc.png" alt="Alt &#39;双层有序链表&#39;"></p><p>这时, 可以从新的链表中查找 22, 同样从第一个节点开始找 1 -&gt; 6 -&gt; 19 -&gt; 22,  经过链表的节点少了, 这次只需要经过 4 个节点。</p><p>这样可以加速查找, 那么是否可以以新的链表为原型, 按照相关的规则, 再次构建一条更短的有序链表</p><p>假设, 这时的有序链表变为</p><p><img src="https://pic.imgdb.cn/item/655384afc458853aefc67fd3.png" alt="Alt &#39;三层有序链表&#39;"></p><p>这时, 同样是查询 22, 只需要经过 2 个节点 (1 -&gt; 22)</p><p>制定这样的规则, 现在看起来可以加速查询的效率, 但是有个问题: <strong>要查找的数据不在新建的链表中</strong>。</p><p><img src="https://pic.imgdb.cn/item/655384afc458853aefc67fd3.png" alt="Alt &#39;三层有序链表&#39;"></p><p>还是这张图, 假设现在我们现在需要查找的数据是 54。<br>这时如果直接从先建的第 2 条链表中查找, 是查询不到的, 但是 54 实际是存在的。</p><p>所以需要继续追加规则</p><blockquote><ol start="3"><li>新增<strong>层</strong>的概念, 同一条链表为同一层, 原始的链表为 0 层 (也可以定为 1 层), 逐层递增</li></ol></blockquote><p>那么最新的链表变为:  </p><p><img src="https://pic.imgdb.cn/item/6553856dc458853aefc99fbf.png" alt="Alt &#39;明确三层分离的有序链表&#39;"></p><p>再加一条规则</p><blockquote><ol start="4"><li>通过 0 层产生的节点之间是一个整体, 一个整体内, 高层的节点可以下降到低一层的节点, 但是无法往上升</li></ol></blockquote><p>最新的链表又变成如下:  </p><p><img src="https://pic.imgdb.cn/item/655385dbc458853aefcb7b00.png" alt="Alt &#39;明确三层分离和节点有序链表&#39;"></p><p>加两条查询的规则</p><blockquote><ol start="5"><li>查找数据时, 必须从最高层开始找</li><li>查找过程中, 通过和同一层的后一个元素比较大小, 决定在同一层继续往后找, 还是在同一个整体的下一层</li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/65538635c458853aefcd229f.png" alt="Alt &#39;简易跳表查询&#39;"></p><p>在最新的链表中, 查找 54 时, 过程如下:  </p><blockquote><ol><li>从最高层的的第 1 个节点开始, 也就是第 2 层的第 1 个节点 1 开始</li><li>此时第 2 层第 1 个节点 1 的后一个节点为 22, 查找的数字比 22 大, 跳到同一层的下一个节点 22</li><li>此时到了第 2 层第 2个节点 22, 它的后一个节点为 null, 只能下到自己的下一层的节点, 也就是第 1 层的第 4 个节点 22</li><li>此时到了第 1 层第 4 个节点 22 , 同样后一个节点为 null, 只能下到自己的下一层的节点, 也就是第 1 层的第 5 个节点 22</li><li>此时到了第 0 层第 5 个节点 22 , 后一个节点为 54, 找到了</li></ol></blockquote><p>此时经过的节点为 1 -&gt; (22, 22, 22, 一个整体的 3 层) -&gt; 54, 可以看作经过了 5 个节点。<br>看起来和直接查找 1 -&gt; 4 -&gt; 6 -&gt; 19 -&gt; 22 -&gt; 54 的 5 个节点一样。 </p><p>但是在实际中, 一个整体的几个层的节点可以用数组进行组织, 达到随机访问的效果, 也就是这里实际是 3 个节点的。</p><p>最后的结构基本就是跳表结构的雏形, 从中可以大体到跳表的结构的性质, 这里对跳表结构做一个定义</p><blockquote><ol><li>跳表本质是一个有序的单向链表</li><li>链表中的每个节点除了存放自己的排序值, 还有若干个<strong>层</strong>节点, 层节点存储着当前节点的排序值, 和同一层的下一个节点或者 null </li><li>查询时, 从第一个节点的最高层开始, 通过比较当前层的下一个节点, 确定是在往同一层的下一个节点, 还是同一个节点的下一层查询</li></ol></blockquote><h2 id="3-Redis-对跳表的实现"><a href="#3-Redis-对跳表的实现" class="headerlink" title="3 Redis 对跳表的实现"></a>3 Redis 对跳表的实现</h2><p>具体的源码可以查看 <strong>t_zset.c</strong> 这个文件。  </p><h3 id="3-1-跳表中的几个对象的定义"><a href="#3-1-跳表中的几个对象的定义" class="headerlink" title="3.1 跳表中的几个对象的定义"></a>3.1 跳表中的几个对象的定义</h3><h4 id="3-1-1-跳表本身的定义"><a href="#3-1-1-跳表本身的定义" class="headerlink" title="3.1.1 跳表本身的定义"></a>3.1.1 跳表本身的定义</h4><p><img src="https://pic.imgdb.cn/item/655387c2c458853aefd3dac5.png" alt="Alt &#39;SkipList 声明&#39;"></p><p>可以看到跳表本身的定义很简单</p><blockquote><ol><li>header 跳表的头节点</li><li>tail 跳表的尾节点</li><li>length 跳表中第一层 (数据最完整的) 的节点长度</li><li>level 跳表中节点中的最高层数</li></ol></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplist</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 跳表的头节点 和 跳表的尾节点</span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>header<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>    <span class="token comment">// 跳表的节点长度, 只算第一层的节点</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>    <span class="token comment">// 跳表的节点中的最高层数</span>    <span class="token keyword">int</span> level<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> zskiplist<span class="token punctuation">;</span></code></pre><h4 id="3-1-2-跳表中的节点定义"><a href="#3-1-2-跳表中的节点定义" class="headerlink" title="3.1.2 跳表中的节点定义"></a>3.1.2 跳表中的节点定义</h4><p><img src="https://pic.imgdb.cn/item/65538837c458853aefd5c67f.png" alt="Alt &#39;SkipNode 声明&#39;"></p><p>节点的定义也很简单</p><blockquote><ol><li>ele 节点存储的数据</li><li>score 节点的分值</li><li>backward 节点的前置节点, 主要用于从表尾向表头遍历时使用</li><li>levels 跳表的特点, 层节点</li></ol></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 节点存储的数据</span>    sds ele<span class="token punctuation">;</span>    <span class="token comment">// 当前节点的分值</span>    <span class="token keyword">double</span> score<span class="token punctuation">;</span>    <span class="token comment">// 当前节点的前置节点, 也就是前一个节点</span>    <span class="token comment">// 主要用于从表尾向表头遍历时使用</span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>backward<span class="token punctuation">;</span>    <span class="token comment">// 当前节点层节点    </span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> levels<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>zskiplistNode<span class="token punctuation">;</span></code></pre><h4 id="3-1-3-跳表节点中的层定义"><a href="#3-1-3-跳表节点中的层定义" class="headerlink" title="3.1.3 跳表节点中的层定义"></a>3.1.3 跳表节点中的层定义</h4><p><img src="https://pic.imgdb.cn/item/65538921c458853aefd99647.png" alt="Alt &#39;SkipListLevel 声明&#39;"></p><p>层节点的定义</p><blockquote><ol><li>forward 当前层节点指向的下一个跳表节点</li><li>span 当前跳表节点和 forward 所指的跳表节点之间跳过了多少个节点</li></ol></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 当前层节点指向的下一个跳表表节点, 不是具体的层节点</span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span>    <span class="token comment">// 以第一层为标准 (第一层数据是最全的, 有多少数据, 第一层就有多少个节点)</span>    <span class="token comment">// 当前层节点指向的链表节点, 中间跳过了多少个跳表节点 </span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> span<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> zskiplistLevel<span class="token punctuation">;</span></code></pre><p>span 的定义了解</p><p>假设现在有一个跳表如下</p><p><img src="https://pic.imgdb.cn/item/65538bdfc458853aefe5b6d2.png" alt="Alt &#39;分析 Span 的跳表&#39;"></p><p>跳表中有 4 个节点 (头节点不算), 分别存储了 A, B, C, D, 每个节点上面的 L 代表了层节点, 括号里面的数字就是 span 的值。</p><p>SkipListNode-1 这个节点的 L4 层, 下一个节点为 null, 到达 null 中间跨过了 SkipListNode-2, SkipListNode-3, SkipListNode-4, null 本身, 总共 4 个节点,  所以 SkipListNode-1 的 L4 层的 span 为 4。  </p><p>同理 SkipListNode-1 节点的 L3 层, 下一个节点为 SkipListNode-3, 中间跨过了 SkipListNode-2, SkipListNode-3 本身, 所以对应的 span 为 2。</p><p>到这里, 可以理解层节点的 span 的含义: 当前跳表节点和 forward 所指的跳表节点 (也就是下一个跳表节点) 之间跨过了多少个节点, 跨过的节点本身也算是一个节点。</p><h3 id="3-2-创建一个跳表对象"><a href="#3-2-创建一个跳表对象" class="headerlink" title="3.2 创建一个跳表对象"></a>3.2 创建一个跳表对象</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 跳表创建 * @return 创建的跳表 */</span>zskiplist <span class="token operator">*</span><span class="token function">zslCreate</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>    <span class="token comment">// 为 zskiplist 分配内存, 可以看为 Java 中的 new zskiplist()</span>    zsl <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>zsl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 当前跳表的最大层高, 默认为 1, 头节点不算</span>    zsl<span class="token operator">-></span>level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 当前跳表的节点长度, 默认为 0, 头节点不算</span>    zsl<span class="token operator">-></span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 创建头节点</span>    <span class="token comment">// ZSKIPLIST_MAXLEVEL, 跳表中节点的最大层数, 默认为 32</span>    zsl<span class="token operator">-></span>header <span class="token operator">=</span> <span class="token function">zslCreateNode</span><span class="token punctuation">(</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 初始头节点的所有层节点的数据</span>    <span class="token comment">// 下一个链表节点为 null, 跳过的节点 span = 0</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> ZSKIPLIST_MAXLEVEL<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        zsl<span class="token operator">-></span>header<span class="token operator">-></span>level<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        zsl<span class="token operator">-></span>header<span class="token operator">-></span>level<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 头节点的前置节点为 NULL</span>    zsl<span class="token operator">-></span>header<span class="token operator">-></span>backward <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">// 跳表的尾节点设置为 NULL</span>    zsl<span class="token operator">-></span>tail <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> zsl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 创建链表节点 * @param level 创建的节点的层高 * @param score 创建的节点的分值 * @param ele   创建的节点的内容 * @return 创建的节点 */</span>zskiplistNode <span class="token operator">*</span><span class="token function">zslCreateNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">double</span> score<span class="token punctuation">,</span> sds ele<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 为跳表的节点分配内存</span>    zskiplistNode <span class="token operator">*</span>zn <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>zn<span class="token punctuation">)</span><span class="token operator">+</span>level<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置跳表节点的分数为入参的 score, 内容为入参的 ele</span>    zn<span class="token operator">-></span>score <span class="token operator">=</span> score<span class="token punctuation">;</span>    zn<span class="token operator">-></span>ele <span class="token operator">=</span> ele<span class="token punctuation">;</span>    <span class="token keyword">return</span> zn<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/65538a31c458853aefde125d.png" alt="Alt &#39;初始跳表&#39;"></p><p>从图中可以看到, Redis 跳表的初始状态</p><blockquote><ol><li>Redis 中限制了节点的层高最大为 32 层 (层数会消耗空间的, 需要有一个合理的限制值)</li><li>跳表的头节点, 默认就是一个最大层高的节点, 但是里面所有内容都指向了 null</li></ol></blockquote><p>这个逻辑很简单, 创建了一个层高 32 的跳表节点, 跳表的头节点执行这个节点, 没了, 节点内的数据都为默认值。</p><h3 id="3-3-向跳表添加第一个元素"><a href="#3-3-向跳表添加第一个元素" class="headerlink" title="3.3 向跳表添加第一个元素"></a>3.3 向跳表添加第一个元素</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 向跳表中新增一个节点 * @param zsl 新增节点的跳表 * @param score 分值 * @param ele  内容  */</span>zskiplistNode <span class="token operator">*</span><span class="token function">zslInsert</span><span class="token punctuation">(</span>zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">,</span> <span class="token keyword">double</span> score<span class="token punctuation">,</span> sds ele<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// update 保存的是新增节点每一层的前一个节点 (也就是这个节点的下一个节点就是新增的节点)</span>    zskiplistNode <span class="token operator">*</span>update<span class="token punctuation">[</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token comment">// rank[i] 存储的是头节点到 update[i] 的中间跨过的跳表节点</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> rank<span class="token punctuation">[</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> level<span class="token punctuation">;</span>    <span class="token function">serverAssert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isnan</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        x <span class="token operator">=</span> zsl<span class="token operator">-></span>header<span class="token punctuation">;</span>        <span class="token comment">// zsl->level 为当前跳表除头结点外的最大层数</span>    <span class="token comment">// 1. 通过遍历跳表, 找到新增节点的应该保存的位置 </span>    <span class="token comment">// 从头节点的这个最大层数出发, 向后或向下遍历, 找到新增节点时, 每一层的前一个节点, 同时记录头节点到这个前一个节点的跨过的节点数</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-></span>level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// for 循环控制同一个节点的下层遍历, 也就是向下遍历</span>        <span class="token comment">// 下面的 while 循环控制同一层的遍历, 也就是向后遍历</span>                        <span class="token comment">// 把上一层经过的跨过节点数继承下来, 然后加上这一层后面的节点(有的话), 就是这一层真正跨过的节点数</span>        <span class="token comment">// 从 for 循环进来, level - 1, 也就是向下遍历, 向下遍历前的节点和向下遍历达到的节点, 只是层数不一样, 实际还是同一个节点,</span>        <span class="token comment">// 所以原本节点的上一层的跨过的节点数继承下来, 再加上这一层后面处理的节点数, 就是这一层真正跨过的节点数</span>        rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">==</span> <span class="token punctuation">(</span>zsl<span class="token operator">-></span>level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> rank<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 先比较分数, 分数相同的话, 再比较内容</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward             <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">&lt;</span> score <span class="token operator">||</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">==</span> score <span class="token operator">&amp;&amp;</span> <span class="token function">sdscmp</span><span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>ele<span class="token punctuation">,</span>ele<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span<span class="token punctuation">;</span>            x <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 新增位置的前一个节点就是 x 了</span>        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 2. 通过随机函数, 获取新增节点的层高, 如果随机出来的层高比现在的最大的层高还高, 多对出来的层进行初始化</span>    level <span class="token operator">=</span> <span class="token function">zslRandomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 随机出来的层高比现在的层高还高的话</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>level <span class="token operator">></span> zsl<span class="token operator">-></span>level<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-></span>level<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> zsl<span class="token operator">-></span>header<span class="token punctuation">;</span>            update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">=</span> zsl<span class="token operator">-></span>length<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 更新最高层数</span>        zsl<span class="token operator">-></span>level <span class="token operator">=</span> level<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 3. 创建新增节点, 保存到跳表表中</span>    x <span class="token operator">=</span> <span class="token function">zslCreateNode</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span>score<span class="token punctuation">,</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 链表的基本操作, 修改节点的上下一个节点</span>        x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">=</span> update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token comment">// 更新新增节点每一层的 span, 也就是新增节点的每一层到下一个节点所跨过的节点数</span>        <span class="token comment">// 从上面的 for 循环可以看出, rank[i] 保存的是头节点到 update[i] 节点, 中间经过的节点数</span>        <span class="token comment">// rank[0] 第一层, update[0] 的下一个节点就是新增的节点, 中间是没有跨过任何其他节点的</span>        <span class="token comment">// rank[0] - rank[i], 可以得到 update[i] 到新增节点中间跨过的节点数</span>        <span class="token comment">// 这时 update[i] 对应层的 span 减去 上一步计算出来的节点就是新增节点的 span 了</span>        x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">=</span> update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">-</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">=</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 4. 更新插入节点的前置节点的其他层的跨度</span>    <span class="token comment">// 上面的 zslRandomLevel() 可能随机出一个比原本层高还低的层数</span>    <span class="token comment">// 这时新增了一个节点, 那么原本在新增节点前面的节点的 span 都要加 1</span>    <span class="token comment">// 小于等于随机出来的 level 的在上一步处理了,  大于随机出的 level, 但是小于原本的 level 的, 这里处理</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> level<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> zsl<span class="token operator">-></span>level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 5. 确定新增节点的前一个节点</span>    x<span class="token operator">-></span>backward <span class="token operator">=</span> <span class="token punctuation">(</span>update<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> zsl<span class="token operator">-></span>header<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">NULL</span> <span class="token operator">:</span> update<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 6. 更新跳表的头尾节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">)</span>        x<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>backward <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">else</span>        zsl<span class="token operator">-></span>tail <span class="token operator">=</span> x<span class="token punctuation">;</span>    zsl<span class="token operator">-></span>length<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 返回一个随机值, 用于确定节点的层高 * 规则: 层数越高的概率越低 * 设负载因子 ZSKIPLIST_P = p, 这里等于 0.25 * 第 n 层的概率为 = p ^ (n - 1) * (1 - p) * 第一层   = 0.25 ^ (1 - 1)  * (1 - 0.25) = 0.25 * 第二层   = 0.25 ^ (2 - 1)  * (1 - 0.25) = 0.1875 * 第三层   = 0.25 ^ (3 - 1)  * (1 - 0.25) = 0.140625 * ... * 第三十二层 = 0.25 ^ (32 - 1) * (1 - 0.25) = 0.000000000 */</span><span class="token keyword">int</span> <span class="token function">zslRandomLevel</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 层数最低为 1</span>    <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 0xFFFF = 0000 0000 0000 0000 1111 1111 1111 1111</span>    <span class="token comment">// ZSKIPLIST_P = 0.25f</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>ZSKIPLIST_P <span class="token operator">*</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        level <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// </span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>level <span class="token operator">&lt;</span> ZSKIPLIST_MAXLEVEL <span class="token punctuation">)</span> <span class="token operator">?</span> level <span class="token operator">:</span> ZSKIPLIST_MAXLEVEL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/65538d4ac458853aefebdd82.png0" alt="Alt &#39;分析跳表新增&#39;"></p><p>假设现在有一个跳表如上, 需要往里面新增一个 score &#x3D; 4 的节点, 这个节点的层高不定, 层节点里面的下一个节点和跨节点数不确定</p><blockquote><ol><li>新增节点在绿色节点的后面</li><li>新增节点的层高不确定, 但是可以知道, 新增节点时, 前 5 层的上一个节点分别为 Node2, Node2, Node2, Node1, Node1, 这些数据就存在了 update[] 数组中</li><li>确定了 update[] 时, 那么也可以确定头节点到这些节点跨过的节点数: 3, 3, 3, 1, 1 这些数据存在 rank[] 数组中</li></ol></blockquote><pre class="language-c" data-language="c"><code class="language-c">zskiplistNode <span class="token operator">*</span><span class="token function">zslInsert</span><span class="token punctuation">(</span>zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">,</span> <span class="token keyword">double</span> score<span class="token punctuation">,</span> sds ele<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-></span>level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">==</span> <span class="token punctuation">(</span>zsl<span class="token operator">-></span>level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> rank<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward             <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">&lt;</span> score <span class="token operator">||</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">==</span> score <span class="token operator">&amp;&amp;</span> <span class="token function">sdscmp</span><span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>ele<span class="token punctuation">,</span>ele<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span<span class="token punctuation">;</span>            x <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>就是为了计算出上面 update 和 rank 的数据。</p><h3 id="3-4-指定范围的查询"><a href="#3-4-指定范围的查询" class="headerlink" title="3.4 指定范围的查询"></a>3.4 指定范围的查询</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 从跳表中找到第一个符合范围的节点 * @param zsl 跳表 * @param range 范围 */</span>zskiplistNode <span class="token operator">*</span><span class="token function">zslFirstInRange</span><span class="token punctuation">(</span>zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">,</span> zrangespec <span class="token operator">*</span>range<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    zskiplistNode <span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token comment">// 判断跳表的分值是否包含了查询范围内的值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">zslIsInRange</span><span class="token punctuation">(</span>zsl<span class="token punctuation">,</span>range<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    x <span class="token operator">=</span> zsl<span class="token operator">-></span>header<span class="token punctuation">;</span>    <span class="token comment">// 从头节点出发, 找到第一个节点的下一个节点的分值大于等于范围的最小值的节点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-></span>level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">zslValueGteMin</span><span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score<span class="token punctuation">,</span>range<span class="token punctuation">)</span><span class="token punctuation">)</span>            x <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取符合条件的节点</span>    x <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>    <span class="token function">serverAssert</span><span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 判断节点的分值是否小于等于范围的最大值, 不符合返回 NULL</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">zslValueLteMax</span><span class="token punctuation">(</span>x<span class="token operator">-></span>score<span class="token punctuation">,</span>range<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 判断跳表节点的分值是否在范围内 * @param zsl 跳表 * @param range 范围 * @return 1: 存在 0: 不存在 */</span><span class="token keyword">int</span> <span class="token function">zslIsInRange</span><span class="token punctuation">(</span>zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">,</span> zrangespec <span class="token operator">*</span>range<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    zskiplistNode <span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token comment">// 入参的范围值有问题, 直接返回不存在</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>range<span class="token operator">-></span>min <span class="token operator">></span> range<span class="token operator">-></span>max <span class="token operator">||</span> <span class="token punctuation">(</span>range<span class="token operator">-></span>min <span class="token operator">==</span> range<span class="token operator">-></span>max <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>range<span class="token operator">-></span>minex <span class="token operator">||</span> range<span class="token operator">-></span>maxex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 获取尾巴节点, 也就是分值最大的节点</span>    x <span class="token operator">=</span> zsl<span class="token operator">-></span>tail<span class="token punctuation">;</span>    <span class="token comment">// 尾节点不存在或者节点的分数小于范围的最小值, 不存在</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">zslValueGteMin</span><span class="token punctuation">(</span>x<span class="token operator">-></span>score<span class="token punctuation">,</span>range<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 获取头节点的下一个节点, 也就是分值最小的节点</span>    x <span class="token operator">=</span> zsl<span class="token operator">-></span>header<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>    <span class="token comment">// 节点不存在, 或者节点的分数大于范围的最大值, 不存在</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">zslValueLteMax</span><span class="token punctuation">(</span>x<span class="token operator">-></span>score<span class="token punctuation">,</span>range<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 返回存在</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 判断入参的数值是否大于或大于等于范围的最小值 * @param value 入参的数值 * @param spec 范围 */</span><span class="token keyword">int</span> <span class="token function">zslValueGteMin</span><span class="token punctuation">(</span><span class="token keyword">double</span> value<span class="token punctuation">,</span> zrangespec <span class="token operator">*</span>spec<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// minex 是否可以等于判断值, 1: 大于 0: 大于等于</span>    <span class="token keyword">return</span> spec<span class="token operator">-></span>minex <span class="token operator">?</span> <span class="token punctuation">(</span>value <span class="token operator">></span> spec<span class="token operator">-></span>min<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>value <span class="token operator">>=</span> spec<span class="token operator">-></span>min<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 判断入参的数组是否小于或小于等于范围的最大值 */</span><span class="token keyword">int</span> <span class="token function">zslValueLteMax</span><span class="token punctuation">(</span><span class="token keyword">double</span> value<span class="token punctuation">,</span> zrangespec <span class="token operator">*</span>spec<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// maxex 是否可以等于判断值, 1: 小于 0: 小于等于</span>    <span class="token keyword">return</span> spec<span class="token operator">-></span>maxex <span class="token operator">?</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> spec<span class="token operator">-></span>max<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;=</span> spec<span class="token operator">-></span>max<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>到这里, Redis 对跳表的实现的大体逻辑基本就分解完了。</p><h2 id="4-问题"><a href="#4-问题" class="headerlink" title="4 问题"></a>4 问题</h2><h3 id="4-1-跳表的最大层数为-32"><a href="#4-1-跳表的最大层数为-32" class="headerlink" title="4.1 跳表的最大层数为 32"></a>4.1 跳表的最大层数为 32</h3><p>本身跳表的层节点是需要消耗空间的, 所以需要有一个上限。<br>而 Redis 提供的确定层高的函数</p><blockquote><ol><li>第一层的概率为 100%</li><li>第二层的概率为 25%</li><li>第五层的概率为 7.9%</li><li>第十三层的概率为 0.7%</li><li>第二十一层的概率为 0.07%</li></ol></blockquote><p>想达到 32 层基本不可能的。</p><h3 id="4-2-Redis中-为啥不用红黑树二用跳表"><a href="#4-2-Redis中-为啥不用红黑树二用跳表" class="headerlink" title="4.2 Redis中 为啥不用红黑树二用跳表"></a>4.2 Redis中 为啥不用红黑树二用跳表</h3><p>作者<a href="https://news.ycombinator.com/item?id=1171423">原文</a>, 概括如下</p><blockquote><ol><li>跳表占用的内存会比红黑树多, 但是多的内存很有限</li><li>跳表的实现比红黑树简单</li><li>范围查询的支持, 比红黑树简单</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 事件轮询</title>
      <link href="/article/2021/3272944063/"/>
      <url>/article/2021/3272944063/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Redis-为什么快"><a href="#1-Redis-为什么快" class="headerlink" title="1 Redis 为什么快"></a>1 Redis 为什么快</h2><blockquote><ol><li>数据存在内存中, 直接操作内存中的数据</li><li>单线程处理业务请求避免了多线的上下文切换, 锁竞争等弊端</li><li>使用 IO 多路复用支撑更高的网络请求</li><li>使用事件驱动模型, 通过事件通知模式, 减少不必要的等待</li><li>…</li></ol></blockquote><p>这些都是 Redis 快的原因。 但是这些到了代码层面是如何实现的呢?</p><p>这篇文章会简单的梳理 Redis 的代码实现 – 事件轮询。<br>主要涉及到上面的单线程, IO 多路复用和事件驱动。</p><p>注: 下面的分析也是按照 <strong>Redis 5.x</strong> 进行分析。</p><h2 id="2-IO-多路复用"><a href="#2-IO-多路复用" class="headerlink" title="2 IO 多路复用"></a>2 IO 多路复用</h2><p>因为 Redis 中大量的使用到了 IO 多路复用, 这边我们先简单的了解一下 IO 多路复用。</p><p><img src="https://pic.imgdb.cn/item/655f6b00c458853aef997860.png" alt="Alt &#39;IO 多路复用的简单原理&#39;"></p><p>上面的 IO 多路复用的简单流程, 还有另外一种<strong>回调</strong>的实现方式, 大体的逻辑差不多。</p><p>而传统的阻塞式 IO 的大体流程如下:</p><p><img src="https://pic.imgdb.cn/item/655f6af4c458853aef993e54.png" alt="Alt &#39;传统的阻塞式 IO 的简单原理&#39;"></p><p>线程一直阻塞在监听端口处, 其间无法进行任何的事务的处理, 没有连接进来, 线程就一直就阻塞着。 同时自己无法兼顾处理多个并发的请求。</p><p>而 IO 多路复用, 则将监听的操作交由系统进行处理, 自己在处理事务的过程中, 不定时的过来询问有自己关心的事件吗, 有就执行相应的事务, 否则继续处理别的业务。</p><h2 id="3-IO-多路复用在各个系统的实现"><a href="#3-IO-多路复用在各个系统的实现" class="headerlink" title="3 IO 多路复用在各个系统的实现"></a>3 IO 多路复用在各个系统的实现</h2><p>从上面的流程可以知道, IO 多路复用需要系统层面的支撑, 就如存在多种操作系统一样, IO 多路复用的具体实现也有多种</p><blockquote><ol><li>select 大部分系统都支持</li><li>epoll Linux</li><li>evport Solaris</li><li>kqueue UNIX (Mac)</li><li>…</li></ol></blockquote><p>不同的实现, 理所当然的映射到程序中, 就是不同的 api, 也就是不同的函数。<br>以 epoll 为例, 在 C 语言中, 提供了 3 个函数来帮助开发者使用多路复用。</p><p><img src="https://pic.imgdb.cn/item/655f6b0fc458853aef99c3d4.png" alt="Alt &#39;epoll 多路复用 Api&#39;"></p><p>Linux 提供的 epoll 多路复用就上面是 3 个方法, 很简单。<br>但是到了 Mac 的 evport 具体实现, 对应的实现是 kevent, meset 等函数, 完全不一样的逻辑。</p><p>不同的多路复用实现有着不同的 Api, 而 Redis 是一个可以支撑多平台的中间件, 那么就不能简单的选择其中一种了, 那么怎么办呢?  </p><p><img src="https://pic.imgdb.cn/item/655f6d29c458853aefa53c90.gif" alt="Alt &#39;全都要表情包&#39;"></p><h2 id="4-Redis-对多路复用的统一"><a href="#4-Redis-对多路复用的统一" class="headerlink" title="4 Redis 对多路复用的统一"></a>4 Redis 对多路复用的统一</h2><p>全都要是有代价的, 首当其冲的就是编码上复杂性将会提高很多。最简单的写法应该就是如下: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 创建多路复用 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createIoMultiplex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>os_system<span class="token operator">==</span><span class="token string">"Linux"</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// TODO</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>os_system<span class="token operator">==</span><span class="token char">'mac'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// TODO</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><p>首先上面的代码逻辑是没错的, 但是从一个开发出发</p><blockquote><ol><li>增加了自己的编码量</li><li>对知识储备有挑战, 需要了解不同的多路复用的实现原理</li><li>…</li></ol></blockquote><p>作为开发人员想要的是一套统一的 Api, 就能操作所有的多路复用。我不需要知道各个的多路复用的 Api, 差异什么, 什么时候用哪个。  </p><p><strong>下面就进入 Redis Java 版代码环节了 (Redis 是基于 C 语言实现的, 而 C 是一门面向过程的语言, 下面会以 Java 语言的形式进行分析总体逻辑是类似的)。</strong></p><p>虽然多路复用的实现在不同的方式有很多种, 但是对于开发通过多路复用要实现的事情都是一样的</p><blockquote><ol><li>创建和销毁多路复用</li><li>向多路复用添加删除我们关心的事件</li><li>从多路复用中获取我们关心的事件, 然后进行处理</li></ol></blockquote><p>所以 Redis 中对多路复用进行了封装。<br>先说一下结论吧: Redis 中对多路复用的封装有 2 层 <strong>AeApiState</strong> + <strong>AeApi</strong>。</p><p>AeApiState: 对各种多路复用<strong>本身实现逻辑</strong>的封装, 屏蔽各种实现细节。<br>可以理解为 AeApiState 就是代表了多路复用, AeApiState &#x3D;&#x3D; 多路复用, 就像我们一直说多路复用有多种实现一样 AeApiState 下面也有多种实现, EpollAeApiState, SelectAeApiState 等。</p><p><img src="https://pic.imgdb.cn/item/655f6aecc458853aef99170d.png" alt="Alt &#39;AeApiState 对多路复用实现逻辑的封装&#39;"></p><p>AeApi: 对多路复用<strong>支持的行为</strong>的封装, 对底层的多路复用进行了屏蔽, 开发人员只需要持有它的实现就可以对多路复用进行操作。</p><p><img src="https://pic.imgdb.cn/item/655f6ae7c458853aef98fe9d.png" alt="Alt &#39;AeApi 对多路复用支持的行为的封装&#39;"></p><h3 id="4-1-AeApiState"><a href="#4-1-AeApiState" class="headerlink" title="4.1 AeApiState"></a>4.1 AeApiState</h3><p>首先需要对各个系统的多路复用的统一: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AeApiState</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></code></pre><p>AeApiState 是 Redis 中各个操作系统重多路复用的统一声明。就和我们一直说多路复用一样, 是一个统称, 落实到实际中, 会有不同的实现, epoll, select 等。<br>AeApiState 也一样是 Redis 多路复用的一个统称, 其本身空空如也, 不具备任何的多路复用的功能。<br>而各个系统中已经给我们准备好了现成的功能, 我们完全可以利用起。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EpollAeApiState</span> <span class="token keyword">extends</span> <span class="token class-name">AeApiState</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 监听的文件描述符, 可以简单理解为一个文件的 id     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> epFd<span class="token punctuation">;</span>    <span class="token comment">/**     * Epoll 会将调用方关心并符合条件的事件存放到这里     * EpollEvent 就 2 个属性       * int fd 对应的文件描述符, 这里一般就是客户端的标识, 简单理解就是某个事件的 id     * int events 触发的事件类型, 可以理解为可读可写等     */</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">EpollEvent</span><span class="token punctuation">></span></span> events<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">epollCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 调用系统提供的 epoll_create() 创建 Epoll 类型的</span><span class="token punctuation">&#125;</span><span class="token comment">// 省略其他 2 个方法</span><span class="token punctuation">&#125;</span></code></pre><p>将各个系统的多路复用技术全部封装起来, 统一为 AeApiState 了。</p><h3 id="4-2-AeApi"><a href="#4-2-AeApi" class="headerlink" title="4.2 AeApi"></a>4.2 AeApi</h3><p>现在有多路复用 AeApiState 了, 但是不同的多路复用的 Api 不同, 同样的行为可以有不同的实现, 还是没解决多种实现的问题, 统一的 Api, 底层的屏蔽呢?<br>这是就轮到 AeApi 出现了, 对常用的多路复用 Api 行为进行抽象</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AeApi</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 获取 aeApi 的名称, 也就是多路复用的实现名称     * @return aeApi 的名称     */</span>    <span class="token class-name">String</span> <span class="token function">aeApiName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 创建 AeApiState, 也就是创建具体的多路复用     * @param setSize 关心的事件最大数量     * @return 创建结果, 1：成功, 其他失败     */</span>    <span class="token keyword">int</span> <span class="token function">aeApiCreate</span><span class="token punctuation">(</span><span class="token keyword">int</span> setSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 重新设置 AeApiState 中监听文件描述符的上限     * @param setSize     重新设置的大小     * @return 释放结果, 1：成功, 其他失败     */</span>    <span class="token keyword">int</span> <span class="token function">aeApiResize</span><span class="token punctuation">(</span><span class="token keyword">int</span> setSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 释放 AeApiState, 也就是关闭具体的多路复用     */</span>    <span class="token keyword">void</span> <span class="token function">aeApiFree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 向多路复用中新增关心事件     * @param aeEventLoop 事件轮询对象     * @param fd          文件描述符     * @param mask        标识     * @return 新增结果, 1：成功, 其他失败     */</span>    <span class="token keyword">int</span> <span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span><span class="token class-name">AeEventLoop</span> aeEventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 向多路复用中删除事件     * @param aeEventLoop 事件轮询对象     * @param fd          文件描述符     * @param delMask     删除标识     * @return 删除结果, 1：成功, 其他失败     */</span>    <span class="token keyword">int</span> <span class="token function">aeApiDelEvent</span><span class="token punctuation">(</span><span class="token class-name">AeEventLoop</span> aeEventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> delMask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 阻塞指定毫秒数, 返回阻塞时间段内就绪的事件     * @param aeEventLoop 事件轮询对象     * @param waitTime    阻塞时间, 毫秒     * @return 准备就绪的事件条数     */</span>    <span class="token keyword">int</span> <span class="token function">aeApiPoll</span><span class="token punctuation">(</span><span class="token class-name">AeEventLoop</span> aeEventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> waitTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上面是对 Redis 中对使用多路复用的支持的行为的定义。 不同的多路复用实现, 实现上面的接口, 实现自己的行为。  </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EpollAeApi</span> <span class="token keyword">implements</span> <span class="token class-name">AeApi</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** Epoll 多路复用自身的封装 */</span>    <span class="token keyword">private</span> <span class="token class-name">AeApiState</span> aeApiState<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">aeApiName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"epoll"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">aeApiCreate</span><span class="token punctuation">(</span><span class="token keyword">int</span> setSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 将 epoll 封装到自定义的 AeApiState 中</span>        <span class="token class-name">EpollAeApiState</span> epollAeApiState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EpollAeApiState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        epollAeApiState<span class="token punctuation">.</span><span class="token function">epollCreate</span><span class="token punctuation">(</span>setSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>aeApiState <span class="token operator">=</span> epollAeApiState<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">// 其他方法省略</span><span class="token punctuation">&#125;</span></code></pre><p>到此, Redis 对多路复用的封装就达成了。</p><p>上面都是底层的封装实现, 而到了开发层面, 在使用时, 就很简单了, 完全屏蔽了多路复用的存在, 基于统一的 Api 就能操作自己想要的效果</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">AeApi</span> aeApi <span class="token operator">=</span> <span class="token function">geteApi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建多路复用</span>aeApi<span class="token punctuation">.</span><span class="token function">aeApiCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 添加事件</span>aeApi<span class="token punctuation">.</span><span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 取消关心的事件</span>aeApi<span class="token punctuation">.</span><span class="token function">aeApiDelEvent</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 阻塞 waitTime 毫秒, 等待多路复用返回关心的事情</span>aeApi<span class="token punctuation">.</span><span class="token function">aeApiPoll</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="5-事件驱动"><a href="#5-事件驱动" class="headerlink" title="5 事件驱动"></a>5 事件驱动</h2><p>多路复用只是 Redis 运行中的一个辅助功能, 需要和 Redis 的事件轮询共同配合, 才支持起了高并发。<br>事件轮询可以拆分成事件 + 轮询。  </p><h3 id="5-1-轮询"><a href="#5-1-轮询" class="headerlink" title="5.1 轮询"></a>5.1 轮询</h3><p>这里我们先说一下轮询。轮询: 实际上就是一个死循环。  </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// TODO 执行逻辑</span><span class="token punctuation">&#125;</span></code></pre><blockquote><ol><li>将这个死循环封装到一个对象 AeEventLoop 中去, 同时加上一个控制循环结束的变量，就达到了 Redis 中事件轮询中轮询的雏形了。</li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/655f6aedc458853aef991cfb.png" alt="Alt &#39;事件轮询的雏形&#39;"></p><blockquote><ol start="2"><li>丰富轮询的功能 –&gt; 将我们的多路复用的 AeApi 添加进去，此时的事件轮询，将会变成这样</li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/655f6b0ac458853aef99abb3.png" alt="Alt &#39;带多路复用的事件轮询雏形&#39;"></p><blockquote><ol start="3"><li>丰富轮询的功能 –&gt; 在循环中调用多路复用时, 添加阻塞前后的回调函数</li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/655f6afac458853aef995ebc.png" alt="Alt &#39;带阻塞前后的回调函数的事件轮询雏形&#39;"></p><p>很多人认为 Redis 整个单线程是完成不会阻塞的。<br>实际上, 还是存在阻塞情况, 如果你有查看上面的 AeApi 的 Api 就可以发现 aeApiPoll 是一个阻塞的方法, 只是 Redis 阻塞时间设置的比较巧妙, 后面再分析。</p><p>上面就是我们常说的事件驱动模型, 事件轮询的轮询主体了。在使用上, 也很简单</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 创建事件轮询对象</span> <span class="token class-name">AeEventLoop</span> aeEventLoop <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AeEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Redis 启动"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 启动事件轮询 (进入了一个死循环)        </span>        aeEventLoop<span class="token punctuation">.</span><span class="token function">aeMain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Redis 停止"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></code></pre><h3 id="5-2-事件"><a href="#5-2-事件" class="headerlink" title="5.2 事件"></a>5.2 事件</h3><p>有了循环了, 但是从整体看的话, 循环中是没有任何的执行逻辑的, 是因为 Redis 将所有的逻辑都封装到了每一个事件上, 事件是将 Redis 中多路复用和轮询组合起来的核心。</p><p>在 Redis 中定义了 2 种事件</p><p><strong>文件事件</strong>: 需要满足某个条件才触发的事件, 但是不确定触发时机<br><img src="https://pic.imgdb.cn/item/655f6ae4c458853aef98ee93.png" alt="Alt &#39;AeFileEvent 的定义&#39;"></p><p><strong>时间事件</strong>: 需要多次有间隔的执行事件<br><img src="https://pic.imgdb.cn/item/655f6b0cc458853aef99b3c7.png" alt="Alt &#39;AeTimeEvent 的定义&#39;"></p><h3 id="5-2-1-时间事件"><a href="#5-2-1-时间事件" class="headerlink" title="5.2.1 时间事件"></a>5.2.1 时间事件</h3><p>因为文件事件和多路复用挂钩, 有点绕了一点, 我们先将时间事件组合到事件轮询中。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AeEventLoop</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 程序自定义的时间事件, 双写链表</span>    <span class="token keyword">private</span> <span class="token class-name">AeTimeEvent</span> aeTimeEvent<span class="token punctuation">;</span>    <span class="token comment">// 对外暴露的函数: 向事件轮询中的时间事件链表添加新的时间事件</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">aeCreateTimeEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 向事件轮询添加时间事件, 就是简单的链表操作</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 对外暴露的函数: 通过事件的 id 从事件轮询中的时间事件链表删除对应的时间事件</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">aeDeleteTimeEvent</span><span class="token punctuation">(</span><span class="token keyword">long</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 从事件轮询删除时间事件, , 就是简单的链表操作</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 启动函数没有任何变化</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">aeMain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stop <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 事件处理函数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 从时间链表中获取最快需要触发的时间事件, 距离触发还需要多少毫秒</span>        <span class="token comment">// 这里就是为什么 Redis 阻塞时间设置的比较巧妙的地方, 阻塞的这段时间理论是无时间触发, 所以对性能影响比较小</span>        <span class="token keyword">long</span> waitTime <span class="token operator">=</span> <span class="token function">handlerWaitTime</span><span class="token punctuation">(</span>aeTimeEvent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2. 执行阻塞前的函数 beforeSleepFunction(this);</span>        <span class="token comment">// 3. 阻塞式的从多路复用中获取文件事件</span>        <span class="token keyword">int</span> numEvents <span class="token operator">=</span> aeApi<span class="token punctuation">.</span><span class="token function">aeApiPoll</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4. 执行阻塞后的函数 afterSleepFunction(this);</span>        <span class="token comment">// 5. 执行需要触发的时间事件的函数</span>        <span class="token function">processTimeEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 时间事件的触发处理</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 获取双向链表的头节点</span>        <span class="token class-name">AeTimeEvent</span> timeEvent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>aeTimeEvent<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>timeEvent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 节点的 id == -1, 表示这个节点需要删除</span>            <span class="token comment">// 节点的删除是延迟删的, 需要删除时, 先打标为 -1，下次执行时, 在删除</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>timeEvent<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 2. 双向链表的节点删除, 同时将下一个节点赋值给 timeEvent</span>                <span class="token comment">// TODO 逻辑省略, 就是常见的双向链表的节点删除</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 3. 计算当前的时间和当前节点的时间是否匹配，匹配这个时间事件需要执行</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">timeEventNeedHander</span><span class="token punctuation">(</span>timeEvent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 执行时间事件的函数，同时会返回一个数字, 大于等于 0 表示多少秒后再执行, 小于 0, 表示不在需要了</span>                <span class="token keyword">int</span> retVal <span class="token operator">=</span> timeEvent<span class="token punctuation">.</span><span class="token function">getFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>retVal <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 需要销毁, 设置 id 为 -1, 下次再删除</span>                    timeEvent<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 重新计算这个时间下次执行的时间</span>                    <span class="token function">updateAeTimeEventTime</span><span class="token punctuation">(</span>aeTimeEvent<span class="token punctuation">,</span> retVal<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre><p>上面的逻辑很简单, 在事件轮询中, 加了 2 个方法, 用来给外部调用, 一个是添加时间事件, 一个是删除时间事件。<br>然后添加到事件轮询中的时间事件, 会在存储在事件轮询中的一个双向链表。</p><p>然后在事件轮询的死循环中, 每一次操作</p><blockquote><ol><li>计算整个事件双向链表中最快需要触发的时间事件, 距离触发还需要多少毫秒</li><li>阻塞式地从多路复用中获取文件事件, 阻塞的时间就是上一步计算出来的时间</li><li>从多路复用中的阻塞中返回后, 遍历整个时间事件双向链表</li><li>遍历整个时间双向链表<blockquote><p>4.1 遍历的时间事件的 fd &#x3D;&#x3D; -1, 表示这个时间事件需要删除, 进行删除 (Redis 对文件事件的删除都是延迟到下一轮循环删除)<br>4.2 遍历的时间事件没达到执行的时间, 跳过这个时间事件, 继续遍历下一个时间事件<br>4.3 遍历的时间事件需要达到了执行的时间, 执行这个时间事件里面的函数<br>4.4 执行的事件函数会返回一个整数, 整数值为 -1, 表示这个时间事件不需要了, 这时会将这个时间事件的 fd 设置为 -1, 下一轮循环删除<br>4.5 执行的事件函数返回的整数为大于等于 0, 表示这个时间事件还需要执行, 这个时间表示多久后执行, 根据这个时间计算这个时间事件下次执行的时间点, 继续遍历下一个时间事件</p></blockquote></li></ol></blockquote><h3 id="5-2-2-文件事件"><a href="#5-2-2-文件事件" class="headerlink" title="5.2.2 文件事件"></a>5.2.2 文件事件</h3><p>了解多路复用和时间轮询的协助前, 需要先了解一个对象 AeFiredEvent: 已满足触发条件的文件事件。  </p><p><img src="https://pic.imgdb.cn/item/655f6aeac458853aef990f78.png" alt="Alt &#39;AeFiredEvent 的定义&#39;"></p><p>AeFiredEvent 中有 2 个属性</p><blockquote><ol><li>fd 文件描述符, 可以简单的理解为文件事件的 id</li><li>mask 文件事件的触发类型, 可读, 可写等</li></ol></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AeEventLoop</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 程序自定义的文件事件, 程序初始时, 指定好了最大容量了</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">AeFileEvent</span><span class="token punctuation">></span></span> aeFileEvents<span class="token punctuation">;</span>        <span class="token comment">// 存储多路复用中通知的已触发的事件数组</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">AeFiredEvent</span><span class="token punctuation">></span></span> aeFiredEvents<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AeEventLoop</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>aeFileEvents <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>maxSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>aeFiredEvents <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>maxSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>aeFileEvents<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AeFileEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>aeFiredEvents<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AeFiredEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>在事件轮询中, 有 2 个文件事件相关的数组</p><blockquote><ol><li>aeFileEvents: 存储的就是注册到事件轮询中的文件事件</li><li>aeFiredEvents: 存储的就是多路复用中通知的<strong>已触发</strong>的事件数组</li></ol></blockquote><p>这 2 个数组的长度是一致的, 长度都是入参的 maxSize。<br>maxSize: 表示当前时间轮询支持的文件事件的个数, 也是<strong>所有文件事件 fd 的最大值, 也就是理解为所有文件事件 id 的最大的值</strong>。</p><p>这个设计可以达到一个好处, 任意一个文件事件的 fd, 也就是 id, 都可以在上面 2 个数组对应的位置找到, <strong>aeFileEvents[fd]</strong>, 得到的就是对应的文件事件。</p><p>aeFileEvents 和 aeFiredEvents 共同配合, 达到获取到已触发的文件事件的效果</p><blockquote><ol><li>事件轮询 AeEventLoop 调用 AeApi 尝试获取已触发的文件事件, 会将自身 AeEventLoop 和阻塞的毫秒数作为参数传给 AeApi 的 aeApiPoll 方法</li><li>AeApi 的 aeApiPoll 方法在阻塞指定毫秒数后, 可以得到已触发的事件 (也可能这段时间的确一个文件事件都没触发)</li><li>根据触发的事件的个数, 获取到事件轮询中的 aeFiredEvents (已触发事件数组) 的前几个 AeFiredEvent, 将触发的事件的 fd 和 mask 逐个赋值给获取到的 AeFiredEvent</li><li>然后将已触发的个数返回给调用的事件轮询 AeEventLoop</li><li>事件轮询 AeEventLoop 根据已触发的个数, 获取 aeFiredEvents 的前几个 AeFiredEvent, 根据 AeFiredEvent 的 fd, 也就是事件的 id, 到 aeFileEvents 数组中获取对应的 AeFileEvent, 执行函数</li></ol></blockquote><p>大体的流程如下:</p><blockquote><ol><li>事件轮询 AeEventLoop 通过 AeApi 的 aeApiPoll 到多路复用 AeApiState 获取已触发的文件事件, 同时将自身作为参数传递过去, 并且说明最多支持在里面阻塞 1000 毫秒 (举例)</li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/655f6b03c458853aef99897b.png" alt="Alt &#39;事件轮询尝试从多路复用中获取已触发文件事件&#39;"></p><blockquote><ol start="2"><li>多路复用 AeApiState 在阻塞 1000 毫秒后, 获取到已触发的文件事件, 假设现在有文件描述符为 2 和 19 的 2 个文件事件触发了</li><li>多路复用 AeApiState 通过入参的事件轮询 AeEventLoop, 获取到事件轮询中的 aeFiredEvents 数组的前 2 个, 将他们的 fd 和 mask 修改为触发的 2 个事件的 fd 和 mask</li><li>多路复用修改为 AeApiState 的 aeFiredEvents 数组后, 然后通知调用方 AeEventLoop, 有 2 个文件事件触发了</li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/655f6b05c458853aef999432.png" alt="Alt &#39;多路复用修改并通知事件轮询已触发文件事件个数&#39;"></p><blockquote><ol start="5"><li>AeEventLoop 根据返回的 2, 获取到 aeFiredEvents 数组的前 2 个, 根据 AeFiredEvent 的 fd, 2 和 19, 到自己的文件事件数组的 aeFileEvents 的第 2 位和第 19 位获取 2 个文件事件</li><li>执行获取到的 2 个文件事件的函数</li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/655f6afcc458853aef9968e6.png" alt="Alt &#39;事件轮询获取触发文件事件并执行&#39;"></p><p>了解完大体的过程, 下面的代码逻辑应该就很清晰了</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AeEventLoop</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">AeFileEvent</span><span class="token punctuation">></span></span> aeFileEvents<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">AeFiredEvent</span><span class="token punctuation">></span></span> aeFiredEvents<span class="token punctuation">;</span><span class="token comment">// 对外暴露的函数: 向事件轮询中的文件事件添加新的文件事件</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">,</span> <span class="token class-name">Function</span> function<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 1. 先向多路复用注册这个事件, 后续才能感知到什么时候触发</span> aeApi<span class="token punctuation">.</span><span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2. 根据文件描述符从文件事件数组中获取对应的位置的文件事件</span> <span class="token class-name">AeFileEvent</span> aeFileEvent <span class="token operator">=</span> aeFileEvents<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3. 将当前关注的事件类型和执行函数覆盖过去</span>aeFileEvent<span class="token punctuation">.</span><span class="token function">setXXX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 对外暴露的函数: 向事件轮询中的文件事件删除对应的文件事件</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">aeDeleteTimeEvent</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 逻辑差不多, 从多路复用中删除即可</span><span class="token punctuation">&#125;</span> <span class="token comment">// 启动函数没有任何变化</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">aeMain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stop <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 调用多路复用, 将符合条件的事件，放到 this(也就是当前的 AeEventLoop) 的 aeFiredEvents 中</span>        <span class="token comment">// 同时返回了, 总共触发了多少个函数</span> <span class="token keyword">int</span> numEvents <span class="token operator">=</span> aeApi<span class="token punctuation">.</span><span class="token function">aeApiPoll</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numEvents<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 2. 遍历触发的已触发事件数组</span>            <span class="token class-name">AeFiredEvent</span> aeFiredEvent <span class="token operator">=</span> aeFiredEvents<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// aeFiredEvent 的 fd 就是对应的文件描述符</span>            <span class="token comment">// 而 aeFileEvent 已经将最大的 fd 声明成一个数组了, 可以在数组中找到其对应的事件</span>            <span class="token class-name">AeFileEvent</span> aeFileEvent <span class="token operator">=</span> aeFileEvents<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>aeFiredEvent<span class="token punctuation">.</span><span class="token function">getFd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 触发的是可读事件，执行可读函数, 是可写函数, 执行可先函数</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>aeFileEvent<span class="token punctuation">.</span><span class="token function">getMask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                aeFileEvent<span class="token punctuation">.</span><span class="token function">getReadFileProc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                aeFileEvent<span class="token punctuation">.</span><span class="token function">getWriteFileProc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="6-事件轮询在-Redis-在运行中的简单分析"><a href="#6-事件轮询在-Redis-在运行中的简单分析" class="headerlink" title="6 事件轮询在 Redis 在运行中的简单分析"></a>6 事件轮询在 Redis 在运行中的简单分析</h2><ol><li>Redis 启动, 加载大量的配置信息, 初始化需要初始的配置等</li><li>创建唯一一个的事件轮询 AeEventLoop, 在创建时, 指定了最大的文件描述符 (默认为 10128), 这里我们假设为 100, 这时我们就得到了一个事件轮询对象<br><img src="https://pic.imgdb.cn/item/655f6b01c458853aef997ecb.png" alt="Alt &#39;AeEventLoop 创建&#39;"></li><li>向事件轮询注册一个 100 毫秒 (虽然注册到事件轮询是 1 毫秒, 但是第一次执行完成后, 重新时间的时间为 1000&#x2F;server.hz, server.hz 默认等于 10, 可以动态修改) 执行一次的时间事件, 执行的函数为 serverCron (这个函数是 Redis 初始的唯一一个定时事件, 里面包含了内存的定时释放, 主从心跳的维持等, 同时虽然是 100 毫秒执行 1 次, 但是内部通过维护一个频率的函数, 可以达到不同的时机触发不同的逻辑), 最新的事件轮询就变成这样:<br><img src="https://pic.imgdb.cn/item/655f6b07c458853aef999f18.png" alt="Alt &#39;AeEventLoop 设置时间事件&#39;"></li><li>和 6379 端⼝建⽴起 Socket 监听, 得到了对应这个端⼝的⼀个⽂件描述符 (这⾥假设为 1)</li><li>向事件轮询注册⼀个可读事件, ⽂件描述符 1 (这⾥可以之间认为 1 就是 6379 端⼝), 关⼼他的可读事件(有客户端连接到这个端⼝了), 执⾏的函数为 acceptTcpHandler (后续所有的客户端连接到这个 Redis 的事件都会被多路复⽤监听到, 同时通知时间轮询触发 acceptTcpHandler 函数), 最新的事件轮询就变成这样:<br><img src="https://pic.imgdb.cn/item/655f6af7c458853aef994ef6.png" alt="Alt &#39;AeEventLoop 设置端口监听文件事件&#39;"></li><li>向事件轮询注册阻塞前后的回调函数 beforeSleep&#x2F;afterSleep (beforeSleep 的逻辑很多, 包括先保存 AOF 缓存, ⽴即向从节点发送⼀次 ack 等操作), 最新的事件轮询就变成这样了<br><img src="https://pic.imgdb.cn/item/655f6af2c458853aef993221.png" alt="Alt &#39;AeEventLoop 设置阻塞前后执行函数&#39;"></li><li>调⽤事件轮询 AeEventLoop 的 aeMain ⽅法, 启动事件轮询的死循环</li><li>从时间链表中找到执⾏时间距离当前最近的⼀个时间事件, 计算出⼀个阻塞时间</li><li>调⽤阻塞前的函数 beforeSleep</li><li>调⽤ aeApi 的阻塞⽅法获取关⼼的事件, 阻塞时间为上⾯计算出来的事件 (这时返回值为 0, 没有关⼼的事件)</li><li>调⽤阻塞后的函数 afterSleep</li><li>aeApi 返回了 0, 没有关⼼的⽂件事件, 跳过⽂件事件的触发</li><li>遍历整个时间事件链表, ⾥⾯有需要触发的, 就进⾏触发, 同时触发的函数返回值为 -1, 就将 fd 设置为 -1, <strong>下次遍历时间事件链表时</strong>, 会从链表中移除, 不为 -1, 根据返回值设置其下次执⾏的时间</li><li>死循环，回到⽅法头, ⼜继续重复上⾯的 8 -13 步骤</li><li>突然 IP: 192.168.1.11 向 Redis 发起了 Socket 连接, 多路复⽤这时发现是上层关⼼的可读事件, 保留起来</li><li>死循环⼜执⾏到了第 10 步, 这时 aeApi 会得到 6379 端⼝的⽂件描述符, 也就是上⾯我们说的⽂件描述符 1 , 将事件轮询的 aeFiredEvents 数组的第⼀个覆盖为⼀个新的 AeFiredEvent, fd 为 1, mask 为可读标识, 最新的事件轮询就变成这样了<br><img src="https://pic.imgdb.cn/item/655f6aefc458853aef99264b.png" alt="Alt &#39;AeEventLoop 有触发文件事件需要执行&#39;"></li><li>死循环得到 aeApi 的返回值不为 0, 根据返回值, 依次从 aeFiredEvents 中获取多少个对象, 这⾥只获取到⼀个, 从第⼀个中获取到⽂件描述符为 1, 从 aeFileEvent 中获取到位置 1 的⽂件事件, 触发其函数, 这⾥是 acceptTcpHandler (acceptTcpHandler 主要是⽤来处理客户端的 socket 连接, 被判定可以处理后，可以通过 ip 得到⼀个⽂件描述符, 然后根据这个⽂件描述符向事件轮询注册⼀个可读事件 (等待客户端发送请求参数)，处理函数为 readQueryFromClient, 而 readQueryFromClient ⾥⾯处理完客户端的请求后, ⼜会将这个 ip 也就是⽂件描述符从事件轮询中移除, 不在关心这个 ip 任何事件)</li><li>执⾏完⽂件事件, ⼜回到 13, 执⾏完，⼜回到⽅法头, ⼜继续重复上⾯的 8 - 13 步骤</li></ol><p>至此, Redis 事件轮询就大体分析完了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis ZipList 编码</title>
      <link href="/article/2021/2617835609/"/>
      <url>/article/2021/2617835609/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>官方的介绍</p><pre class="language-log" data-language="log"><code class="language-log">The ziplist is a specially encoded dually linked list that is designedto be very memory efficient<span class="token punctuation">.</span> It stores both strings and integer values<span class="token punctuation">,</span>where integers are encoded as actual integers instead of a series ofcharacters<span class="token punctuation">.</span> It allows push and pop operations on either side of the listin O<span class="token operator">(</span><span class="token number">1</span><span class="token operator">)</span> time<span class="token punctuation">.</span> However<span class="token punctuation">,</span> because every operation requires a reallocation ofthe memory used by the ziplist<span class="token punctuation">,</span> the actual complexity is related to theamount of memory used by the ziplist<span class="token punctuation">.</span>ziplist 是一个经过特殊编码的内存高效的双向链表。它同时存储字符串和整数值<span class="token punctuation">,</span> 其中整数被编码为实际整数<span class="token punctuation">,</span> 而不是一系列字符。它允许在 O<span class="token operator">(</span><span class="token number">1</span><span class="token operator">)</span> 时间内对列表的两边进行 push 和 pop 操作。但是<span class="token punctuation">,</span> 因为每个操作都需要重新分配 ziplist 所使用的内存<span class="token punctuation">,</span> 所以实际的复杂性与 ziplist 所使用的内存数量有关。</code></pre><p>ziplist 是一个双向链表。但是它不存储指向上一个链表节点和指向下一个链表节点的指针, 而是存储上一个节点长度和当前节点长度。<br>通过牺牲部分读写性能, 来换取高效的内存空间利用率, 是一种时间换空间的思想。</p><p>注: 下面的分析也是按照 <strong>Redis 5.x</strong> 进行分析。</p><h2 id="2-ziplist-的实现逻辑"><a href="#2-ziplist-的实现逻辑" class="headerlink" title="2 ziplist 的实现逻辑"></a>2 ziplist 的实现逻辑</h2><p>在 Redis 中, ziplist 虽然是一个双向链表, 却是通过一个 <strong>char[]</strong> 数组实现的, 先后遍历时, 借助在存储数据时冗余的上一个节点长度和当前节点长度, 计算后得到上下节点的位置。<br>所以, 在 Reids 中, **ziplist &#x3D;&#x3D; char[]**。</p><p>首先明确一点, 在 C 语言中, char 类型只占 8 位 (这个很重要, 因为下面的内容基本都是会涉及到很多的字节内容), 整个 char[] 数组会被按照下面的格式进行划分。</p><p><img src="https://pic.imgdb.cn/item/655b1625c458853aef5649a6.png" alt="Alt &#39;char[] 实现 ziplist 的方式&#39;"></p><p>整个 char[] 数组的划分如下:  </p><blockquote><ol><li>0 ~ 3 位, 4 个字节, 叫做 <strong>zlbytes</strong>, 表示当前整个 ziplist 的字节长度, 也就是整个数组的长度, 因此压缩列表最多有 2^32 - 1 个字节</li><li>4 ~ 7 位, 4 个字节, 叫做 <strong>zltail</strong>, 表示当前 ziplist 的起始位置到最后一个 entry 元素的起始位置相差的字节数, 也就是 ziplist 的起始位置 + zltail &#x3D; ziplist 最后一个 entry 的起始位置 (简单理解就是, 数组的第几位是最后一个 entry 的开始位置)  </li><li>8 ~ 9 位, 2 个字节, 叫做 <strong>zllen</strong>, 表示当前整个 ziplist 中的 entry 个数, 也就是整个 ziplist 最多有 2^16 - 1 个 entry</li><li>10 ~ n 位, 字节数不定, 就是真正存储数据的 entry 集合</li><li>最后 1 位, 1 个字节, 叫做 <strong>zlend</strong>, 表示整个 ziplist 的结束位, 固定为 0xFF (255, 1111 1111)</li></ol></blockquote><p>整个数组中, 只有 entry 是存储数据的地方。</p><h3 id="2-1-entry-的结构"><a href="#2-1-entry-的结构" class="headerlink" title="2.1 entry 的结构"></a>2.1 entry 的结构</h3><p>整个 ziplist 的大体布局了解完了, 看一下存储数据的 entry, 整个 entry 的话分成了 3 部分</p><blockquote><ol><li>previous_entry_length: 当前 entry 的前一个 entry 的占的字节长度</li><li>encoding: 当前 entry 存储的数据内容是什么类型, 大体有 2 种：整数和字节数组 (也就是字符串)</li><li>content: 需要存储的内容</li></ol></blockquote><p><strong>previous_entry_length</strong>  </p><p>表示前一个 entry 的字节长度, 会占 1 个或者 5 个字节, 占的字节数取决于上一个 entry 的的字节长度。<br>当前一个 entry 的长度小于 254 字节时, 用 1 个字节表示。<br>当前一个 entry 的长度大于或等于 254 字节时, 用 5 个字节来表示, 这 5 个字节中第一个固定为 0xFE (254, 1111 1110)</p><p><strong>encoding</strong>  </p><p>当前 entry 的编码, 不同的编码, 表示后面的 content 是不同的内容, 会占 1, 2 或者 5 个字节, 占的字节取决于存储在当前 entry 内的内容的格式</p><table><thead><tr><th align="center">encoding 占的字节数</th><th align="center">encoding 的二进制</th><th align="center">二进制的前 2 位的</th><th align="center">表示的内容</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">00 bbbbbb</td><td align="center">00</td><td align="center">长度最大为 63 的字节数组,  encoding 后面的 6 位用来存储字节数组的长度</td></tr><tr><td align="center">1</td><td align="center">1100 0000</td><td align="center">11</td><td align="center">int_16 的整数</td></tr><tr><td align="center">1</td><td align="center">1101 0000</td><td align="center">11</td><td align="center">int 32 的整数</td></tr><tr><td align="center">1</td><td align="center">1110 0000</td><td align="center">11</td><td align="center">int 64 的整数</td></tr><tr><td align="center">1</td><td align="center">1111 0000</td><td align="center">11</td><td align="center">int 24 位的整数</td></tr><tr><td align="center">1</td><td align="center">1111 1110</td><td align="center">11</td><td align="center">8 位的整数</td></tr><tr><td align="center">1</td><td align="center">1111 bbbb</td><td align="center">11</td><td align="center">后面的 bbbb 的取值范围为 0001 到 1101 (避免和上面的 24 位和 8 位整数的影响), 表示 1 - 13, 这个编码表示的是后面没有 content 字段, 值存储在 encoding 后面 4 位, 表示值为 0 - 12, 进制值减 1</td></tr><tr><td align="center">2</td><td align="center">01 bbbbbb aaaa aaaa</td><td align="center">01</td><td align="center">长度最大为 2^14 - 1 的字节数组, 2 个字节的 encoding 后面的 14 位用来存储字节数组的长度</td></tr><tr><td align="center">4</td><td align="center">10_ bbbb bbbb aaaa aaaa cccc cccc dddd dddd</td><td align="center">10</td><td align="center">长度最大为 2^32 - 1 的字节数组, 5 个字节的 encoding 用后面的 4 个字节, 32 位用来存储字节数组的长度</td></tr></tbody></table><p>从上面的编码可以看出, encoding 的第一个字节的前二位可以确定后面 content 的数据类型了, 11xx xxxx 为整数, 不是 11xx xxxx 就是字节数组, 字节数组再判断前二位, 知道具体的长度类型, 最终得到了存储数据长度。</p><p><strong>content</strong><br>没什么好说的, 真正存储的数据。</p><h3 id="2-1-1-entry-代码中的实现-zlentry"><a href="#2-1-1-entry-代码中的实现-zlentry" class="headerlink" title="2.1.1 entry 代码中的实现 zlentry"></a>2.1.1 entry 代码中的实现 zlentry</h3><p>通过上面的 entry 组成分析可以知道, 整体的数据都是压缩在 entry 中的, 这个存储没问题。<br>但是在代码的处理中, 不可能说每次需要用就进行进行一次解析, 比如需要内容的长度, 解析对应的 entry, 需要内容的具体值, 再解析对应的 entry。<br>这个基本不实际, 一般都是直接将一个 entry 解析完成, 在整个<strong>方法域</strong>中都能起作用。  </p><p>在 <strong>Redis 5.x</strong> 中, entry 会被解析成 ZlEntry 对象, 解析后, 在整个方法的执行中都能通过这个 zlentry 获取到整个 entry 的内容。</p><p>zlentry 的定义  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zlentry</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** previous_entry_length 占用了多少个字节, 取值为 1 或者 5 */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prevrawlensize<span class="token punctuation">;</span>     <span class="token comment">/** previous_entry_length 的表示的值 */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prevrawlen<span class="token punctuation">;</span>     <span class="token comment">/** encoding 占用了多少个字节  1,2,5 */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> lensize<span class="token punctuation">;</span>     <span class="token comment">/** content 占用的字节数 */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">;</span>     <span class="token comment">/**      * content 的数据类型, 用一些枚举替代, 不保存具体的值     * 取值范围:     * 0000 0000 长度最大为 63 的字节数组     * 0100 0000 最大长度为 2^14 - 1 的字节数组      * 1000 0000 最大长度为 2^32 - 1 的字节数组     * 1100 0000 整数     */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> encoding<span class="token punctuation">;</span>     <span class="token comment">/** 头部的长度占用的长度, 等于 prevrawlensize + lensize */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> headersize<span class="token punctuation">;</span>     <span class="token comment">/** 当前 entry 在字节数组中的开始位置, 指向这个 entry 的指针开始 */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> zlentry<span class="token punctuation">;</span></code></pre><p>在 <strong>Redis 5.x</strong> 的源码中, entry 解析为 zlentry 的方法有 2 个 <strong>zipEntry</strong> 和 <strong>zipEntrySafe</strong>, 2 个的逻辑的一样的。<br>不同的是后面的 zipEntrySafe 会加上字节长度的校验, 确保当前 entry 的内容不会超过当前存储内容的 char[] 数组的长度。</p><p><strong>下面的代码, 经过调整, 逻辑不变, 但是相对更容易理解, 所以和源码有点区别</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * zlentry 解析 * @param p 就是需要解析的 entry 的指针地址, 转为为 Java 就是 可以理解为一个 int, 表示在 char[] 数组的这个位置 entry 的开始位置 * @param e 就是一个 zlentry 的地址引用, 将解析后的结果存入到这个 zlentry */</span><span class="token keyword">void</span> <span class="token function">zipEntry</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> zlentry <span class="token operator">*</span>e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 从 p 的开始位置, 也就是 previous_entry_length 的位置解析出 prevrawlensize 和 prevrawlen, 存入到 e 对应的位置</span>    <span class="token function">zip_decode_prevlen</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> e<span class="token operator">-></span>prevrawlensize<span class="token punctuation">,</span> e<span class="token operator">-></span>prevrawlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 从 p + prevrawlensize 的位置, 也就是到了 encoding 的位置, 解析出 encoding,</span>    <span class="token function">zip_entry_encoding</span><span class="token punctuation">(</span>p <span class="token operator">+</span> e<span class="token operator">-></span>prevrawlensize<span class="token punctuation">,</span> e<span class="token operator">-></span>encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 从 p + prevrawlensize 的位置, 也就是到了 encoding 的位置, 解析出 encoding, lensize, len 存入到 e 对应的位置</span>    <span class="token function">zip_decode_length</span><span class="token punctuation">(</span>p <span class="token operator">+</span> e<span class="token operator">-></span>prevrawlensize<span class="token punctuation">,</span> e<span class="token operator">-></span> encoding<span class="token punctuation">,</span> e<span class="token operator">-></span>lensize<span class="token punctuation">,</span> e<span class="token operator">-></span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// e 的 headersize 的值等于 prevrawlensize + lensize 的值</span>    e<span class="token operator">-></span>headersize <span class="token operator">=</span> e<span class="token operator">-></span>prevrawlensize <span class="token operator">+</span> e<span class="token operator">-></span>lensize<span class="token punctuation">;</span>     <span class="token comment">// e 的 p 值等于入参的 p 值, 也就是 entry 开始的位置</span>    e<span class="token operator">-></span>p <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">zip_decode_prevlen</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> prevlensize<span class="token punctuation">,</span> prevlen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 解析 previous_entry_length 占的字节数</span>    <span class="token comment">// ZIP_BIG_PREVLEN = 0xfe, 1111 1110 </span>    <span class="token comment">// 上面说过了 previous_entry_length 的字节长度只有 1 和 5</span>    <span class="token comment">// 如果 5 个字节的话, 第一位必定是 0xfe</span>    <span class="token comment">// 所以 第一位如果是 0xfe, 那么 previous_entry_length 必定是 5 个字节, 否则就是 1 个字节</span>    <span class="token punctuation">(</span>prevlensize<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>prt<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> ZIP_BIG_PREVLEN <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>prevlensize<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1 个字节, 那么第一个字节就是 previous_entry_length 的值</span>        <span class="token punctuation">(</span>prevlen<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>prt<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 不是 1 个字节, 那么就是 5 个字节, 取后面的 4 个字节拼接成一个 int 值</span>        <span class="token punctuation">(</span>prevlen<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>prt<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>prt<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>prt<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span>  <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>prt<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">zip_entry_encoding</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> encoding<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 注意此处的 ptr 不是 entry 的开始位置, 而是 entry + previous_entry_length 后的位置, 也就是 encoding 的开始位置</span>    <span class="token comment">// encoding 等于当前 encoding 的第一个字节</span>    <span class="token punctuation">(</span>encoding<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ZIP_STR_MASK = 0xc0, 二进制 1100 0000</span>    <span class="token comment">// 当前 ptr[0] 小于 1100 0000, 表示 encoding 当前表示的是字节数组</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span> <span class="token operator">&lt;</span> ZIP_STR_MASK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// encoding &amp; 1100 0000, 只取前 2 位, 即可</span>        <span class="token punctuation">(</span>encoding<span class="token punctuation">)</span> <span class="token operator">&amp;=</span> ZIP_STR_MASK<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">zip_decode_length</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> lensize<span class="token punctuation">,</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// encoding &lt; 1100 0000, 字节数组</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span> <span class="token operator">&lt;</span> ZIP_STR_MASK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span> <span class="token operator">==</span> ZIP_STR_06B<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// ZIP_STR_06B = 0, 二进制 0000 0000</span>            <span class="token comment">// 结果: 字节数组, 长度最大为 63 的字节数组, encoding 只需要使用 1 个字节存储</span>            <span class="token punctuation">(</span>lensize<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                                                        <span class="token comment">// 0x3f = 63, 二进制 0011 1111, &amp; 上 0011 1111, 得到 encoding 去掉前 2 位后的值, 也就是 content 的字节长度          </span>            <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3f</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span> <span class="token operator">==</span> ZIP_STR_14B<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              <span class="token comment">// ZIP_STR_14B = 64, 二进制 0100 0000</span>            <span class="token comment">// 结果: 字节数组, 2^14 - 1 的字节数组, encoding 需要使用 2 个字节存储</span>            <span class="token punctuation">(</span>lensize<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                                                         <span class="token comment">// 得到存储在 encoding 2 个字节中 content 字节长度        </span>            <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3f</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span> <span class="token operator">==</span> ZIP_STR_32B<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// ZIP_STR_32B = 128, 二进制 10000000</span>            <span class="token comment">// 结果: 字节数组, 2^32 - 1 的字节数组, encoding 需要使用 5 个字节存储</span>            <span class="token punctuation">(</span>lensize<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>              <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span>  <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 异常情况处理</span>            <span class="token punctuation">(</span>lensize<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 整数处理</span>        <span class="token comment">// 整数的话, 默认 encoding 只需要一个字节</span>        <span class="token punctuation">(</span>lensize<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// ZIP_INT_8B = 254, 二进制 11111110, 表示 8 位的整数, content 只需要 1 个字节</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span> <span class="token operator">==</span> ZIP_INT_8B<span class="token punctuation">)</span>  <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                 <span class="token comment">// ZIP_INT_16B = 192, 二进制 1100 0000, 表示 16 位的整数, content 需要 2 个字节</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span> <span class="token operator">==</span> ZIP_INT_16B<span class="token punctuation">)</span> <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                                         <span class="token comment">// ZIP_INT_24B = 240, 二进制 1111 0000, 表示 24 位的整数, content 需要 3 个字节</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span> <span class="token operator">==</span> ZIP_INT_24B<span class="token punctuation">)</span> <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>          <span class="token comment">// ZIP_INT_32B = 208, 二进制 1101 0000, 表示 32 位的整数, content 需要 4 个字节</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span> <span class="token operator">==</span> ZIP_INT_32B<span class="token punctuation">)</span> <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>                                 <span class="token comment">// ZIP_INT_64B = 224, 二进制 1110 0000, 表示 64 位的整数, content 需要 5 个字节</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span> <span class="token operator">==</span> ZIP_INT_64B<span class="token punctuation">)</span> <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>         <span class="token comment">// ZIP_INT_IMM_MIN = 241, 二进制 1111 0001 </span>        <span class="token comment">// ZIP_INT_IMM_MAX = 253, 二进制 1111 1101</span>        <span class="token comment">// 1111 0001 &lt;= encoding &lt;= 1111 1101, 没有 content，值直接存储在 encoding </span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>encoding <span class="token operator">>=</span> ZIP_INT_IMM_MIN <span class="token operator">&amp;&amp;</span> encoding <span class="token operator">&lt;=</span> ZIP_INT_IMM_MAX<span class="token punctuation">)</span>            <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>         <span class="token comment">// 异常情况处理</span>            <span class="token punctuation">(</span>lensize<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>上面的就是 entry 解码为 zlentry 的过程, 同样的 zlentry 编码为 entry， 就是过程逆过来的处理, 就不展开了。</p><h2 id="3-ziplist-节省了哪些空间"><a href="#3-ziplist-节省了哪些空间" class="headerlink" title="3  ziplist 节省了哪些空间"></a>3  ziplist 节省了哪些空间</h2><p>我们可以知道 ziplist 是一个双向链表, 可以从 2 侧遍历。<br>通过 <strong>zltail</strong> 可以获取到最后一个 entry 的起始位置, 同时通过 entry 的 previous_entry_length 属性, 可以得到上一个 entry 的字节长度, 从而达到从后到前的遍历。<br>而从 ziplist 的 char[] 数组的第 10 位开始就是第一个 entry, 通过解码每一个 entry, 获取到每一个 entry 的长度, 也可以得到下一个 entry 的开始位置, 从而达到从前往后的遍历。<br>通过这种方式达到了用数组实现双向链表的操作。 </p><p>这种方式每次遍历都需要解码编, 浪费了时间, 影响执行效率, 但是节省了空间, 那么节省了哪些空间呢?</p><p>在传统的双向链表中的每一个节点需要</p><blockquote><ol><li>指向前一个节点的指针, 64 位的系统中, 这个指针需要 8 个字节的内存</li><li>指向后一个节点的指针, 同样是 8 个字节的内存</li><li>节点中的内容指针, 指向存储的字符串的指针, 8 个字节</li><li>C 语言中, 字符串的特殊处理, 末尾加上 \0 的结束符</li></ol></blockquote><p>最终需要 25 个字节的辅助, 假设现在有 3 个字符串 <strong>one</strong>, <strong>two</strong>, <strong>three</strong>, 内存中的情况如下:</p><p><img src="https://pic.imgdb.cn/item/655b1627c458853aef56523b.png" alt="Alt &#39;普通链表的内存形式&#39;"></p><p>而通过上面的 entry 进行存储时</p><blockquote><ol><li>previous_entry_length: 受前面的 entry 的长度影响, 但是最大为 5 个字节</li><li>encoding: 受当前存储的 entry 的内容影响, 最大为 5 个字节</li><li>content: 可以不需要借助 \0 结束<br>所以最终最坏的情况 (不考虑里面存储的内容) 需要 10 个字节的辅助。</li></ol></blockquote><h2 id="4-ziplist-在使用上的一些情况"><a href="#4-ziplist-在使用上的一些情况" class="headerlink" title="4 ziplist 在使用上的一些情况"></a>4 ziplist 在使用上的一些情况</h2><p>下面以插入 (伪代码) 为例, 进行分析</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * @param zl 插入的压缩列表 * @param p 插入的位置指针, 原位置的 entry 变为当前插入 entry 的后一个节点 * @param s 需要插入的字符串 * @param slen 插入的字符串的长度 */</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">ziplistInsert</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> slen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 向压缩列表插入元素有 4 种情况</span><span class="token comment">// 1. 列表没有数据的插入</span><span class="token comment">// 2. 列表有数据, 在尾部插入</span><span class="token comment">// 3. 列表有数据, 在中间插入</span><span class="token comment">// 4. 列表有数据, 在首部插入</span>    <span class="token comment">// 插入位置当前的 entry 的 previous_entry_length 占的字节数</span>    <span class="token keyword">int</span> prevlensize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 插入位置当前的 entry 的 previous_entry_length 的值, 也就是当前插入的位置前一个 entry 的字节长度</span>    <span class="token keyword">int</span> prevlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// ZIP_END = 0xff, 二进制 1111 1111</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> ZIP_END<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 插入的位置不是压缩列表的尾部, 插入的情况 3, 4</span>                <span class="token comment">// 获取当前插入位置的 entry 的 previous_entry_length</span>        <span class="token comment">// 获取到的 prevlen 就等于插入 entry 的 previous_entry_length</span>        <span class="token function">zip_decode_prevlen</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> prevlensize<span class="token punctuation">,</span> prevlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 插入的位置是压缩列表的尾部, 插入的情况 1，2</span>        <span class="token comment">// 获取到 zltail 指向的位置, zltail 一般指向的是最后一个 entry 的起始位置</span>        <span class="token comment">// 当没有 entry 在当前压缩列表, zltai 指向的位置就是 zllen, 值为 0xff</span>        <span class="token keyword">char</span> <span class="token operator">*</span>ptail <span class="token operator">=</span> <span class="token function">getZlTailPos</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptail<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> ZIP_END<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// ptail 也就是 zltail 对应的位置的第一个字节不是 0xff, 表示插入的压缩列表有数据了, 情况 2</span>            <span class="token comment">// 获取 ptail 位置 entry 的字节长度, 也就是插入 entry 的 previous_entry_length</span>            prevlen <span class="token operator">=</span> <span class="token function">getPreEntryLength</span><span class="token punctuation">(</span>zl<span class="token punctuation">,</span> ptail<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 给予一个初始值, 避免警告, 同时给一个容易排查的值, 便于后面没有初始时排查</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> value <span class="token operator">=</span> <span class="token number">123456789</span><span class="token punctuation">;</span>        <span class="token comment">// 插入的 entry 的编码</span>    <span class="token keyword">char</span> encoding <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 插入的 entry 的 content 需要的字节长度</span>    <span class="token keyword">int</span> reqlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// zipTryEncoding 的作用</span>    <span class="token comment">// 尝试将传入的 s 转为整数, 如果可以转换将转换后的值放到 value, 同时将其编码放到 encoding, 同时返回 true</span>    <span class="token comment">// 不能转换, 返回 false</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">zipTryEncoding</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> slen<span class="token punctuation">,</span> <span class="token operator">&amp;</span>value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>encoding<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 可以转换</span>        <span class="token comment">// 通过 encoding 获取当前的 int 需要的字节数, 也就是 content 的字节长度</span>        reqlen <span class="token operator">=</span> <span class="token function">zipIntSize</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 不可以转换   </span>        <span class="token comment">// 那么字符串的长度是多少, 需要的字节数就是多少</span>        reqlen <span class="token operator">=</span> slen<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 加上上一个 entry 的长度</span>    <span class="token comment">// reqLen 的长度 = previous_entry_length + content</span>    reqlen <span class="token operator">+=</span> prevlen<span class="token punctuation">;</span>    <span class="token comment">// 加上当前的 encoding 需要的字节数</span>    <span class="token comment">// previous_entry_length + encoding + content, 这时候 reqLen 就是当前存储内容需要的字节数</span>    reqlen <span class="token operator">+=</span> <span class="token function">getEncodingLength</span><span class="token punctuation">(</span>encoding<span class="token punctuation">,</span> slen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 当前的位置已经有 entry 的情况</span>    <span class="token comment">// 插入的位置的当前的 entry, 将会变为插入 entry 的后一个 entry </span>    <span class="token comment">// 那么当前的 entry 的 previous_entry_length 的字节数存储插入 entry 的字节长度 reqlen, 还需要多少个字节</span>        <span class="token comment">// 三种情况 4, -4, 0</span>    <span class="token keyword">int</span> nextdiff <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> ZIP_END<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">zipPrevLenByteDiff</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>reqlen<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 获取当前的压缩列表的字节长度</span>    <span class="token keyword">int</span> curlen <span class="token operator">=</span> <span class="token function">getZlbytes</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 最新的压缩列表需要的在字节长度</span>    newlen <span class="token operator">=</span> curlen <span class="token operator">+</span> reqlen <span class="token operator">+</span> nextdiff<span class="token punctuation">;</span>    <span class="token comment">// 按照新内存重新分配一个新的压缩列表, 会将旧的压缩列表的内容全部拷贝到新的压缩列表</span>    zl <span class="token operator">=</span> <span class="token function">ziplistResize</span><span class="token punctuation">(</span>zl<span class="token punctuation">,</span>newlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 更新 zlBytes 属性</span>    <span class="token function">updateZlBytes</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 更新 zlend 属性</span>    <span class="token function">updateZlend</span><span class="token punctuation">(</span>zl<span class="token punctuation">,</span> newlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 插入的位置不是尾部, 需要迁移数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> ZIP_END<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 空出一个 reqlen + nextdiff 的空间, 存放插入的 entry</span>        <span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token operator">+</span>reqlen<span class="token punctuation">,</span> p <span class="token operator">-</span> nextdiff<span class="token punctuation">,</span> curlen <span class="token operator">-</span> offset <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">+</span> nextdiff<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新当前需要插入的位置的下一个 entry 的 previous_entry_length</span>        <span class="token function">updateNextEntryPreviousEntryLength</span><span class="token punctuation">(</span>p <span class="token operator">+</span> reqlen<span class="token punctuation">,</span> reqlen<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新 zlTail 属性</span>        <span class="token function">updateZlTail</span><span class="token punctuation">(</span><span class="token function">getZlTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> reqlen <span class="token operator">+</span> nextdiff<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 当后一个 entry 的 previous_entry_length 的字节有变动, 进行连续更新的检查</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextdiff <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 连续更新检查, 如果需要进行连续更新处理</span>        <span class="token comment">// 连续更新后面聊</span>        zl <span class="token operator">=</span> <span class="token function">ziplistCascadeUpdate</span><span class="token punctuation">(</span>zl<span class="token punctuation">,</span>p<span class="token operator">+</span>reqlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 更新当前 entry 的 previous_entry_length</span>    <span class="token function">updateCurEntryPreviousEntryLength</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> prevlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 更新当前 entry 的 encoding</span>    <span class="token function">updateCurEntryEncoding</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> slen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 更新当前 entry 的 content</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">zip2Str</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 字符串内容</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> s<span class="token punctuation">,</span> slen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 整数内容</span>        <span class="token function">zipSaveInteger</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> value<span class="token punctuation">,</span> encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 更新 zlLen 属性</span>    <span class="token function">updateZlLen</span><span class="token punctuation">(</span><span class="token function">getZlLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> zl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>从中可以看到整个新增的过程</p><blockquote><ol><li>如果插入的位置, 后面有 entry, 获取插入位置的 entry 的 previous_entry_length, 这个就是等一下插入 entry 的 previous_entry_length 值</li><li>如果插入的位置, 后面没有 entry, 需要获取到前一个 entry 的字节长度, 这个长度就是等一下插入 entry 的 previous_entry_length 值</li><li>获取当前插入的 entry 的编码 encoding</li><li>计算插入的 entry 需要的字节长度</li><li>计算插入的 entry 需要的字节长度 存入到插入位置的 entry 的 previous_entry_length, 还需要多少个字节 (0, 4, -4)</li><li>重新分配新的压缩列表, 更新 zlbytes, zlend</li><li>将新分配的压缩列表的要插入位置后面的内容, 往后移动, 空出需要插入的 entry 的空间</li><li>更新当前需要插入的位置的下一个 entry 的 previous_entry_length 为插入 entry 的字节长度</li><li>更新新的压缩列表的 zltail</li><li>当前需要插入的位置的下一个 entry 的 previous_entry_length 变动了, 进行连续更新的检查</li><li>逐步将需要插入的 entry 的 previous_entry_length, encoding, content 更新到新的压缩列表</li><li>更新新的压缩列表的 zllen</li></ol></blockquote><p>整个过程很复杂</p><blockquote><ol><li>涉及到插入 entry 的解码, 编码</li><li>新压缩列表的内存分配和旧数据的迁移</li><li>新的 entry 的编码</li><li>还有一个连续更新的问题</li></ol></blockquote><p><strong>连锁更新</strong></p><p>假设现在有一个列表 A(p_e_l&#x3D;5) B(p_e_l&#x3D;5) C(p_e_l&#x3D;5), 这时候如果插入一个只需要 1 个字节的 entry,  I(p_e_l&#x3D;5)。<br>A(p_e_l&#x3D;1) A 需要的字节数变小了, 假设刚好变为只需要 1 个字节，那么后面的 B 的 previous_entry_length 也需要变小,<br>导致 B 也变为只需要 1 个字节了, 导致 C 也需要变小, 从而引起了后面的连续更新</p><p>连锁更新会导致多次重新分配内存及数据复制，效率很低, 出现的情况在新增, 删除, 更新都有可能。<br>但是出现这种情况的概率是很低的, 所以 Redis 并没有为了避免连锁更新而采取措施。</p><p>上面的就是新增 entry 的过程, 基本可以从这个过程推导出更新删除的过程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis String 的三种编码</title>
      <link href="/article/2021/2448473522/"/>
      <url>/article/2021/2448473522/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>在 <strong>Redis 5.x 版本</strong> 中, String (OBJ_STRING) 数据类型的编码 (encoding) 中有 3 种: </p><blockquote><ol><li>int (OBJ_ENCODING_INT): 存储 8 个字节的长整型 (long, 2^64 - 1)</li><li>embstr (OBJ_ENCODING_EMBSTR): 存储小于 44 个字节的字符串</li><li>raw (OBJ_ENCODING_RAW): 存储大于 44 个字节的字符串 (3.2 版本之前是 39 字节)</li></ol></blockquote><p>向 Redis 存入一个 String 类型的值时, Redis 可以根据存储的内容和长度, 自动的在上面 3 种编码中选择其中一个, 用来组织存储的数据。<br>整数优先考虑用 int 处理, int 无法处理的情况, 再从 embstr 和 raw 中选择一个。</p><p>embstr 和 raw 虽说是 2 者不同的编码, 但是 2 者在内部的实现都是一个字符串。<br>基于 char[] 封装的一组结构体 (类比 Java 的 Class), 官方统一叫做 sds (类比 Java 的 String)。</p><p>注: 下面的分析也是按照 <strong>Redis 5.x</strong> 进行分析。</p><h2 id="2-Sds"><a href="#2-Sds" class="headerlink" title="2 Sds"></a>2 Sds</h2><p>在了解 Redis String 的 3 种编码之前, 需要先了解一下 Redis 中的 sds。</p><h3 id="2-1-char-实现字符串的问题"><a href="#2-1-char-实现字符串的问题" class="headerlink" title="2.1 char[] 实现字符串的问题"></a>2.1 char[] 实现字符串的问题</h3><p>在 Java 中, 如果不借助 String, 实现存储一段字符如何实现比较好呢？</p><p>进到 String 的源码, 可以发现 String 本身是对 char[] 的封装, 所以可以直接使用 char[] 来存储一段字符, 达到存储字符串的效果</p><p><img src="https://pic.imgdb.cn/item/6556f4f4c458853aef431b9e.png" alt="Alt &#39;Java char 实现字符串&#39;"></p><p>我们知道 Redis 是用 C 语言编写的, C 语言本身像 Java 一样提供类似 String 的封装类。<br>所以要实现字符串的效果需要借助 char[] 数组的, 而直接使用 char[] 时, 在使用时有一些问题:  </p><blockquote><ol><li>字符串长度变化, char[] 数组就需要重新分配内存</li><li>获取字符串长度时, 需要遍历数组, 或者通过内存进行计算等, C 语言的数组没有提供 len 属性或者 len() 方法直接获取长度</li><li>C 语言中的数组不记录自身长度和空闲空间, 在使用上容易造成数组越界等问题</li><li>C 语言中的 char[] 数组是二进制不安全的. 通过 char[] 实现字符串时, 内部会通过 “\0” 代表字符串的结束, 也就是数组的结束的位置追加一个 “\0” 以表示字符串的结束。</li></ol></blockquote><p>比如存储 “one” 3 个字符, 却需要 4 个字符进行存储, 实际的存储情况为 “one\0”。 这个特点在存储其他的格式的内存, 如二进制表示的音频图片等, 可能会出现问题, 比如本身的内容上就包含一个 \0, 但是 C 语言读到这个位置, 认为结束了, 后面的内容被舍弃了, 这就是二进制不安全。</p><p><img src="https://pic.imgdb.cn/item/6556f4e8c458853aef42f4ad.png" alt="Alt &#39;C 语言 char 实现数组特点&#39;"></p><h3 id="2-2-低版本-Redis-中的-sds"><a href="#2-2-低版本-Redis-中的-sds" class="headerlink" title="2.2 低版本 Redis 中的 sds"></a>2.2 低版本 Redis 中的 sds</h3><p>因为 C 语言中 char[] 实现字符串的存在着问题。<br>所以, Redis 内部自定义了一个 sds (Simple Dynamic String) 的结构体, 来代替 char[], 实现字符串。<br>达到的效果很像 Java 中的 ArrayList, 采用<strong>预分配冗余空间</strong>和<strong>惰性空间释放</strong>的方式来减少内存的频繁分配, 同时在达到内存的上限时, 自动扩容等。</p><p>sds 的定义如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sds</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** buf 中已经使用的字节 */</span>    <span class="token keyword">int</span> len<span class="token punctuation">;</span>     <span class="token comment">/** buf 中剩余多少字节 */</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span>    <span class="token comment">/** 存储数据的数组 */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>这个就是 3.2 版本之前 Redis 对字符串的实现。本质还是一个 char[] 数组, 但是多了 2 个字段 <strong>len</strong> 和 <strong>free</strong>。</p><blockquote><ol><li>有长度统计变量 len 的存在, 读写字符串时不依赖 <strong>\0</strong> 终止符, 保证了二进制安全和长度的获取的便利 (读取内容直接从数组的开始位置读取对应长度的内存数据)</li><li>借助 len 和 free 可以做到空间预分配和惰性空间释放, 同时更安全的使用数组</li><li>buf[] 是一个柔性数组, 在内存中查找性能影响不大 (柔性数组的地址和结构体是连续的, 这样查找内存更快, 因为不需要额外通过指针找到字符串的位置)</li></ol></blockquote><p>上面的实现是否是最好的实现呢? Redis 是一款基于内存的数据库, 那么内存是极其重要的, 结合平时使用字符串的长度和内存的使用上考虑有什么问题吗?</p><h3 id="2-3-Redis-3-2-之后-的-sds"><a href="#2-3-Redis-3-2-之后-的-sds" class="headerlink" title="2.3 Redis 3.2 之后 的 sds"></a>2.3 Redis 3.2 之后 的 sds</h3><p>在 3.2 版本之前 sds 的 len &#x2F; free, 用的是 int 修饰的, 最大值为 2147483647, 正常情况下字符串的长度会超过这个吗？<br>应该不会, 那么是否可以用 2 个字节的 uint16_t (Java 层面的 short, 最大值为 32768) 进行存储呢?    </p><p>一直往下推导下去<br>1 个字节的 uint8_t (Java 层面的 byte, 最大值为 127) 是否也可以呢?<br>一个字节 8 位, 乃至用位级别的大小呢?</p><p>所以在 Redis 3.2 后, 对 sds 更进一步的细化, 分成了 5 种实现, 基于 5bit,  8bit (1 个字节), 16bit (2 个字节), 32bit (4 个字节), 64bit (8 个字节) 的实现,<br>同时在结构体内追加了一个 1 个字节的 flags 表示这个结构体的类型。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr5</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// flags 1个字节, 8 位,  低位的 3 位表示 sds 的类型, 剩下的 5 位表示下面 char[] 的内容长度</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span>     <span class="token comment">// 具体的内容</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// char[] 已使用的长度</span>    <span class="token class-name">uint8_t</span> len<span class="token punctuation">;</span>    <span class="token comment">// 总长度, 不包含最后追加的 \0 结束符</span>    <span class="token class-name">uint8_t</span> alloc<span class="token punctuation">;</span>    <span class="token comment">// 低位的 3 位表示 sds 类型, 剩余 5 位没有使用, 表示当前字符数组的属性, 用来标识到底是 sdshdr8 还是 sdshdr16 等</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span>        <span class="token comment">// 具体的内容</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr16</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint16_t</span> len<span class="token punctuation">;</span>     <span class="token class-name">uint16_t</span> alloc<span class="token punctuation">;</span>     <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr32</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> len<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> alloc<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr64</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint64_t</span> len<span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> alloc<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>len&#x2F; alloc &#x2F; buf, 三个属性都和一开始简单版的 sds 用法类似的。 只是在结构体内追加多了一个 flags 的属性。<br>这个 flag 是一个 8 位, 1 个字节的 char, 而在实际中, 现在只使用到了低位的 3 位, 剩余 5 位暂时没有使用到。</p><p>flag 的取值如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// flag 的值 0 ~ 4</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SDS_TYPE_5</span>  <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SDS_TYPE_8</span>  <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SDS_TYPE_16</span> <span class="token expression"><span class="token number">2</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SDS_TYPE_32</span> <span class="token expression"><span class="token number">3</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SDS_TYPE_64</span> <span class="token expression"><span class="token number">4</span></span></span></code></pre><p>备注: sds5 基本不用用到, 实际上在使用上时, 即使字符串的长度很小, 满足 sds5 的情况下, 也会被转换为 sds8 进行存储。这个情况满足大部分的情况,<br>但是在某些情况下, Redis 内部 key 还是可以用 sds5 进行存储的。<br>想要了解的可以看一下这篇<a href="https://segmentfault.com/a/1190000017450295">文章</a></p><p>思考一下, 这个 flags (代表当前 sds 是具体什么类型的) , 是否有存在的意义呢? </p><p>实际是有用的。<br>在面向对象的编程语言中, 默认 sds 这个对象代表字符串 (如 Java 中, 声明了一个 String, 都会任务 String, 代表了我们存储的字符串, 而不是 String 中的 value)。  </p><p>而在 Redis 中, 初始的是 sds 这个结构体中所有属性的值, 而实际在使用时, 还是 char[], 这样可以兼容很多系统的函数等。<br>需要时, 通过 <strong>buf[-1]</strong> (在 C 语言中, 数组变量就是内存地址, 所有索引值可以为 - 1, 逆推到前面的地址, 而上面的几个结构体的定义中 char[] 前面就是 flags) 就能获取到 flags 这个属性, 得到了 flags, 很容易逆推出len 和 alloc 的属性。</p><p>上文说过了, C 语言中是没有自己的字符串类型的, sds 是 Redis 自己封装的, 所以很多系统的函数, 比如 strlen, strcpy 等, 入参都是 char[], 而不是 sds。<br>所以 Redis 创建字符串时, 是用 sds 进行创建的。 但是在使用时, 依旧是用 char[], 这样就可以兼容很多系统的函数等。<br>读取内容时, 再根据 C 语言的内存操作, 获取到结构体内其他值, 再进行其他操作。</p><p>为了实现这个效果, 上面的结构体都通过了 <strong><strong>attribute</strong>((<strong>packed</strong>))</strong> 就行修饰了, 强制结构体中所有的变量按照 1 个字节进行对齐 (结构体会按其所有变量大小的最小公倍数做字节对齐),<br>避免了系统的<strong>内存对齐</strong>, 影响到了 <strong>buf[-1]</strong> 获取不到真正的 flags 值, 同时间接的达到了节省内存的效果。</p><p>所以, 在 Redis 中通过 sds 来实现字符串的效果。    </p><blockquote><ol><li>sds 不用担心内存溢出问题, 如果需要会对 sds 进行自动扩容。</li><li>通过 <strong>空间预分配</strong> 和 <strong>惰性空间释放</strong>, 防止多次重分配内存。  </li><li>sds 中存储了 len 变量, 存储当前字符串的长度, 那么可以直接通过 len 获取到字符串的长度, 变为了 O(1)</li><li>字符串的结束可以完全通过 len 进行判断, 而忽略 C 语言中的遇 <strong>\0</strong> 结束的特点。</li></ol></blockquote><p>综上: sds 具备了<strong>可动态扩展内存</strong>, <strong>二进制安全</strong>, <strong>快速遍历字符串</strong>和<strong>与传统的 C 语言字符串类型兼容</strong>的特点。</p><p>注: sds 的扩容规则</p><blockquote><ol><li>sds 长度修改后 小于 1M, 则 alloc &#x3D; len * 2, 以原本的大小的两倍进行扩容</li><li>sds 长度修改后 大于 1M, 则 alloc +&#x3D; 1M, 以 1M 的大小进行扩容</li></ol></blockquote><h2 id="3-embstr-和-raw-编码"><a href="#3-embstr-和-raw-编码" class="headerlink" title="3 embstr 和 raw 编码"></a>3 embstr 和 raw 编码</h2><p>上面普遍了那么久的字符串, 实际都是在介绍 embstr 和 raw。 因为 2 者本身都是一个 sds, 唯一的区别就是在<strong>内存分配</strong>不同！</p><p>当我们向 Redis 存入一个 String 的数据, Redis 需要为我们存储一个 key 和 value。<br>key 没必要说, 这时就是一个 sds,  而 value 是一个 String, 那么也同样是一个 sds。</p><p>但是因为 Redis 中 value 涉及到涉及到引用次数, 回收策略等配置, 所以官方对所有的编码外面多包装了一层 redisObject。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/** 4 位, 数据类型: OBJ_STRING, OBJ_LIST, OBJ_HASH, OBJ_SET, OBJ_ZSET 等*/</span>    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment">/** 4 位, 底层存储的数据结构编码: raw, int embstr 等 */</span>    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment">/** 24 位, 对象最后一次被命令程序访问的时间或者访问的次数, 与内存回收有关 */</span>    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span>LRU_BITS<span class="token punctuation">;</span>    <span class="token comment">/** 4 个字节 被引用的次数, 当 refcount 为 0 的时候, 表示该对象已经不被任何对象引用, 则可以进行垃圾回收了 */</span>    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>    <span class="token comment">/** 指针对象的大小和操作系统的位数有关, 64 位系统, 8 个节点 */</span>    <span class="token comment">/** 指向对象实际的数据结构, 也就是真正的值, 比如 sds8, sds16 等 */</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> robj<span class="token punctuation">;</span></code></pre><p>这样, Redis 在创建一个 String 类型的 value, 需要分配内存有 2 个,  redisObject 本身 + 存储内容的 sds。<br>分配 redisObject 自身需要  (4 + 4 + 24)bit + 4 字节 + 8 字节 &#x3D; 16 个字节<br>分配一个最少内存的 sds, 也就是 sds8 需要  1 (uint8_t len) + 1 (uint8_t alloc) + 1 (unsigned char) + 1 (别忘了, char[] 系统会在后面自动填充一个 \0) &#x3D; 4 个字节 (sds5 会被转换为 sds8 进行分配)<br>这样创建一个不包含任何内容的 String 类型的 value, 需要 16 字节的 redisObject + 4 字节的 sds8 &#x3D; 20 字节的内存。</p><p>在 C 语言中常用的内存分配器为 jemalloc、tcmalloc<br>这 2 个 的共同特点就是在进行内容分配时, 都是按照 2 的 n 次方进行分配的, 既 2, 4, 8 的方式进行分配。  </p><p>所以在为一个不包含任何内容的 String 类型的 value (20 个字节) 进行内存分配时, 需要分配 32 个字节, 多分配了 12 个字节。  </p><p>上面讨论的是 sds8 的 <strong>char[] buf</strong> 为空的情况, 实际中, sds8 是一定会有内容的, 如果这时, 这些内容的大小在 12 个字节以内,<br>那么我们创建一个 String 类型的 value, 只用到了一次内存分配就完成了。</p><p>在 Redis 中, 认为一次分配的内存大于 64 字节, 是一个得不偿失的行为, 大内存的申请消耗的时间更长等。<br>超过 64 字节的内存分配, 会多次进行。  </p><p>到这里, 可以得到 embstr 和 raw 的区别了。  </p><blockquote><ol><li>embstr: redisObject + sds, 内存是一起分配的, 只需要一次内存分配, 同时内存是相连在一起。</li><li>raw : redisObject + sds 是分开分配的, 需要 2 次内存分配以上, 内存也不一定相连在一起。</li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/6556f4f8c458853aef43274b.png" alt="Alt &#39;embstr 和 raw 的内存分配&#39;"></p><p>同时这里也可以看到, embstr 和 raw 的分界线为什么是 44 字节?<br>分配一个不含任何内容的 redisObject + sds 需要 20 字节, 最大一次分配 64 字节, 64 - 20  &#x3D; 44 字节, 所以在 Redis 中创建一个 String 对象</p><blockquote><p>String 的内容长度小于等于 44 字节, 编码为 embstr<br>String 的内容长度大于 44 字节, 编码为 raw</p></blockquote><h2 id="4-int-编码"><a href="#4-int-编码" class="headerlink" title="4 int 编码"></a>4 int 编码</h2><p>String 的另一个编码 int, 很简单,<br>因为存储的是整数, 完全可以不用 char[] 存储, 直接用一个整数进行存储即可了, 所以在 Redis 中 int 编码就是一个整数数据类型, 没了。  </p><p>唯一要说的话, Redis 有一个整数的缓存池, 和 Java 中 Long 的数据缓存一样。会预先初始一定的数据, 同时缓存起来。</p><p>在 Redis 没有设置最大内存值或者内存过期方式不是为 MAXMEMORY_FLAG_NO_SHARED_INTEGERS (lru&#x2F;lfu 策略) 的前提下,<br>value 为 0 - 9999, 直接使用缓存的数据, 而不是创建对象。</p><p>大体的流程如下：</p><pre class="language-c" data-language="c"><code class="language-c">robj <span class="token operator">*</span><span class="token function">createStringObjectFromLongLongWithOptions</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> valueobj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    robj <span class="token operator">*</span>o<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_NO_SHARED_INTEGERS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        valueobj <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> value <span class="token operator">&lt;</span> OBJ_SHARED_INTEGERS <span class="token operator">&amp;&amp;</span> valueobj <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">incrRefCount</span><span class="token punctuation">(</span>shared<span class="token punctuation">.</span>integers<span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 直接使用缓存的数据, 而不是创建对象</span>        o <span class="token operator">=</span> shared<span class="token punctuation">.</span>integers<span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 创建对象</span>        <span class="token comment">// LONG_MIN &lt;  value &lt; LONG_MAX, 创建 int 编码的对象</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">>=</span> LONG_MIN <span class="token operator">&amp;&amp;</span> value <span class="token operator">&lt;=</span> LONG_MAX<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 创建对象</span>            o <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span>OBJ_STRING<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            o<span class="token operator">-></span>encoding <span class="token operator">=</span> OBJ_ENCODING_INT<span class="token punctuation">;</span>            o<span class="token operator">-></span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 超出范围, 用字符串处理</span>            o <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span>OBJ_STRING<span class="token punctuation">,</span><span class="token function">sdsfromlonglong</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> o<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="5-问题"><a href="#5-问题" class="headerlink" title="5 问题"></a>5 问题</h2><h3 id="5-1-int-和-embstr-什么时候转化为-raw"><a href="#5-1-int-和-embstr-什么时候转化为-raw" class="headerlink" title="5.1 int 和 embstr 什么时候转化为 raw"></a>5.1 int 和 embstr 什么时候转化为 raw</h3><p>当 int 数据不再是整数或大小超过了 long 的范围 (2^63-1 &#x3D; 9223372036854775807) 时, 自动转化为 embstr。<br>在 Redis 中, embstr 是被设置为只读的, 当对 embstr 字符串进行修改 (例如: append), 无论 embstr 是否超过了 44 个字节, 都会变为 raw</p><h3 id="5-2-embstr-和-raw-的区别"><a href="#5-2-embstr-和-raw-的区别" class="headerlink" title="5.2 embstr 和 raw 的区别"></a>5.2 embstr 和 raw 的区别</h3><p>embstr 的使用只分配一次内存空间 (因为 redisObject 和 sds 是连续的), 而 raw 需要分配多次内存空间 (分别为 redisObject 和 sds 的空间不是连续的)。<br>因此, 与 raw 相比, embstr 的好处在于创建时只分配一次空间, 删除时只释放一次空间, 以及对象的所有数据连在一起, 寻找方便。<br>而 embstr 的坏处也很明显, 如果字符串的长度增加需要重新分配内存时, 整个 redisObject 和 sds 都需要重新分配空间, 因此 Redis 中的 embstr 实现为只读。</p><h3 id="5-3-当长度小于阈值时-会还原吗"><a href="#5-3-当长度小于阈值时-会还原吗" class="headerlink" title="5.3 当长度小于阈值时, 会还原吗"></a>5.3 当长度小于阈值时, 会还原吗</h3><p>Redis 内部编码的转换, 都符合以下规律: 编码转换在 Redis 写入数据时完成, 且转换过程不可逆, 只能从小内存编码向大内存编码转换。但是可以通过重新 set, 可以重新分配。</p><h3 id="5-4-为什么要对底层的数据结构进行一层包装呢"><a href="#5-4-为什么要对底层的数据结构进行一层包装呢" class="headerlink" title="5.4 为什么要对底层的数据结构进行一层包装呢"></a>5.4 为什么要对底层的数据结构进行一层包装呢</h3><p>通过封装, 可以根据对象的类型动态地选择存储结构和可以使用的命令, 实现节省空间和优化查询速度</p><h2 id="6-String-的使用场景"><a href="#6-String-的使用场景" class="headerlink" title="6 String 的使用场景"></a>6 String 的使用场景</h2><blockquote><ol><li>热点数据缓存 (报表, 促销库存等), 可以提升热点数据的访问速度</li><li>Redis 是分布式的独立服务, 可以在多个应用之间共享, 可以用于<strong>分布式 Session</strong></li><li>同样因为 Redis 的分布式的独立服务, 可以通过 <strong>setnx</strong>, 实现<strong>分布式锁</strong></li><li>利用其原子性, 通过 <strong>incr</strong> 实现全局 Id 和计数器(文章阅读量, 点赞等)</li><li>限流, 同样可以通过 <strong>incr</strong>, 以访问者的 IP 和其他信息作为 key, 访问一次增加一次计数, 超过次数则返回 false</li><li>Redis 支持位运算, 因为 bit 非常节省空间 (1 MB &#x3D; 8388608 bit), 可以用来做大数据量的统计, 如: 在线用户统计, 用户签到情况等</li><li>利用其自动过期的功能, 做有限时操作, 比如验证码</li></ol></blockquote><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h2><p><a href="https://www.cnblogs.com/sunchong/p/11924295.html">Redis开发与运维：SDS与44字节深入理解 </a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 编码概念介绍</title>
      <link href="/article/2021/2448473521/"/>
      <url>/article/2021/2448473521/</url>
      
        <content type="html"><![CDATA[<p>本文主要是对介绍 Redis 数据类型会涉及到的几个概念做一个简单说明, 方便后面的学习。</p><p>对了后面的 Redis 的总结, 都是基于 <strong>Redis 5.x</strong> 版本的进行分析的。</p><h2 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1. 相关概念"></a>1. 相关概念</h2><h3 id="1-1-二个小问题的思考"><a href="#1-1-二个小问题的思考" class="headerlink" title="1.1 二个小问题的思考"></a>1.1 二个小问题的思考</h3><p>如果现在如果我提出 2 个问题</p><blockquote><ol><li>Redis 的数据类型有哪些?</li><li>Redis 的数据结构有哪些?</li></ol></blockquote><p>你会怎么回答呢? </p><h3 id="1-2-概念的简单说明"><a href="#1-2-概念的简单说明" class="headerlink" title="1.2 概念的简单说明"></a>1.2 概念的简单说明</h3><p>这个是我在网上看到的一个段子:</p><p><img src="https://pic.imgdb.cn/item/6556212ac458853aef5e7178.png" alt="Alt &#39;Reids 数据结构段子&#39;"></p><p>在这个段子中  </p><p>面试官想要的是 Redis 在使用时, 数据直接显示的格式, 也就是官方提供的给用户直接使用的数据结构。<br>官方的叫法是 data structures, 网上的一般叫做外部数据结构。</p><p>而面试者回答的 raw, int 等, 本身是从 Redis 源码出发, 数据在实现时的组织存储实现。<br>官方的叫法是 encoding (编码), 网上的一般叫法是内部数据结构，这一个更接近于我们认知中的数据结构。</p><p>内外数据结构和数据类型三者的关系如下:</p><p><img src="https://pic.imgdb.cn/item/65562128c458853aef5e6aec.png" alt="Alt &#39;Reids 编码相关概念图&#39;"></p><p>数据结构(Data Structures):<br>纯粹的从一个使用者出发, 看到的数据的形式, 忽略掉内部的所有源码实现。</p><p>数据类型(Data Type):<br>从源码出发, 一个数据组织存储的具体的类型。Redis 提供了一个 <strong>type redisKey</strong> 的命令, 可以用来查看 key 对应的数据的数据类型。</p><p>编码类型 (Encoding Type):<br>数据类型的具体实现方式。Redis 也提供了一个 <strong>object encoding redisKey</strong> 的命令, 用来查看对应的 key 的编码类型。</p><p>数据类型可以理解为 Java 中各种集合的接口, 如 List, Set 等。<br>编码类型可以理解为 Java 中各种集合的接口的具体实现, 如 List 的实现有 ArrayList, LinkedList 等。</p><p>比如 Redis 的一个 set 命令, <strong>set key value</strong>, 存储 value 时, 已经确定了他的数据类型为 <strong>String</strong>, 然后会根据 value 是否可以转为整数, value 的长度, 从 String 的三个编码<br><strong>int</strong>, <strong>embstr</strong> 和 <strong>raw</strong> 中选择一个进行数据的组织和存储。</p><h2 id="2-Redis-当前已有的数据类型和编码"><a href="#2-Redis-当前已有的数据类型和编码" class="headerlink" title="2 Redis 当前已有的数据类型和编码"></a>2 Redis 当前已有的数据类型和编码</h2><h3 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h3><p>在 5.x 版本的源码中, Redis 一共声明了 7 种数据类型</p><pre class="language-C" data-language="C"><code class="language-C">&#x2F;** 可以在 server.h 中看到对应的定义 **&#x2F;#define OBJ_STRING 0    &#x2F;* String object. *&#x2F;#define OBJ_LIST 1      &#x2F;* List object. *&#x2F;#define OBJ_SET 2       &#x2F;* Set object. *&#x2F;#define OBJ_ZSET 3      &#x2F;* Sorted set object. *&#x2F;#define OBJ_HASH 4      &#x2F;* Hash object. *&#x2F;#define OBJ_MODULE 5    &#x2F;* Module object. *&#x2F;#define OBJ_STREAM 6    &#x2F;* Stream object. *&#x2F;</code></pre><h3 id="2-2-编码类型"><a href="#2-2-编码类型" class="headerlink" title="2.2 编码类型"></a>2.2 编码类型</h3><p>在 5.x 版本的源码中, Redis 一共声明了 11 种数据类型</p><pre class="language-C" data-language="C"><code class="language-C">&#x2F;** 可以在 server.h 中看到对应的定义 **&#x2F;#define OBJ_ENCODING_RAW 0     &#x2F;* Raw representation *&#x2F;#define OBJ_ENCODING_INT 1     &#x2F;* Encoded as integer *&#x2F;#define OBJ_ENCODING_HT 2      &#x2F;* Encoded as hash table *&#x2F;#define OBJ_ENCODING_ZIPMAP 3  &#x2F;* Encoded as zipmap *&#x2F;#define OBJ_ENCODING_LINKEDLIST 4 &#x2F;* No longer used: old list encoding. *&#x2F;#define OBJ_ENCODING_ZIPLIST 5 &#x2F;* Encoded as ziplist *&#x2F;#define OBJ_ENCODING_INTSET 6  &#x2F;* Encoded as intset *&#x2F;#define OBJ_ENCODING_SKIPLIST 7  &#x2F;* Encoded as skiplist *&#x2F;#define OBJ_ENCODING_EMBSTR 8  &#x2F;* Embedded sds string encoding *&#x2F;#define OBJ_ENCODING_QUICKLIST 9 &#x2F;* Encoded as linked list of ziplists *&#x2F;#define OBJ_ENCODING_STREAM 10 &#x2F;* Encoded as a radix tree of listpacks *&#x2F;</code></pre><h3 id="2-3-数据类型和编码的对应关系"><a href="#2-3-数据类型和编码的对应关系" class="headerlink" title="2.3 数据类型和编码的对应关系"></a>2.3 数据类型和编码的对应关系</h3><p>OBJ_STRING 对应的编码类型为</p><blockquote><p>OBJ_ENCODING_INT: 当字符串类型的值可以被解析为整数时, 同时不超过 long 的最大值时<br>OBJ_ENCODING_EMBSTR: 当字符串类型的值长度小于等于 44 时<br>OBJ_ENCODING_RAW: OBJ_ENCODING_INT 和 OBJ_ENCODING_EMBSTR 都不满足时</p></blockquote><p>OBJ_LIST</p><blockquote><p>OBJ_ENCODING_ZIPLIST: 列表元素数量较少且每个元素的长度较短时<br>OBJ_ENCODING_QUICKLIST: 列表元素数量较多时</p></blockquote><p>OBJ_SET</p><blockquote><p>OBJ_ENCODING_INTSET: 当集合中的元素都是整数类型且元素数量较少时<br>OBJ_ENCODING_HT: 当集合中的元素数量较多时</p></blockquote><p>OBJ_ZSET</p><blockquote><p>OBJ_ENCODING_ZIPLIST: 当有序集合中的元素数量较少且每个元素的长度较短时<br>OBJ_ENCODING_SKIPLIST: 当有序集合中的元素数量较多时</p></blockquote><p>OBJ_HASH</p><blockquote><p>OBJ_ENCODING_ZIPLIST:  当哈希对象中的键值对数量较少且每个键值对的键和值的长度都较短时<br>OBJ_ENCODING_HT: 当哈希对象中的键值对数量较多时</p></blockquote><p>OBJ_MODULE</p><blockquote><p>编码并不是 Redis 内置的编码方式, 而是为了支持模块开发而引入的一种编码方式。 每个模块可以根据自己的需求和设计选择适合的数据结构和编码方式来存储自定义数据类型</p></blockquote><p>OBJ_STREAM</p><blockquote><p>OBJ_ENCODING_STREAM: 唯一的选择</p></blockquote><p>上面的数据类型和编码类型的对应关系, 只需要简单了解一下即可。<br>里面很多大概的描述, 比如较少, 较多等, 后面再详细说明, 因为里面很多会涉及到一些配置相关的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM 常用参数</title>
      <link href="/article/2021/3218752733/"/>
      <url>/article/2021/3218752733/</url>
      
        <content type="html"><![CDATA[<h2 id="1-空间大小设置"><a href="#1-空间大小设置" class="headerlink" title="1 空间大小设置"></a>1 空间大小设置</h2><p>-Xss: 设置每个线程的堆栈大小, -Xss514K<br>-Xmx: 设置 JVM 最大可用内存为, -Xmx8192m<br>-Xms: 设置 JVM 初始内存为多少, 此值可以设置与 -Xmx 相同，以避免每次垃圾回收完成后 JVM 重新分配内存, -Xmx8192m<br>-Xmn: 设置年轻代大小为多少, 此值对系统性能影响较大，Sun 官方推荐配置为整个堆的 3&#x2F;8, -Xmn3g</p><p>-XX:NewRatio: 设置年轻代和年老代的比值 (除去持久代), 设置为 4，则年轻代与年老代所占比值为 1：4，年轻代占整个堆栈的 1&#x2F;5, -XX:NewRatio&#x3D;4<br>-XX:SurvivorRatio: 设置年轻代中 Eden 区与 Survivor 区的大小比值。设置为 4，则两个 Survivor 区与一个 Eden 区的比值为 1:1:4，一个 Survivor 区占整个年轻代的 1&#x2F;6, -XX:SurvivorRatio&#x3D;4<br>-XX:MaxPermSize: 设置持久代大小, JDK8 后废弃了, 通过元空间进行配置, -XX:MaxPermSize&#x3D;16m<br>-XX:MetaspaceSize: 设置元空间初始分配的大小,  -XX:MetaspaceSize&#x3D;128m<br>-XX:MaxMetaspaceSize: 设置元空间最大空间, -XX:MaxMetaspaceSize&#x3D;320m</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java ArrayBlockingQueue</title>
      <link href="/article/2021/3511137632/"/>
      <url>/article/2021/3511137632/</url>
      
        <content type="html"><![CDATA[<p>ArrayBlockingQueue, 顾名思义: 基于数组的阻塞队列, 位于 JUC (java.util.concurrent) 下, 是一个线程安全的集合, 其本身具备了</p><blockquote><ol><li>不支持 null 元素:  存入 null 元素会抛出异常</li><li>固定容量: 在初始化时需要指定一个固定的容量大小。这意味着一旦队列达到最大容量，将不再接受新的元素，直到有消费者取出元素为止</li><li>有序性: 内部采用数组作为底层数据结构，保持了元素的有序性。这意味着当你向队列中添加元素时，它们将按照添加的顺序排列，而消费者线程将按照相同的顺序取出这些元素</li><li>阻塞特性：ArrayBlockingQueue 会在队列满时, 阻塞添加数据的线程直至队列非满状态, 同样, 在队列空时, 阻塞获取数据的线程直至队列重新非空</li><li>支持锁公平性配置: 在初始化时可以指定是否使用公平锁, 默认为非公平锁。公平锁通常会降低吞吐量, 但是减少了可变性和避免了线程饥饿问题</li></ol></blockquote><h2 id="1-实现的数据结构"><a href="#1-实现的数据结构" class="headerlink" title="1 实现的数据结构"></a>1 实现的数据结构</h2><p>通常, 队列的实现方式有数组和链表两种方式。</p><p>ArrayBlockingQueue 的选择数组作为自己底层的数据结构, 同时通过维护 1 个队头指针 + 1 个队尾指针指针, 达到数据的入队和出队操作。<br>同时他内部对数组的使用做了一些小心思, 使得入队和出队操作都可以在 O(1) 的时间内完成。</p><p>入队涉及到的是数组的添加数据, 同理, 出队涉及到的是数组的删除数据。<br>而数组的删除操作, 通常的步骤是</p><blockquote><ol><li>删除数组中的某个元素</li><li>将数组中删除元素后的所有元素往前移动一个位置</li></ol></blockquote><p>而 ArrayBlockingQueue 的是队列, 出队固定的第一个节点, 也就是数组的第一个, 所以内部通过维护的 2 个指针, 简化了数组删除的操作</p><blockquote><ol><li>删除数组中的某个元素</li><li>将头指针指向下一个元素, 如果头指针指向了数组的最后一个元素, 那么将头指针重新指向数组的第一个元素,</li><li>数组的添加也是到了数组的最后一个元素, 重新回到数组的头部, 通过这种方式避免了删除时, 对数组元素的移动</li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/65804ff6c458853aef8b8b2d.png" alt="Alt &#39;ArrayBlockingQueue 内部数组指针移动方向&#39;"></p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><p>分析完了 ArrayBlockingQueue 的逻辑实现方式, 下面我们通过源码的形式, 更进一步的了解 ArrayBlockingQueue 的实现。</p><h3 id="2-1-ArrayBlockingQueue-持有的属性"><a href="#2-1-ArrayBlockingQueue-持有的属性" class="headerlink" title="2.1 ArrayBlockingQueue 持有的属性"></a>2.1 ArrayBlockingQueue 持有的属性</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 队列的底层实现结构, 数组</span>    <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>    <span class="token comment">// 当前队列的队头指针</span>    <span class="token keyword">int</span> takeIndex<span class="token punctuation">;</span>        <span class="token comment">// 当前队列的队尾指针</span>    <span class="token keyword">int</span> putIndex<span class="token punctuation">;</span>    <span class="token comment">// 队列中的元素个数</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token comment">// 用于并发控制的可重入锁</span>    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock<span class="token punctuation">;</span>    <span class="token comment">// 并发时的两种状态</span>    <span class="token comment">// 非空等待条件 (内部实际就是一个队列, 所以可以理解为一个等待队列), 也就是数组中重新有数据了, 可以继续取数据了</span>    <span class="token comment">// 当某个线程尝试从当前的队列中获取元素时, 如果数组中没有数据, 会把这个线程放到这个等待条件中</span>    <span class="token comment">// 在另外一个线程中添加元素到数组中，数组变为非空状态, 会唤醒等待在这个等待条件中的线程</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> notEmpty<span class="token punctuation">;</span>    <span class="token comment">// 非满等待条件 (内部实际就是一个队列, 所以可以理解为一个等待队列), 也就是数组中的数据没有达到上限, 可以继续添加数据</span>    <span class="token comment">// 当某个线程尝试向当前的队列添加元素, 但是当前数组已经满了, 会把这个线程放到这个等待条件中</span>    <span class="token comment">// 在另一个线程中从当前队列中获取一个元素时, 数组变为非满状态, 会唤醒等待在这个等待条件中的线程</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> notFull<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>items 是一个数组, 用来存放入队的数据, count 表示队列中元素的个数。takeIndex 和 putIndex 分别代表队头和队尾指针。</p><h3 id="2-2-ArrayBlockingQueue-构造函数"><a href="#2-2-ArrayBlockingQueue-构造函数" class="headerlink" title="2.2 ArrayBlockingQueue 构造函数"></a>2.2 ArrayBlockingQueue 构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 指定容量构造函数</span>    <span class="token keyword">public</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用自带的指定容量和锁公平性配置的构造函数, 默认为非公平的</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 指定容量和锁公平性配置的构造函数</span>    <span class="token keyword">public</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 容量小于等于 0, 直接抛异常</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 声明数组    </span>        <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 创建可重入锁, 锁公平性由参数配置</span>        lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span>fair<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取非空等待条件</span>        notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取非满等待条件</span>        notFull <span class="token operator">=</span>  lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 指定容量, 公平性和初始元素的构造函数    </span>    <span class="token keyword">public</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">,</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// // 指定容量和锁公平性配置的构造函数</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> fair<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 上锁</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 依次遍历入参的集合, 添加到当前的队列中</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 队列中的数据不能为空</span>                    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                    items<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ArrayIndexOutOfBoundsException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 算出队列中的元素个数</span>            count <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token comment">// 下次添加元素的位置  =  当前队列中的元素个数等于容量上限了 ? 0 (重新回到队头) : 元素的个数 (当前队列的队尾)</span>            putIndex <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 释放锁</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>三个构造函数</p><blockquote><p>指定队列大小的非公平锁构造函数<br>指定队列大小和锁公平性的构造函数<br>指定队列大小, 锁公平性和初始元素的构造函数</p></blockquote><p>在第三个函数中, 将入参的集合元素依次添加到当前的队列的过程前, 先使用了 ReentrantLock 来加锁, 再把传入的集合元素按顺序一个个放入 items 中, 这个加锁的操作有必要吗?<br>一个实例的构造函数不可能存在并发调用的, 那么这个锁的作用是什么呢?  </p><p>在 Happens-Before 规则中, 有一条监视器锁规则 (Monitor Lock Rule), 简单理解就是线程 A 加锁, 做了数据变更, 线程 A 解锁, 线程 B 加上同一个锁, 这时线程 A 做的变更对线程 B 都是可见的。<br>创建 ArrayBlockingQueue 的线程是加锁初始 ArrayBlockingQueue 的属性, 后面线程调用 ArrayBlockingQueue 的其他方法时, 都会遇到这个锁, 就会获取到最新的数据。</p><p>既然为了可见性, 为什么不使用 volatile 修饰 items 数组呢?<br>这就涉及到 volatile 的特性了, volatile 修饰的变量, 只能保证可见性, 而这里的 items 数组是一个引用类型, 如果对 items 的引用做了修改 (比如重新赋值, 置为空),<br>那么其他的线程可以感知到, 但是修改数组里面的数据, volatile 不会保证他们的可见性。</p><h3 id="2-3-ArrayBlockingQueue-支持的方法"><a href="#2-3-ArrayBlockingQueue-支持的方法" class="headerlink" title="2.3 ArrayBlockingQueue 支持的方法"></a>2.3 ArrayBlockingQueue 支持的方法</h3><h4 id="2-3-1-数据入队方法"><a href="#2-3-1-数据入队方法" class="headerlink" title="2.3.1 数据入队方法"></a>2.3.1 数据入队方法</h4><p>ArrayBlockingQueue 提供了多种入队操作的实现来满足不同情况下的需求, 入队操作有如下几种:</p><blockquote><ol><li>boolean add(E e)</li><li>void put(E e)</li><li>boolean offer(E e)</li><li>boolean offer(E e, long timeout, TimeUnit unit)</li></ol></blockquote><p><strong>add(E e)</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// super.add(E e), 父级的 add 方法, 也就是 AbstractQueue 方法</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 调用自身的 offer     </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">offer</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Queue full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到 add 方法调用的是父类, 也就是 AbstractQueue 的 add 方法, 而 AbstractQueue 的 add 方法又重新调用会子类的 offer 方法。</p><p><strong>offer(E e)</strong></p><p>顺着 add 方法, 看一下 offer 方法:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 非空校验, 为空会抛出一个异常</span>        <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        <span class="token comment">// 加锁</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 当前存储数据的数组的长度 == 存储的数组元素个数的, 达到上限了</span>            <span class="token comment">// 直接返回 false</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 调用自身的 enqueue 方法将元素添加到队列中</span>                <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>        <span class="token comment">// 将当前的元素添加到数组的 putIndex 位置</span>        items<span class="token punctuation">[</span>putIndex<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token comment">// putIndex + 1 后如果已经等于当前数组的长度了, 也就是达到了数组的尾部最后一个了, 直接将 putIndex 设置为 0</span>        <span class="token comment">// 下次添加元素的位置从 0 开始</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>putIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>            putIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 元素个数 + 1    </span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">// 队列里面又有数据了, 非空了, 唤醒在 notEmpty 里面等待的线程</span>        notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>offer 方法的逻辑很简单</p><blockquote><p>入参非空校验<br>加锁<br>队列中的元素达到上限, 直接返回 false, 并释放锁<br>队列中的元素达未到上限, 将元素添加到队列中, 唤醒在非空等待条件中等待的线程, 返回 ture, 并释放锁</p></blockquote><p>在 enqueue 方法中, 将元素放到队列后, 会计算下次元素存放的位置, 这个计算过程实际就是一个取模操作, 当下一个元素存放的位置超过了队列的长度, 那么将元素重新存放到队列的头部, 也就是我们上面说的指针回到数组头部。</p><p><strong>offer(E e, long timeout, TimeUnit unit)</strong></p><p>offer(E e, long timeout, TimeUnit unit) 方法只是在 offer(E e) 的基础上增加了超时时间的概念。在队列上阻塞了多少时间后, 队列还是满的, 就返回。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 先进行非空校验</span>        <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 把超时时间转换成纳秒</span>        <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        <span class="token comment">// 获取一个可中断的互斥锁</span>        lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// while 循环的目的是防止在中断后没有到达传入的 timeout 时间, 可以继续重试</span>            <span class="token comment">// 当数组的元素个数等于数组的长度了, 达到上限了, 先进入阻塞</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 已经达到超时时间了, 直接返回 false， 结束</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">// 将当前线程阻塞在 非满 等待条件上 nanos 纳秒</span>                <span class="token comment">// 唤醒后, 返回剩余的等待时间 (可被中断)</span>                nanos <span class="token operator">=</span> notFull<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 入队操作</span>            <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>该方法利用了 Condition 的 awaitNanos 方法, 等待指定时间, 因为该方法可中断, 所以这里利用 while 循环来处理中断后还有剩余时间的问题, 等待时间到了以后数组非满时, 可以调用 enqueue 方法放入队列。</p><p><strong>put(E e)</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 非空校验</span>        <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>                <span class="token comment">// 可中断锁获取</span>        lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 当数组的元素个数 等于数组的长度了, 达到上限了, 进入阻塞等待唤醒</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 入队操作    </span>            <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>put() 方法在 count 等于 items 长度时, 即队列已经满时, 进入阻塞, 然后一直等待, 直到被其他线程唤醒。唤醒后调用 enqueue 方法放入队列。</p><h4 id="2-3-2-数据出队方法"><a href="#2-3-2-数据出队方法" class="headerlink" title="2.3.2 数据出队方法"></a>2.3.2 数据出队方法</h4><p>同入队的方法一样, 出队也有多种实现, ArrayBlockingQueue 提供了好几种出队的方法, 大体如下:</p><blockquote><ol><li>E poll()</li><li>E poll(long timeout, TimeUnit unit)</li><li>E take()</li></ol></blockquote><p><strong>poll()</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        <span class="token comment">// 加锁</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果当前数组的元素个数为 0, 直接返回 null,</span>            <span class="token comment">// 否则调用 dequeue 方法获取一个元素返回</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>        <span class="token comment">// 获取 taskIndex 位置的元素, 同时将 taskIndex 位置置为 null</span>        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>        <span class="token class-name">E</span> x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>        items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// taskIndex + 1 后, 如果等于数组的长度， 达到了数组的长度, 将 taskIndex 置为 0, 从头开始</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>takeIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>            takeIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 元素个数 - 1    </span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token comment">// 迭代器不为空, 也要进行元素的弹出 (这里可以先暂时不处理)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>itrs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            itrs<span class="token punctuation">.</span><span class="token function">elementDequeued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 唤醒在 notFull 等待条件上的线程</span>        notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>poll() 如果队列没有元素返回 null, 否则调用 dequeue() 方法把队头的元素出队列。<br>dequeue 会根据 takeIndex 获取到该位置的元素, 并把该位置置为 null, 然后将队头的指针指向下一个元素, 当当前指针已经在数组的最后一个元素, 则重新回到数组的头部, 最后唤醒 notFull 等待条件中的线程。</p><p><strong>poll(long timeout, TimeUnit unit)</strong></p><p>该方法是 poll() 的可配置超时等待方法。<br>和入队方法 offer() 方法一样, 使用 while 循环 + Condition 的 awaitNanos 来进行等待, 等待时间到后, 队列有数据, 就执行 dequeue 获取元素。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 转换为纳秒</span>        <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        <span class="token comment">// 获取可中断的锁</span>        lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 数组的元素个数为 0 </span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 超过了等待时间了, 返回 null</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token comment">// 带超时的的等待</span>                nanos <span class="token operator">=</span> notEmpty<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>take()</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 当前数组的容量为 0, 将当前线程阻塞在 notEmpty 的等待条件中, 等待唤醒</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 线程唤醒了, 调用 dequeue 获取数据    </span>            <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>take() 方法和 put() 方法类似, 当队列为空时, 进入阻塞, 一直等待, 直到被唤醒, 唤醒后调用 dequeue() 方法获取队列中的元素。</p><h4 id="2-3-3-获取元素方法"><a href="#2-3-3-获取元素方法" class="headerlink" title="2.3.3 获取元素方法"></a>2.3.3 获取元素方法</h4><p>获取数据的方法就一个。</p><p><strong>peek()</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        <span class="token comment">// 尝试获取锁</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 直接返回当前数组的 takeIndex 位置的元素, 也就是队头, 可能为空</span>            <span class="token keyword">return</span> <span class="token function">itemAt</span><span class="token punctuation">(</span>takeIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">final</span> <span class="token class-name">E</span> <span class="token function">itemAt</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>这里获取元素时上锁是为了避免脏数据的产生。</p><h4 id="2-3-4-删除元素方法"><a href="#2-3-4-删除元素方法" class="headerlink" title="2.3.4 删除元素方法"></a>2.3.4 删除元素方法</h4><p>因为删除元素是指定元素删除，删除的位置不确定，所以只能像普通的数组删除一样, 对应位置的元素删除后, 后面的元素向前移动一个位置。</p><p><strong>remove(Object o)</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 需要删除的元素为空, 直接返回 false</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 数组里面没有数据, 可以直接不处理</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">final</span> <span class="token keyword">int</span> putIndex <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putIndex<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> takeIndex<span class="token punctuation">;</span>                <span class="token comment">// 从 takeIndex 一直遍历到 putIndex, (遍历途中, 如果到了数组的尾部, 就从 0 继续开始) </span>                <span class="token comment">// 直到找到和元素 o 相同的元素, 调用 removeAt 进行删除</span>                <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token function">removeAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>i <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                        i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> putIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">removeAt</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> removeIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>        <span class="token comment">// 移除的位置刚好是 taskIndex, 也就是数组的头部</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>removeIndex <span class="token operator">==</span> takeIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 直接将 taskIndex 置为 null</span>            items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token comment">// taskIndex + 1 后等于数组的长度, 达到了尾部了, 回到头部</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>takeIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                takeIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment">// 元素个数 - 1    </span>            count<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment">// 迭代器不为空, 进行迭代器的元素删除</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>itrs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                itrs<span class="token punctuation">.</span><span class="token function">elementDequeued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> putIndex <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putIndex<span class="token punctuation">;</span>            <span class="token comment">// 将 removeIndex 到 putIndex 间所有的元素都向前移动一位, 移动到尾部了, 就从 0 继续开始</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> removeIndex<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 从下一个位置开始</span>                <span class="token keyword">int</span> next <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// 下一个位置为数组的尾部了, 从 0 继续开始</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                    next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">// 当前要处理的位置 i 的下一个位置不等于 putIndex </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">!=</span> putIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 将当前的位置 i 的值修改为下一个位置的值</span>                    items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> items<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token comment">// 更新需要处理的位置为下一个位置</span>                    i <span class="token operator">=</span> next<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 当前要处理的位置 i 的下一个位置为 putIndex </span>                    <span class="token comment">// 将当前位置置为 null</span>                    items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token comment">// 当前的 putIndex = 当前的位置</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>putIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>                    <span class="token comment">// 跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 元素个数减 1</span>            count<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment">// 迭代器不为空, 进行迭代器的元素删除</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>itrs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                itrs<span class="token punctuation">.</span><span class="token function">removedAt</span><span class="token punctuation">(</span>removeIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 唤醒等待在 notFull 上的线程</span>        notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>remove 整体的逻辑比较简单, 从 takeIndex 开始一直遍历到 putIndex, 直到找到和元素 o 相同的元素, 调用 removeAt 方法进行删除。</p><p>而 removeAt 方法的处理方式分为两种情况来考虑</p><blockquote><ol><li>removeIndex &#x3D;&#x3D; takeIndex, 这时后面的元素不需要往前移, 而只需要把 takeIndex 的指向下一个元素即可</li><li>removeIndex !&#x3D; takeIndex, 这时通过 putIndex 将 removeIndex 后的元素往前移一位</li></ol></blockquote><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>它是 BlockingQueue 接口的一种实现，通过固定大小的数组来存储元素，<br>同时借助 ReentrantLock 和 ReentrantLock 的 Condition 提供了阻塞操作，使得在队列已满或为空时，线程能够安全地等待。<br>内部借助头尾 2 个指针的移动达到一种循环数组的效果, 避免了整个元素删除时, 数组需要将后面的元素迁移的操作。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><a href="https://benjaminwhx.com/2018/05/07/%E3%80%90%E7%BB%86%E8%B0%88Java%E5%B9%B6%E5%8F%91%E3%80%91%E8%B0%88%E8%B0%88ArrayBlockingQueue/">【细谈Java并发】谈谈ArrayBlockingQueue</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java LinkedBlockingDeque</title>
      <link href="/article/2021/662858951/"/>
      <url>/article/2021/662858951/</url>
      
        <content type="html"><![CDATA[<p>在开始介绍 LinkedBlockingDeque 之前, 我们先看一下 LinkedBlockingDeque 的类图: </p><p><img src="https://pic.imgdb.cn/item/65844286c458853aeff8f704.png" alt="Alt &#39;LinkedBlockingDeque 类图&#39;"></p><p>从其中可以看出他直接实现了 BlockingDeque 接口, 而 BlockingDeque 又实现了 BlockingQueue 的接口, 所以它本身具备了队列的特性。<br>而实现 BlockingDeque 使其在 BlockingQueue 的基础上多了 Deque 的功能。</p><p>什么是 Deque 呢?<br>Deque（双端队列）是一种具有两端插入和删除操作的数据结构, 允许在队列的前端和后端执行高效的操作。<br>Deque 是“双端队列”（Double-Ended Queue）的缩写, 其特点在于可以在两端同时进行元素的插入和删除操作, 这使得它在许多应用中具有卓越的灵活性和性能。</p><p>我们知道队列只能是头进尾出, 而 Deque 2 边都支持进出, 这个特性更加的灵活。</p><p>实现了 BlockingDeque 的 LinkedBlockingDeque 其本身具备了以下特点</p><blockquote><ol><li>不支持 null 元素:  存入 null 元素会抛出异常</li><li>线程安全性: 在内部中通过 ReentrantLock 保证多线程环境下的安全访问 </li><li>无界容量: 在不指定容量的情况下, 默认为 Integer.MAX_VALUE, 理论上的无限容量</li><li>阻塞操作: 当 LinkedBlockingDeque 的操作尝试在空队列中执行移除操作或在满队列中执行插入操作时, 它会导致操作的阻塞</li></ol></blockquote><h2 id="1-实现的数据结构"><a href="#1-实现的数据结构" class="headerlink" title="1 实现的数据结构"></a>1 实现的数据结构</h2><p>内部的实现结构就是一个链表, 但是为了支持 2 端都可以出入队操作, 所以是一个双向链表。 </p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><h3 id="2-1-LinkedBlockingDeque-链表节点的定义"><a href="#2-1-LinkedBlockingDeque-链表节点的定义" class="headerlink" title="2.1 LinkedBlockingDeque 链表节点的定义"></a>2.1 LinkedBlockingDeque 链表节点的定义</h3><p>我们知道 LinkedBlockingDeque 的底层实现结构就是一个链表, 而链表绕不开的一个概念就是节点, 所以我们先来看一下 LinkedBlockingDeque 的节点定义。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 节点类, 用于存储数据     */</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 存储的内容</span>        <span class="token class-name">E</span> item<span class="token punctuation">;</span>        <span class="token comment">// 上一个节点的指针</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> prev<span class="token punctuation">;</span>        <span class="token comment">// 下一个节点的指针</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            item <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>上面的 Node 就是队列中的节点了, 声明的属性</p><blockquote><p>item: 存储的内容<br>prev: 上一个节点的指针<br>next: 下一个节点指针</p></blockquote><p>可以看出 LinkedBlockingDeque 是一个具备双向操作的链表</p><h3 id="2-2-LinkedBlockingQueue-持有的属性"><a href="#2-2-LinkedBlockingQueue-持有的属性" class="headerlink" title="2.2 LinkedBlockingQueue 持有的属性"></a>2.2 LinkedBlockingQueue 持有的属性</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** 队列的第一个元素的节点, 也就是头节点*/</span>    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> first<span class="token punctuation">;</span>    <span class="token comment">/** 队列的最后一个元素节点, 也就是尾节点 */</span>    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> last<span class="token punctuation">;</span>    <span class="token comment">/** 当前队列中的元素个数 */</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token comment">/** 队列的大小, 默认为 Integer.MAX_VALUE */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token comment">/** 所有操作队列元素节点时使用的锁 */</span>    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 非空, 也就是数组中重新有数据了, 可以继续取数据了</span>    <span class="token comment">// 当某个线程尝试从当前的队列中获取元素时, 如果数组中没有数据, 会把这个线程放到这个等待条件中</span>    <span class="token comment">// 在另外一个线程中添加元素到数组中, 会唤醒阻塞在这个等待条件中的线程</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 非满, 也就是数组中的数据又没有达到上限了, 可以继续添加数据</span>    <span class="token comment">// 当某个线程尝试向当前的队列添加元素, 但是当前数组已经满了, 会把这个线程放到这个等待条件中</span>    <span class="token comment">// 在另一个线程中从当前队列中获取一个元素时, 会唤醒等待在这个等待队列中的线程</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> notFull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>通过上面属性的声明, 可以发现 LinkedBlockingDeque 和 ArrayBlockingQueue 类似, 都是通过一个可重入锁控制并发, 同时通过 2 个 Condition 实现在队列空或满时挂起或唤醒线程。</p><p>再来看表示队列容量的 count, 就是简单的用一个 int 表示, 没有用 volatile 修饰, 可以保证线程的可见性吗?<br>在 LinkedBlockingQueue 容量的大小却是的用 AtomicInteger 来表示, 为什么不是同样简单用一个 int 呢?</p><p>这 2 个问题都可以用 Happens-Before 的<strong>监视器原则</strong>来解释。<br>在 LinkedBlockingDeque 中只用了一把锁, 同时 count 的修改也只有在线程持有锁的过程中变更, 所以能够保证可见性, 而<strong>监视器原则</strong>,<br>确保了同一把锁的解锁 Happens-Before 加锁, 也就是说在 A 线程解锁之前的操作对于 B 线程获取同一把锁后都是可见的。<br>而 LinkedBlockingQueue 中使用了 2 把锁, 一个用于添加元素, 一个用于移除元素, 所以 2 把锁之间的加锁和解锁不能保证可见性, 所以使用了 AtomicInteger, 利用其内部的 CAS 操作来保证可见性。</p><h3 id="2-3-LinkedBlockingQueue-构造函数"><a href="#2-3-LinkedBlockingQueue-构造函数" class="headerlink" title="2.3 LinkedBlockingQueue 构造函数"></a>2.3 LinkedBlockingQueue 构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 无参构造函数</span>    <span class="token keyword">public</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用自身指定容量的构造函数, 默认为 int 的最大值</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 指定容量的构造函数</span>    <span class="token keyword">public</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 指定的容量小于等于 0, 直接抛出异常</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 指定一个集合的构造函数</span>    <span class="token keyword">public</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        <span class="token comment">// 加锁</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 元素不能为空</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 把当前的数据封装为 Node 节点, 放到了队列的尾部, 添加失败就抛出异常</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">linkLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Deque full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">linkLast</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 队列中的元素个数大于等于容量上限了, 直接返回 false</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">>=</span> capacity<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">// 获取尾节点</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token comment">// 新增节点的上一个节点为原本的尾节点</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token comment">// 当前的尾节点等于新增的节点</span>        last <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token comment">// 头节点为空, 原本链表没有数据, 新增节点就是头节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            first <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// 头节点不为空, 原本链表有数据, 那么把原本的尾节点的下一个节点指向新增的节点</span>            l<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token comment">// 队列中的元素个数 + 1</span>        <span class="token operator">++</span>count<span class="token punctuation">;</span>        <span class="token comment">// 队列有数据了, 唤醒阻塞在非空等待条件上的线程</span>        notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>第一个构造函数无参, 那么创建的队列的容量就是 Integer.MAX_VALUE, 也就是理论上的无限容量。</p><p>第二个构造函数可以指定队列大小。</p><p>第三个构造函数传入一个集合, 这样也会创建出理论无限容量的队列。</p><p>同理里面使用了 ReentrantLock 来加锁, 然后把传入的集合元素按顺序一个个放入 items 中。<br>这里加锁目的不是使用它的互斥性, 而是让修改后的头节点 first 和尾节点 last 的变动, 对其他线程可见, 也就是使用了 ReentrantLock 的<strong>监视器原则</strong>。 </p><h3 id="2-4-LinkedBlockingDeque-支持的方法"><a href="#2-4-LinkedBlockingDeque-支持的方法" class="headerlink" title="2.4 LinkedBlockingDeque 支持的方法"></a>2.4 LinkedBlockingDeque 支持的方法</h3><h4 id="2-4-1-数据入队方法"><a href="#2-4-1-数据入队方法" class="headerlink" title="2.4.1 数据入队方法"></a>2.4.1 数据入队方法</h4><p>LinkedBlockingDeque 提供了多种入队操作的实现来满足不同情况下的需求, 入队操作有如下几种：</p><blockquote><ol><li>add(E e) &#x2F; addFirst(E e) &#x2F; addLast(E e)</li><li>offer(E e) &#x2F; offerFirst(E e) &#x2F; offerLast(E e)</li><li>offer(E e, long timeout, TimeUnit unit) &#x2F; offerFirst(E e, long timeout, TimeUnit unit) &#x2F; offerLast(E e, long timeout, TimeUnit unit)</li><li>put(E e) &#x2F; putFirst(E e) &#x2F; putLast(E e)</li></ol></blockquote><p><strong>add() 相关的方法</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用到添加到尾部的方法</span>        <span class="token function">addLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用 offerFirst 的方法</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">offerFirst</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Deque full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用 offerLast 的方法</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">offerLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Deque full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>add() 相关的方法都是直接调用 offer() 对应的方法, 比如 add 对应 offer,  addFirst 对应 offerFirst, 所以我们只需要看 offer() 方法的实现就可以了。</p><p><strong>offer() 相关的方法</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用自身的 offerLast 方法, 添加到队列的尾部</span>        <span class="token keyword">return</span> <span class="token function">offerLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offerFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 添加的数据不能为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 封装为 Node 节点    </span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        <span class="token comment">// 获取锁</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 添加到队列的头部</span>            <span class="token keyword">return</span> <span class="token function">linkFirst</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offerLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 添加的数据不能为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 封装为 Node 节点  </span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        <span class="token comment">// 获取锁</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 添加到队列的尾部</span>            <span class="token keyword">return</span> <span class="token function">linkLast</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">linkFirst</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 节点个数大于等于容量上限了, 直接返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">>=</span> capacity<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">// 获取头节点    </span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token comment">// 新增的节点的下一个节点为当前的头节点</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> f<span class="token punctuation">;</span>        <span class="token comment">// 当前的头节的设置为新增的节点</span>        first <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token comment">// 当前的尾节点为空, 表示原本链表中没有数据, 把新增的节点同时设置为尾节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            last <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// 为节点不为空, 表示原本链表中有数据了</span>            <span class="token comment">// 那么只需要把 旧的头节点的上一个节点指向新增的节点</span>            f<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token comment">// 队列中的元素个数 + 1    </span>        <span class="token operator">++</span>count<span class="token punctuation">;</span>        <span class="token comment">// 唤醒阻塞在非空等待条件中的线程</span>        notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">linkLast</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">>=</span> capacity<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">// 获取尾结点    </span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token comment">// 新增节点的上一个节点为原本的尾节点</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token comment">// 当前的尾节点等于新增的节点</span>        last <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token comment">// 头节点为空, 原本链表没有数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">// 将头节点设置为新增的节点</span>            first <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// 尾节点不为空, 原本队列有数据了, 把原本尾节点的下一个节点设置为新增的节点</span>            l<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token comment">// 队列中的元素个数 + 1      </span>        <span class="token operator">++</span>count<span class="token punctuation">;</span>        <span class="token comment">// 唤醒阻塞在非空等待条件中的线程</span>        notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>offer() 相关的方法的实现很简单, 最终就是调用到内部的 linkFirst() 和 linkLast() 方法, 而 2 个就是链表的节点新增操作。</p><p>而 offer() 相关的带超时时间的方法就不展开了, 原理和 LinkedBlockingQueue 一样, 利用了 Condition 的 awaitNanos 进行超时等待, 并在外面用 while 循环控制等待时的中断问题。</p><p><strong>put() 相关的方法</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用到 putLast 方法</span>        <span class="token function">putLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">putLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 添加的数据不能为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将当前的数据封装为 Node 节点            </span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 阻塞等待 linkLast 成功</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">linkLast</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment">// 添加到队列尾部失败的话, 将当前线程放到非满的等待条件, 等待唤醒后, 尝试添加元素到队列</span>                notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">putFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 阻塞等待linkFirst成功</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">linkFirst</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment">// 添加到队列尾部失败的话, 当前线程放到非满的等待条件, 等待唤醒后, 尝试添加元素到队列</span>                notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>lock 加锁后一直阻塞等待, 直到元素插入到队列中。<br>整体的方法和 offer 方法类似, 前者在当队列已满时, 进入阻塞, 后者在队列已满时, 则是返回。</p><h4 id="2-3-2-数据出队方法"><a href="#2-3-2-数据出队方法" class="headerlink" title="2.3.2 数据出队方法"></a>2.3.2 数据出队方法</h4><p>同入队的方法一样, 出队也有多种实现, LinkedBlockingDeque 提供了好几种出队的方法, 大体如下:</p><blockquote><ol><li>remove() &#x2F; removeFirst() &#x2F;removeLast()</li><li>poll() &#x2F; pollFirst() &#x2F; pollLast()</li><li>poll(long timeout, TimeUnit unit) &#x2F; pollFirst(long timeout, TimeUnit unit) &#x2F; pollLast(long timeout, TimeUnit unit)</li><li>take() &#x2F; takeFirst() &#x2F; takeLast()</li></ol></blockquote><p><strong>remove() 相关的方法</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用自身的 removeFirst 方法</span>        <span class="token keyword">return</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用自身的 pollFirst 方法</span>        <span class="token class-name">E</span> x <span class="token operator">=</span> <span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用自身的 pollLast 方法</span>        <span class="token class-name">E</span> x <span class="token operator">=</span> <span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>remove() 相关的方法都是调用到对应的 poll() 方法, 在拿到方法的返回值后, 做一层非空的判断。</p><p><strong>poll() 相关的方法</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用到自身的 pollFirst 方法</span>        <span class="token keyword">return</span> <span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        <span class="token comment">// 加锁</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 带锁的执行 unlinkFirst 方法</span>            <span class="token keyword">return</span> <span class="token function">unlinkFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 带锁的执行 unlinkLast 方法</span>            <span class="token keyword">return</span> <span class="token function">unlinkLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">unlinkFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token comment">// 判断当前的头节点, 为空的话, 直接返回 null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 获取头节点的下一个节点    </span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> n <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment">// 获取头节点的数据</span>        <span class="token class-name">E</span> item <span class="token operator">=</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token comment">// 置空头节点的数据</span>        f<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 把头节点的下一个节点指向自身</span>        f<span class="token punctuation">.</span>next <span class="token operator">=</span> f<span class="token punctuation">;</span>        <span class="token comment">// 把头节点的指针 first 指向当前头节点的下一个节点</span>        first <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token comment">// 头节点的下一个节点为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">// 置空尾结点</span>            last <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// 否则设置头节点的下一个节点的上一个节点为空</span>            n<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 队列元素个数 - 1    </span>        <span class="token operator">--</span>count<span class="token punctuation">;</span>        <span class="token comment">// 唤醒在 notFull 等待队列上的线程</span>        notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> item<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">unlinkLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token comment">// 尾节点为空, 直接返回 null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 获取尾节点的上一个节点</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> l<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token comment">// 获取尾节点的数据</span>        <span class="token class-name">E</span> item <span class="token operator">=</span> l<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token comment">// 置空尾节点的数据</span>        l<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 设置尾结点的上一个节点为自身</span>        l<span class="token punctuation">.</span>prev <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token comment">// 设置尾节点的指针 last 指向当前尾结点的上一个节点</span>        last <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment">// 尾结点的上一个节点为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">// 置空头节点</span>            first <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// 设置尾结点的上一个节点的下一个节点为空</span>            p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">//   队列元素个数 - 1       </span>        <span class="token operator">--</span>count<span class="token punctuation">;</span>        <span class="token comment">// 唤醒在 notFull 等待队列上的线程</span>        notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> item<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>poll() 相关的方法的实现很简单, 最终就是调用到内部的 unlinkFirst() 和 unlinkLast() 方法, 而 2 个就是链表的节点删除操作。</p><p>而 poll() 相关的带超时时间的方法就不展开了, 原理和 LinkedBlockingQueue 一样, 利用了 Condition 的 awaitNanos 进行超时等待, 并在外面用 while 循环控制等待时的中断问题。</p><p><strong>take() 相关的方法</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用到自身的 takeFirst 方法</span>        <span class="token keyword">return</span> <span class="token function">takeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">takeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">E</span> x<span class="token punctuation">;</span>            <span class="token comment">// 通过 unlinkFirst 方法删除头节点, </span>            <span class="token comment">// 删除失败, 即返回结果为 null, 将当前线程阻塞在非空等待条件上</span>            <span class="token comment">// 等待唤醒后重新执行删除</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token function">unlinkFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">takeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">E</span> x<span class="token punctuation">;</span>            <span class="token comment">// 通过 unlinkFirst 方法删除头节点, </span>            <span class="token comment">// 删除失败, 即返回结果为 null, 将当前线程阻塞在非空等待条件上</span>            <span class="token comment">// 等待唤醒后重新执行删除</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token function">unlinkLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>和 <strong>put()</strong> 方法一个套路, 先通过 lock 加锁, 然后 while 循环重试, 失败就 await 阻塞等待, 等待下次唤醒, 直至成功。</p><h4 id="2-3-3-获取元素方法"><a href="#2-3-3-获取元素方法" class="headerlink" title="2.3.3 获取元素方法"></a>2.3.3 获取元素方法</h4><p>LinkedBlockingDeque 提供了获取元素的方法主要有 2 个 <strong>element()</strong> 和 <strong>peek()</strong> 方法, 他们的区别在于, element() 方法在队列为空时会抛出异常, 而 peek() 方法则是返回 null。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用 getFirst() 方法</span>        <span class="token keyword">return</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用 peekFirst() 方法</span>        <span class="token keyword">return</span> <span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用 getFirst 方法结果还是调用到 peekFirst() 方法</span>        <span class="token class-name">E</span> x <span class="token operator">=</span> <span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用 getLast 方法结果还是调用到 peekLast() 方法</span>        <span class="token class-name">E</span> x <span class="token operator">=</span> <span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        <span class="token comment">// 加锁</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 头节点为空吗 ? 是的话返回 null, 否则返回头节点的数据</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> first<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        <span class="token comment">// 加锁</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 尾节点为空吗？ 是的话返回 null, 否则返回尾节点的数据</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> last<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>获取元素前加锁, 防止并发问题导致数据不一致, 然后利用 first 和 last 2 个节点直接可以获得元素。</p><h4 id="2-3-4-删除元素方法"><a href="#2-3-4-删除元素方法" class="headerlink" title="2.3.4 删除元素方法"></a>2.3.4 删除元素方法</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用自身的 removeFirstOccurrence 方法</span>        <span class="token keyword">return</span> <span class="token function">removeFirstOccurrence</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">removeFirstOccurrence</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 从头开始遍历</span>        <span class="token comment">// 需要移除的节点为 null, 直接抛异常</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>             <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        <span class="token comment">// 加锁</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 从 first 向后开始遍历比较, 找到元素后调用 unlink 移除</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> first<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">unlink</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">removeLastOccurrence</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 从尾开始遍历</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>             <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        <span class="token comment">// 加锁</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 从 last 向前开始遍历比较, 找到元素后调用 unlink 移除</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> last<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">unlink</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取删除节点的上一个节点</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token comment">// 获取删除节点的下一个节点</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> n <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment">// 需要删除的节点上一个节点为空, 需要删除的节点为头节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">unlinkFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 需要删除的节点的下一个节点为空, 需要删除对接的为尾节点</span>            <span class="token function">unlinkLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 把需要删除的节点的上一个节点的下一个节点的指针 指向 需要删除的节点的下一个节点</span>            p<span class="token punctuation">.</span>next <span class="token operator">=</span> n<span class="token punctuation">;</span>            <span class="token comment">// 把需要删除的节点的下一个节点的上一个节点的指针 指向 需要删除的节点的上一个节点</span>            n<span class="token punctuation">.</span>prev <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token comment">// 置空需要删除节点的数据</span>            x<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token comment">// 队列中的元素个数 - 1</span>            <span class="token operator">--</span>count<span class="token punctuation">;</span>            <span class="token comment">// 唤醒阻塞在 notFull 等待队列上的线程</span>            notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>删除元素是从头 &#x2F; 尾向两边进行遍历比较, 故时间复杂度为 O(n), 最后调用 unlink 把要移除元素的 prev 和 next 进行关联, 把要移除的元素从链中脱离, 等待下次 GC 回收。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>总体而言, LinkedBlockingDeque 的源码实现通过锁、条件等待和双向链表结构, 保证了在多线程环境中对队列的安全操作。<br>其本身可以作为一个双端队列使用, 也可以作为一个双端阻塞队列使用, 具有很好的灵活性。</p><h2 id="4-转载"><a href="#4-转载" class="headerlink" title="4 转载"></a>4 转载</h2><p><a href="http://benjaminwhx.com/2018/05/12/%E3%80%90%E7%BB%86%E8%B0%88Java%E5%B9%B6%E5%8F%91%E3%80%91%E8%B0%88%E8%B0%88LinkedBlockingDeque/">【细谈Java并发】谈谈LinkedBlockingDeque</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java LinkedBlockingQueue</title>
      <link href="/article/2021/3300141062/"/>
      <url>/article/2021/3300141062/</url>
      
        <content type="html"><![CDATA[<p>LinkedBlockingQueue, 顾名思义: 基于链表的阻塞队列, 位于 JUC (java.util.concurrent) 下, 是一个线程安全的集合, 其本身具备了</p><blockquote><ol><li>不支持 null 元素:  存入 null 元素会抛出异常</li><li>固定不限容量: 在不手动设置容量时, 最大可以支持 Integer.MAX_VALUE 个元素, 也就是理论上的无限个数</li><li>有序性: 内部采用链表作为底层数据结构, 保持了元素的有序性。这意味着当你向队列中添加元素时, 它们将按照添加的顺序排列, 而消费者线程将按照相同的顺序取出这些元素</li><li>LinkedBlockingQueue 会在队列满时, 阻塞添加数据的线程直至队列非满状态, 同样, 在队列空时, 阻塞获取数据的线程直至队列重新非空</li><li>支持锁公平性配置: 在初始化时可以指定是否使用公平锁, 默认为非公平锁。公平锁通常会降低吞吐量, 但是减少了可变性和避免了线程饥饿问题</li></ol></blockquote><h2 id="1-实现的数据结构"><a href="#1-实现的数据结构" class="headerlink" title="1 实现的数据结构"></a>1 实现的数据结构</h2><p>内部的实现结构就是一个链表, 而且是所有链表中最简单的单向链表, 所以就不展开了。</p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><h3 id="2-1-LinkedBlockingQueue-链表节点的定义"><a href="#2-1-LinkedBlockingQueue-链表节点的定义" class="headerlink" title="2.1 LinkedBlockingQueue 链表节点的定义"></a>2.1 LinkedBlockingQueue 链表节点的定义</h3><p>我们知道 LinkedBlockingQueue 的底层实现结构就是一个链表, 而链表绕不开的一个概念就是节点, 所以我们先来看一下 LinkedBlockingQueue 的节点定义。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 链表节点类, 数据的主要存储地方</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 节点的数据</span>        <span class="token class-name">E</span> item<span class="token punctuation">;</span>        <span class="token comment">// 下一个节点</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             item <span class="token operator">=</span> x<span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>通过节点 Node 的定义中就一个数据域和一个指向下一个节点的指针, 明确 LinkedBlockingQueue 就是一个单向链表。</p><h3 id="2-2-LinkedBlockingQueue-持有的属性"><a href="#2-2-LinkedBlockingQueue-持有的属性" class="headerlink" title="2.2 LinkedBlockingQueue 持有的属性"></a>2.2 LinkedBlockingQueue 持有的属性</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** 队列的大小, 默认为 Integer.MAX_VALUE */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token comment">/** 队列中的元素个数 */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/** 队列头结点 */</span>    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> head<span class="token punctuation">;</span>    <span class="token comment">/** 队列尾节点 */</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> last<span class="token punctuation">;</span>    <span class="token comment">/** 可重入锁, 用于从队列中获取元素时使用, 后面我们统一叫做读锁 */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> takeLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/** 非空条件对象, 当队列没有数据时, 用于挂起获取数据的线程 */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> notEmpty <span class="token operator">=</span> takeLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/** 可重入锁, 用于先队列添加元素时使用, 后面我们统一叫做写锁 */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> putLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/** 非满条件对象, 当队列数据已满时, 用于挂起添加数据的线程 */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> notFull <span class="token operator">=</span> putLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>和 ArrayBlockingQueue 类似, 都是通过可重入锁控制并发, 通过 Condition 来实现线程的挂起和唤醒。<br>和 ArrayBlockingQueue 不同的时, 添加和删除数据, ArrayBlockingQueue 使用的是同一把锁, 而 LinkedBlockingQueue 将添加数据和删除数据分开, 使用了两把锁, 这样可以提高并发度。</p><h3 id="2-3-LinkedBlockingQueue-构造函数"><a href="#2-3-LinkedBlockingQueue-构造函数" class="headerlink" title="2.3 LinkedBlockingQueue 构造函数"></a>2.3 LinkedBlockingQueue 构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 无参构造函数</span>    <span class="token keyword">public</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 默认大小为 Integer.MAX_VALUE</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 指定容量的构造函数</span>    <span class="token keyword">public</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>        <span class="token comment">// 初始化头尾节点</span>        last <span class="token operator">=</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 指定集合的构造函数</span>    <span class="token keyword">public</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 同样默认为 Integer.MAX_VALUE 的容量</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>        <span class="token comment">// 获取添加数据锁</span>        putLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 非空校验</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 达到容量了</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> capacity<span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Queue full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 将当前的数据封装为 Node 节点, 添加到队列中</span>                <span class="token comment">// 先知道这个方法的作用, 后面新增数据的时候有分析    </span>                <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 添加个数 + 1</span>                <span class="token operator">++</span>n<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 当前链表的个数设置为添加的个数</span>            count<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>从 LinkedBlockingQueue 的 3 个构造函数中可以看出, 都需要通过<strong>指定容量构造函数</strong>先构建出一个<strong>只有 1 个节点, 同时节点数据为空的链表</strong>, 如下:</p><p><img src="https://pic.imgdb.cn/item/6581b378c458853aef1188e3.png" alt="Alt &#39;LinkedBlockingQueue 初始状态&#39;"></p><p>在构建为这个空链表后, 实际我们的 LinkedBlockingQueue 算是初始化完成了。<br>而指定集合的构造函数, 会在初始化完成, 加上写锁后, 将入参的集合元素添加到当前的队列中。</p><p>同 ArrayBlockingQueue 一样, 在构造函数中使用了 ReentrantLock 来加锁, 通过这个锁达到 Happens-Before 的<strong>监视器原则</strong>, 达到后面可见性。</p><h3 id="2-4-LinkedBlockingQueue-支持的方法"><a href="#2-4-LinkedBlockingQueue-支持的方法" class="headerlink" title="2.4 LinkedBlockingQueue 支持的方法"></a>2.4 LinkedBlockingQueue 支持的方法</h3><h4 id="2-4-1-数据入队方法"><a href="#2-4-1-数据入队方法" class="headerlink" title="2.4.1 数据入队方法"></a>2.4.1 数据入队方法</h4><p>LinkedBlockingQueue 提供了多种入队操作的实现来满足不同情况下的需求, 入队操作有如下几种：</p><blockquote><ol><li>boolean add(E e)</li><li>boolean offer(E e)</li><li>boolean offer(E e, long timeout, TimeUnit unit)</li><li>void put(E e)</li></ol></blockquote><p><strong>add(E e)</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 直接调用自身的 offer 方法, 添加成功就返回 true</span>        <span class="token comment">// offer 方法后面分析</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">offer</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Queue full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>````<span class="token operator">*</span><span class="token operator">*</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">*</span>顺着 add 方法<span class="token punctuation">,</span> 看一下 offer 方法<span class="token operator">:</span>```java<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 新增的数据为空, 直接抛异常</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>        <span class="token comment">// 达到了容量上限, 直接返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 将当前的数据封装为 Node 节点</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>        <span class="token comment">// 获取添加锁</span>        putLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 当前队列的容量还没达到上线</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 将当前这个节点添加到队列的尾部</span>                <span class="token function">enqueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 获取当前的数组容量</span>                c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 当前的数组容量 + 1 后还是小于容量上限</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span>                    <span class="token comment">// 唤醒阻塞在非满条件上的线程</span>                    notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 上面 c = count.getAndIncrement(), 会先将 count 当前的值赋给 c, 然后在 count 再 + 1</span>        <span class="token comment">// 所以这里 c == 0, 表示当前链表新增了一个节点前, 没有数据, 尝试唤醒阻塞在非空条件上的线程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">signalNotEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> c <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 简单的链表新增节点操作</span>        <span class="token comment">// 把当前链表的尾结点的下一个节点设置为新增的节点</span>        <span class="token comment">// 把当前的尾节点更新为新增的节点</span>        last <span class="token operator">=</span> last<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">signalNotEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>        <span class="token comment">// 获取读锁</span>        takeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 唤醒在非空条件上阻塞的线程 (唤醒前需要获取对应的锁, 所以上面先获取了读锁)</span>            notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 释放读锁</span>            takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>offer 方法概括一下就是:</p><blockquote><ol><li>非空和队列容量判断</li><li>获取写锁成功时, 将当前的元素封装为节点放到链表的尾部</li><li>添加成功后, 队列的容量没有达到上限, 唤醒在非满条件上阻塞的线程, 然后释放锁</li><li>如果当前添加的元素是当前链表的第一个元素, 唤醒在非空条件上阻塞的线程</li></ol></blockquote><p><strong>offer(E e, long timeout, TimeUnit unit)</strong></p><p>offer(E e, long timeout, TimeUnit unit) 方法只是在 offer(E e) 的基础上增加了超时时间的概念。在队列上阻塞了多少时间后, 队列还是满的, 就返回。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 时间转为纳秒</span>        <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>                <span class="token comment">// 获取可中断的写锁</span>        putLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// while 循环的目的是防止在中断后没有到达传入的 timeout 时间, 可以继续重试</span>            <span class="token comment">// 等待超时时间达到了 nanos, 就直接返回 false</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">// 将当前线程阻塞在非空条件上     </span>                nanos <span class="token operator">=</span> notFull<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                        <span class="token comment">// 把当前的节点放到队列的尾部</span>            <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 获取当前的数组容量</span>            c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 当前的数组容量 + 1 后还是小于容量上限</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span>                <span class="token comment">// 唤醒阻塞在非空条件上的线程</span>                notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 上面 c = count.getAndIncrement(), 会先将 count 当前的值赋给 c, 然后在 count 再 + 1</span>        <span class="token comment">// 所以这里 c == 0, 表示当前链表新增了一个节点前, 没有数据, 尝试唤醒阻塞在非空条件上的线程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">signalNotEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到主要的逻辑和 offer(E e) 方法一样, 只是在队列满时, 使用的是带超时时间的阻塞方法。<br>该方法会在等待时间到达后, 会自动唤醒, 同时线程时间到达后被唤醒, 队列还是满的, 就返回 false。</p><p><strong>put(E e)</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 非空校验</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取添加需要的 putLock, 也就是写锁</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>        <span class="token comment">// 获取锁中断</span>        putLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 判断队列是否已满, 如果已满阻塞等待</span>            <span class="token comment">// 如果每次唤醒都是满的话, 就会一直阻塞</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 把node放入队列中</span>            <span class="token function">enqueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 链表中的元素个数 + 1</span>            c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 再次判断队列是否有可用空间, 如果有唤醒下一个线程进行添加操作</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span>                notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>  <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 上面 c = count.getAndIncrement(), 会先将 count 当前的值赋给 c, 然后在 count 再 + 1</span>        <span class="token comment">// 所以这里 c == 0, 表示当前链表新增了一个节点前, 没有数据, 尝试唤醒阻塞在非空条件上的线程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">signalNotEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre><p>put 方法和 offer 方法类似, 前者在当队列已满时, 进入阻塞, 后者在队列已满时, 则是返回。</p><h4 id="2-3-2-数据出队方法"><a href="#2-3-2-数据出队方法" class="headerlink" title="2.3.2 数据出队方法"></a>2.3.2 数据出队方法</h4><p>同入队的方法一样, 出队也有多种实现, LinkedBlockingQueue 提供了好几种出队的方法, 大体如下:</p><blockquote><ol><li>E poll();</li><li>E poll(long timeout, TimeUnit unit);</li><li>E take()</li></ol></blockquote><p><strong>poll()</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>        <span class="token comment">// 当前的数组为节点个数为空, 直接返回 null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">E</span> x <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>        <span class="token comment">// 获取读锁</span>        takeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 当前的数组容量大于 0, 有数据可以获取</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 获取头节点的数据</span>                x <span class="token operator">=</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 当前数组的节点个数 - 1</span>                c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 当前数组的节点个数还是大于 1</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>                    <span class="token comment">// 唤醒阻塞在非空条件上的线程</span>                    notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 释放读锁</span>            takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 当前的容量等于上限了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> capacity<span class="token punctuation">)</span>            <span class="token comment">// 唤醒阻塞在非满条件上阻塞的线程</span>            <span class="token function">signalNotFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 简单的链表删除操作</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">// 获取当前头节点的下一个节点</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> first <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment">// 将头节点下一个节点设置为自身, 这里的操作后面分析</span>        h<span class="token punctuation">.</span>next <span class="token operator">=</span> h<span class="token punctuation">;</span>        <span class="token comment">// 将当前的头节点设置为头节点的下一个节点</span>        head <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token comment">// 获取旧的头结点的数据</span>        <span class="token class-name">E</span> x <span class="token operator">=</span> first<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token comment">// 设置旧的节点的数据为 null</span>        first<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 返回旧的节点的数据</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">signalNotFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>        <span class="token comment">// 获取写锁</span>        putLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 唤醒阻塞在非满条件上的线程</span>            notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>poll() 逻辑整理如下</p><blockquote><ol><li>队列为空, 直接返回 null</li><li>获取读锁, 队列不为空, 获取头节点的数据</li><li>获取后队列还是有数据, 唤醒阻塞在非空条件上的线程, 释放锁</li><li>如果当前的容量等于上限了, 再次唤醒阻塞在非满条件上阻塞的线程</li></ol></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">E</span> x <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>        takeLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 当前的数组容量为 0, 队列为空, 将当前线程阻塞在非空条件上</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token comment">// 带超时时间的等待</span>                nanos <span class="token operator">=</span> notEmpty<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 队列不为空, 获取头节点的数据</span>            x <span class="token operator">=</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 当前数组的节点个数 - 1</span>            c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 当前数组的节点个数还是大于 1</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>                <span class="token comment">// 唤醒阻塞在非空条件上的线程</span>                notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 当前的容量等于上限了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> capacity<span class="token punctuation">)</span>            <span class="token comment">// 唤醒阻塞在非满条件上阻塞的线程</span>            <span class="token function">signalNotFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>整个 poll(long timeout, TimeUnit unit) 方法和 poll() 方法类似, 只是在队列为空时, 使用的是带超时时间的阻塞方法。</p><p><strong>take()</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">E</span> x<span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>        <span class="token comment">// 获取可中断的锁</span>        takeLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 队列为空, 阻塞等待</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 获取头节点的数据</span>            x <span class="token operator">=</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 获取当前的数组容量</span>            c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 队列中还有元素, 唤醒下一个消费线程进行消费</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>                notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 移除元素之前队列是满的, 唤醒生产线程进行添加元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> capacity<span class="token punctuation">)</span>            <span class="token function">signalNotFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>take() 方法和 poll() 方法类似, 当队列为空时, 进入阻塞, 一直等待, 直到被唤醒, 唤醒后调用 dequeue() 方法获取队列中的元素, 而 poll() 方法则是在队列为空时, 直接返回 null。</p><h4 id="2-3-3-获取元素方法"><a href="#2-3-3-获取元素方法" class="headerlink" title="2.3.3 获取元素方法"></a>2.3.3 获取元素方法</h4><p>获取数据的就一个方法, 同时只支持获取头节点的数据。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 当前数组上的节点为 0,  直接返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>        <span class="token comment">// 获取读锁</span>        takeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 获取头节点的下一个节点 (有数据的头节点)</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> first <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment">// 头节点的下一个节点为 null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token comment">// 返回 null</span>                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token comment">// 返回头节点的数据</span>                <span class="token keyword">return</span> first<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>很简单, 就是获取头节点的下一个节点的数据, 有数据返回数据, 没有数据, 就返回 null。</p><h4 id="2-3-4-删除元素方法"><a href="#2-3-4-删除元素方法" class="headerlink" title="2.3.4 删除元素方法"></a>2.3.4 删除元素方法</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">// 两个 lock 全部上锁</span>        <span class="token function">fullyLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 从 head 开始遍历元素, 直到最后一个元素</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> trail <span class="token operator">=</span> head<span class="token punctuation">,</span> p <span class="token operator">=</span> trail<span class="token punctuation">.</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> trail <span class="token operator">=</span> p<span class="token punctuation">,</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 如果找到相等的元素, 调用 unlink 方法删除元素</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">unlink</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> trail<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 两个lock全部解锁</span>            <span class="token function">fullyUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">fullyLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        putLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        takeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> p<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> pred<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 简单的链表节点删除操作</span>                <span class="token comment">// 将这个节点的数据项设置为 null</span>        <span class="token comment">// 同样是删除元素, 什么这里这里删除的元素 p 不需要想 dequeue 方法一样, 将他的 next 设置为 自身?</span>        p<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 将这个节点的上一个节点的 next 设置为删除节点 p 的下一个节点</span>        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment">// 删除的节点为尾结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> p<span class="token punctuation">)</span>            <span class="token comment">// 设置尾节点为删除节点的上一个节点</span>            last <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token comment">// 当前数组的容量减 1 后还是等于数组上限  </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token punctuation">)</span>            <span class="token comment">// 唤醒 notFull 上等待队列的线程</span>            notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">fullyUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="3-问题"><a href="#3-问题" class="headerlink" title="3 问题"></a>3 问题</h2><p>在上面的源码的分析中, 留了 2 个比较特殊的地方</p><blockquote><ol><li>dequeue 方法中里的移除的元素 h, 为什么需要将 h.next 指向自身, 而不是 null</li><li>同样删除元素的 unlink 方法却不需要将 p.next &#x3D; null 或者 p.next &#x3D; p 这样的操作</li></ol></blockquote><p>这里都可以在 LinkedBlockingQueue 内部的迭代器中找到答案</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Itr</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 遍历的链表头节点</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> current<span class="token punctuation">;</span>    <span class="token comment">// 遍历的链表头节点的数据</span>    <span class="token keyword">private</span> <span class="token class-name">E</span> currentElement<span class="token punctuation">;</span>    <span class="token comment">// 构造函数</span>    <span class="token class-name">Itr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 加双锁</span>        <span class="token function">fullyLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            current <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                currentElement <span class="token operator">=</span> current<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token function">fullyUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取入参节点的下一个节点</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 解决了问题 1</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> s <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> p<span class="token punctuation">)</span>                <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>item <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> s<span class="token punctuation">;</span>            p <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>问题 1 在 nextNode 方法中也能找到</p><blockquote><ol><li>为了正确遍历, nextNode 中通过 s &#x3D;&#x3D; p 进行判断, 当下一个元素是自己本身时, 返回 head 的下一个节点。</li></ol></blockquote><p>而第二个问题主要在迭代器的遍历中, 迭代器的遍历分为两步</p><blockquote><ol><li>加双锁, 然后链表的头节点放到一个临时变量中</li><li>遍历临时变量的元素。在遍历的过程是无锁的, 也就是其他线程可以执行 remove 方法, 如果其他线程通过 unlink 修改了 p 的 next, 可能在导致迭代异常</li></ol></blockquote><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>它是 BlockingQueue 接口的一种实现, 通过链表的形式存储元素, 在不明确指定容量时, 可以存储 Integer.MAX_VALUE 个元素, 也就是理论上的无上限, 但是建议在使用中还是指定容量, 避免 OOM 等问题。<br>同时借助 2 个 ReentrantLock 达到读写互不影响, 提高并发性能。同时 ReentrantLock 的 Condition 提供了阻塞操作, 使得在队列已满或为空时, 线程能够安全地等待。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><a href="http://benjaminwhx.com/2018/05/11/%E3%80%90%E7%BB%86%E8%B0%88Java%E5%B9%B6%E5%8F%91%E3%80%91%E8%B0%88%E8%B0%88LinkedBlockingQueue/">【细谈Java并发】谈谈LinkedBlockingQueue</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java BlockingQueue 简介</title>
      <link href="/article/2021/2968928754/"/>
      <url>/article/2021/2968928754/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>在 Java 中容器主要有 2 个大类 Collection 和 Map, 其中 Collection 主用用于数据的直接存储 (Map 则是一种键值对的存储方式, 除了要存储的数据外, 还需要有一个 key 和数据建立一个映射关系)。<br>Collection 使用的最多的大概就是 List, Set 和 Queue。<br>而在日常的开发中, 会根据不同数据的特性, 比如是否可重复, 是否需要有序等条件选择不同的集合, 同时还会考虑其他的因素, 比如线程是否安全。</p><p>而本文的主要是对基于 Queue 派生的另一个线程安全的接口 – BlockingQueue 做个简单的介绍。</p><p>在经典的“生产者-消费者”问题中, 队列通常被视为线程间操作的数据容器。这样一来, 我们能够将各个模块的业务功能解耦。生产者负责将其“生产”出来的数据放置在数据容器中, 而消费者则仅需在“数据容器”中获取数据。这种设计使得生产者线程和消费者线程能够实现解耦, 各自专注于自身的业务功能</p><p>而本篇主要对基于 Queue 派生的另一个线程安全的接口 BlockingQueue 做一个简单的介绍。</p><p>阻塞队列 (BlockingQueue) 被广泛使用在 “生产者-消费者” 问题中, 作为线程间操作的数据容器, 使得各个模块的业务功能进行解耦。生产者专注生产数据, 然后投递到队列中即可, 而消费者则从队列中获取数据, 然后专注消费数据。</p><p>BlockingQueue 能够高频的应用于 “生产者-消费者” 其原因是它提供了可阻塞的插入和移除的方法。<br><strong>当队列容器已满, 生产者线程会被阻塞, 直到队列未满；当队列容器为空时, 消费者线程会被阻塞, 直至队列非空时为止</strong>。</p><h2 id="2-BlockingQueue-的基本操作"><a href="#2-BlockingQueue-的基本操作" class="headerlink" title="2 BlockingQueue 的基本操作"></a>2 BlockingQueue 的基本操作</h2><p>几种不同的场景的新增删除和检查方法列表</p><table><thead><tr><th align="center"></th><th align="center">Throws Excepiton</th><th align="center">Special Value</th><th align="center">Blocks</th><th align="center">Times Out</th></tr></thead><tbody><tr><td align="center">insert</td><td align="center">add(e)</td><td align="center">offer(e)</td><td align="center">put(e)</td><td align="center">offer(e, time, unit)</td></tr><tr><td align="center">remove</td><td align="center">remove()</td><td align="center">poll()</td><td align="center">take()</td><td align="center">poll(time, unit)</td></tr><tr><td align="center">examine</td><td align="center">element()</td><td align="center">peek()</td><td align="center">not applicable</td><td align="center">not applicable</td></tr></tbody></table><p>新增数据</p><blockquote><ol><li>add(E e): 往队列插入数据, 当队列满时, 插入元素时会抛出 IllegalStateException 异常  </li><li>offer(E e): 当往队列插入数据时, 插入成功返回 true, 否则返回 false, 当队列满时不会抛出异常</li><li>put(E e): 当阻塞队列容量已经满时, 往阻塞队列插入数据的线程会被阻塞, 直至阻塞队列已经有空余的容量可供使用 </li><li>offer(E e, long timeout, TimeUnit unit)：若阻塞队列已经满时, 同样会阻塞插入数据的线程, 直至阻塞队列已经有空余的地方, 与 put 方法不同的是, 该方法会有一个超时时间, 若超过当前给定的超时时间, 插入数据的线程会退出</li></ol></blockquote><p>删除元素</p><blockquote><ol><li>remove(Object o)：从队列中删除数据, 成功则返回 true, 否则为 false </li><li>poll(): 删除队列中第一个的数据, 当队列为空时, 返回 null</li><li>take()：当阻塞队列为空时, 获取队头数据的线程会被阻塞  </li><li>poll(long timeout, TimeUnit unit): 当阻塞队列为空时, 获取数据的线程会被阻塞, 另外, 如果被阻塞的线程超过了给定的时长, 该线程会退出</li></ol></blockquote><p>查看元素</p><blockquote><ol><li>element(): 获取队头元素, 如果队列为空时则抛出 NoSuchElementException 异常  </li><li>peek()：获取队头元素, 如果队列为空, 返回 null</li></ol></blockquote><h2 id="3-常用的-BlockingQueue"><a href="#3-常用的-BlockingQueue" class="headerlink" title="3 常用的 BlockingQueue"></a>3 常用的 BlockingQueue</h2><p>实现 BlockingQueue 接口的有</p><blockquote><ol><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue </li><li>PriorityBlockingQueue</li><li>SynchronousQueue</li><li>LinkedTransferQueue</li><li>DelayQueue</li><li>LinkedBlockingDeque</li></ol></blockquote><p>而这几种常见的阻塞队列也是在实际编程中会常用的, 下面对这几种常见的阻塞队列进行说明。</p><h3 id="3-1-ArrayBlockingQueue"><a href="#3-1-ArrayBlockingQueue" class="headerlink" title="3.1 ArrayBlockingQueue"></a>3.1 ArrayBlockingQueue</h3><p>特点</p><blockquote><ol><li>ArrayBlockingQueue 一旦创建, 容量不能改变</li><li>ArrayBlockingQueue 是由数组实现的有界阻塞队列, 该队列里面的元素满足 FIFO (先进先出), 因此, 头元素在队列中存在时间最长, 而队尾数据则是当前队列最新的数据元素。   </li><li>ArrayBlockingQueue 可作为 “有界数据缓冲区”, 生产者插入数据到队列容器中, 并由消费者提取。  </li><li>当队列容量满时, 尝试将元素放入队列将导致操作阻塞, 同理尝试从一个空队列中取一个元素也会同样阻塞。</li></ol></blockquote><p>ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性。<br>所谓公平性是指严格按照线程等待的绝对时间顺序, 即最先等待的线程能够最先访问到 ArrayBlockingQueue 中的数据。<br>而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序。有可能存在, ArrayBlockingQueue 从无数据变为有数据, 即可被访问时, 长时间阻塞的线程依然无法访问到 ArrayBlockingQueue。<br>如果需要保证公平性, 可以在声明 ArrayBlockingQueue 的时候指明公平锁, 但是这通常会降低吞吐量。</p><p>ArrayBlockingQueue 的声明:  </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// true 公平竞争  false 非公平竞争</span><span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>容量大小<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><h3 id="3-2-LinkedBlockingQueue"><a href="#3-2-LinkedBlockingQueue" class="headerlink" title="3.2 LinkedBlockingQueue"></a>3.2 LinkedBlockingQueue</h3><p>LinkedBlockingQueue 是用链表实现的有界阻塞队列, 同样满足 FIFO 的特性, 与 ArrayBlockingQueue 相比起来具有更高的吞吐量, 为了防止 LinkedBlockingQueue 容量迅速增, 损耗大量内存。<br>通常在创建 LinkedBlockingQueue 对象时, 会指定其大小, 如果未指定, 容量等于 Integer.MAX_VALUE。</p><h3 id="3-3-PriorityBlockingQueue"><a href="#3-3-PriorityBlockingQueue" class="headerlink" title="3.3 PriorityBlockingQueue"></a>3.3 PriorityBlockingQueue</h3><p>PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。<br>默认情况下元素采用自然顺序进行排序, 也可以通过自定义类实现 compareTo() 方法来指定元素排序规则, 或者初始化时通过构造器参数 Comparator 来指定排序规则。</p><h3 id="3-4-SynchronousQueue"><a href="#3-4-SynchronousQueue" class="headerlink" title="3.4 SynchronousQueue"></a>3.4 SynchronousQueue</h3><p>SynchronousQueue 每个插入操作必须等待另一个线程进行相应的删除操作, 因此, SynchronousQueue 实际上没有存储任何数据元素, 因为只有线程在删除数据时, 其他线程才能插入数据。<br>同样的, 如果当前有线程在插入数据时, 线程才能删除数据。SynchronousQueue 也可以通过构造器参数来为其指定公平性。</p><h3 id="3-5-LinkedTransferQueue"><a href="#3-5-LinkedTransferQueue" class="headerlink" title="3.5 LinkedTransferQueue"></a>3.5 LinkedTransferQueue</h3><p>LinkedTransferQueue 是一个由链表数构成的无界阻塞队列, 由于该队列实现了 TransferQueue 接口, 与其他阻塞队列相比主要有以下不同的方法</p><p><strong>transfer(E e)</strong>: 如果当前有线程 (消费者) 正在调用 take() 方法或者可延时的 poll() 方法进行消费数据时, 生产者线程可以调用这个方法将数据传递给消费者线程。<br>如果当前没有消费者线程的话, 生产者线程就会将数据插入到队尾, 直到有消费者能够进行消费才能退出</p><p><strong>tryTransfer(E e)</strong>: 如果当前有线程 (消费者) 正在调用 take() 方法或者可延时的 poll() 方法进行消费数据时, 生产者线程可以调用这个方法将数据立即传送给消费者线程, 如果当前没有消费者线程消费数据的话, 就立即返回 false。  </p><p>因此, 与 transfer 方法相比, transfer 方法是必须等到有消费者线程消费数据时, 生产者线程才能够返回。而 tryTransfer 方法能够立即返回结果退出。</p><p><strong>tryTransfer(E e,long timeout,imeUnit unit)</strong>: 与 transfer 基本功能一样, 只是增加了超时特性, 如果数据到了规定的超时时间内没有消费者进行消费的话, 就返回 false。  </p><h3 id="3-6-DelayQueue"><a href="#3-6-DelayQueue" class="headerlink" title="3.6 DelayQueue"></a>3.6 DelayQueue</h3><p>DelayQueue 是一个存放实现 Delayed 接口的数据的无界阻塞队列, 只有当数据对象的延时时间达到时才能插入到队列进行存储。如果当前所有的数据都还没有达到创建时所指定的延时期,<br>则队列没有队头, 并且线程通过 poll() 等方法获取数据元素则返回 null。</p><p>所谓数据延时期满时, 则是通过 Delayed 接口的 <strong>long getDelay(TimeUnit unit)</strong> 进行判定,<br>如果该方法返回的是小于等于 0 则说明该数据元素的延时期已满。</p><h3 id="3-7-LinkedBlockingDeque"><a href="#3-7-LinkedBlockingDeque" class="headerlink" title="3.7 LinkedBlockingDeque"></a>3.7 LinkedBlockingDeque</h3><p>LinkedBlockingDeque 是基于链表实现的有界阻塞双端队列, 如果在创建对象时为指定大小时, 其默认大小为 Integer.MAX_VALUE。<br>与 LinkedBlockingQueue 相比, 主要的不同点在于, LinkedBlockingDeque 具有双端队列的特性。 所以其提供的增删操作的方法有些不同。</p><p><strong>头部操作</strong>    </p><table><thead><tr><th align="center"></th><th align="center">Throws Excepiton</th><th align="center">Special Value</th><th align="center">Blocks</th><th align="center">Times Out</th></tr></thead><tbody><tr><td align="center">insert</td><td align="center">addFirst(e)</td><td align="center">offerFirst(e)</td><td align="center">putFirst(e)</td><td align="center">offerFirst(e, time, unit)</td></tr><tr><td align="center">remove</td><td align="center">removeFirst()</td><td align="center">pollFirst()</td><td align="center">takeFirst()</td><td align="center">pollFirst(time, unit)</td></tr><tr><td align="center">examine</td><td align="center">getFirst()</td><td align="center">peekFirst()</td><td align="center">not applicable</td><td align="center">not applicable</td></tr></tbody></table><p><strong>尾部操作</strong>    </p><table><thead><tr><th align="center"></th><th align="center">Throws Excepiton</th><th align="center">Special Value</th><th align="center">Blocks</th><th align="center">Times Out</th></tr></thead><tbody><tr><td align="center">insert</td><td align="center">addLast(e)</td><td align="center">offerLast(e)</td><td align="center">putLast(e)</td><td align="center">offerLast(e, time, unit)</td></tr><tr><td align="center">remove</td><td align="center">removeLast()</td><td align="center">pollLast()</td><td align="center">takeLast()</td><td align="center">pollLast(time, unit)</td></tr><tr><td align="center">examine</td><td align="center">getLast()</td><td align="center">peekLast()</td><td align="center">not applicable</td><td align="center">not applicable</td></tr></tbody></table><p>LinkedBlockingDeque 的基本操作可以分为四种类型:   </p><blockquote><ol><li>特殊情况, 抛出异常</li><li>特殊情况, 返回特殊值如 null 或者 false  </li><li>当线程不满足操作条件时, 线程会被阻塞直至条件满足   </li><li>操作具有超时特性</li></ol></blockquote><p>另外, LinkedBlockingDeque 实现了 BlockingDueue 接口, 而 LinkedBlockingQueue 实现的是 BlockingQueue, 这两个接口的主要区别如下</p><p><strong>Insert</strong>  </p><table><thead><tr><th align="center"></th><th align="center">Throws Excepiton</th><th align="center">Special Value</th><th align="center">Blocks</th><th align="center">Times Out</th></tr></thead><tbody><tr><td align="center">BlockingDeque</td><td align="center">addLast(e)</td><td align="center">offerLast(e)</td><td align="center">putLast(e)</td><td align="center">offerLast(e, time, unit)</td></tr><tr><td align="center">BlockingQueue</td><td align="center">add(e)</td><td align="center">offer(e)</td><td align="center">put(e)</td><td align="center">offer(e, time, unit)</td></tr></tbody></table><p><strong>Remove</strong>  </p><table><thead><tr><th align="center"></th><th align="center">Throws Excepiton</th><th align="center">Special Value</th><th align="center">Blocks</th><th align="center">Times Out</th></tr></thead><tbody><tr><td align="center">BlockingDeque</td><td align="center">removeFist()</td><td align="center">pollFirst()</td><td align="center">takeFirst()</td><td align="center">pollFirst(time, unit)</td></tr><tr><td align="center">BlockingQueue</td><td align="center">remove()</td><td align="center">poll()</td><td align="center">take(e)</td><td align="center">poll(e, time, unit)</td></tr></tbody></table><p><strong>Examine</strong>  </p><table><thead><tr><th align="center"></th><th align="center">Throws Excepiton</th><th align="center">Special Value</th><th align="center">Blocks</th><th align="center">Times Out</th></tr></thead><tbody><tr><td align="center">BlockingDeque</td><td align="center">getFirst()</td><td align="center">peeKFirst()</td><td align="center">not applicable</td><td align="center">not applicable</td></tr><tr><td align="center">BlockingQueue</td><td align="center">element()</td><td align="center">peek()</td><td align="center">not applicable</td><td align="center">not applicable</td></tr></tbody></table><p>从上可以看出, 两个接口的很多功能是可以等价使用的, 比如 BlockingQueue 的 add 方法和 BlockingDeque 的 addLast 方法的功能是一样的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentLinkedQueue</title>
      <link href="/article/2021/143166105/"/>
      <url>/article/2021/143166105/</url>
      
        <content type="html"><![CDATA[<p>在日常中, 我们用到的数据结构有很多: 数组, 链表, 树等, 而在这些结构中, 还有一个叫做队列的存在。<br>和其他的集合相同, Java 原生提供了不同的实现。<br>而如果我们需要一个线程安全的队列的话, 可以基于实际的场景进行选择, 比如基于数组实现同时操作上会阻塞的 ArrayBlockingQueue, 基于链表同时也会阻塞的 LinkedBlockingDeque。<br>而今天我们聊的同样也是基于链表实现的线程安全的 ConcurrentLinkedQueue。</p><h2 id="1-ConcurrentLinkedQueue-简单介绍"><a href="#1-ConcurrentLinkedQueue-简单介绍" class="headerlink" title="1 ConcurrentLinkedQueue 简单介绍"></a>1 ConcurrentLinkedQueue 简单介绍</h2><p>ConcurrentLinkedQueue 是 Java 中的一个并发队列实现, 位于 java.util.concurrent 包下。<br>它提供了一个基于链表实现的无界线程安全队列, 采用非阻塞算法实现并发操作。主要特点包括: </p><blockquote><ol><li>无界队列:  ConcurrentLinkedQueue 不限制队列的大小, 可以动态地增长</li><li>非阻塞算法:  内部实现采用了非阻塞算法, 避免了传统锁的性能开销, 提高了并发性能</li><li>线程安全:  所有的操作都是线程安全的, 不需要额外的同步手段, 主用是通过 CAS（Compare and Swap）等无锁算法来实现的</li><li>高性能:  适用于高并发场景, 由于采用非阻塞算法, 避免了大部分锁的争用, 因而具有较好的性能表现</li><li>FIFO 顺序:  队列遵循先进先出（FIFO）的原则, 保持元素插入的顺序</li></ol></blockquote><p>使用 ConcurrentLinkedQueue 可以方便地实现生产者 - 消费者模型, 适用于多线程环境下需要高效并发操作的场景。<br>需要注意的是, 由于该队列是无界的, 需要合理控制生产者的速度, 以防止队列无限制地增长。</p><h2 id="2-存储数据的节点-Node"><a href="#2-存储数据的节点-Node" class="headerlink" title="2 存储数据的节点 Node"></a>2 存储数据的节点 Node</h2><p>ConcurrentLinkedQueue 虽然叫做队列, 但是在内部的实现中是通过链表的方式实现的。<br>而说到链表就绕不开一个重要的属性: 链表的节点。</p><h3 id="2-1-节点的属性定义"><a href="#2-1-节点的属性定义" class="headerlink" title="2.1 节点的属性定义"></a>2.1 节点的属性定义</h3><p>在 ConcurrentLinkedQueue 中的节点定义很简单</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 链表节点定义</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">/**        * 节点的数据         */</span>        <span class="token keyword">volatile</span> <span class="token class-name">E</span> item<span class="token punctuation">;</span>        <span class="token comment">/**        * 下一个节点        */</span>        <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>这个节点的定义很简单, 就 2 个属性</p><blockquote><ol><li>item: 存储在节点里面的数据</li><li>next: 下一个节点</li></ol></blockquote><p>有些特殊的就是 item 和 next 都是用 volatile 修饰的, 保证了其可见性。</p><h3 id="2-2-节点的方法"><a href="#2-2-节点的方法" class="headerlink" title="2.2 节点的方法"></a>2.2 节点的方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 链表节点定义</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">/**         * CAS 更改 Node 中的数据域 item         * @param cmp  旧值         * @param val  新值         */</span>        <span class="token keyword">boolean</span> <span class="token function">casItem</span><span class="token punctuation">(</span><span class="token class-name">E</span> cmp<span class="token punctuation">,</span> <span class="token class-name">E</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> itemOffset<span class="token punctuation">,</span> cmp<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/**         * CAS 更改 Node 中的指针域 next, 也就是修改当前节点的下一个节点         * @param val 新的值         */</span>        <span class="token keyword">void</span> <span class="token function">lazySetNext</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">putOrderedObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nextOffset<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/**         * 通过 CAS 将 Node 中的 next 指针从 cmp 设置为 val         * 涉及 cas 的旧值比较, 一样才会替换         * @param cmp 旧值         * @param val 新值         */</span>        <span class="token keyword">boolean</span> <span class="token function">casNext</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> cmp<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nextOffset<span class="token punctuation">,</span> cmp<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>Node 本身就只提供了这 3 个方法, 这些方法实际上是通同 UNSAFE 的方法, 达到 CAS 式的修改值, 具备着原子性。</p><h3 id="2-3-节点在-ConcurrentLinkedQueue-中的使用"><a href="#2-3-节点在-ConcurrentLinkedQueue-中的使用" class="headerlink" title="2.3 节点在 ConcurrentLinkedQueue 中的使用"></a>2.3 节点在 ConcurrentLinkedQueue 中的使用</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** 头结点 */</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> head<span class="token punctuation">;</span><span class="token comment">/** 尾结点 */</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> tail<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    head <span class="token operator">=</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>head, tail 2 个节点分别代表了链表的头和尾, 而 ConcurrentLinkedQueue 就是通过这 2 个节点对队列进行管理的。  </p><p>通过无参的构造函数构造后, ConcurrentLinkedQueue 的结构如下:</p><p><img src="https://pic.imgdb.cn/item/657c56a4c458853aefd5d56d.png" alt="Alt &#39;ConcurrentLinkedQueue 初始状态&#39;"></p><p>一个很简单的链表。</p><h2 id="3-ConcurrentLinkedQueue-的源码实现"><a href="#3-ConcurrentLinkedQueue-的源码实现" class="headerlink" title="3 ConcurrentLinkedQueue 的源码实现"></a>3 ConcurrentLinkedQueue 的源码实现</h2><h3 id="3-1-ConcurrentLinkedQueue-的构造函数"><a href="#3-1-ConcurrentLinkedQueue-的构造函数" class="headerlink" title="3.1 ConcurrentLinkedQueue 的构造函数"></a>3.1 ConcurrentLinkedQueue 的构造函数</h3><p>ConcurrentLinkedQueue 的声明有 2 种 方式</p><p><strong>第一种: 无参的构造函数</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        head <span class="token operator">=</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>声明了一个值为空的节点, 并将头尾指针都指向这个节点, 结束。</p><p><strong>第二种: 带 Collection 参数的构造方法</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 临时的头尾指针, 用来处理程序运行中的临时变量</span>      <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> h <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 遍历入参的集合</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">/// 检查入参的数据是否为 null, 为 null 的话, 抛出异常</span>            <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 将数据封装为 Node 节点</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 临时头节点为 null, 将当前节点设置为头节点和尾结点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>          h <span class="token operator">=</span> t <span class="token operator">=</span> newNode<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 通过 CAS, 设置当前的尾结点节点的下一个节点 (next 属性) 为 newNode</span>                t<span class="token punctuation">.</span><span class="token function">lazySetNext</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 更新当前的尾结点节点为新创建的节点, 也就是更新临时尾指针的位置</span>                t <span class="token operator">=</span> newNode<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>        <span class="token comment">// 头指针为空的话, 创建一个新的空值节点, 并将其赋给临时头尾指针</span>        <span class="token comment">// 如果入参的集合为空, 就存在这种可能</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            h <span class="token operator">=</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 真正地更新头指针</span>        head <span class="token operator">=</span> h<span class="token punctuation">;</span>        <span class="token comment">// 真正地更新尾指针</span>        tail <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>ConcurrentLinkedQueue 的构造方法很简单, 基本就是创建维护了一个链表, 自身持有了链表的头尾节点的引用。</p><h3 id="3-2-ConcurrentLinkedQueue-新增数据-offer-方法"><a href="#3-2-ConcurrentLinkedQueue-新增数据-offer-方法" class="headerlink" title="3.2 ConcurrentLinkedQueue 新增数据 - offer() 方法"></a>3.2 ConcurrentLinkedQueue 新增数据 - offer() 方法</h3><p>ConcurrentLinkedQueue 做为一个队列来说, 需要满足 FIFO 特性, 既插入元素总是在队列最末尾的地方进行插入, 而取 (移除) 元素总是从队列的队头。<br>那么可以从 offer(新增) 和 poll(取出) 2 个方法理解 ConcurrentLinkedQueue。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 非空判断, 为空会抛出空指针异常</span>        <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 把数据封装为 Node 节点</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 死循环,  将封装好的 Node 节点放到当前队列的尾部, 直到成功, 返回 true</span>        <span class="token comment">// p = t = tail = 尾结点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> t <span class="token operator">=</span> tail<span class="token punctuation">,</span> p <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// q = p 的下一个节点 = 当前尾节点的下一个节点</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> q <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment">// 通过 cas 将新增的节点设置在 p 的后面</span>            <span class="token comment">// 因为尾结点 p 的后一个节点 q 为空, 所以将 p 的下一个节点设置为 newNode 成功后, 这时候 newNode 就是队列的尾部了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">casNext</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 当前节点设置在尾部成功了</span>                <span class="token comment">// 当 p != t 时, 将创建的节点更新为尾部</span>                <span class="token comment">// 什么时候会出现 p 不等于 t? 可以从放入第二个元素时开始考虑</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> t<span class="token punctuation">)</span>                    <span class="token comment">// 通过 cas 尝试将 tail 从 t 设置为 newNode</span>                    <span class="token comment">// 设置成功/失败都没关系,  即使失败了, 在后续的循环进行重新更新</span>                    <span class="token function">casTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 返回 true, 结束死循环</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 当前的 p 的 next 节点 q, 等于 q 自身, </span>            <span class="token comment">// 这种情况一般会出现在有线程新增和有线程进行删除的情况, 我们可以在了解了 poll 后, 在回来看</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> q<span class="token punctuation">)</span>                <span class="token comment">// 尾结点变了 ? 取新的尾结点 : 头结点</span>                p <span class="token operator">=</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> tail<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> t <span class="token operator">:</span> head<span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token comment">// p 不等于 t, 同时 tail 被别的线程修改了, 直接取修改后的尾结点 t, 没有的话, 取下一个节点</span>                p <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> tail<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> t <span class="token operator">:</span> q<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * cas 操作, 将当前队列的 tail 从 cmp 设置为 val     *     * @param cmp 旧值     * @param val 新值     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">casTail</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> cmp<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tailOffset<span class="token punctuation">,</span> cmp<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>offer 方法里面的 for 循环分析</strong>    </p><p>注: 规定 ConcurrentLinkedQueue 是通过无参的构造方法声明的, 初始的节点为 Node-0</p><p>第一次往里面放数据时 (存放的值为 e)</p><blockquote><ol><li>Node p &#x3D; Node t &#x3D; tail,  tail 指向的是一个值为 null, next 为 null 的初始节点 Node-0 </li><li>Node q &#x3D; p.next, 因为 tail.next &#x3D; null, 所以 q &#x3D; null  </li><li>走进 if 里面的判断, 通过 cas 操作, 将 p.next 从 null 设置为 newNode 节点  </li><li>cas 设置成功了, 进入到里面的第二个 if, 这时候 p 还是等于 t 的, 所以直接返回 true</li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/657c56a6c458853aefd5e15f.png" alt="Alt &#39;ConcurrentLinkedQueue 新增一个元素后的状态&#39;"></p><p>如图, 此时队列的尾节点应该为 Node-1, 而 tail 指向的节点依然还是 Node-0, 从上面的流程看下来, 也没有对 tail 指针重试设置指向尾部的操作 (实际 tail 的重新指向最新的尾结点的, 由下次的添加数据进行更新),<br>所以 ConcurrentLinkedQueue 内的 tail 并不一定都是指向尾指针, 具有延迟性。</p><p>第二次往里面放数据时 (存放的值为 f)</p><blockquote><ol><li>Node p &#x3D; Node t &#x3D; tail,  tail 指向的是一个值为 e, next 为 Node-1 的初始节点 Node-0  </li><li>Node q &#x3D; p.next, 这时候因为 p &#x3D; tail, tail.next &#x3D; Node-1, 所以 q &#x3D; Node-1  </li><li>因为 p.next 不等于 null,  p !&#x3D; q, 所以走到了 else 里面的逻辑, 这时候 p &#x3D;&#x3D; t 的, 所以 p &#x3D; q, 也就是 p &#x3D; Node-1 了</li><li>回到循环体的第一步, Node q &#x3D; p.next &#x3D; Node-1.next &#x3D; null, 所以 q &#x3D; null</li><li>走进 if 里面的判断, 通过 cas 操作, 将 p.next 从设置为 newNode 节点</li><li>这时 p !&#x3D; t 了, 通过 cas 操作将 tail 从 t 设置到 newNode, 更新尾结点 tail</li></ol></blockquote><p>这时候的样子为<br><img src="https://pic.imgdb.cn/item/657c56a7c458853aefd5e7e2.png" alt="Alt &#39;ConcurrentLinkedQueue 新增两个元素后的状态&#39;"></p><p>通过分析, 我们可以整理出 poll 的执行逻辑为</p><blockquote><ol><li>如果 tail 指向的节点的下一个节点 (next 域) 为 null 的话, 说明 tail 指向的节点即为队列真正的队尾节点, 因此可以通过 casNext 插入当前待插入的节点, 但此时 tail 并未变化</li><li>如果 tail 指向的节点的下一个节点 (next 域) 不为 null 的话, 说明 tail 指向的节点不是队列的真正队尾节点。通过q (Node<E> q &#x3D; p.next) 指针往前递进去找到队尾节点, 然后通过 casNext 插入当前待插入的节点, 并通过 casTail 方式更改 tail</li></ol></blockquote><p>不知道你有没有留意到 <code>p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</code> 这行代码呢?<br>按照我们上面一步一步的分析下去，p 不可能被赋值为 t 的。 那么我们需要从多线程的角度思考了。</p><p><strong>从多线程分析 offer 方法</strong>  </p><p>其实在多线程环境下这行代码很有意思的。<strong>t !&#x3D; (t &#x3D; tail)</strong> 这个操作并非一个原子操作, 这个可以看成 2 个效果</p><blockquote><ol><li>t &#x3D; tail</li><li>判断赋值前的 t !&#x3D; tail</li></ol></blockquote><p>在循环中一开始 t &#x3D; tail, 那么在多线程的情况下可能存在另一个线程将 tail 修改了, 导致了 t !&#x3D; tail。<br>至于为什么 <strong>t !&#x3D; (t &#x3D; tail)</strong> 是旧的 t 值和修改后的 tail 进行比较，因为涉及到一点 JVM 的知识, 感兴趣的, 可以看一下下文的附录, 这里就不展开了。</p><h3 id="3-3-ConcurrentLinkedQueue-删除数据-poll-方法"><a href="#3-3-ConcurrentLinkedQueue-删除数据-poll-方法" class="headerlink" title="3.3 ConcurrentLinkedQueue 删除数据 - poll() 方法"></a>3.3 ConcurrentLinkedQueue 删除数据 - poll() 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Java 标签写法</span>    restartFromHead<span class="token operator">:</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// p = h = head = 头节点, q = null</span>            <span class="token comment">// 从头部往后遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> h <span class="token operator">=</span> head<span class="token punctuation">,</span> p <span class="token operator">=</span> h<span class="token punctuation">,</span> q<span class="token punctuation">;</span><span class="token punctuation">;</span> p <span class="token operator">=</span> q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">final</span> <span class="token class-name">E</span> item<span class="token punctuation">;</span>                                <span class="token comment">// 将 p 的值赋给 item， item 不为空同时通过 cas 将 p 的 item 属性从 item 设置为 null</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>item <span class="token operator">=</span> p<span class="token punctuation">.</span>item<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span><span class="token function">casItem</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 设置成功了 出现了 p 的节点 不等于 h 也就是 head 节点, 更新头节点</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> h<span class="token punctuation">)</span>                         <span class="token comment">// 更新最新的头部</span>                        <span class="token comment">// p 的下一个节点不为 null 吗 ? 是的话就取 p 的下一个节点，不是的话，还是取 p</span>                        <span class="token function">updateHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>q <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> q <span class="token operator">:</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 返回 item 值</span>                    <span class="token keyword">return</span> item<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                 <span class="token comment">// 没有其他的节点了</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>q <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 把头节点从 h 设置为 p</span>                    <span class="token function">updateHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                            <span class="token comment">// p q 是同一个节点, 回到循环头部, 重新开始</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> q<span class="token punctuation">)</span>                    <span class="token keyword">continue</span> restartFromHead<span class="token punctuation">;</span>                <span class="token keyword">else</span>                    <span class="token comment">// 剩余的情况, p = q</span>                    p <span class="token operator">=</span> q<span class="token punctuation">;</span>             <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 尝试更新头结点     * @param h 头节点当前的值     * @param p 头节点将要被设置的值     */</span>    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">updateHead</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> h<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> p <span class="token operator">&amp;&amp;</span> <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span>            h<span class="token punctuation">.</span><span class="token function">lazySetNext</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>一看到这段代码，第一眼应该是感觉到奇怪吧<br><code>restartFromHead:</code> Java 的一个标签语法支持，搭配 break, continue, 可以直接跳出循环, 类似于 goto 的特性。</p><p>ok，进入代码的分析</p><p><strong>poll 方法里面的 for 循环分析</strong></p><p>假设初始的链表的样子为<br><img src="https://pic.imgdb.cn/item/657c56a7c458853aefd5e7e2.png" alt="Alt &#39;ConcurrentLinkedQueue 新增两个元素后的状态&#39;"></p><p>第一次往里面取数据时</p><blockquote><ol><li>Node h &#x3D; Node p &#x3D; head &#x3D; 队列的头结点</li><li>取到头结点的值 item</li><li>item 不为空, 尝试通过 cas 将 p 也就是头结点的 item 属性设置为 null</li><li>更新成功了, 这时候 p &#x3D;&#x3D; h,  直接返回 item 值</li></ol></blockquote><p>这时候 head 还是没有改变，还是指向了原来的头结点, 同时 head 节点的 item 属性等于 null, next 执行了下一个节点</p><p><img src="https://pic.imgdb.cn/item/657c56a9c458853aefd5eed6.png" alt="Alt &#39;ConcurrentLinkedQueue 删除一个元素后的状态&#39;"></p><p>第二次往里面取数据  </p><blockquote><ol><li>Node h &#x3D; Node p &#x3D; head &#x3D; 队列的头结点  </li><li>取到头结点的值 item  </li><li>经过第一次后，这时候 item &#x3D;&#x3D; null, 走下一个判断  </li><li>(q &#x3D; p.next) 不为 null, 走下一个判断  </li><li>q &#x3D; p.next, p !&#x3D; q, 走下一个判断  </li><li>这时候走到了最后的 else, 也就是 p &#x3D; q 也就是 p &#x3D; p.next  </li><li>又回到循环的头部, 次数 item &#x3D; p.item  </li><li>item 不为空, 尝试通过 CAS 将 p 也就是头结点的 item 属性设置为 null  </li><li>更新成功了, 这时候 p !&#x3D; h, 进入到判断内部  </li><li>这时候的 p 的 item 为空了，p 的下一个节点不为空的话，将 p 的下一个节点设置为新的头结点，如果 p 的下一个节点为空的话, 也就是队列没有其他的节点了, 那么只能取 p 作为尾结点了  </li><li>进入到 updateHead 方法， h !&#x3D; p, 同时将头节点从 h 也就是 head 设置为 p</li><li>更新头节点成功后，将原本旧的头节点 h 的 next 设置为自身，这种 next 指向自身的节点称之为<strong>哨兵节点</strong>,  一般表示为要删除的节点或者是空节点  </li><li>返回 item 值，结束</li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/657c56aac458853aefd5f4b2.png" alt="Alt &#39;ConcurrentLinkedQueue 删除两个元素后的状态&#39;"></p><p>按照上面的流程，循环体内的判断还有 1 个 <strong>else if</strong> 的逻辑是不会走进去的，那么什么情况下, 才会跨入这个判断</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> q<span class="token punctuation">)</span>    <span class="token keyword">continue</span> restartFromHead<span class="token punctuation">;</span></code></pre><p>这个判断主要用于处理多个线程 poll 的情况, q &#x3D; p.next 也就是说 q 永远指向的是 p 的下一个节点，那么什么情况下会使得 p, q 指向同一个节点呢?<br>根据上面我们的分析，只有 p 指向的节点在 poll 的时候转变成了哨兵节点 (通过 updateHead 方法中的 h.lazySetNext),<br>当线程 A 在判断 p&#x3D;&#x3D;q 时，线程 B 已经将执行完 poll 方法将 p 指向的节点转换为哨兵节点并且 head 指向的节点已经发生了改变, 所以就需要从 restartFromHead 处执行，保证用到的是最新的 head。</p><h2 id="4-部分线程执行-offer-方法-部分线程执行-poll-方法"><a href="#4-部分线程执行-offer-方法-部分线程执行-poll-方法" class="headerlink" title="4 部分线程执行 offer() 方法, 部分线程执行 poll() 方法"></a>4 部分线程执行 offer() 方法, 部分线程执行 poll() 方法</h2><p>在分析 offer 方法的时候我们还留下了一个问题 <code>if (p == q)</code> 让 if 判断为 true 的情况为 p 指向的节点为哨兵节点，而什么时候会构造哨兵节点呢?<br>在对 poll 方法的讨论中，我们已经找到了答案，即<strong>当 head 指向的节点的 item 域为 null 时会寻找真正的队头节点，等到待插入的节点插入之后，会更新 head，并且将原来 head 指向的节点设置为哨兵节点</strong>。</p><p><img src="https://pic.imgdb.cn/item/657c56abc458853aefd5fb66.png" alt="Alt &#39;ConcurrentLinkedQueue 取和增同时存在状态&#39;"></p><p>模拟一下，大概是这样的过程:</p><p><strong>第一步: 初始队列</strong><br>这时，只要一个节点 Node-0, tail 和 head 都指向 Node-0</p><p><strong>第二步: 线程 A 放入一个元素 e</strong><br>这时，新增了一个节点 Node-1, tail 和 head 都还是指向 Node-0</p><p><strong>第三步: 线程 B 取出一个节点</strong><br>这时, head 指向了 Node-1, 但是 tail 还是指向了一个 next 指向自己的哨兵节点 Node-0</p><p><strong>第四步：线程 A 继续放入一个元素 f</strong><br>一开始 Node p &#x3D; Node t &#x3D; tail, Node q &#x3D; p.next &#x3D; q, 所以 p &#x3D;&#x3D; q 成立了。这时候，tail 没变，所以 t !&#x3D; t 为 false, t 取值变为 head。</p><h2 id="5-HOPS-设计"><a href="#5-HOPS-设计" class="headerlink" title="5 HOPS 设计"></a>5 HOPS 设计</h2><p>通过上面对 offer 和 poll 方法的分析，可以发现 tail 和 head 是延迟更新的，两者更新触发时机为:    </p><p><strong>tail 更新触发时机:</strong> 当 tail 指向的节点的下一个节点不为 null 的时候, 会执行定位队列真正的队尾节点的操作, 找到队尾节点后完成插入之后才会通过 casTail 进行 tail 更新。<br>当 tail 指向的节点的下一个节点为 null 的时候，只插入节点不更新 tail</p><p><strong>head 更新触发时机:</strong> 当 head 指向的节点的 item 域为 null 的时候，会执行定位队列真正的队头节点的操作, 找到队头节点后完成删除之后才会通过 updateHead 进行 head 更新,<br>当 head 指向的节点的 item 域不为 null 的时候，只删除节点不更新 head</p><p>并且在更新操作时，源码中会有注释为<strong>hop two nodes at a time</strong>, 所以这种延迟更新的策略就被叫做 HOPS 的大概原因是这个。从上面更新时的状态图可以看出，<br>head 和 tail 的更新是 “跳着的”, 即中间总是间隔了一个。那么这样设计的意图是什么呢？</p><p>如果让 tail 永远作为队列的队尾节点，实现的代码量会更少，而且逻辑更易懂。但是，这样做有一个缺点: <strong>如果大量的入队操作，每次都要执行 cas 进行 tail 的更新，汇总起来对性能也会是大大的损耗</strong>。<br>如果能减少 cas 更新的操作，无疑可以大大提升入队的操作效率，每间隔 1 次 (tail 和队尾节点的距离为 1) 才利用 cas 更新 tail。 对 head 的更新也是同样的道理。<br>虽然，这样设计会多出在循环中定位队尾节点，但总体来说读的操作效率要远远高于写的性能，因此，多出来的在循环中定位尾节点的操作的性能损耗相对而言是很小的。</p><h2 id="6-附录"><a href="#6-附录" class="headerlink" title="6 附录"></a>6 附录</h2><p>在上面的 offer() 方法中有一段代码 <code>(p != t &amp;&amp; t != (t = tail))</code>, 有说到 <code>t != (t = tail)</code>, 中实际的效果是 先把当前的 tail 赋值给 t, 然后用赋值前的 t 判断是否等于 tail。</p><p>这设计到 JVM 的<strong>操作数栈</strong>和<strong>局部变量表</strong> 的部分知识。</p><p>可以简单的先理解当前有一个栈和一堆人为定义好的操作指令。这些指令会将各种数据往这个栈里面扔数据, 获取数据等。<br>还有一个局部变量表, 可以简单的看出一个 HashMap, 方法中声明的变量, 变量的值都存在这个 HashMap 中。</p><p>几个等一下需要用到的指令:  </p><table><thead><tr><th align="center">直接指令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">bipush</td><td align="left">将单字节的常量值（-128 ~ 127）推送至栈顶</td></tr><tr><td align="center">istore_{n}</td><td align="left">将栈顶的整数弹出，并且赋值给局部变量表中的 index 为 n 的元素</td></tr><tr><td align="center">iload_{n}</td><td align="left">局部变量表中的 index 为 n 的元素放到栈顶</td></tr><tr><td align="center">if_icmpeq</td><td align="left">比较栈顶两 int 型数值大小，当结果等于 0 时跳转</td></tr><tr><td align="center">dup</td><td align="left">复制栈顶数值并将复制值压入栈顶</td></tr><tr><td align="center">iconst_{0}</td><td align="left">将 int 型 n 推送至栈顶</td></tr></tbody></table><p>看一下, 下面的例子</p><p>先看一下 <strong>p, t</strong> 不相同的情况。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token keyword">int</span> tail <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>                <span class="token comment">// 因为 p = t = 8 </span>        <span class="token comment">// 所以第一步 p != t 就是 false, 后面的逻辑可以省略, 不进行比较了</span>                <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> tail<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"p="</span> <span class="token operator">+</span> p <span class="token operator">+</span> <span class="token string">", t="</span> <span class="token operator">+</span> t <span class="token operator">+</span> <span class="token string">", result="</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>上面的代码修改为字节码的形式如下:</p><pre class="language-none"><code class="language-none">public class Main &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 在栈顶 放入 8        0: bipush        8             &#x2F;&#x2F; 将栈顶（8）弹出，放到局部变量表第二个的位置(t)        2: istore_1        &#x2F;&#x2F; 将局部变量表第二个的位置(t)的值(8)，压到栈顶        3: iload_1        &#x2F;&#x2F; 将栈顶（8）弹出，放到局部变量表第三个的位置(p)        4: istore_2        &#x2F;&#x2F; 在栈顶 放入 9        5: bipush        9        &#x2F;&#x2F; 将栈顶（9）弹出，放到局部变量表第四个的位置(tail)        7: istore_3        &#x2F;&#x2F; 将局部变量表第三个的位置(p)的值，压到栈顶        8: iload_2        &#x2F;&#x2F; 将局部变量表第二个的位置(t)的值，压到栈顶        9: iload_1        &#x2F;&#x2F; p &#x3D; 8, t &#x3D; 8  2个的比较结果等于 false(0) , 跳转到 24        10: if_icmpeq     24        13: iload_1        14: iload_3        15: dup        16: istore_1        17: if_icmpeq     24        20: iconst_1        21: goto          25        &#x2F;&#x2F; 在栈顶压入 0 这里的 0 可以看为 false        24: iconst_0        &#x2F;&#x2F; 将栈顶（0）弹出，放到局部变量表第五个的位置(result)        25: istore        4        &#x2F;&#x2F; 输出        27: getstatic     #7                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;        30: iload_2        31: iload_1        32: iload         4        34: invokedynamic #13,  0             &#x2F;&#x2F; InvokeDynamic #0:makeConcatWithConstants:(IIZ)Ljava&#x2F;lang&#x2F;String;        39: invokevirtual #17                 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V        42: return&#125;&#125;</code></pre><p>再看一下 <strong>p, t</strong> 相同的情况，这时候的代码如下:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token keyword">int</span> tail <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>        <span class="token comment">// 因为 p = t = 8 </span>        <span class="token comment">// 所以第一步 p == t 就是 true, 进行后面的比较了</span>        <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> t <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> tail<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"p="</span> <span class="token operator">+</span> p <span class="token operator">+</span> <span class="token string">", t="</span> <span class="token operator">+</span> t <span class="token operator">+</span> <span class="token string">", result="</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>上面的代码修改为字节码的形式如下:</p><pre class="language-none"><code class="language-none">public class Main &#123;    public static void main(String[] args) &#123;0: bipush        8        2: istore_1        3: iload_1        4: istore_2        5: bipush        9        7: istore_3        8: iload_2        9: iload_1        &#x2F;&#x2F; 上面的流程差不多，省略        &#x2F;&#x2F; 比较 p &#x3D;&#x3D; t  结果为true(1) 不跳转，走下一步        10: if_icmpne     24        &#x2F;&#x2F; 将局部变量表第二个的位置(t)的值，压到栈顶        13: iload_1        &#x2F;&#x2F; 将局部变量表第四个的位置(tail)的值，压到栈顶        14: iload_3        &#x2F;&#x2F; 复制栈顶数值并将复制值压入栈顶。即复制 tail 变量值并压入栈顶(9)        15: dup        &#x2F;&#x2F; 将栈顶（9）弹出, 将栈顶数值存入局部变量表第二个的位置(t), 此时 t &#x3D; 9        16: istore_1        &#x2F;&#x2F; 比较栈顶两 int 型数值大小，也就是赋值前的 t 和 tail, 此时 8 !&#x3D; 9 结果为 true(1) 所以不会跳转到24行，继续执行下一行        17: if_icmpeq     24        &#x2F;&#x2F; 将 int 型 1 压入栈顶        20: iconst_1        &#x2F;&#x2F; 无条件跳转到 25 行        21: goto          25        24: iconst_0        &#x2F;&#x2F; 将栈顶 1 存入局部变量表第五个的位置，同时出栈 result &#x3D; 1        25: istore        4        &#x2F;&#x2F; 内容输出        27: getstatic     #7                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;        30: iload_2        31: iload_1        32: iload         4        34: invokedynamic #13,  0             &#x2F;&#x2F; InvokeDynamic #0:makeConcatWithConstants:(IIZ)Ljava&#x2F;lang&#x2F;String;        39: invokevirtual #17                 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V        42: return&#125;&#125;</code></pre><p>通过上面字节码的逐步分析，我们可以得出 <code>t != (t = tail)</code> 实际的效果为</p><blockquote><ol><li>t &#x3D; tail</li><li>判断未改变值前的 t !&#x3D; tail</li></ol></blockquote><p>一旦有另一个线程将 tail 修改了，就会出现 t !&#x3D; tail 为 true</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h2><p><a href="https://github.com/CL0610/Java-concurrency/blob/master/15.%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentLinkedQueue/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentLinkedQueue.md">ConcurrentLinkedQueue简介</a><br><a href="https://www.cnblogs.com/zaizhoumo/p/7726218.html">Java并发容器–ConcurrentLinkedQueue</a>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java ConcurrentHashMap (JDK 1.8 版本)</title>
      <link href="/article/2021/403589194/"/>
      <url>/article/2021/403589194/</url>
      
        <content type="html"><![CDATA[<h2 id="1-ConcurrentHashMap-简介"><a href="#1-ConcurrentHashMap-简介" class="headerlink" title="1 ConcurrentHashMap 简介"></a>1 ConcurrentHashMap 简介</h2><p>Map 一种存储键值对 (key-value) 的数据结构, 可以通过 key 快速地定位到需要的 value, 在 Java 中是一个使用频率很高的一个数据结构。一般情况下, 我们都是可以直接使用它的实现类 HashMap 就能满足需求了。<br>但是 HashMap 在多线程情况, 并不是一个线程安全的类。<br>解决的方式有很多, 例如:</p><blockquote><ol><li>使用在 Java 体系中古老的 Hashtable 作为替代, 该类基本上所有的方法都采用 synchronized 进行线程安全的控制, 虽然保证了线程安全, 但是牺牲了很大的性能。 在高并发的情况下, 每次只有一个线程能够获取对象监视器锁, 这样的并发性能的确不令人满意。</li><li>通过 Collections 的 synchronizedMap(Map&lt;K,V&gt; m) 方法返回一个线程安全的 Map。但是这个的效果实际上和 Hashtable 的一样, 依然是采用 synchronized 独占式锁进行线程安全的并发控制的, 所以这种方案的性能也是令人不太满意的。</li></ol></blockquote><p>那么有没有一种既保证了线程安全性, 性能也不错的 Map 呢? ConcurrentHashMap 就是我们的选择了, 内部利用了<strong>锁分段</strong>的思想提高了并发度。当然的, 随着 JDK 的升级, ConcurrentHashMap 的实现也有了不同的方式。<br>大体了分为 2 个版本: 1.6 版本的 和 1.8 版本。</p><p>ConcurrentHashMap 在 JDK 1.6 的版本网上资料很多, 有兴趣的可以去看看。 JDK 1.6 版本关键要素:</p><blockquote><ol><li>segment 继承了 ReentrantLock 充当锁的角色, 为每一个 segment 提供了线程安全的保障</li><li>segment 维护了哈希散列表的若干个桶, 每个桶由 HashEntry 构成的链表</li></ol></blockquote><p>而到了 JDK 1.8 的 ConcurrentHashMap 就有了很大的变化, 光是代码量就足足增加了很多。1.8 版本舍弃了 segment, 并且大量使用了 synchronized, 以及 CAS 无锁操作以保证 ConcurrentHashMap 操作的线程安全性。<br>至于为什么不用 ReentrantLock 而是 Synchronzied 呢? 实际上, synchronzied 在 JDK 1.6 做了很多的优化, 包括偏向锁, 轻量级锁, 重量级锁, 可以依次向上升级锁状态。<br>因此, 使用 synchronized 相较于 ReentrantLock 的性能会持平甚至在某些情况更优, 具体的性能测试可以去网上查阅一些资料。另外, 底层数据结构改变为采用数组 + 链表 + 红黑树的数据形式。  </p><h2 id="2-ConcurrentHashMap-的关键属性-类和-CAS-方法"><a href="#2-ConcurrentHashMap-的关键属性-类和-CAS-方法" class="headerlink" title="2 ConcurrentHashMap 的关键属性, 类和 CAS 方法"></a>2 ConcurrentHashMap 的关键属性, 类和 CAS 方法</h2><p>在了解 ConcurrentHashMap 的具体方法实现前, 我们需要系统的来看一下几个关键的地方, 从这几个地方, 从大体上了解 ConcurrentHashMap 的一些特性。</p><h3 id="2-1-常量设置-这些设置基本和-HashMap-的类似"><a href="#2-1-常量设置-这些设置基本和-HashMap-的类似" class="headerlink" title="2.1 常量设置 (这些设置基本和 HashMap 的类似)"></a>2.1 常量设置 (这些设置基本和 HashMap 的类似)</h3><blockquote><ol><li>ConcurrentHashMap 内部是使用一个数组存放数据的,  这个数组的长度必须是 2 的 n 次方, 默认的容量是 16, 最大是 1 &lt;&lt; 30, 既 2 的 30 次方</li><li>默认负载因子为 0.75, 当数组的的存数据的项 &gt;&#x3D; 数组的长度 * 负载因子, 就会进行数组长度扩容</li><li>数组的每一项, 在 JDK 1.8 中, 可以是链表, 也可以是红黑树。</li><li>当数组的长度大于等于 64, 数组的某一项的长度大于等于 8, 会转为红黑树, 小于等于 6, 会重新转为链表</li><li>key 和 value 都不允许为 null (HashMap 允许一个 key 为 null 和 不限制的 value 为 null)</li><li>在 ConcurrentHash 中数组中的每个节点的 hash 都有特殊作用</li></ol></blockquote><p>ConcurrentHash 中数组中的节点的 hash 值不同的含义</p><blockquote><ol><li><strong>&gt;&#x3D; 0</strong>, 表明这个节点为 Node, 既链表节点</li><li><strong>-1</strong>, 表明这个节点为 ForwardingNode, 说明这个位置正在数据迁移</li><li><strong>-2</strong>, 表明这个节点为 TreeBin, 树节点 TreeNode 的进一步封装</li><li><strong>-3</strong>, 表明这个节点为 ReservationNode, 通过 JDK 1.8 新增的几个方法给 ConcurrentHashMap 设值时, 会先对应位置的节点变为 ReservationNode, 再做处理</li></ol></blockquote><p>比如 JDK 1.8 中 Map 新提供了 computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) 方法, 这个方法的作用, 就是向 Map 获取 key 对应的值不存在时, 将后面的 lambda 表达式的返回值设置到 Map 中, 然后返回。<br>这样就能保证从 Map 不会获取到 null 值。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出: 2123</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> k <span class="token operator">-></span> k <span class="token operator">+</span> <span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出: null</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>computeIfAbsent 定义在 Map 接口中声明的方法, 同时基于 JDK 1.8 的特性, 用 default 关键字进行了修饰, 提供了默认的实现。</p><p>Map 提供的这些 default 方法, 可以发现都是线程不安全的, 所以 ConcurrentHashMap 对他们进行了重写, 在这些方法中, 需要对向已有的数组里面的添加新值,<br>那么就会向把对应位置的那一项, 设置为 ReservationNode 节点。用于通知其他的线程, 这个位置的数据在修改中。</p><h3 id="2-2-关键属性"><a href="#2-2-关键属性" class="headerlink" title="2.2 关键属性"></a>2.2 关键属性</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 装载 Node 的数组, 作为 ConcurrentHashMap 的数据容器, 采用懒加载的方式, 直到第一次插入数据的时候才会进行初始化操作, 数组的大小总是为 2 的幂次方</span>    <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>    <span class="token comment">// 扩容时使用, 平时为 null, 只有在扩容的时候才为非 null, 扩容时先把数据放在这个对象, 扩容完成后, 才把 table 指向这个对象</span>    <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTable<span class="token punctuation">;</span>    <span class="token comment">// 在没有发生争用时的元素个数的统计, 即当前的元素个数</span>    <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> baseCount<span class="token punctuation">;</span>    <span class="token comment">// 数组大小控制</span>    <span class="token comment">// 这个属性非常重要, 取值不同有不同的情况</span>    <span class="token comment">// 1. 当 sizeCtl > 0 时</span>    <span class="token comment">// 在 ConcurrentHashMap 声明, 但是内部存储数据的数组是延迟加载的, 这个数组的大小临时存放到 sizeCtl 中</span>    <span class="token comment">// 初始化后表示扩容的阈值, 默认为当前数组的长度 * 0.75</span>    <span class="token comment">// 2. 当 sizeCtl = 0 时</span>    <span class="token comment">// 在声明 ConcurrentHashMap, 没有指定容量大小, 这时 sizeCtl 为 0, 也就是表明 数组 table 的长度去默认值: 16</span>    <span class="token comment">// 3. 当 sizeCtl = -1 时</span>    <span class="token comment">// 表明当前 table 正在初始中</span>    <span class="token comment">// 4. 当 sizeCtl &lt; -1 时</span>    <span class="token comment">// sizeCtl 的数据类型为 int, 占 32 位。</span>    <span class="token comment">// 那么 sizeCtl 的高 16 位存放的是扩容时标识符(具体的解释可以看后面, 现在知道有这个设定就行了), 低 16 位存放的是参与扩容的线程数目 (CocurrentHashMap 在扩容的时候, 有别的线程发现正在扩容中, 会一起参与进来, 一起扩容)</span>    <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> sizeCtl<span class="token punctuation">;</span>    <span class="token comment">// 扩容索引值, 表示已经分配给扩容线程的 table 数组索引位置, 主要用来协调多个线程间迁移任务的并发安全</span>    <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> transferIndex<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-3-关键内部类"><a href="#2-3-关键内部类" class="headerlink" title="2.3 关键内部类"></a>2.3 关键内部类</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>                <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>        <span class="token comment">// 很多属性都是用 volatile 进行修饰的, 也就是为了保证内存可见性</span>        <span class="token keyword">volatile</span> <span class="token class-name">V</span> val<span class="token punctuation">;</span>        <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> parent<span class="token punctuation">;</span>  <span class="token comment">// red-black tree links</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> left<span class="token punctuation">;</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> right<span class="token punctuation">;</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> prev<span class="token punctuation">;</span>    <span class="token comment">// needed to unlink next upon deletion</span>        <span class="token keyword">boolean</span> red<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 这个类并不负责包装用户的 key、value 信息, 而是包装的很多 TreeNode 节点。 </span>        <span class="token comment">// 实际的 ConcurrentHashMap "数组" 中, 存放的是 TreeBin 对象, 而不是 TreeNode 对象</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> root<span class="token punctuation">;</span>        <span class="token keyword">volatile</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> first<span class="token punctuation">;</span>        <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> waiter<span class="token punctuation">;</span>        <span class="token keyword">volatile</span> <span class="token keyword">int</span> lockState<span class="token punctuation">;</span>        <span class="token comment">// values for lockState</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">WRITER</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 持有写锁时的标志</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">WAITER</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 等待写锁的标志</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">READER</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 读锁的增加值</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 在扩容时才会出现的特殊节点, 作为一个标记节点放在桶的首位, </span>        <span class="token comment">// 其 key, value, next 全部为 null, hash 为 MOVED (-1), 并拥有 nextTable 指针指向新的 table 数组</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTable<span class="token punctuation">;</span>        <span class="token class-name">ForwardingNode</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// hash, key, value, next</span>            <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">MOVED</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>nextTable <span class="token operator">=</span> tab<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ReservationNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用 Map default 方法时, 会把节点修改为这个特殊节点</span>        <span class="token comment">// 其 key, value, next 全部为 null, hash 为 RESERVED (-3)</span>        <span class="token class-name">ReservationNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">RESERVED</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token class-name">Object</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>结合上面几个内部类, 基本可以推理出 ConcurrentHashMap 的存储数据的方式和 HashMap 一样, 都是数组, 数组的数据类型可以是链表, 也可以是红黑树。</p><p>大体的结构如下:<br><img src="https://pic.imgdb.cn/item/65829240c458853aef72be4d.png" alt="Alt &#39;ConcurrentHashMap 的数据结构&#39;"></p><h3 id="2-4-一些高频的-CAS-方法"><a href="#2-4-一些高频的-CAS-方法" class="headerlink" title="2.4 一些高频的 CAS 方法"></a>2.4 一些高频的 CAS 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 该方法用来获取 tab 数组中索引为 i 的 Node 元素     */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">tabAt</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">getObjectAcquire</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>i <span class="token operator">&lt;&lt;</span> <span class="token constant">ASHIFT</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">ABASE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 利用 cas 操作将 tab 数组中索引为 i 的元素从 c 替换为 v     */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">boolean</span> <span class="token function">casTabAt</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> c<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSetObject</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>i <span class="token operator">&lt;&lt;</span> <span class="token constant">ASHIFT</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">ABASE</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 将 tab 数组中索引为 i 的元素设置为 v     */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">void</span> <span class="token function">setTabAt</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">putObjectRelease</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>i <span class="token operator">&lt;&lt;</span> <span class="token constant">ASHIFT</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">ABASE</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="3-ConcurrentHashMap-的源码实现"><a href="#3-ConcurrentHashMap-的源码实现" class="headerlink" title="3 ConcurrentHashMap 的源码实现"></a>3 ConcurrentHashMap 的源码实现</h2><h3 id="3-1-实例构造器方法"><a href="#3-1-实例构造器方法" class="headerlink" title="3.1 实例构造器方法"></a>3.1 实例构造器方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1. 构造一个空的 map, 即 table 数组还未初始化, 初始化放在第一次插入数据时, 默认大小为 16</span>    <span class="token keyword">public</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 2. 给定 map 的大小</span>    <span class="token keyword">public</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 3. 给定一个 map</span>    <span class="token keyword">public</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 4. 给定 map 的大小以及负载因子</span>    <span class="token keyword">public</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 5. 给定 map 大小, 加载因子以及最少多少个桶(数组的最小长度)</span>    <span class="token keyword">public</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">int</span> concurrencyLevel<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>ConcurrentHashMap 一共给我们提供了 5 种构造器方法, 具体使用请看注释, 我们来看看第 2 种构造器, 传入指定大小时的情况 (其他的构造方式都是类似的), 该构造器源码为: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 存储数据的数组的最大容量 </span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//1. 小于 0 直接抛异常</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2. 判断指定的容量是否超过了允许的最大值, 超过了话则取最大值, 否则再对该值进一步处理, 使其为 2 的 n 次方</span>        <span class="token comment">// 在 initialCapacity 的值大于等于 MAXIMUM_CAPACITY / 2 的情况下, 直接取最大值 MAXIMUM_CAPACITY, 否则重试计算出第一个大于 initialCapacity 的 2 的 n 次方的数</span>        <span class="token comment">// initialCapacity >>> 1 相当于除以2 取整, 经过这样处理可以得到第一个大于 initialCapacity 的 2 的 n 次方的数</span>        <span class="token keyword">int</span> cap <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>initialCapacity <span class="token operator">>=</span> <span class="token punctuation">(</span><span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span>  <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">:</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//3. 赋值给 sizeCtl, 这时候 sizeCtl 作用是存放初始时数组的容量</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>sizeCtl <span class="token operator">=</span> cap<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 经过这个方法的处理后, 可以得到第一个大于等于 c 的 2 的 n 次方的数</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>        <span class="token comment">// MAXIMUM_CAPACITY == 1 &lt;&lt; 30</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>这段代码的逻辑请看注释, 很容易理解。<br>如果小于 0 就直接抛出异常, 如果指定值大于了所允许的最大值的话就取最大值。<br>否则, 在对指定值做进一步处理。最后将计算出来的容量 cap 赋值给 sizeCtl, 关于 sizeCtl 的说明请看上面的说明, <strong>当调用构造器方法之后, sizeCtl 的大小就代表了 ConcurrentHashMap 的大小, 即 table 数组长度</strong>。</p><p>在指定容量的处理方法 <strong>tableSizeFor</strong> 中, 根据入参的值计算出第一个大于当前入参的 2 的 n 次方数, 这个值就是 ConcurrentHashMap 中数组进行声明时的容量了。<br>比如, 当指定大小为 18 时, 经过这个方法处理, 会得到一个 32 的值。</p><p>需要注意的是, <strong>调用构造器方法的时候并未构造出 table 数组 (可以理解为 ConcurrentHashMap 的数据容器) , 只是算出 table 数组的长度, 当第一次向 ConcurrentHashMap 插入数据的时候才真正的完成初始化创建 table 数组的工作</strong>。</p><h3 id="3-2-ConcurrentHashMap-中数组的初始方法-initTable"><a href="#3-2-ConcurrentHashMap-中数组的初始方法-initTable" class="headerlink" title="3.2 ConcurrentHashMap 中数组的初始方法 initTable()"></a>3.2 ConcurrentHashMap 中数组的初始方法 initTable()</h3><p>在上面的指定容量的构造函数中, 可以看到, 只是对入参的容量参数进行了处理, 然后赋值给 sizeCtl, 就结束了, 而真正存储数据的 table 数组还是为空的。<br>这是一种懒加载的方式, 而只要第一次向里面放数据时, 就会进行数组的初始化, initTable 就是初始化的方法。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>         <span class="token keyword">int</span> sc<span class="token punctuation">;</span>        <span class="token comment">// table 为空 或者长度为 0, 进入循环, 否则进入后面的逻辑</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 当前的 sizeCtl 小于 0, 表示 ConcurrentHashMap 正在扩容中</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token comment">// 让当前线程让出行时间段, 使正在运行中的线程重新变成就绪状态, 后面重新竞争 CPU 的调度权</span>                <span class="token comment">// 确保当前只有一个线程在初始化</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 通过 CAS 将 sizeCtl 设置为 -1, 成功了, 进行初始化</span>                <span class="token comment">// 在初始时, 会先将 sizeCtl CAS 为 -1, 也就是其他的线程进入到 while 里面, 也会在上面的判断时, 判断为 true 然后让出执行权</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 再次判断 table 为 null 或者长度为 0 </span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                                <span class="token comment">// 如果指定的容量小于 0, 使用默认值 16, 进行声明, 否则就用指定的大小进行声明</span>                        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> <span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">;</span>                        <span class="token comment">// 初始数组</span>                        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                        table <span class="token operator">=</span> tab <span class="token operator">=</span> nt<span class="token punctuation">;</span>                        <span class="token comment">// 计算数组中可用的大小: 实际大小 n * 0.75 (加载因子) </span>                        <span class="token comment">// n >>> 2 相等于 n /2 /2 = n/4 = 0.25</span>                        <span class="token comment">// sc = n - 0.25 * n = 0.75 * n</span>                        sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 这时候 sizeCtl 存放的是阈值, 不是数组的长度, 也不是 -1 了</span>                    <span class="token comment">// 如果上面异常了, 可以把 sc 重新赋值过来, 也就是还是维护的是数组的长度</span>                    sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>代码的逻辑请见注释, 有可能存在一个情况是多个线程同时走到这个方法中, 为了保证能够正确初始化, 会在数组初始时做了一个判断 sizeCtl &lt; 0 的判断,<br>若当前已经有一个线程正在初始化即 sizeCtl 值变为 -1, 这个时候其他线程在 if 判断为 true 从而调用 Thread.yield() 让出 CPU 时间片。<br>正在进行初始化的线程会调用 U.compareAndSwapInt 方法将 sizeCtl 改为 -1 即正在初始化的状态。</p><p>构造方法 +  initTable 基本就构成了 ConcurrentHashMap 的初始的全部逻辑了。</p><h3 id="3-3-ConcurrentHashMap-新增数据-put-方法"><a href="#3-3-ConcurrentHashMap-新增数据-put-方法" class="headerlink" title="3.3 ConcurrentHashMap 新增数据 - put() 方法"></a>3.3 ConcurrentHashMap 新增数据 - put() 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">spread</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// ConcurrentHashMap 中 hash 值的计算方法</span>        <span class="token comment">// h 异或 (h 无符号右移 16 位) 后, 再与上 HASH_BITS</span>        <span class="token comment">// HASH_BITS = 0x7fffffff = 2147483647, 二进制表示为  01111111 11111111 11111111 11111111</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token constant">HASH_BITS</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 注意: 这里和 HashMap 的区别, HashMap 允许一个 key 为 0 和 多个 value 为 null</span>        <span class="token comment">// ConcurrentHashMap 则 key 和 value 都不允许, 直接抛出异常</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 第一步, 计算 key 对应的 hash 值</span>        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 用来计算对应位置的链表的长度</span>        <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 注意: 这里做了一个死循环, 自旋操作</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> f<span class="token punctuation">;</span>             <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span>            <span class="token comment">// 第二步, 当前的数据结构为 null 或者 长度为 0, 进行初始化</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token comment">// 继续数组的声明, 数组创建成功后, 回到循环的头部, 重新循环</span>                tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 第三步, 将当前 key 对应的 hash 值 &amp; 上 数组的长度 - 1 (这一步的操作, 在数组的长度为 2 的 n 次方的情况下《等同于 hash % 数组的长度) </span>            <span class="token comment">// 得到当前 value 存放在数组的哪个位置, 并赋值给 i    </span>            <span class="token comment">// 通过 CAS 得到 i 位置的值, 如果为空, 进入判断里面的操作</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 把当前的数据封装为节点, 通过 cas 把这个节点放到 i 位置</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// cas 操作成功, 跳出循环, 但是还是会执行到下面的 addCount 方法, 这时候 binCount = 0</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment">// 第四步, MOVED = -1; 对应位置的节点的 hash 为 -1, 既当前节点为 ForwardingNode 节点, 表示当前正在扩容, 当前线程进行协助扩容        </span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">MOVED</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 协助扩容</span>                <span class="token comment">// 协助扩容后, 又会回到循环的头部, 重新处理</span>                tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 当前 value 应该存放到位置已经有节点了</span>                <span class="token class-name">V</span> oldVal <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token comment">// 如果指定的位置不为 null, 同时不是 ForwardingNode, 对这个对象上锁</span>                <span class="token comment">// 因为这里对这个节点上锁了, 所以扩容和添加新数据, 只有一个线程进入</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 做多一次判断, 当前位置的节点还是指定的节点</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 第五步, 当前为链表, 在链表中插入新的键值对, 或者存在 key 相同的, 进行值替换</span>                        <span class="token comment">// fh = 定位到的位置的 hash, > 0 为 链表, -2 表示的是树节点</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token comment">// 链表当前有节点个数</span>                            binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                            <span class="token comment">// 循环遍历 链表</span>                            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token class-name">K</span> ek<span class="token punctuation">;</span>                                <span class="token comment">// 找到 hash 和 key 完成相同的节点, 覆盖旧值即可</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                    <span class="token comment">// 旧值</span>                                    oldVal <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                                    <span class="token comment">// 是否替换旧值, 这里是 !false</span>                                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>                                        e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>                                    <span class="token comment">// 这里旧值不为 null 并且 binCount >= 1, 走到下面的判断后, 不会走到 addCount 方法</span>                                    <span class="token keyword">break</span><span class="token punctuation">;</span>                                <span class="token punctuation">&#125;</span>                                <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> pred <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token comment">// 如果当前节点的下一个节点为 null, 把当前数据封装为新节点放到链表的尾部, 跳出循环</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                    pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token comment">// 这时候旧值为 null, binCount = 链表的长度, 会走到 addCount 方法</span>                                    <span class="token keyword">break</span><span class="token punctuation">;</span>                                <span class="token punctuation">&#125;</span>                            <span class="token punctuation">&#125;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token comment">// 第六步, 当前为红黑树节点的话, 将新的键值对插入到红黑树中</span>                        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">;</span>                            <span class="token comment">// 直接把 binCount 设置为 2, 用于后面判断, 跳出循环</span>                            binCount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                            <span class="token comment">// 将节点转为 TreeBin 红黑树, 调用 TreeBin 的 putTreeVal 方法, 尝试将当前节点放到树内</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                oldVal <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>                                    p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                                     <span class="token punctuation">&#125;</span>                <span class="token comment">// 第七步, 插入完键值对后再根据实际大小看是否需要转换成红黑树</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 链表的长度大于等于 8 了, 红黑树化</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> <span class="token constant">TREEIFY_THRESHOLD</span><span class="token punctuation">)</span>                        <span class="token comment">// 在 treeifyBin 中会判断当前的数组长度, 如果长度小于 MIN_TREEIFY_CAPACITY = 64</span>                        <span class="token comment">// 不会红黑树化, 而是直接扩容</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                        <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token comment">// 第八步, 新增元素节点 1 个, 当前新增元素所在位置的节点个数 binCount 元素计数, </span>        <span class="token comment">// 在 addCount 中检查是否需要扩容</span>        <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">,</span> binCount<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>从整体而言, 为了解决线程安全的问题, ConcurrentHashMap 使用了 <strong>synchronized</strong> 和 <strong>CAS</strong> 的方式。</p><p>ConcurrentHashMap 的数据存储方式和 HashMap 没有多大的区别。ConcurrentHashMap 是一个<strong>哈希桶数组</strong>, 如果不出现哈希冲突的时候, 每个元素均匀的分布在哈希桶数组中。<br>当出现哈希冲突的时候, 是标准的<strong>链地址</strong>的解决方式, 将 hash 值相同的节点构成链表的形式, 称为 “拉链法”, 另外, 在 1.8 版本中为了防止拉链过长, 当链表的长度大于<br>8 (<strong>同时还需要满足数组的长度达到了 64, 否则只会进行数组的扩容, 进行重新调整</strong>) 的时候会将链表转换成红黑树。table 数组中的每个元素实际上是单链表的头结点或者红黑树的根节点。</p><p>上面的新增数据的流程大体如下:</p><p><strong>第一步: 计算 key 的 hash 值</strong></p><p>当插入键值对时, 首先应该定位到要插入的桶, 即插入 table 数组的索引 i 处。那么, 怎样计算得出索引 i 呢? 在 ConcurrentHash 通过 spread 方法就能得到 key 对应的 hash 值。</p><p>spread() 方法 主要是将 key 的 hashCode 和 key 的高 16 位进行异或运算, 这样不仅能够使得 hash 值能够分散, 均匀减小 hash 冲突的概率, 另外只用到了异或运算,<br>在性能开销上也能兼顾, 做到权衡。</p><p><strong>第二步: table 的初始化</strong><br>判断当前的存放数据的 table 是否为空或者长度为 0, 如果是的话, 调用 initTable() 方法进行初始化, 方法的介绍可以看上面的。</p><p><strong>第三步: 能否直接将新值插入到 table 数组中</strong></p><p>通过公式 <strong>通过当前 key 计算出来的 hash 值 &amp; (当前存储数据的数组的长度  - 1)</strong>, 得到当前的键值对应该存储在数组的哪个位置, 这个计算公式在数组长度确保为 2 的 n 次方下,<br>相当于 hash 对数组的长度取模, 既 <code>hash % n</code>。</p><p>得到当前键值对待插入的位置, 再通过 tabAt() 方法获取该位置的节点, 如果节点为 null 的话, 就可以直接用 casTabAt() 方法将新值插入即可。</p><p><strong>第四步: 当前是否正在扩容, 协助扩容</strong><br>如果键值对待插入的位置的节点不为 null, 且该节点为特殊节点 (ForwardingNode) 的话, 就说明当前 ConcurrentHashMap 正在进行扩容操作。<br>怎样确定当前的这个 Node 是不是特殊的节点了? 是通过判断该节点的 hash 值是不是等于 -1(MOVED)。如果是说明当前正在扩容中, 则会协助扩容。</p><p><code>helpTransfer</code> 协助扩容这里涉及到扩容的一些知识, 所以将其放到后面的扩容一起讲解。</p><p><strong>第五步: 当前为链表, 在链表中插入新的键值对, 或者存在 key 相同的, 进行值替换</strong><br>在 table[i] 不为 null 并且不为 ForwardingNode 时, 并且当前 Node f 的 hash 值大于 0 (fh &gt;&#x3D; 0) 的话说明当前节点 f 为当前桶的所有的节点组成的链表的头结点。<br>那么接下来, 要想向 ConcurrentHashMap 插入新值的话就是向这个链表插入新值就行了。通过 synchronized(f) 的方式进行加锁以实现线程安全性。<br>只对数组中这个位置的链表进行加锁, 而不是整个数组加锁, 提高了并发性。</p><p><strong>第六步: 当 table[i] 为红黑树的根节点, 在红黑树中插入新值</strong><br>按照之前的数组 + 链表的设计方案, 这里存在一个问题, 即使负载因子和 Hash 算法设计的再合理, 也免不了会出现拉链过长的情况, 一旦出现拉链过长, 甚至在极端情况下,<br>查找一个节点会出现时间复杂度为 O(n) 的情况, 则会严重影响 ConcurrentHashMap 的性能, 于是, 在 JDK 1.8 版本中, 对数据结构做了进一步的优化, 引入了红黑树。<br>而当链表长度太长 (默认超过 8) 时, 链表就转换为红黑树, 利用红黑树快速增删改查的特点提高 ConcurrentHashMap 的性能。</p><p>通过 f instanceof TreeBin 判断当前 table[i] 是否是树节点, 这下也正好验证了我们在最上面介绍时说的 TreeBin 会对 TreeNode 做进一步封装,<br>对红黑树进行操作的时候针对的是 TreeBin 而不是 TreeNode。<br><strong>如果在红黑树中存在于待插入键值对的 Key 相同 (hash 值相等并且 equals 方法判断为 true) 的节点的话, 就覆盖旧值, 否则就向红黑树追加新节点</strong></p><p><strong>第七步: 插入完键值对后再根据实际大小看是否需要转换成红黑树</strong><br>如果当前链表节点个数大于等于 8 (TREEIFY_THRESHOLD) 的时候, 就会调用 treeifyBin 方法将 tabel[i] (第 i 个散列桶) 拉链转换成红黑树。</p><p><strong>第八步 添加元素计数, 并在 binCount 大于 0 时检查是否需要扩容</strong><br>每次新增的时候都会对当前的数组的长度做一个检查, 超过了临界值, 就会进行扩容, 相关的方法 <code>addCount</code>。</p><p>同样的, <code>addCount</code> 涉及到了扩容方面的知识, 将其也放到扩容的时候一起讲。</p><p>整体的流程是这样的:</p><blockquote><ol><li>首先对于每一个放入的值, 首先利用 spread 方法对 key 的 hashcode 进行一次 hash 计算, 由此来确定这个 key 应该存放在 table 中的位置</li><li>如果当前 table 数组还未初始化, 先将 table 数组进行初始化操作</li><li>如果要存放的位置是 null 的, 那么使用 cas 操作直接放入</li><li>如果这个位置存在结点, 说明发生了 hash 碰撞, 首先判断这个节点的类型。如果该节点 fh &#x3D;&#x3D; MOVED (代表 forwardingNode, 数组正在进行扩容) 的话, 说明正在进行扩容, 协助扩容, 扩容结束后, 重新判断</li><li>如果是链表节点 (fh &gt; 0), 则得到的结点就是 hash 值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到 key 相同的节点, 则只需要覆盖该结点的 value 值即可。否则依次向后遍历, 直到链表尾插入这个结点。</li><li>如果这个节点的类型是 TreeBin 的话, 直接调用红黑树的插入方法进行插入新的节点</li><li>插入完节点之后再次检查链表长度, 如果长度大于 8, 就把这个链表转换成红黑树</li><li>对当前容量大小进行检查, 判断是否需要扩容</li></ol></blockquote><h3 id="3-4-ConcurrentHashMap-获取数据-get-方法"><a href="#3-4-ConcurrentHashMap-获取数据-get-方法" class="headerlink" title="3.4 ConcurrentHashMap 获取数据 - get() 方法"></a>3.4 ConcurrentHashMap 获取数据 - get() 方法</h3><p>看完了 put 方法再来看 get 方法就很容易了, 用逆向思维去看就好, 怎么存, 反过来这么取就好了, get 方法的源码:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>         <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">,</span> p<span class="token punctuation">;</span>         <span class="token keyword">int</span> n<span class="token punctuation">,</span> eh<span class="token punctuation">;</span> <span class="token class-name">K</span> ek<span class="token punctuation">;</span>        <span class="token comment">// 得到 key 的 hash 值</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// table 数组不为空同时长度大于 0, 计算得到的位置不为 null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 指定位置的 hash key 都相同, 直接在头节点找到了, 直接返回这个节点值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eh <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> h<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                    <span class="token comment">// 节点的 hash 为 0 说明为树节点, 在红黑树中查找即可</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>eh <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> p<span class="token punctuation">.</span>val <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token comment">// 依次遍历链表的每一个节点</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// hash 和 key 都相同, 返回这个节点 value </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// 找到了直接返回</span>                    <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>整理后的流程大体如下:</p><blockquote><ol><li>计算出 key 的 hash</li><li>通过 hash 得到对应位置的节点, 如果为 null, 直接返回</li><li>判断对应位置的节点的 hash 和 key 是否一致, 如果是的话, 返回这个节点的值</li><li>判断这个节点的 hash 小于 0, 说明这个为树节点, 在树中进行查找</li><li>到了这一步, 说明这个节点为链表, 依次遍历这个链表的节点, 进行查找</li><li>如果都没有的的, 直接返回 null</li></ol></blockquote><h3 id="3-5-ConcurrentHashMap-的扩容"><a href="#3-5-ConcurrentHashMap-的扩容" class="headerlink" title="3.5 ConcurrentHashMap 的扩容"></a>3.5 ConcurrentHashMap 的扩容</h3><p>当 ConcurrentHashMap 容量不足的时候, 需要对 table 进行扩容。这个方法的基本思想跟 HashMap 是很像的, 但是由于它是支持并发扩容的, 所以要复杂的多。<br>原因是它支持多线程进行扩容操作, 而并没有加锁。这样做的目的不仅仅是为了满足 concurrent 的要求, 而是希望利用并发处理去减少扩容带来的时间影响。  </p><h4 id="3-5-1-扩容标识的获取-resizeStamp-方法"><a href="#3-5-1-扩容标识的获取-resizeStamp-方法" class="headerlink" title="3.5.1 扩容标识的获取 - resizeStamp() 方法"></a>3.5.1 扩容标识的获取 - resizeStamp() 方法</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 返回一个标志位用于调整 table 的大小     * 这个数左移 RESIZE_STAMP_SHIFT, 也就是 16 位, 必须后能得到一个负数     */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Interger.numberOfLeadingZero 的作用: 返回整型 n 非零最高位前面 0 的个数</span>        <span class="token comment">// 比如: 13 的二进制为: 00000000 00000000 00000000 00001101 , 从右往左, 最后一个非零的前面有 28 个 0, 所以这里等于 28</span>        <span class="token comment">// RESIZE_STAMP_BITS = 16 , 所以 1 &lt;&lt; (RESIZE_STAMP_BITS - 1) 固定为 32768, 二进制表达为 00000000 00000000 10000000 00000000</span>        <span class="token comment">// 这里的 |, 或操作, 2 位只要有一个是 1 就是 1 了, 在这里可以简单的看出是 2 个数相加</span>        <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">numberOfLeadingZeros</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token constant">RESIZE_STAMP_BITS</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>这个方法看起来就一行代码, 但是拆成三部分来看。</p><p><strong>Integer.numberOfLeadingZeros(n)</strong><br>这个方法的作用: 返回一个整形, 从左往右到第一个非 0 位的位数, 比如 13 的二进制为 00000000 00000000 00000000 00001101, 从左往右算到第一个 1 时, 总共有 28 位, 所以这个返回 28。</p><p>因为 int 为 32 位, 那么经过这个方法计算最终得到的结果最大为 32 (输入了 0), 最小当然是 0 (输入了 -1), 所以这个方法返回值在 0 - 32 之间。返回值的二进制为 00000000 00000000 00000000 00XXXXXX</p><p><strong>1 &lt;&lt; (RESIZE_STAMP_BITS - 1)</strong></p><p>RESIZE_STAMP_BITS 是一个常量, 等于 16, 1 &lt;&lt; (16 - 1) &#x3D; 32768, 二进制为: 00000000 00000000 10000000 00000000, 刚好得到了一个第 16 位为 1 的数</p><p><strong>| (或操作)</strong><br>或运算, 这里可以看做是 2 个数相加, 将上面 2 步的结果进行或运算后, 可以得到一个二进制: 00000000 00000000 10000000 00XXXXXX</p><p>这个方法的作用是返回一个扩容标志符, 这个标志符经过左移 16 位后, 必须是一个负数。这个标志位主要用于后面的扩容。</p><p>通过这个方法得到的数字, 左移 16 位后, 为 10000000 00XXXXXX 00000000 00000000, 将这个数分成 2 部分。</p><p>高 16 位表示当前在扩容中, 而且保存了当前 table 的长度。<br>调用 resizeStamp() 方法, 传过来的 n &#x3D; 当前 table 的长度, 而 table 的长度是 2^n 次方, 2^n 在二进制的形式为从 01 {n 个 0} 的形式, 结合 Interge.numberOfLeadingZeros 就可以知道当前 table 的长度了。<br>而低 16 位用在后面的记录当前参与扩容的线程数。每有一个线程参加了扩容就加 1, 所以最多参与扩容的线程个数就是 00000000 00000000 11111111 11111111 既 2^17 - 1 个线程。</p><p>先记住他的含义, 后面扩容的时候, 就能了解他的神奇之处。</p><h4 id="3-5-2-扩容的判断-addCount-方法"><a href="#3-5-2-扩容的判断-addCount-方法" class="headerlink" title="3.5.2 扩容的判断 - addCount() 方法"></a>3.5.2 扩容的判断 - addCount() 方法</h4><p>在每次 put 新值的时候, 存放成功后, 都会执行一次是否需要扩容的检测, 如果需要就会调用扩容, 扩容的检测的方法就是 addCount() 方法</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 这个方法的作用: 更新当前的键值对的个数, 同时根据个数判断是否需要扩容     * 不存在并发的情况下, 键值对的个数存放在 baseCount 下     * 但是当出现了并发的时候, 键值对的个数的统计是通过数组 counterCells 每一项的 value 的累加     *     * @param x  增加的个数     * @param check 检查模式,   check &lt; 0 不进行扩容的的检测, check >= 0 进行扩容检测, 但是出现了并发时,  0&lt;= check &lt;= 1, 不进行扩容检测     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> check<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// CounterCell 是 ConcurrentHashMap 中的一个内部类</span>        <span class="token comment">// 整个类只有一个 long value 的属性</span>        <span class="token comment">// 主要用于并发时, ConcurrentHashMap 的数据个数的计算</span>        <span class="token class-name">CounterCell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span>         <span class="token keyword">long</span> b<span class="token punctuation">,</span> s<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> counterCells<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">BASECOUNT</span><span class="token punctuation">,</span> b <span class="token operator">=</span> baseCount<span class="token punctuation">,</span> s <span class="token operator">=</span> b <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 1. 用于统计数组个数的 counterCells 数组已经不为 null 了</span>            <span class="token comment">// 2. 通过 cas 将当前直接存储 ConcurrentHashMap 元素个数的 bseCount + x, 失败 (baseCount 存放的是当前 ConcurrentHashMap 中存放的数据个数)</span>                        <span class="token comment">// 这 2 个情景都可以确定当前的增加元素个数进入了并发情景了</span>            <span class="token class-name">CounterCell</span> a<span class="token punctuation">;</span>             <span class="token keyword">long</span> v<span class="token punctuation">;</span>             <span class="token keyword">int</span> m<span class="token punctuation">;</span>            <span class="token comment">// 线程争用的状态标记, 默认为无竞争</span>            <span class="token keyword">boolean</span> uncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token comment">// ThreadLocalRandom.getProbe() 随机产生一个 int 的数字, </span>            <span class="token comment">// 下面的 m = ConcurrentHashMap 的 CounterCell[] counterCells 数组的长度, 默认声明是为 2, 后面扩容也是在原来的基础上 * 2, 所以 counterCell 的长度也是 2 的 n 次方</span>            <span class="token comment">// 所以通过 ThreadLocalRandom.getProbe() &amp; m, 就是从  CounterCell[] counterCells 中随机去一个位置</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>m <span class="token operator">=</span> as<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> cs<span class="token punctuation">[</span><span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>uncontended <span class="token operator">=</span> <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token constant">CELLVALUE</span><span class="token punctuation">,</span> v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> v <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token comment">// 1. ConcurrentHashMap 的 CounterCell[] counterCells 为空或者长度小于 0</span>                <span class="token comment">// 2. 从 CounterCell[] counterCells 随机取出一个位置为 null</span>                <span class="token comment">// 3. 从 CounterCell[] counterCells 随机取出一个位置不为 null, 通过 cas 将这个位置的 CounterCell 的 value + x 失败了</span>                <span class="token comment">// 这里只有是给当前的 ConcurrentHashMap 的元素个数加上 x, 通过 fullAddCount() 方法实现的</span>                <span class="token comment">// 这个方法的复杂度很高, 就不展开了, 说一下大体的功能</span>                <span class="token comment">// 先通过 ThreadLocalRandom.getProbe() 当前线程的用于产生随机数的随机种子</span>                <span class="token comment">// 同一个线程一直调用这个方法会返回通过一个值, 调用 advanceProbe() 方法进行刷新, 再次调用 getProbe() 可以得到另一个新的随机种子</span>                <span class="token comment">// 下面的整个操作的过程都是自旋的</span>                <span class="token comment">// 1. 当前的 counterCells 有数据</span>                <span class="token comment">// 1.1 通过获取到随机种子, 算出在 counterCells 中的一个位置</span>                <span class="token comment">// 1.2 获取到的位置不为 null, 通过 cas 给这个位置的 CounterCell 的 value + x</span>                <span class="token comment">// 1.2.1 cas 设置成功了, 结束整个方法</span>                <span class="token comment">// 1.2.2 cas 设置失败了, 给 counterCells 进行扩容, 变为原来的 2 倍, 调用 ThreadLocalRandom.advanceProbe() 获取新的随机种子, 回到自旋循环的开头</span>                <span class="token comment">// 1.3 获取到的位置为 null, 创建一个新的 CounterCell, value 为 x</span>                <span class="token comment">// 1.3.1 在判断这个位置为 null, 将新的 CounterCell 放到这个位置, 结束</span>                <span class="token comment">// 1.3.3 在判断这个位置不为 null, 回到自旋循环的开头</span>                <span class="token comment">// 2. counterCells 没有数据, 通过 cas 将 baseCount 加 x</span>                <span class="token comment">// 在 fullAddCount 中实际的实现比上面的复杂, 会通过 cas cellsBusy 从 0 设置为 1, 设置成功, 才能进行上面的操作, 设置失败都只能自旋</span>                <span class="token function">fullAddCount</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> uncontended<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 注意这里的 return 有个问题, 通过 fullAddCount() 给当前的 ConcurrentHashMap 的元素个数 + 1, 为什么不检测是否需要扩容呢?</span>                <span class="token comment">// 这里其实需要从多线程的角度考虑了, 能够进到这里, 有哪些情况? 结合上面 2 个 if</span>                <span class="token comment">// 1. counterCells 不为 null,  并且通过 cas 更新 counterCells 的计算出来的位置的值失败, 那么就是有另一个线程更新了这个值, 扩容的检测交给那个线程就行了</span>                <span class="token comment">// 2. counterCells 为 null, 通过 cas 更新 baseCount 失败了, 进到这里很大概率 as 为空, 同样的是交给另一个线程进行扩容的检测</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 增加元素个数进入了并发情景了</span>            <span class="token comment">// 不需要进行扩容的检测</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>check <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token comment">// 统计总个数</span>            <span class="token comment">// baseCount + CounterCell[] counterCells 中每个不为 null 的元素的 value  </span>            s <span class="token operator">=</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 进行扩容的检测</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>check <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> nt<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> sc<span class="token punctuation">;</span>            <span class="token comment">// 当前的元素个数 > 阈值 并且 table 不为空, 同时 table 的长度小于最大容量 2^30, 还有扩容空间</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//根据数组长度获取一个扩容标志, 格式 16 个 0 + 1 + 15 位 (表示当前 table 容量的二进制表示从左往右 0 的个数)</span>                <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 在上面我们说过了 sizeCtl 的不同取值有不同的含义, </span>                <span class="token comment">// 小于 0, 初始中或者有线程在扩容中, 但是在 addCount 方法可以断定为扩容中</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>sc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 1. sc 无符号右移 16 位和扩容标识 rs 不相同, 将不做处理, </span>                    <span class="token comment">// 出现不同的原因就是 table 的长度改变了, 导致计算出来的 rs 变了 也就是上次的扩容完成了, 不进行处理</span>                    <span class="token comment">// 当第一个线程进行扩容的时候, 会把 sizeCtl 设置为计算出来的 rs 右移 16 位后 + 2, </span>                    <span class="token comment">// 所以当改变后的 sizeCtl 左移 16 位和当前的 rs 不一致了, 说明 table 的长度已经变了</span>                    <span class="token comment">// 如果 rs 从 + 1, 是无法区分 sizeCtl 低 16 位都是 0 时, 是扩容为开始还是扩容已经结束</span>                    <span class="token comment">// 如果直接 + 2, 后续减少时 -1, 那么低 16 位都是 0 表示扩容未开始, 低 16 位为 1, 扩容结束</span>                    <span class="token comment">// 2. sc == rs + 1 这里是一个 bug, 应该改为 sc == (rs &lt;&lt;&lt; RESIZE_STAMP_SHIFT) + 1</span>                    <span class="token comment">// sc 在经过条件 1 后, 值是不会变的, 那么 sc 依旧是小于 0, 而 rs 在我们分析后必定是一个大于 0 的数, 所以 sc 一定不会等于 rs + 1, 应该是 sc == (rs &lt;&lt;&lt; RESIZE_STAMP_SHIFT) + 1</span>                    <span class="token comment">// 这个 bug 可以查看 这里 https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427, 预计在 JDK 12 修复, 在 14 的时候已经看到修复了</span>                    <span class="token comment">// 如果修改为上面的, 我们知道 sc 的低位存放的是当前线程参与扩容的线程数, 默认是从 2 开始累积的, 在扩容 transfer 中,</span>                    <span class="token comment">// 每有一个线程扩容完成时会 - 1, 当 sc 的低位减到了 1 时, 说明这时候扩容已经完成了, 而 rs 无符号左移 16 位后, 低 16 位都是 0, </span>                    <span class="token comment">// 如果 sc 的低位 = 右移后的 rs 的低位 + 1, 说明扩容完成了, 正在进行末尾的处理了, 不进行处理</span>                    <span class="token comment">// 3. 同上面的条件 2 一样, 应该修改为 sc == (rs &lt;&lt;&lt; RESIZE_STAMP_SHIFT) + MAX_RESIZERS, 这里的 MAX_RESIZERS = 1 &lt;&lt; 16 - 1; </span>                    <span class="token comment">// 也就是 00000000 00000000 11111111 11111111, 也就是我们扩容能支持的最大线程数, 这里也就是我们当前扩容的线程数达到了上限, 不进行处理</span>                    <span class="token comment">// 4. 在扩容的时候, 我们会先声明 nextTable, 逐渐将数据放到这个对象, 如果这个对象为 null, 说明没有线程在进行扩容, 不进行处理, 在上面的 size &lt; 0, 我们可以得知线程进来是有线程在扩容, 现在 nextTable 为空, 说明扩容完成了</span>                    <span class="token comment">// 5. 转移索引标识 transferIndex &lt;= 0, 不进行处理, 这个变量用于扩容时控制, 可以查看下面的扩容方法, &lt;= 0 说明我们的扩容已经完成了</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">>>></span> <span class="token constant">RESIZE_STAMP_SHIFT</span><span class="token punctuation">)</span> <span class="token operator">!=</span> rs <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token constant">MAX_RESIZERS</span> <span class="token operator">||</span> <span class="token punctuation">(</span>nt <span class="token operator">=</span> nextTable<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> transferIndex <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token comment">// 在 sizeCtl 添加多一个线程, 开始协助扩容, 这时候扩容的新数组就是 nextTable</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc<span class="token punctuation">,</span> sc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> nt<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                 <span class="token comment">// 尝试将 sizeCtl 设置为 扩容标志 rs 左移 16 位 + 2, 2 表示线程数默认是从 2 开始累积的</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSetInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;&lt;</span> <span class="token constant">RESIZE_STAMP_SHIFT</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// cas 将 sizeCtl 设置成功, 开始扩容</span>                    <span class="token comment">//  进行扩容, 存放数据的新数组为 null,</span>                    <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 重新计算元素个数</span>                s <span class="token operator">=</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>总的来说: addCount 就做了 2 件事</p><blockquote><ol><li>更新当前的元素个数</li><li>检查是否需要扩容或者协助扩容</li></ol></blockquote><h4 id="3-5-3-扩容-transfer-方法"><a href="#3-5-3-扩容-transfer-方法" class="headerlink" title="3.5.3 扩容 - transfer() 方法"></a>3.5.3 扩容 - transfer() 方法</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 扩容     * 大体的步骤：     * 通过当前机器的 cpu 和 当前数组的容量算出一个迁移跨度  stride     * 每次一个线程进来扩容的话，就会分配当前数组的 stride 个位置给它, 另一线程进来或者当前线程 stride 个位置已经迁移完了,      * 就再分配另外 stride 个位置给他, 直到当前数组所有的位置都分配完成     * ConcurrentHashMap 的  transferIndex 扩容时默认为当前数组的容量, 类似于一个游标, 每次分配是从这个游标开始往前 stride 个位置就是分配个     * 这个线程的区间了。     * 里面声明的 2 个变量 i 和 boud, 就是当前线程可以处理的区间的位置 [bound, i], [transferIndex - 1 - stride, transferIndex - 1]     * 同时把 transferIndex 更新为 transferIndex - stride     *      * 遍历中的操作     * 1. 获取到的位置为空, 填充为 ForwardingNode 节点， 处理下一个节点     * 2. 获取到的位置的节点为 ForwardingNode, 跳过处理下一个节点     * 3. 判断当前位置的节点是否为链表或者树     * 3.1 链表, 新找到尾节点, 尾节点的 hash &amp; 当前数组的容量 == 0 ? 放到低纬链表的头部, 放到高纬链表的头部, 使用同 HashMap 的高低位链表的方式进行迁移     * 3.2 遍历当前位置的链表直到倒数第二个, 处理的节点的 hash &amp; 数组的长度 = 0? 应该放到低纬, 应该放到高纬度     * 3.3 把当前的节点封装为新的节点, 这个节点的下一个节点为当前的高纬/低纬节点, 然后把当前节点放到低纬/高纬的位置     * 3.4 最后把临时数组 nextTab 的 i 位置设置为当前的低纬链表， i + 当前数组的容量的位置设置为当期的高纬链表     * 3.5 把当前数组的 i 位置设置为 ForwardingNode 节点, 下一个遍历     *     * 迁移完成     * 把临时数据 nextTable 赋值给真正的存储数组 table     * 把 nextTable 设置为 null      * 把 sizeCtl 设置为 旧数组容量的 * 1.5      *      * 没法迁移了, 就给当前的 sizeCtl 减  1     *     * @param tab 扩容前的数组     * @param nextTab 新的数组, 扩容的话, 这里为 null, 协助扩容的为, 为新的数组     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 这里的 tab 就是成员变量 table</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">,</span> stride<span class="token punctuation">;</span>        <span class="token comment">// MIN_TRANSFER_STRIDE = 16   NCPU = 当前服务器的 CPU 核数</span>        <span class="token comment">// n 为数组的长度, 默认为 2 的 n 次方, 所以这里的 >>> 3, 相当于除以 8</span>        <span class="token comment">// 当前为多核服务器的话 stride = 当前的容量 / 8 / CPU 的数量</span>        <span class="token comment">// 如果为单核的话的话, stride = 当前数组容量</span>        <span class="token comment">// 最终计算出来的 stride 如果小于 16, 将其变为 16</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>stride <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">NCPU</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token constant">NCPU</span> <span class="token operator">:</span> n<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MIN_TRANSFER_STRIDE</span><span class="token punctuation">)</span>            stride <span class="token operator">=</span> <span class="token constant">MIN_TRANSFER_STRIDE</span><span class="token punctuation">;</span>                <span class="token comment">// 如果用于存数据的下一个数组为 null, 进行初始, 然后把这个数组赋值给变量 nextTable,</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 扩容为原来的 2 倍</span>                <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>                <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                nextTab <span class="token operator">=</span> nt<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 扩容失败, 直接将阈值变为 int 的最大值, 然后返回</span>                sizeCtl <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 将创建出来的扩容数组赋给给 nextTable, 可以让其他线程看见</span>            nextTable <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>            <span class="token comment">// 扩容索引变为扩容前数组的长度</span>            transferIndex <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>           <span class="token comment">// 记录过渡数组的长度</span>        <span class="token keyword">int</span> nextn <span class="token operator">=</span> nextTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>         <span class="token comment">// 创建一个 ForwardingNode 节点, 用于占位。当别的线程发现这个槽位中是 ForwardingNode 类型的节点, 则跳过这个节点</span>        <span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> fwd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 该变量控制迁移的进行 true 说明可以再次迁移一个下标 (i--) , </span>        <span class="token comment">// 反之, 如果是 false, 那么就不能推进下标, 需要将当前的下标处理完毕才能继续推进</span>        <span class="token keyword">boolean</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">// 完成状态, 如果是 true, 说明迁移完成, 可以结束此方法</span>        <span class="token keyword">boolean</span> finishing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">// 下面的循环主要是</span>        <span class="token comment">// 1. 为了计算出当前线程需要处理的区间 [transferIndex - stride, transferIndex], 即 [bound (transferIndex - stride), i(transferIndex - 1)], </span>        <span class="token comment">// 同时更新 transferIndex = transferIndex - stride, 方便后续的线程或者线程重新获取的迁移的区间</span>        <span class="token comment">// 2. 遍历中, 负责进行 i - 1 操作, 然后决定是继续遍历还是进行下一次分配</span>        <span class="token comment">// i 表示处理的当前桶区间最大下标, bound 表示当前线程可以处理的当前桶区间最小下标</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bound <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> f<span class="token punctuation">;</span>             <span class="token keyword">int</span> fh<span class="token punctuation">;</span>            <span class="token comment">// 当前线程是否可以向后推进, 这个循环就是控制 i 递减, 同时, 每个线程都会进入这里取得自己需要转移的桶的区间</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>advance<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> nextIndex<span class="token punctuation">,</span> nextBound<span class="token punctuation">;</span>                <span class="token comment">// 对 i 减一, 判断是否大于等于 bound (正常情况下, 如果大于等于 bound 不成立, 说明该线程上次领取的任务已经完成了那么, 需要在下面继续领取任务)</span>                <span class="token comment">// 如果对 i 减一, 大于等于 bound (还需要继续做任务) , 或者迁移完成了, 修改推进状态为 false, 不能推进了。 每迁移完成一个位置, 推进状态会被修改为 true</span>                <span class="token comment">// 通常, 第一次进入循环, i-- 这个判断会无法通过, 从而走下面的 nextIndex 赋值操作 (获取最新的转移下标) </span>                <span class="token comment">//其余情况都是: 如果可以推进, 将 i 减一, 然后修改成不可推进。如果 i 对应的位置处理成功了, 又把推进状态修改成可以推进。</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>i <span class="token operator">>=</span> bound <span class="token operator">||</span> finishing<span class="token punctuation">)</span>                    advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nextIndex <span class="token operator">=</span> transferIndex<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 如果 transferIndex 小于等于 0, 说明没有区间了, i 改成 -1, 推进状态变成 false, 不再推进, 表示, 扩容结束了, 当前线程可以退出了</span>                    i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                    advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span>compareAndSwapInt <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">TRANSFERINDEX</span><span class="token punctuation">,</span> nextIndex<span class="token punctuation">,</span> nextBound <span class="token operator">=</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">></span> stride <span class="token operator">?</span> nextIndex <span class="token operator">-</span> stride <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                         <span class="token comment">// 通过 cas 减少 transferIndex (transferIndex - stride 跨度) 的值成功了, 为当前线程重新分配新的扩容区间</span>                    <span class="token comment">// 这里的目的是: </span>                    <span class="token comment">// 1. 当一个线程进入时, 使其可以获取最新的转移下标</span>                    <span class="token comment">// 2. 当一个线程处理完自己的区间时, 如果还有剩余区间的没有别的线程处理, 再次获取区间</span>                    <span class="token comment">// 这个值就是当前线程可以处理的最小当前区间最小下标</span>                    bound <span class="token operator">=</span> nextBound<span class="token punctuation">;</span>                    <span class="token comment">// 初次对 i 赋值, 这个就是当前线程可以处理的当前区间的最大下标</span>                    i <span class="token operator">=</span> nextIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                    advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                            <span class="token punctuation">&#125;</span>            <span class="token comment">// i &lt; 0 (当 transferIndex &lt;= 0 时, 数组已经分配完成了, 线程进入到上面的 while, 使得 i = -1, 然后走到这个方法, 让线程结束扩容 )</span>            <span class="token comment">// i >= 旧数组的长度</span>            <span class="token comment">// i + n >= 新数组的长度</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> n <span class="token operator">||</span> i <span class="token operator">+</span> n <span class="token operator">>=</span> nextn<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> sc<span class="token punctuation">;</span>                <span class="token comment">// 如果完成了扩容</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>finishing<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 成员变量设置为 null</span>                    nextTable <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token comment">// 将迁移完成的数组赋值给 table</span>                    table <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>                    <span class="token comment">// sizeCtl 变为 1.5 倍 (2n - 0.5n)</span>                    sizeCtl <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// 通过 cas 设置 sizeCtl 的扩容线程数减 1</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">,</span> sc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 一开始进入扩容时 sc + 2, 这里 - 2 等于扩容标识, 说明当前扩容完成了, 只剩一个线程了</span>                    <span class="token comment">// 让这个线程进行扩容完成后的处理</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">RESIZE_STAMP_SHIFT</span><span class="token punctuation">)</span>                        <span class="token keyword">return</span><span class="token punctuation">;</span>                    <span class="token comment">// 更新结束标志为 true, 推进标志为 true</span>                    finishing <span class="token operator">=</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token comment">// 将 i 重新设置为 n, 让上面的 --i >= bound 为 true, 可以进入后面 finish 的判断</span>                    i <span class="token operator">=</span> n<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>              <span class="token punctuation">&#125;</span>                              <span class="token comment">// 扩容时发现负责的区域有空的桶直接使用 ForwardingNode 填充</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                advance <span class="token operator">=</span> <span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 对应位置的节点为 -1 (MOVED) 已经处理了, 继续下一个位置的处理   </span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">MOVED</span><span class="token punctuation">)</span>                advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 对 table 的 i 位置的节点上锁, 防止 putVal 的时候向链表插入新的数据</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 做一次判断, 确保对应位置的对象为需要处理的对象</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                                <span class="token comment">// 此处扩容和 HashMap 有点像, 在原数组的 pos 位置的节点, 在扩容后, 会在新数组的 pos 位置 或者 pos + 原数组长度的位置</span>                        <span class="token comment">// 前者为低纬  lowNode, 后者为高纬 highNode</span>                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> ln<span class="token punctuation">,</span> hn<span class="token punctuation">;</span>                                                <span class="token comment">// 如果 f 的 hash 值大于 0, 表明这个节点为链表</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token comment">// 节点的 hash  &amp; 旧数组的长度</span>                            <span class="token keyword">int</span> runBit <span class="token operator">=</span> fh <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>                            <span class="token comment">// 存储的是链表的尾结点</span>                            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> lastRun <span class="token operator">=</span> f<span class="token punctuation">;</span>                            <span class="token comment">// 遍历链表, 找到最后链表中最后的一个</span>                            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token keyword">int</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>                                <span class="token comment">// hash 和 runBit 不一样了, 进行替换</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> runBit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                    runBit <span class="token operator">=</span> b<span class="token punctuation">;</span>                                    lastRun <span class="token operator">=</span> p<span class="token punctuation">;</span>                                <span class="token punctuation">&#125;</span>                            <span class="token punctuation">&#125;</span>                            <span class="token comment">// 尾结点的 hash 处理后为 0, 将尾节点放在低纬链表</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>runBit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                ln <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>                                hn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                            <span class="token comment">// 尾结点的 hash 处理后不为 0, 将尾结点放在高纬链表</span>                            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                hn <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>                                ln <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                            <span class="token comment">// 没有上面的操作, 直接遍历链表也完成功能, 只是上面的都是做了一些优化</span>                            <span class="token comment">// 比如 原来数组的链表为 1(低纬) - 2(高纬) - 3(高纬) - 4(低纬) - 5(低纬) - 6(低纬) - 7(低纬)</span>                            <span class="token comment">// 那么经过上面的处理, lastRun = 4(低纬)</span>                            <span class="token comment">// ln = 4(低纬) - 5(低纬) - 6(低纬) - 7(低纬)</span>                            <span class="token comment">// 因为 lastRun 后面的节点必定和 lastRun 在同一个位置, 那么我们在迁移时, 只需要遍历到 lastRun 这个位置就行了</span>                            <span class="token comment">// 后面的都是位置和 lastRun 一样, 直接把 lastRun 移过来就行了, 后面的节点都在 lastRun 后面, 不用处理了</span>                            <span class="token comment">// 注意了, 这里是头插法, 也就是我们直接遍历链表, 把节点直接放到lastRun 的前面就行了</span>                            <span class="token comment">// 重新遍历链表, 以 lastRun 为结束标志</span>                            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> f<span class="token punctuation">;</span> p <span class="token operator">!=</span> lastRun<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token keyword">int</span> ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">;</span> <span class="token class-name">K</span> pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span> <span class="token class-name">V</span> pv <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                                <span class="token comment">// 可以看出这里是头插法</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                                    ln <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    hn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                            <span class="token comment">// 在 nextTable 的 i 位置上插入一个链表</span>                            <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 在 nextTable 的 i + 旧数组长度的位置上插入一个链表</span>                            <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 在 table 的 i 位置上插入 forwardNode 节点</span>                            <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 设置推进标志为 true</span>                            advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                             <span class="token comment">// 树节点, 处理</span>                            <span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>f<span class="token punctuation">;</span>                            <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> lo <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                            <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> hi <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                            <span class="token keyword">int</span> lc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> hc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                            <span class="token comment">// 遍历树节点</span>                            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> t<span class="token punctuation">.</span>first<span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token keyword">int</span> h <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>                                <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> e<span class="token punctuation">.</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span>val<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 和链表相同的判断, 与运算 == 0 的放在低位</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> loTail<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                                        lo <span class="token operator">=</span> p<span class="token punctuation">;</span>                                    <span class="token keyword">else</span>                                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>                                    loTail <span class="token operator">=</span> p<span class="token punctuation">;</span>                                    <span class="token operator">++</span>lc<span class="token punctuation">;</span>                                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                    <span class="token comment">// 不是 0 的放在高位</span>                                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> hiTail<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                                        hi <span class="token operator">=</span> p<span class="token punctuation">;</span>                                    <span class="token keyword">else</span>                                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>                                    hiTail <span class="token operator">=</span> p<span class="token punctuation">;</span>                                    <span class="token operator">++</span>hc<span class="token punctuation">;</span>                                <span class="token punctuation">&#125;</span>                            <span class="token punctuation">&#125;</span>                            <span class="token comment">// 如果树的节点数小于等于 6, 那么转成链表, 反之, 创建一个新的树</span>                            ln <span class="token operator">=</span> <span class="token punctuation">(</span>lc <span class="token operator">&lt;=</span> <span class="token constant">UNTREEIFY_THRESHOLD</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span>                                <span class="token punctuation">(</span>hc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>                            hn <span class="token operator">=</span> <span class="token punctuation">(</span>hc <span class="token operator">&lt;=</span> <span class="token constant">UNTREEIFY_THRESHOLD</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span>                                <span class="token punctuation">(</span>lc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>                            <span class="token comment">// 低位树</span>                            <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 高位数</span>                            <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 旧的设置成占位符</span>                            <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 继续向后推进</span>                            advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></code></pre><p><strong>第一部分</strong> 构建一个 nextTable, 它的容量是原来的两倍, 这个操作是单线程完成的。新建 table 数组的代码为: Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node<?,?>[n &lt;&lt; 1], 在原容量大小的基础上右移一位</p><p><strong>第二部分</strong>就是将原来 table 中的元素复制到 nextTable 中, 主要是遍历复制的过程。 根据运算得到当前遍历的数组的位置 i, 然后利用 tabAt 方法获得i位置的元素再进行判断</p><blockquote><ol><li>如果这个位置为空, 就在原 table 中的 i 位置放入 forwardNode 节点, 这个也是触发并发扩容的关键点</li><li>如果这个位置是 Node 节点 (fh &gt;&#x3D; 0) , 如果它是一个链表的头节点, 就构造一个反序链表, 把他们分别放在 nextTable 的 i 和 i + n 的位置上</li><li>如果这个位置是 TreeBin 节点 (fh &lt; 0) , 也做一个反序处理, 并且判断是否需要 untreefi, 把处理的结果分别放在 nextTable 的 i 和 i + n 的位置上</li><li>遍历过所有的节点以后就完成了复制工作, 这时让 nextTable 作为新的 table, 并且更新 sizeCtl 为新容量的 0.75 倍, 完成扩容</li></ol></blockquote><h4 id="3-5-4-协助扩容-helpTransfer-方法"><a href="#3-5-4-协助扩容-helpTransfer-方法" class="headerlink" title="3.5.4 协助扩容 - helpTransfer() 方法"></a>3.5.4 协助扩容 - helpTransfer() 方法</h4><p>当 ConcurrentHashMap 正在扩容中, 有其他的线程计划向里面添加数据时, 因为正在扩容中, 无法添加。<br>但是 ConcurrentHashMap 的设计是不会让这个线程阻塞, 而是让这个线程帮忙扩容, 既执行 helpTransfer() 方法。 </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * @param tab 扩容的数组, 这里看成存放数据的 table 就对了     * @param f 当前处于扩容中的节点     */</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>        <span class="token comment">// 1. 当前的 tab(也就是 table) 不为 null,</span>        <span class="token comment">// 2. 当前的节点为 ForwardingNode</span>        <span class="token comment">// 3. 当前 ForwardingNode 中用于临时存放扩容时, 数据的 nextTable 不为空</span>        <span class="token comment">// 三个条件都满足了, 会进入协助扩容</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">ForwardingNode</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>nextTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span>nextTable<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>nextTab <span class="token operator">==</span> nextTable <span class="token operator">&amp;&amp;</span> table <span class="token operator">==</span> tab <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 这里的逻辑和 addCount 里面的差不多, 就不做解释了</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">>>></span> <span class="token constant">RESIZE_STAMP_SHIFT</span><span class="token punctuation">)</span> <span class="token operator">!=</span> rs <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token constant">MAX_RESIZERS</span> <span class="token operator">||</span> transferIndex <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment">// 通过 CAS 操作, 设置当前的扩容线程 + 1, </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc<span class="token punctuation">,</span> sc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 设置成功了, 进入协助扩容</span>                    <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                   <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> nextTab<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> table<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="4-ConcurrentHashMap-与-size-相关的一些方法"><a href="#4-ConcurrentHashMap-与-size-相关的一些方法" class="headerlink" title="4 ConcurrentHashMap 与 size 相关的一些方法"></a>4 ConcurrentHashMap 与 size 相关的一些方法</h2><p>对于 ConcurrentHashMap 来说, 这个 table 里到底装了多少东西其实是个不确定的数量, 因为不可能在调用 size() 方法的时候像 GC 的 “stop the world” 一样让其他线程都停下来让你去统计,<br>因此只能说这个数量是个估计值。对于这个估计值, ConcurrentHashMap 也是大费周章才计算出来的。</p><p>为了统计元素个数, ConcurrentHashMap 定义了一些变量和一个内部类</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     *  Contended 注解可以用来解决伪共享     */</span>    <span class="token annotation punctuation">@sun.misc.Contended</span>     <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">CounterCell</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">volatile</span> <span class="token keyword">long</span> value<span class="token punctuation">;</span>        <span class="token class-name">CounterCell</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> value <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/** 当出现了并发的时候, 整个 ConcurrentHashMap 的元素个数, 是分散存在这个数组内*/</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">CounterCell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> counterCells<span class="token punctuation">;</span>    <span class="token comment">/** 创建 CounterCells 是充当自旋锁使用 */</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> cellsBusy<span class="token punctuation">;</span>    <span class="token comment">/** 实际保存的是 Map 中的元素个数  利用 CAS 锁进行更新, 但是当出现了并发情况, 元素的个数就不从这个进行获取了*/</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> baseCount<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>size() 方法</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> n <span class="token operator">=</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CounterCell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> as <span class="token operator">=</span> counterCells<span class="token punctuation">;</span> <span class="token class-name">CounterCell</span> a<span class="token punctuation">;</span>        <span class="token keyword">long</span> sum <span class="token operator">=</span> baseCount<span class="token punctuation">;</span>                <span class="token comment">/** counterCells 不为 null, 就是出现了并发情况, 这个对象被声明了 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> as<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    sum <span class="token operator">+=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token comment">//所有counter的值求和</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * mappingCount 与 size 方法的类似      * 官方的给出的注释来看, 应该使用 mappingCount 代替 size 方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">mappingCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> n <span class="token operator">=</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0L</span> <span class="token operator">:</span> n<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>JDK 1.6, 1.7 中的 ConcurrentHashmap 主要使用 Segment 来实现减小锁粒度。 分割成若干个 Segment, 在 put 的时候需要锁住 Segment, get 时候不加锁, 使用 volatile 来保证可见性。<br>当要统计全局时 (比如 size) , 首先会尝试多次计算 modcount 来确定, 这几次尝试中, 是否有其他线程进行了修改操作, 如果没有, 则直接返回 size。如果有, 则需要依次锁住所有的 Segment 来计算。</p><p>1.8 之前 put 定位节点时要先定位到具体的 segment, 然后再在 segment 中定位到具体的桶。而在 1.8 的时候摒弃了 segment 臃肿的设计, 直接针对的是 Node[] table 数组中的每一个桶, 进一步减小了锁粒度。<br>并且防止拉链过长导致性能下降, 当链表长度大于 8 的时候采用红黑树的设计。</p><p>主要设计上的变化有以下几点:</p><blockquote><ol><li>放弃采用 segment 而采用 node, 锁住 node 来实现减小锁粒度</li><li>设计了 MOVED 状态, 当 resize 的过程中, 线程 2 在 put 数据, 线程 2 会帮助 resize</li><li>使用 3 个 CAS 操作来确保 node 的一些操作的原子性, 这种方式代替了锁。</li><li>sizeCtl 的不同值来代表不同含义, 起到了控制的作用</li><li>采用 synchronized 而不是 ReentrantLock</li></ol></blockquote><p>更多关于 1.7 版本与 1.8 版本的 ConcurrentHashMap 的实现对比, 可以参考<a href="https://www.jianshu.com/p/e694f1e868ec">这篇文章</a>。</p><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h2><p><a href="https://github.com/CL0610/Java-concurrency/blob/master/14.%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap(JDK%201.8%E7%89%88%E6%9C%AC)/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap(JDK%201.8%E7%89%88%E6%9C%AC).md">ConcurrentHashmap简介</a><br><a href="https://juejin.im/post/5c40a1fa51882525ed5c4ac2">ConcurrentHashMap源码阅读</a><br><a href="https://stackoverflow.com/questions/47175835/how-does-concurrenthashmap-resizestamp-method-work">How does ConcurrentHashMap resizeStamp method work</a>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java ThreadLocal</title>
      <link href="/article/2021/1792166938/"/>
      <url>/article/2021/1792166938/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>在多线程编程中，我们经常面临共享数据的问题，而这可能引发一系列并发性和线程安全性的挑战。<br>Java 提供了许多机制来处理这些问题，比如控制并发的各种锁, 控制线程串行地修改资源, 避免线程安全, 或者通过关键字 volatile 修饰变量, 保证可见性等。<br>而在解决并发共享的方式中, 还有一种方式, 那么就是<strong>线程隔离</strong>, 每个线程各自维护资源的副本, 从而避免了共享资源的竞争。<br>而实现这个实现的一个经典代表就是 ThreadLocal, ThreadLocal 为每个线程提供了独立的变量副本, 从而在不同线程之间隔离数据。这为我们提供了一种简单而强大的方式来确保线程间数据的安全性。</p><p>ThreadLocal 的特点:</p><blockquote><ol><li>线程隔离性: 每个线程都有自己独立的 ThreadLocal 变量, 彼此之间不共享数据</li><li>数据共享: ThreadLocal 变量在同一个线程内共享，这意味着在同一线程中的不同方法可以轻松地访问相同的 ThreadLocal 变量</li><li>线程安全性: 单个 ThreadLocal 实例通常是线程安全的，因为每个线程操作的是自己的副本，而不是共享的实例</li><li>内存泄漏风险: 因为一个变量, 每个线程都会以副本的形式存储在自己身上, 这本身就是一种消耗空间的行为, 同时它的生命周期和 Thread 一样长, 在使用过程中不手动进行删除, 可能会导致内存泄露</li></ol></blockquote><h2 id="2-ThreadLocal-的实现原理"><a href="#2-ThreadLocal-的实现原理" class="headerlink" title="2 ThreadLocal 的实现原理"></a>2 ThreadLocal 的实现原理</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> numThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> stringThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        numThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>numThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stringThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>假设现在我们执行上面代码的的线程名为 Thread-1。</p><p>从代码上面直观看到的效果如下:<br><img src="https://pic.imgdb.cn/item/658986b1c458853aefafc8e3.png" alt="Alt &#39;ThreadLocal 表面的效果&#39;"></p><p>程序启动后, 创建了 2 个 ThreadLocal</p><blockquote><ol><li>numThreadLocal: 存储 Integer 类型的数据</li><li>stringThreadLocal: 存储 String 类型的数据</li></ol></blockquote><p>然后 Thread-1 将 1 存入 numThreadLocal, 将 “hello” 存入 stringThreadLocal<br>最后 Thread-1 通过 get 方法分别从 numThreadLocal 和 stringThreadLocal 中获取到了 1 和 “hello”。</p><p>看起来的我们的数据都是存储在 ThreadLocal 中的。</p><p>但是实际中, ThreadLocal 在整个过程中发挥的作用不是存储数据, 而是一个转换器的效果, 真正的数据还是存储在 Thread 中的, 存储的地方是一个 ThreadLocalMap, 可以理解为一个 Map。<br>每创建一个 ThreadLocal 都分配给自己的唯一编码, 调用这个 ThreadLocal 的 get, set 等方法, ThreadLocal 都是通过这个 code 定位到调用的线程的内部的一个 ThreadLocalMap 的某个位置, 然后给这个 Map 添加或删除数据。<br>不同的 ThreadLocal 有不同的 code, 所以通过这个 code 定位到 Thread 的 ThreadLocalMap 的某个位置, 从而实现了线程隔离 (实际这个通过 code 定位到具体的位置涉及到 hash, 所以还是有冲突的可能, 但是通过别的方式解决了)。</p><p><img src="https://pic.imgdb.cn/item/658986b4c458853aefafd5a3.png" alt="Alt &#39;ThreadLocal 实际的效果&#39;"></p><p>我们先通过它的几个核心方法简单了解一下。</p><h3 id="2-1-设值到-ThreadLocal-set-方法"><a href="#2-1-设值到-ThreadLocal-set-方法" class="headerlink" title="2.1 设值到 ThreadLocal - set() 方法"></a>2.1 设值到 ThreadLocal - set() 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取当前的线程</span>        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 通过当前线程实例获取到 ThreadLocalMap 对象</span>        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">// 如果 map 不为 null, 则以当前 threadLocal 实例为 key, 值为 value 进行存入</span>            <span class="token comment">// ThreadLocalMap 内部的 set 会通过 this, 得到当前的 ThreadLocal, 然后获取里面的 code</span>            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// map 为 null, 则新建 ThreadLocalMap 并存入 value</span>            <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 返回指定线程自身的 ThreadLocalMap 对象     */</span>    <span class="token class-name">ThreadLocalMap</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 为指定的线程创建一个 ThreadLocalMap 对象     */</span>    <span class="token keyword">void</span> <span class="token function">createMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">,</span> <span class="token class-name">T</span> firstValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 这里同 ThreadLocalMap 的 set, 会通过 this, 得到当前的 ThreadLocal, 然后获取里面的 code</span>        t<span class="token punctuation">.</span>threadLocals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>从上面的代码, 我们可以知道<br>ThreadLocal 实际的数据是存在每个线程自身的 ThreadLocalMap 对象中。</p><p>那么 ThreadLocalMap 是什么样的呢? </p><p>首先 ThreadLocalMap 是定义在 Thread 身上的一个属性。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 每个线程内部都有一个 ThreadLocalMap 属性</span>    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> threadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>我们可以在类 A 中声明一个 <strong>TheadLocal<String></strong>, 然后在类 B 中用声明一个 **TheadLocal<Integer>**。<br>同一个线程同时使用到了类 A 和类 B, 那么线程身上的 TheadLocalMap threadLocals 需要支持同时存储 2 个数据以上, 那么 ThreadLocalMap<br>应该是什么样的一个数据结构呢?  </p><p>答案是<strong>数组</strong>, 最终实现出来的结果类似于 HashMap, value 是我们存入的内容, 而 key 就是每个类上的 ThreadLocal 的实例内部的一个 code。</p><p>通过这个 TheadLocal 的 code 得到一个 hash 值, 通过这个 hash 值计算得到其在数组中的哪个位置。<br>这时候如果有另外一个 TheadLocal 实例, 他的 code 不一样, 计算出来的 hash 不一样, 那么这个 TheadLocal 的内容存在数组的另外一个位置。</p><p>TheadLocalMap 的理解可以简单的先按照上面的方式, 后面会具体的分析。</p><p>向 ThreadLocal 放数据, 也就是 set 过程</p><blockquote><ol><li>获取当前线程的所维护的 threadLocalMap</li><li>若 threadLocalMap 不为 null, 则以当前的 ThreadLocal 实例内部的 code 为 key, 值为 value 的键值对存入 threadLocalMap</li><li>若 threadLocalMap 为 null 的话, 就为当前的线程新建一个 ThreadLocalMap, 然后在以当前的 ThreadLocal 实例内部的 code 为 key, 值为 value 的键值对存入即可</li></ol></blockquote><h3 id="2-2-从-ThreadLocal-中取值-get-方法"><a href="#2-2-从-ThreadLocal-中取值-get-方法" class="headerlink" title="2.2 从 ThreadLocal 中取值 - get() 方法"></a>2.2 从 ThreadLocal 中取值 - get() 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 获取当前的线程</span>        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2. 获取当前线程的 ThreadLocalMap</span>        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3. 当前线程的 ThreadLocalMap 不为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 获取 map 中 key 为当前 ThreadLocal 内部 code 的 Entry</span>            <span class="token class-name">ThreadLocalMap<span class="token punctuation">.</span>Entry</span> e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 获取到了需要的 Entry</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">T</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//若 map 为 null 或者 entry 为 null 的话通过该方法初始化, 并返回该方法返回的 value</span>        <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 为当前的线程设置一个 value 为 null 的 ThreadLocalMap      */</span>     <span class="token keyword">private</span> <span class="token class-name">T</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取一个 null 的 value</span>        <span class="token class-name">T</span> value <span class="token operator">=</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取当前线程的 TheadLocalMap</span>        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 不为 null, 设值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// 为 null, 创建一个</span>            <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 默认返回一个 null     */</span>    <span class="token keyword">protected</span> <span class="token class-name">T</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>从 ThreadLocal 取数据, 也就是 get 的过程  </p><blockquote><ol><li>获取当前线程的所维护的 threadLocalMap</li><li>若 threadLocalMap 不为 null, 通过当前 ThreadLocal 的 code 为 key 从 threadLocalMap 中获取存储数据的 Entry, Entry 不为 null, 就是找到需要的值了, 返回</li><li>threadLocalMap 为 null, 或者从 threadLocalMap 获取到的 Entry 为空, 声明一个初始的 value 默认为 null, 走一遍 set 的逻辑</li><li>返回声明的初始 value, 也就是 null</li></ol></blockquote><h3 id="2-3-从-ThreadLocal-中删除数据-remove-方法"><a href="#2-3-从-ThreadLocal-中删除数据-remove-方法" class="headerlink" title="2.3 从 ThreadLocal 中删除数据 - remove() 方法"></a>2.3 从 ThreadLocal 中删除数据 - remove() 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取当前线程的 TheadLocalMap </span>        <span class="token class-name">ThreadLocalMap</span> m <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">// 从 map 中删除以当前 threadLocal 实例内部 code 为 key 的键值对</span>            <span class="token comment">// ThreadLocalMap 的 remove 后面在讲</span>            m<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>remove 的方法很简单的, 就是从从当前线程获取到 ThreadLocalMap, 不为 null 的话, 调用 ThreadLocalMap 的 remove 进行移除数据。</p><h2 id="3-ThreadLocalMap-的实现原理"><a href="#3-ThreadLocalMap-的实现原理" class="headerlink" title="3 ThreadLocalMap 的实现原理"></a>3 ThreadLocalMap 的实现原理</h2><p>从上面的分析我们已经知道, 数据其实都放在了线程自身的 ThreadLocalMap 中, ThreadLocal 的 get, set 和 remove 方法实际上是通过 ThreadLocalMap<br>的 getEntry, set 和 remove 方法实现的。如果想真正全方位的弄懂 ThreadLocal, 就是在了解 TheadLocalMap。</p><h3 id="3-1-ThreadLocalMap-中的-Entry"><a href="#3-1-ThreadLocalMap-中的-Entry" class="headerlink" title="3.1 ThreadLocalMap 中的 Entry"></a>3.1 ThreadLocalMap 中的 Entry</h3><p>ThreadLocalMap 是 ThreadLocal 一个静态内部类, 和大多数容器一样内部维护了一个数组, 同样的 ThreadLocalMap 内部维护了一个 Entry 类型的 table 数组</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Object</span> value<span class="token punctuation">;</span>    <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        value <span class="token operator">=</span> v<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>Entry 是一个以 ThreadLocal 内部 code 为 key,  value 为 Object类型 的键值对。 有点类似于 HashMap, <strong>T key, Object value</strong>。 key 的变量声明在父级 <strong>WeakReference</strong> 中。<br>Entry 继承了 WeakReference, 同时在构造函数中将当前的 ThreadLocal 作为参数传递给了父级, 在父级中, 会将对应的 TheadLocal 封装为一个弱引用。<br>而不像我们平时直接在 Entry 中多声明一个 T key, 然后将 TheadLocal&lt;?&gt; k 赋值给 key, 这种做法是强引用, key 和当前的 Entry 是共生的, 一起存在一次消亡。<br>而使用弱引用进行包装可以达到: 在 GC 时, 在 Entry 存在的情况下, k 能被回收。  </p><p>Java 中的 4 种引用可以看下面的附录, 有简单的介绍。</p><p>Thead, TheadLocal, TheadLocalMap 三者的关系如下:<br><img src="https://pic.imgdb.cn/item/658986aec458853aefafbb83.png" alt="Alt &#39;Thread 和 ThreadLocal 和 ThreadLocalMap 三者之间的关系&#39;"></p><p>实线表示强引用, 虚线表示弱引用。</p><p>每个线程实例中可以通过 Thead.threadLocals 获取到 ThreadLocalMap, 而 ThreadLocalMap 实际上就是一个以 ThreadLocal 实例内部 code 为 key, 任意对象为 value 的 Entry 数组。  </p><p>当我们为 ThreadLocal 变量赋值时, 就是给对应的线程的 ThreadLocalMap 中放入一个当前 ThreadLocal 实例内部 code 为 key, 值为 value 的 Entry。</p><p>需要注意的是 <strong>Entry 中的 key 是弱引用</strong>, 当 ThreadLocal 外部强引用被置为 null (ThreadLocalInstance &#x3D; null) 时, 那么系统 GC 的时候,<br>根据可达性分析, 这个 ThreadLocal 实例就没有任何一条链路能够引用到它, 这个 ThreadLocal 势必会被回收。 这样一来, ThreadLocalMap 中就会出现<br>key 为 null 的 Entry, 就没有办法访问这些 key 为 null 的 Entry 的 value。如果当前线程再迟迟不结束的话, 这些 key 为 null 的 Entry 的<br>value 就会一直存在一条强引用链: Thread Ref -&gt; Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value 永远无法回收, 造成内存泄漏。<br>当然, 如果当前 Thread 运行结束, ThreadLocal, ThreadLocalMap, Entry 没有引用链可达, 在垃圾回收的时候都会被系统进行回收。<br>在实际开发中, 会使用线程池去维护线程的创建和复用, 比如固定大小的线程池, 线程为了复用是不会主动结束的。所以, ThreadLocal 的内存泄漏问题, 是应该值得我们思考和注意的问题。</p><h3 id="3-2-ThreadLocalMap-的创建"><a href="#3-2-ThreadLocalMap-的创建" class="headerlink" title="3.2 ThreadLocalMap 的创建"></a>3.2 ThreadLocalMap 的创建</h3><p><strong>创建方式一</strong> </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 存放数据的数组</span>    <span class="token keyword">private</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>    <span class="token comment">// 数组当前的元素个数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 数组中的元素个数达到了这个就会扩容, 而不是数组满了才扩容</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> firstKey<span class="token punctuation">,</span> <span class="token class-name">Object</span> firstValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// INITIAL_CAPACITY = 16;</span>        table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token constant">INITIAL_CAPACITY</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 调用 ThreadLocal 的 threadLocalHashCode 的 threadLocalHashCode 属性值, 然后 &amp; (16 - 1) </span>        <span class="token comment">// 得到这个 firstKey 应该存在数组的哪个位置</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> firstKey<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token constant">INITIAL_CAPACITY</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 在数组对应的位置存入 Entry</span>        table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>firstKey<span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 当前容量设置为 1 </span>        size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// setTheshold 里面只有一行代码 threshold = len * 2 / 3;</span>        <span class="token comment">// 也就是设置阈值 = 长度 * 2/3</span>        <span class="token function">setThreshold</span><span class="token punctuation">(</span><span class="token constant">INITIAL_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>创建方式二</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocalMap</span> parentMap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 取到入参 ThreadLocalMap 的数组</span>        <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parentTable <span class="token operator">=</span> parentMap<span class="token punctuation">.</span>table<span class="token punctuation">;</span>        <span class="token comment">// 入参 ThreadLocalMap 的数组的长度, 这里的长度不用做任何处理, 因为这里的长度必定为 2 的 n 次方</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> parentTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// 设置阈值 = len * 2/3</span>        <span class="token function">setThreshold</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置新的数组    </span>        table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 遍历入参的 ThreadLocalMap 的数组</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 获取到 table 数组的第 j 个位置</span>            <span class="token class-name">Entry</span> e <span class="token operator">=</span> parentTable<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 对应的位置有数据</span>                                <span class="token comment">// 从 e 中获取对应的 key  即 ThreadLocal 实例</span>                <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 调用 ThreadLocal 的 childValue 方法</span>                    <span class="token comment">// 在 ThreadLocal 中这个方法的默认实现为 throw new UnsupportedOperationException(); 抛出一个异常</span>                    <span class="token comment">// 也就是这里的 key 必须是 TheadLocal 的子类, 同时重写了 childValue 方法, 否则会报错</span>                    <span class="token class-name">Object</span> value <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">childValue</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 把 key 和 value 封装为 Entry</span>                    <span class="token class-name">Entry</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 定位到放在数组的位置</span>                    <span class="token keyword">int</span> h <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 对应的位置不为空, 查询后面的一个位置, 到了尾部, 回到头部继续往后找</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>table<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                        h <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 对应的位置 设置为当前的 Entry</span>                    table<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>                    <span class="token comment">// 个数加 1</span>                    size<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 位置的定位     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 当前的位置 + 1 小于当前的长度, 取 + 1 的位置, 否则取 0, 既头部的位置</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token operator">?</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>从上面的方法中可以看出一个有趣的点:  </p><blockquote><ol><li>HashMap 在处理 hash 碰撞时使用的是: 拉链法</li><li>ThreadLocalMap 在处理 hash 碰撞时使用的是: 开放定址法 (一旦产生了冲突, 就按某种规则去寻找另一空地址) 中的<strong>线性探测法</strong>。</li></ol></blockquote><p>具体的开放地址法如何解决 hash 冲突的可以看一下这篇文章: <a href="https://blog.csdn.net/happyjacob/article/details/84886323">冲突处理方法—-开放定址法</a></p><h3 id="3-3-ThreadLocalMap-中决定-Entry-的-hashCode-的计算"><a href="#3-3-ThreadLocalMap-中决定-Entry-的-hashCode-的计算" class="headerlink" title="3.3 ThreadLocalMap 中决定 Entry 的 hashCode 的计算"></a>3.3 ThreadLocalMap 中决定 Entry 的 hashCode 的计算</h3><p>在 ThreadLocalMap 中 key 对应的 Entry 在 Entry[] table 的位置的计算方式为 <strong>key.threadLocalHashCode &amp; (len - 1)</strong>, 这里的 key 就是我们传入的 ThreadLocal。<br>决定位置的元素有 2 个</p><blockquote><ol><li>当前 Entry[] table 数组的长度</li><li>key 对应的 ThreadLocal 中的 threadLocalHashCode 的值 (这个 code 就是上面我们一直说的 ThreadLocal 内部的 code)</li></ol></blockquote><p>Entry[] table 的长度很容易知道, 但是 threadLocalHashCode 是如何计算的呢</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> threadLocalHashCode <span class="token operator">=</span> <span class="token function">nextHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">AtomicInteger</span> nextHashCode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 这个值为 1640531527</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">HASH_INCREMENT</span> <span class="token operator">=</span> <span class="token number">0x61c88647</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> nextHashCode<span class="token punctuation">.</span><span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token constant">HASH_INCREMENT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>先说结论:  </p><p>每个 ThreadLocal 实例的 threadLocalHashCode 在 ThreadLocal 实例创建出来后就不会再变了, 这个 ThreadLocal 实例后面在使用中, threadLocalHashCode 固定的。<br>每个 ThreadLocal 实例的 threadLocalHashCode 都是不同的。</p><blockquote><ol><li>nextHashCode 这个变量在 ThreadLocal 中被 static 修饰了, 说明所有的 ThreadLocal 的实例共用 1 个 AtomicInteger 的属性</li><li>当我们声明第 1 个 ThreadLocal, 调用唯一的 nextHashCode, 得到了当前的 threadLocalHashCode 值, 值为 0, 同时让唯一的 AtomicInteger 的值增加 1640531527</li><li>声明第 2 个 ThreadLocal, 又调用了唯一的 nextHashCode, 得到了当前的 threadLocalHashCode 值, 值为 1640531527, 然后又让 AtomicInteger 的值增加 1640531527</li><li>这样每创建一个 ThreadLocal 的 nextHashCode 都是不一样的。不要忽略了 int 值的取值范围, 导致值的变化</li><li>为什么每个 ThreadLocal 之间的的 nextHashCode 的差值为 1640531527 ? 这个和斐波那契散列有关, 它可以使 hashcode 均匀的分布在大小 2 的 N 次方的数组里。至于为什么, 涉及到数学相关的知识, pass !</li></ol></blockquote><p>通过上面的分析基本知道了 ThreadLocal 的大体实现了吧</p><blockquote><ol><li>每次声明了一个 ThreadLocal 实例, 这时候这个实例会得到一个固定的 hashCode, 存储在 threadLocalHashCode 变量中</li><li>每个线程中都有一个变量 threadLocals, 类型为 ThreadLocalMap</li><li>ThreadLocalMap 本质是一个 Entry 的数组, Entry 对象中存储了 key, value, key 默认一个 ThreadLocal 的实例内部的 hash code, value 就是通过 ThreadLocal 存储到 Thread 的内容</li><li>当我们调用 ThreadLocal 的实例, 将内容存储到当前的 Thread 本质是存在 Thread 中的 threadLocals 属性, 也就是 Entry[] 数组中</li></ol></blockquote><p>调用 ThreadLocal 的实例, 存放数据的步骤大体如下</p><blockquote><ol><li>创建一个 ThreadLocal 的实例, 实例的得到一个接近唯一的 hashCode, 存储在自身的 threadLocalHashCode 变量</li><li>获取当前的线程维护的 threadLocals 变量, 数据类型为 ThreadLocalMap, 本质就是一个 Entry[] 的数组, 如果为空, 进行初始化</li><li>将当前的 ThreadLocal 实例内部的 threadLocalHashCode 作为 key, 需要存储的内容做为 value, 封装为一个 Entry 实例</li><li>通过当前的 ThreadLocal 实例的 threadLocalHashCode 和当前 Entry[] 数组的长度计算出, 这个 ThreadLocal 存储在数组中的哪一个位置, 把封装好的 Entry 实例放到数组中</li><li>这时候又声明了一个新的 ThreadLocal 的实例, 又是另一个 threadLocalHashCode</li><li>往这个新的 ThreadLocal 的实例存值, 同样是封装为 Entry,</li><li>当前线程的 threadLocals 变量不为空, 不会初始化, 也就是新的 ThreadLocal 和旧的 ThreadLocal 用着同一个 threadLocals 变量, 也就是同一个 Entry[] 数组</li><li>但是新的 ThreadLocal 的实例的 threadLocalHashCode 不一样, 计算出来的位置也会不一样, 这样放到同一个 Entry[] 数组的不同位置</li><li>也就是说使用 ThreadLocal 存储数据时, 数据是存储在当前线程的数组中的</li></ol></blockquote><h3 id="3-4-ThreadLocalMap-的-set-方法"><a href="#3-4-ThreadLocalMap-的-set-方法" class="headerlink" title="3.4 ThreadLocalMap 的 set() 方法"></a>3.4 ThreadLocalMap 的 set() 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取到当前存数据的数组引用</span>        <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token comment">// 数组长度</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            <span class="token comment">// 当前 ThreadLocal 的 threadLocalHasCode &amp; (数组的长度 - 1), 得到当前应该存在数组的哪个位置</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 取到对应位置的元素,  但 i 位置的 不为 null</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 这时候的 e 一定不会是 null</span>            <span class="token comment">// 从 Entry e 中获取 key</span>            <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 对应的 k == 输入的 key, 替换新值, 结束</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 对应的位置的 k 为 null, 将当前的 value 设置到 ThreadLocalMap 的数组</span>            <span class="token comment">// Entry 不为 null, 但是 Entry 的 key 为 null, 情况是存在的, 因为 Entry 中的 key 是一个弱引用, 能被 GC 直接回收</span>            <span class="token comment">// 这时候可以把当前的 Entry 放到这个位置</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 将当前的 value 放到数组 i 的位置, 进行 table 数组的重新整理, 即对数组中, 无效的 Entity (key 为 null) 进行移除</span>                <span class="token comment">// 然后对数组中的 Entry 通过其 key 的 hashCode 计算出来的位置和这个 Entry 当前所在的位置不一致 (hash 冲突过), 进行重试计算位置</span>                <span class="token comment">// 这样经过了无效 Entry 删除后, 重新计算位置, 可能将其重新放到正确的位置</span>                <span class="token function">replaceStaleEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 到了这里, 会执行 for 后面的 e = tab[i = nextIndex(i, len)], e != null, 又有进入到这个循环</span>            <span class="token comment">// 等于 null 的话, 跳出循环, 执行下面的逻辑</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// i 位置为 null, 创建一个新的 Entry 放到数组的 i 位置</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 容量加 1</span>        <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token operator">++</span>size<span class="token punctuation">;</span>        <span class="token comment">// cleanSomeSlots 没有清除过无效的 Entry, 同时当前数组中的数据已经大于阈值了, 进行扩容</span>        <span class="token comment">// 插入后再次清除一些 key 为 null 的 "脏" entry, 如果大于阈值还是需要扩容 </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">>=</span> threshold<span class="token punctuation">)</span>            <span class="token comment">// 扩容</span>            <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="24-3-4-1-replaceStaleEntry-方法-无效-Entry-清理和-Entry-位置重计算"><a href="#24-3-4-1-replaceStaleEntry-方法-无效-Entry-清理和-Entry-位置重计算" class="headerlink" title="24.3.4.1 replaceStaleEntry() 方法:  无效 Entry 清理和 Entry 位置重计算"></a>24.3.4.1 replaceStaleEntry() 方法:  无效 Entry 清理和 Entry 位置重计算</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 移除数组中的部分无效 Entry, 然后对范围内的 Entry 重新地位      *      * @param key       ThreadLocal 实例 的 key     * @param value     需要存储的值     * @param staleSlot key 当前打算放到这个位置, 同时这个位置的 Entry 的 key 为 null, 为当前 key 的最优位置     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">replaceStaleEntry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> staleSlot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token class-name">Entry</span> e<span class="token punctuation">;</span>        <span class="token comment">// 下面的所有的遍历, 基本都是</span>        <span class="token comment">// 1. 向前遍历, 遍历到数组的头部后, 会继续从数组的尾部开始继续往前遍历</span>        <span class="token comment">// 2. 向后遍历, 遍历到数组的尾部后, 会继续从数组的头部开始继续向后遍历</span>        <span class="token comment">// 所以把存储数据的 table 数组看成一个头尾相接的环, 可以容易理解</span>        <span class="token comment">// staleSlot 位置的 Entry key 为 null</span>        <span class="token comment">// 在向前遍历中, 遇到的 Entry key 问 null, slotToExpunge 就会变更为这个 Entry 所在的数组位置</span>        <span class="token keyword">int</span> slotToExpunge <span class="token operator">=</span> staleSlot<span class="token punctuation">;</span>        <span class="token comment">// 从当前的 staleSlot 位置向前(如果到了头部, 则从尾部继续往前找), 直到遇到第一个位置 Entry 为空才停止</span>                <span class="token comment">// prevIndex 的逻辑就一句话: ((i - 1 >= 0) ? i - 1 : len - 1); </span>        <span class="token comment">// 位置 i - 1 >=0, 没到数组的头部, 向前一位,</span>        <span class="token comment">// 位置 i - 1 &lt;0, i 已经是数组的头部了, 那么从 len - 1, len 为数组长度, len - 1 就是数组的尾部</span>        <span class="token comment">// 往前找的过程中, slotToExpunge 会不断重置, 当前位置的 Entry 的 key 为 null, slotToExpunge 更新为这个 Entry 所在的位置</span>        <span class="token comment">// 这个循环直到 (e = tab[i]) == null 才结束, 就是对应的位置为空, 没有数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">prevIndex</span><span class="token punctuation">(</span>staleSlot<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> i <span class="token operator">=</span> <span class="token function">prevIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment">// 对应对象的 key 为 null, 变更 slotToExpunge 等于当前的数组索引位置 i</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                slotToExpunge <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment">// 从 staleSlot 开始向后找(如果到了尾部了, 从头部继续找), 直到遇到第一个位置没有数据的才结束</span>        <span class="token comment">// 从当前的 staleSlot 位置向后找(如果到了尾部了, 则从头部继续找后找), 直到下面 2 种情况才停止</span>        <span class="token comment">// 1. 直到遇到第一个位置 Entry 为空才停止, 把当前的 Entry 放到 staleSlot 的位置</span>        <span class="token comment">// 2. 在遍历中找到了 Entry 的 key 和当前要存储的 Entry 的 key 一样  => 将当前的 value 放到 找到的 Entry, 同时找到的 Entry 和 staleSlot 的 Entry 交换</span>        <span class="token comment">// nextIndex 的逻辑就一句话: ((i + 1 &lt; len) ? i + 1 : 0);</span>        <span class="token comment">// 位置 i + 1 &lt; len, 没到数组的尾部部, 向后一位,</span>        <span class="token comment">// 位置 i + 1 >= len, i 已经是数组的尾部了, 从数组的第 0 位, 也就是头部开始</span>        <span class="token comment">// 这个循环直到 (e = tab[i]) == null 才结束, 就是对应的位置为空, 没有数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>staleSlot<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 在这里面的 e 不为 null</span>            <span class="token comment">// 获取 entity 的 key, 也就是 ThreadLocal</span>            <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 当前的 Entry 的 key 等于我们要存储的数据的 key </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 更新当前的 Entity 的 value 为我们要存储的 value</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token comment">// 上面的入参说过了, staleSlot 是当前需要存储的 ThreadLocal key 计算后存储的最优位置, 同时这个位置的 Entry 的 key 为 null</span>                <span class="token comment">// 所以将 staleSolt 和当前找到的 key 一样的 Entry 进行交换</span>                <span class="token comment">// 将 i 和一开始无效的位置 staleSlot 替换</span>                tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span><span class="token punctuation">;</span>                tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token comment">// 如果上面的向前查找过程中没有更新 slotToExpunge 的值, 则更新 slotToExpunge 为当前值 i, staleSlot 的值是存在的</span>                <span class="token comment">// slotToExpunge 初始值 = staleSlot, 在上面的向前找 Entry 中, 如果 staleSlot 向前的到第一个为空的距离间, 所有的 Entry 的 key 都不为 null</span>                <span class="token comment">// slotTOExpunge 没有更新, 也就是还是等于 staleSlot </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>slotToExpunge <span class="token operator">==</span> staleSlot<span class="token punctuation">)</span>                    <span class="token comment">// 从 nextIndex, 可以得知 i 是在 staleSlot 的后面的, 不等于 staleSlot</span>                    <span class="token comment">// 那么把 i 赋值诶 slotToExpunge, 此时的 i 是 Entry key 为空的元素</span>                    slotToExpunge <span class="token operator">=</span> i<span class="token punctuation">;</span>                                <span class="token comment">// expungeStaleEntry 将从 slotToExpunge 到向后遇到的第一个为空的位置(环形的遍历, 可以从尾部回到头部), 这段距离</span>                <span class="token comment">// 1. 无效的 Entry, 既 Entry 的 key 为 null 的清空</span>                <span class="token comment">// 2. 有效的 Entry, 拿到 key 的 hashCode 重新计算自身的最优位置, 最优位置和当前 Entry 所在的位置不一样, 重试重新调整这个 Entry 的位置</span>                <span class="token comment">// 同时返回遇到的第一个为空的位置的位置索引</span>                <span class="token comment">// cleanSomeSlots 从第一个入参的位置开始, 向后遍历 log2(第二个入参) 次, 同样是环形遍历,</span>                <span class="token comment">// 同样是 对 Entry 的 key 为 null 的进行清除, 对有效 Entity 的位置不等于直接计算出来的, 重新分配位置</span>                <span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span><span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>slotToExpunge<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>                 <span class="token punctuation">&#125;</span>            <span class="token comment">// key 为 null 并且当前的 slotToExpunge 还是等于 staleSlot(也就是上面向前找的时候, 没有找到符合条件的), </span>            <span class="token comment">// 更新 slotToExpunge 为当前的 i(这时候的 entity 为无效 entity)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> slotToExpunge <span class="token operator">==</span> staleSlot<span class="token punctuation">)</span>                slotToExpunge <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>        <span class="token comment">// 把 staleSlot 位置设置为当前的 key 和 value 组合的 Entity</span>        tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果 slotToExpunge 和 staleSlot 不行等, 表示有数据可以清除, 调用 expungeStaleEntry 和 cleanSomeSlots 进行清除</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>slotToExpunge <span class="token operator">!=</span> staleSlot<span class="token punctuation">)</span>            <span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span><span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>slotToExpunge<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token comment">/*     * 从入参的位置开始, 向后遍历到第一个位置为空的位置 (环形遍历),      * 将这段距离中的无效 Entity 移除, 有效 Entity 的位置不等于直接计算出来的, 重新分配位置     * @param staleSlot 开始移除的位置     * @return 遇到的第一个为 null 的数组位置     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> staleSlot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// 先直接将 staleSlot 位置的置为 null</span>        tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token class-name">Entry</span> e<span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>        <span class="token comment">// nextIndex 和 后面的 (e = tail[i]) != null, 老套路</span>        <span class="token comment">// 从 staleSolt 向后遍历, 直到遇到第一个为 null 停止, 注意是环形的, 会从尾部回到头部</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>staleSlot<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 当前位置的 Entry 的 key 为 null, 清掉</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                size<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 当前位置的 Entry 的 key 不为 null</span>                <span class="token comment">// 获取这个 Entry 的 key 直接计算后的直接存储位置</span>                <span class="token keyword">int</span> h <span class="token operator">=</span> k<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 当前存储的位置和直接计算出来的位置不一样, 重新试着调整一下位置</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 把当前的位置置为 null, 方便下面的循环, 最坏的情况能到这个位置停下来, 即重新计算后的位置和当前的一样, 是最优的位置了</span>                    tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token comment">// 从计算出来的位置 h 向后遍历到第一个为 null 的位置 (nextIndex 环形的)</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>tab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                        h <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 把计算出来的新位置设置为当前的 Entry    </span>                    tab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 从 i 位置开始, 向后遍历 log2(n) 次, 同样是环形遍历,     * 在这 log2(n) 次遍历中, 对 Entry 的 key 为 null 的进行清除, 对有效 Entity 的位置不等于直接计算出来的, 重新分配位置     * 对无效的 entity 进移除和对算出来的位置不一致的重新计算     *     * 控制遍历的次数在 log2(n) 次数, 是一个时间上的折中控制, 全数组扫描会和耗时, 扫描次数太少又没太大意义     *     * @param i 数组中为空的位置     * @param n 需要扫描的次数, 一般都是当前数组的长度     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">boolean</span> removed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// i 的下一个位置 (环形的)</span>            i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 下一个位置不为空, 但是 key 为空</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// n 更新为当前数组的禅道</span>                n <span class="token operator">=</span> len<span class="token punctuation">;</span>                <span class="token comment">// 有数据被清空</span>                removed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token comment">// 调用到上面的 expungeStaleEntry 方法</span>                <span class="token comment">// 对从 i 向后遍历遇到的一个位置为空的距离(环形遍历), 清空无效的 Entry, 将有效 Entry 直接计算出来的位置和当前位置不一样的, 进行位置的重新调整</span>                <span class="token comment">// 返回遇到的第一个位置为空的位置索引</span>                i <span class="token operator">=</span> <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token comment">// n>>> 1 等于 n / 2    </span>        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>n <span class="token operator">>>>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 返回这次清洗中是否有无效 Entry 被清除过</span>        <span class="token keyword">return</span> removed<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="24-3-4-2-rehash-方法-存储数据的数组扩容"><a href="#24-3-4-2-rehash-方法-存储数据的数组扩容" class="headerlink" title="24.3.4.2 rehash() 方法: 存储数据的数组扩容"></a>24.3.4.2 rehash() 方法: 存储数据的数组扩容</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 对这个数组中的无效 Entry 调用 expungeStaleEntry(无效 Entry 的位置) 方法进行清理</span>        <span class="token function">expungeStaleEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 通过 expungeStaleEntries 尝试清理后</span>        <span class="token comment">// 当前的数组容量还是大于 阈值的 3/4, 真正的扩容</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold <span class="token operator">-</span> threshold <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">/**     * 对整个数组中的无效 Entry 所在的位置调用 expungeStaleEntry() 进行无效 Entry 的清除和有效 Entry 的重新分配位置     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">expungeStaleEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// 遍历整个数组, 通过 expungeStaleEntry 进行数组数据的清除和位置重置</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 对数组中 Entry 不为 null, 但是 key 为 null 的位置</span>            <span class="token comment">// 调用 expungeStaleEntry() 方法对当前数组从这个位置开始, 向后遍历到第一个为位置为空的位置 (环形遍历), 对这段距离内</span>            <span class="token comment">// 将这段距离中的无效 Entity 移除, 有效 Entity 的位置不等于直接计算出来的, 重新分配位置</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>         <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token keyword">int</span> oldLen <span class="token operator">=</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// 长度扩大为原来的 2 倍</span>        <span class="token keyword">int</span> newLen <span class="token operator">=</span> oldLen <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newLen<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 遍历旧数组</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span> e <span class="token operator">:</span> oldTab<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 不为空</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 无效的 entity </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 值也置为空, 帮助 GC</span>                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 计算出新的位置</span>                    <span class="token keyword">int</span> h <span class="token operator">=</span> k<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newLen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 冲突检测, 如果对应的位置有值了, 则找下一个位置</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>newTab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                        h <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> newLen<span class="token punctuation">)</span><span class="token punctuation">;</span>                      newTab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                    <span class="token comment">// 个数加 1 </span>                    count<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 更新阈值为当前长度的 2/3</span>        <span class="token function">setThreshold</span><span class="token punctuation">(</span>newLen<span class="token punctuation">)</span><span class="token punctuation">;</span>        size <span class="token operator">=</span> count<span class="token punctuation">;</span>        table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>上面就是这个 ThreadLocalMap 的 set 方法的整体流程, 繁杂的一个大流程, 整理后, 我们可以知道</p><p><strong>1. 怎样确定新值插入到哈希表中的位置</strong></p><p>每个 ThreadLocal 的 threadLocalHashCode 都是在 ThreadLocal 声明的时候就确定了, 通过 ThreadLocal 实例的 threadLocalHashCode &amp; (当前数组的长度 - 1) 就能得到当前的 value 放在数组的位置</p><p><strong>2. 当存放的位置出现冲突了, 怎么解决冲突的</strong>  </p><p>源码中通过 <strong>nextIndex(i, len)</strong> 方法解决 hash 冲突的问题, 该方法为 ((i + 1 &lt; len) ? i + 1 : 0);<br>也就是不断往后线性探测, 当到哈希表末尾的时候再从 0 开始, 成环形, 直到找到数据为空的位置, 这个就是这个 Entry 存放的地方了</p><p><strong>3. 怎样解决无效 Entry</strong><br>在 set() 方法的 for 循环中寻找和当前 Key 相同的可覆盖 Entry 的过程中通过 replaceStaleEntry 方法解决脏 entry 的问题。<br>如果当前 table[i] 为 null 的话, 直接插入新 Entry 后也会通过 cleanSomeSlots() 来解决脏 entry 的问题</p><p><strong>4. 扩容的时机和方式</strong><br>扩容的时机:<br>表面上是当前存放数据的个数 &#x3D; 数组的长度 * 3&#x2F;4;<br>而实际是 当前存放数据的个数 &#x3D; 数组的长度 * 3&#x2F;4 时, 会触发一次全数组的无效 Entry 清除和有效 Entry 的位置重算。<br>经过清除和重算后, 当前存放数据的个数还是 &gt;&#x3D; 当前阈值的 *3&#x2F;4 (阈值 &#x3D; 数组的长度 * 2&#x2F;3) &#x3D; 当前数组的 1&#x2F;2 就扩容了</p><p>扩容的方式: 当前的长度变为 2 倍, 然后把旧的数据移到新的数组中</p><h3 id="3-5-ThreadLocalMap-的-getEntry-方法"><a href="#3-5-ThreadLocalMap-的-getEntry-方法" class="headerlink" title="3.5 ThreadLocalMap 的 getEntry() 方法"></a>3.5 ThreadLocalMap 的 getEntry() 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Entry</span> <span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 计算出位置</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Entry</span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// e 不为空, 同时对应的 key 一致, 也就是直接找到了, 就返回这个 entity</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> key<span class="token punctuation">)</span>            <span class="token keyword">return</span> e<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// 找到的位置的 Entry 为空 或者 Entry 的 key 不等于当前的 key</span>            <span class="token keyword">return</span> <span class="token function">getEntryAfterMiss</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">Entry</span> <span class="token function">getEntryAfterMiss</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">Entry</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// 变量 Entry 不为空, 也就是当前的 key 直接计算出来的位置有数据, 才能进入到下面的循环, 否则直接返回 null</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 再次判断获取到的 Entry 的 key 是否等于当前的 key</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span>                <span class="token comment">// 一样直接返回入参的 Entry</span>                <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token comment">// k 为 null     </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token comment">// 无效 Entry 回收, 有效 Entry 位置重置</span>                <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">else</span>                <span class="token comment">// 下一个位置</span>                i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 获取新位置的 Entry       </span>            e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 返回 null</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-6-ThreadLocalMap-的-remove-方法"><a href="#3-6-ThreadLocalMap-的-remove-方法" class="headerlink" title="3.6 ThreadLocalMap 的 remove() 方法"></a>3.6 ThreadLocalMap 的 remove() 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// 计算出位置</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 遍历 i 和其后面的 Entity, 直到 key 找到了或者遇到了空</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 无效 Entry 清除, 有效 Entry 位置重算</span>                <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="4-ThreadLocal-的使用场景"><a href="#4-ThreadLocal-的使用场景" class="headerlink" title="4 ThreadLocal 的使用场景"></a>4 ThreadLocal 的使用场景</h2><p>ThreadLocal 不是用来解决共享对象的多线程访问问题的, 数据实质上是放在每个 Thread 实例引用的 ThreadLocalMap, 也就是说每个不同的线程都拥有专属于自己的数据容器 (ThreadLocalMap), 彼此不影响。  </p><p>因此 ThreadLocal 只适用于 <strong>共享对象会造成线程安全</strong> 的业务场景。<br>比如 Hibernate 中通过 HhreadLocal 管理 Session 就是一个典型的案例, 不同的请求线程 (用户) 拥有自己的 session, 若将 session 共享出去被多线程访问, 必然会带来线程安全问题。</p><h2 id="5-附录"><a href="#5-附录" class="headerlink" title="5 附录"></a>5 附录</h2><h3 id="5-1-引用"><a href="#5-1-引用" class="headerlink" title="5.1 引用"></a>5.1 引用</h3><p>在 Java 中, 我们声明了一个对象, 这个对象一般情况下是在堆中, 而创建的线程只是持有对象的引用, 通过这个引用调用创建的对象。  </p><p>而对于这个对象的内存分配和内存回收, 都不需要程序员负责, 都是由 JVM 去负责。一个对象是否可以被回收, 主要看是否有引用指向此对象, 说的专业点, 叫可达性分析。<br>所以,引用对应 JVM 有着重要的作用。</p><p>Java 设计这四种引用的主要目的有两个</p><blockquote><ol><li>可以让程序员通过代码的方式来决定某个对象的生命周期</li><li>有利用垃圾回收</li></ol></blockquote><h3 id="5-2-Java-的四种引用"><a href="#5-2-Java-的四种引用" class="headerlink" title="5.2 Java 的四种引用"></a>5.2 Java 的四种引用</h3><p><strong>1. 强引用</strong><br>只要某个对象有强引用与之关联, 这个对象永远不会被回收, 即使内存不足, JVM 宁愿抛出 OOM, 也不会去回收</p><p><strong>2. 软引用</strong><br>当内存不足, 会触发 JVM 的 GC, 如果 GC 后, 内存还是不足, 就会把软引用的包裹的对象给干掉, 也就是只有在内存不足, JVM 才会回收该对象</p><p><strong>3. 弱引用</strong><br>不管内存是否足够, 只要发生 GC, 都会被回收</p><p><strong>4. 虚引用</strong>  </p><blockquote><ol><li>无法通过虚引用来获取对一个对象的真实引用  </li><li>虚引用必须与 ReferenceQueue 一起使用, 当 GC 准备回收一个对象, 如果发现它还有虚引用, 就会在回收之前, 把这个虚引用加入到与之关联的 ReferenceQueue 中</li><li>当发生 GC, 虚引用就会被回收, 并且会把回收的通知放到 ReferenceQueue 中</li></ol></blockquote><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h2><p><a href="https://github.com/CL0610/Java-concurrency/blob/master/17.%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BThreadLocal/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BThreadLocal.md">并发容器之ThreadLocal</a><br><a href="https://www.jianshu.com/p/acfd2239c9f4">ThreadLocal源码深入剖析</a><br><a href="https://www.javazhiyin.com/60330.html">强软弱虚引用, 只有体会过了, 才能记住</a>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Semaphore</title>
      <link href="/article/2021/438773345/"/>
      <url>/article/2021/438773345/</url>
      
        <content type="html"><![CDATA[<p>Java 中 的 Semaphore (信号量) 是多线程编程中一种重要的同步工具, 用于控制对共享资源的访问。<br>通过 Semaphore, 我们可以限制同时访问共享资源的线程数量, 有效地管理并发访问, 确保程序在多线程环境下的稳定性和效率。<br>在一些资源有限制场景下, Semaphore 是特别合适的, 比如流量控制, 数据库连接池等。</p><h2 id="1-Semaphore-的构造方法"><a href="#1-Semaphore-的构造方法" class="headerlink" title="1 Semaphore 的构造方法"></a>1 Semaphore 的构造方法</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Semaphore</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token keyword">permits</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// permits 同时可以有多少资源可以获取, 默认的实现为非公平实现</span>        sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token keyword">permits</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token keyword">permits</span><span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 参数 2 可以配置是否为公平实现</span>        sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token keyword">permits</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token keyword">permits</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>通过上面的构造函数可以看出, Semaphore 最终还是依靠 AQS 实现的, 关于 AQS 就不展开了。<br>核心的思想就是传入一个整数, 表示资源的数量, 同时提供了一个布尔值, 来决定资源的竞争是否按照公平原则。</p><h2 id="2-Semaphore-的主要方法"><a href="#2-Semaphore-的主要方法" class="headerlink" title="2 Semaphore 的主要方法"></a>2 Semaphore 的主要方法</h2><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>void acquire() throws InterruptedException</code></td><td align="center">获取一个资源，如果无法获取到, 则阻塞等待直至能够获取为止</td></tr><tr><td align="center"><code>void acquire(int permits) throws InterruptedException</code></td><td align="center">同 acquire 方法功能基本一样, 只不过该方法可以一次性获取多个资源</td></tr><tr><td align="center"><code>void release()</code></td><td align="center">释放一个资源</td></tr><tr><td align="center"><code>void release(int permits)</code></td><td align="center">同 release 方法功能基本一样, 只不过该方法可以一次性释放多个资源</td></tr><tr><td align="center"><code>boolean tryAcquire()</code></td><td align="center">尝试获取一个资源, 如果能够获取成功则立即返回 true, 否则, 则返回 false</td></tr><tr><td align="center"><code>boolean tryAcquire(int permits)</code></td><td align="center">与 tryAcquire 方法一致, 只不过这里可以指定获取多个资源</td></tr><tr><td align="center"><code>boolean tryAcquire(long timeout,  TimeUnit unit) throws InterruptedException</code></td><td align="center">尝试获取一个资源, 如果能够立即获取到或者在指定时间内能够获取到, 则返回 true, 否则返回 false</td></tr><tr><td align="center"><code>boolean tryAcquire(int permits,  long timeout,  TimeUnit unit) throws InterruptedException</code></td><td align="center">与上一个方法一致, 只不过这里能够获取多个资源</td></tr><tr><td align="center"><code>int availablePermits()</code></td><td align="center">返回当前可用的资源个数</td></tr><tr><td align="center"><code>int getQueueLength()</code></td><td align="center">返回正在等待获取资源的线程数</td></tr><tr><td align="center"><code>boolean hasQueuedThreads()</code></td><td align="center">是否有线程正在等待获取资源</td></tr><tr><td align="center"><code>Collection&lt;Thread&gt; getQueuedThreads()</code></td><td align="center">获取所有正在等待资源的线程集合</td></tr></tbody></table><p>下面用一个简单的例子来说明 Semaphore 的具体使用。 我们来模拟这样一样场景。<br>有一天, 班主任需要班上 10 个同学到讲台上来填写一个表格, 但是老师只准备了 5 支笔, 因此, 只能保证同时只有 5<br>个同学能够拿到笔并填写表格,<br>没有获取到笔的同学只能够等前面的同学用完之后, 才能拿到笔去填写表格。该示例代码如下：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphoreDemo</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 表示老师只有 10 支笔</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Semaphore</span> semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 表示 10 个学生</span>        <span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"  同学准备获取笔......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"  同学获取到笔"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"  填写表格ing....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"  填写完表格, 归还了笔！！！！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        service<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>输出结果</p><pre class="language-log" data-language="log"><code class="language-log">pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span>  同学准备获取笔<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span>  同学获取到笔pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span>  填写表格ing<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span>  同学准备获取笔<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span>  同学获取到笔pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span>  填写表格ing<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span>  同学准备获取笔<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span>  同学准备获取笔<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span>  同学获取到笔pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span>  同学获取到笔pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span>  填写表格ing<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span>  填写表格ing<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span>  同学准备获取笔<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span>  同学获取到笔pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span>  填写表格ing<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">6</span>  同学准备获取笔<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">7</span>  同学准备获取笔<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">8</span>  同学准备获取笔<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">9</span>  同学准备获取笔<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">10</span>  同学准备获取笔<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span>  填写完表格<span class="token punctuation">,</span> 归还了笔！！！！！！pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">9</span>  同学获取到笔pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">9</span>  填写表格ing<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span>  填写完表格<span class="token punctuation">,</span> 归还了笔！！！！！！pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">7</span>  同学获取到笔pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">7</span>  填写表格ing<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">8</span>  同学获取到笔pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">8</span>  填写表格ing<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span>  填写完表格<span class="token punctuation">,</span> 归还了笔！！！！！！pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">6</span>  同学获取到笔pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">6</span>  填写表格ing<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span>  填写完表格<span class="token punctuation">,</span> 归还了笔！！！！！！pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span>  填写完表格<span class="token punctuation">,</span> 归还了笔！！！！！！pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">10</span>  同学获取到笔pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">10</span>  填写表格ing<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">7</span>  填写完表格<span class="token punctuation">,</span> 归还了笔！！！！！！pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">9</span>  填写完表格<span class="token punctuation">,</span> 归还了笔！！！！！！pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">8</span>  填写完表格<span class="token punctuation">,</span> 归还了笔！！！！！！pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">6</span>  填写完表格<span class="token punctuation">,</span> 归还了笔！！！！！！pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">10</span>  填写完表格<span class="token punctuation">,</span> 归还了笔！！！！！！</code></pre><p>根据输出结果进行分析, Semaphore 允许的最大资源为 5, 也就是允许的最大并发执行的线程个数为 5, 可以看出, 前 5 个线程（前 5 个学生）先获取到笔, 然后填写表格。<br>而 6-10 这 5 个线程, 由于获取不到资源, 只能阻塞等待。当线程 pool-1-thread-4 释放了资源后, pool-1-thread-9 就可以获取到许可, 继续往下执行,<br>对其他线程的执行过程, 也是同样的道理。 从这个例子就可以看出, Semaphore 用来做特殊资源的并发访问控制是相当合适的, 如果有业务场景需要进行流量控制, 可以优先考虑 Semaphore。</p><h2 id="3-Semaphore-的源码实现"><a href="#3-Semaphore-的源码实现" class="headerlink" title="3 Semaphore 的源码实现"></a>3 Semaphore 的源码实现</h2><p><strong>Semaphore 内部是通过 AQS 的共享锁实现的</strong>, 所以只要理解了 Semaphore 的同步器, 基本就能了解大体的实现了。</p><h3 id="3-1-Semaphore-中的-同步器"><a href="#3-1-Semaphore-中的-同步器" class="headerlink" title="3.1 Semaphore 中的 同步器"></a>3.1 Semaphore 中的 同步器</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Semaphore</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 内部定义的同步器     */</span>    <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token keyword">permits</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">permits</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">nonfairTryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 非公平的获取锁</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token comment">// 当前的状态</span>                <span class="token keyword">int</span> available <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 当前的状态 - 需要的状态, 得到剩下的状态</span>                <span class="token keyword">int</span> remaining <span class="token operator">=</span> available <span class="token operator">-</span> acquires<span class="token punctuation">;</span>                <span class="token comment">// remaining 小于 0 或者通 cas 设置为新的状态</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>available<span class="token punctuation">,</span> remaining<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> remaining<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 共享锁的释放</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 当前的状态</span>                <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 增加释放的值</span>                <span class="token keyword">int</span> next <span class="token operator">=</span> current <span class="token operator">+</span> releases<span class="token punctuation">;</span>                <span class="token comment">// 增加后的值还是小于当前的状态值, 抛出异常</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">&lt;</span> current<span class="token punctuation">)</span>                     <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum permit count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 通过 cas 设置, 成功了释放锁成功    </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">reducePermits</span><span class="token punctuation">(</span><span class="token keyword">int</span> reductions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 减少许可证, 即减少状态值</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 获取当前的状态</span>                <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 计算出新的状态值</span>                <span class="token keyword">int</span> next <span class="token operator">=</span> current <span class="token operator">-</span> reductions<span class="token punctuation">;</span>                <span class="token comment">// 新的状态值大于当前的状态值</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">></span> current<span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Permit count underflow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// cas 交换    </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">drainPermits</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 将当前的状态值设置为 0 </span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 获取当前的状态值</span>                <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 当前的状态值等于 0 了</span>                <span class="token comment">// 或者通过 cas 将当前的状态值设置为 0</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> current<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 非公平锁的实现     * 很简单, 全部都是直接复用 Sync 的方法     */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token keyword">permits</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token keyword">permits</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">nonfairTryAcquireShared</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 公平锁的实现     */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">FairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 尝试获取共享锁</span>        <span class="token comment">// 这里是公平锁的实现, 而非公平锁的实现, 就是直接调用 nonfairTryAcquireShared 方法</span>        <span class="token comment">// FairSync 和 NonfairSync 只是在 Sync 的基础上重写了这个方法, 没有其他的改变了</span>        <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 调用 AbstractQueuedSynchronizer 的 hasQueuedPredecessors 方法, </span>                <span class="token comment">// 判断当前同步队列中是否有符合条件的候选节点, 即同步队列中有没有状态不是取消状态的节点, </span>                <span class="token comment">// 有的话, 返回 -1, 尝试获取锁失败</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// 获取可用的状态    </span>                <span class="token keyword">int</span> available <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 可用的状态 - 需要的状态, 得到剩下的状态</span>                <span class="token keyword">int</span> remaining <span class="token operator">=</span> available <span class="token operator">-</span> acquires<span class="token punctuation">;</span>                <span class="token comment">// 如果剩余的状态小于 0 了 获取通过 cas 设置新的状态失败</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>available<span class="token punctuation">,</span> remaining<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// 返回剩余的状态</span>                    <span class="token keyword">return</span> remaining<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre><h3 id="3-2-Semaphore-的-acquire-方法"><a href="#3-2-Semaphore-的-acquire-方法" class="headerlink" title="3.2 Semaphore 的 acquire 方法"></a>3.2 Semaphore 的 acquire 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Semaphore</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 先调用到 AbstractQueuedSynchronizer 的 acquireSharedInterruptibly</span>        <span class="token comment">// 2. 在 AQS 的 acquireSharedInterruptibly 中先通过 Semaphore 自定义的 Sync 的 tryAcquireShared() 方法判断是否可以获取锁</span>        <span class="token comment">// 在 tryAcquireShared 方法获取当前的状态值, 通过当前的状态值 - 需要获取的状态值, 得到剩余的状态值</span>        <span class="token comment">// 如果剩余的状态值小于 0, 否则通过 cas 交换当前的状态值为剩余值</span>        <span class="token comment">// 最后返回剩余值</span>        <span class="token comment">// 3. 获取锁失败后, 会加入同步队列, 等待唤醒</span>        sync<span class="token punctuation">.</span><span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-3-Semaphore-的-release-方法"><a href="#3-3-Semaphore-的-release-方法" class="headerlink" title="3.3 Semaphore 的 release 方法"></a>3.3 Semaphore 的 release 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Semaphore</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 先调用到 AbstractQueuedSynchronizer 的 releaseShared</span>        <span class="token comment">// 2. 在 AQS 的 releaseShared 中先通过 CountDownLatch 自定义的 Sync 的 tryReleaseShared() 方法判断是否可以释放锁</span>        <span class="token comment">// 在 tryReleaseShared 方法中, 获取到当前的状态值, 当前的状态值 + 释放的状态值, 得到最新的状态值</span>        <span class="token comment">// 通过 cas 设置当前的状态值为最新的状态值, 释放锁成功</span>        sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>几乎所有的方法都是基于同步器 AQS 实现的, 所有理解了 AQS 的实现, Semaphore 的实现也就不难理解了。<br>至于其他的方法, 比如 tryAcquire, tryRelease, availablePermits 等方法也都是同样的思想, 这里就不再赘述了。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><a href="https://github.com/CL0610/Java-concurrency/blob/master/26.%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%AF%B4java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-Semaphore%EF%BC%8CExchanger/%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%AF%B4java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-Semaphore%EF%BC%8CExchanger.md">大白话说Java并发工具类-Semaphore, Exchanger</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java CountDownLatch 介绍</title>
      <link href="/article/2021/2025171875/"/>
      <url>/article/2021/2025171875/</url>
      
        <content type="html"><![CDATA[<p>在并发编程中, 经常会遇到需要等待某些任务完成后再执行其他任务的情况。这就涉及到线程之间的协作和同步。<br>CountDownLatch 是 Java 并发包中的一个类, 它允许一个或多个线程等待其他线程完成操作, 再继续执行。<br>其灵活性和简洁性使得它成为并发编程中的不可或缺的工具。</p><h2 id="1-CountDownLatch-简介"><a href="#1-CountDownLatch-简介" class="headerlink" title="1 CountDownLatch 简介"></a>1 CountDownLatch 简介</h2><p><strong>CountDownLatch</strong> 的核心特点在于它是一种倒计数器, 初始值设定为某个正整数。<br>在多线程任务中, 当一个线程完成了一定的操作, 可通过调用 countDown() 方法来使计数器减 1, 而其他线程可通过 await() 方法等待计数器变为零。<br>一旦计数器变为零, 等待的线程将被唤醒继续执行。</p><p>为了能够理解 CountDownLatch,  举一个很通俗的例子。<br>运动员进行跑步比赛时, 假设有 6 名运动员参与比赛, 裁判员在终点会为这 6 名运动员分别计时, 可以想象每当一个运动员到达终点的时候,<br>对于裁判员来说就少了一个计时任务。直到所有运动员都到达终点了, 裁判员的任务也才完成。这 6 名运动员可以类比成 6 个线程, 当线程<br>调用 CountDownLatch.countDown 方法时就会对计数器的值减一, 直到计数器的值为 0 的时候, 裁判员 (调用 await 方法的线程) 才能继续往下执行。</p><p>下面通过代码的形式模拟一下上面的过程, 了解一下 CountDownLatch 的具体用法:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatchDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">CountDownLatch</span> startSignal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//用来表示裁判员需要维护的是 6 个运动员</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">CountDownLatch</span> endSignal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 运动员等待裁判员响哨！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 这时候线程会被挂起</span>                    startSignal<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"正在全力冲刺"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                        endSignal<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"  到达终点"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"裁判员发号施令啦！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// startSignal 里面的计数值 - 1, 本身维护的就是 1, 减 1 后, 为 0, 所有卡在 startSignal 的线程都会唤醒</span>        <span class="token comment">// 即线程池中的 6 个线程都会唤醒</span>        startSignal<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 等待 endSignal 中的计数值 - 1</span>        endSignal<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// endSignal 中的计数值变为 0, 继续执行了</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有运动员到达终点, 比赛结束！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>输出结果:</p><pre class="language-log" data-language="log"><code class="language-log">pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> 运动员等待裁判员响哨！！！pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> 运动员等待裁判员响哨！！！pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> 运动员等待裁判员响哨！！！pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> 运动员等待裁判员响哨！！！pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> 运动员等待裁判员响哨！！！pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">6</span> 运动员等待裁判员响哨！！！裁判员发号施令啦！！！pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span>正在全力冲刺pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span>  到达终点pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span>正在全力冲刺pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span>  到达终点pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span>正在全力冲刺pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span>  到达终点pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span>正在全力冲刺pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span>  到达终点pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span>正在全力冲刺pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span>  到达终点pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">6</span>正在全力冲刺pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">6</span>  到达终点所有运动员到达终点<span class="token punctuation">,</span> 比赛结束！</code></pre><p>该示例代码中设置了两个 CountDownLatch, 第一个 endSignal 用于控制让 main 线程 (裁判员) 必须等到其他线程 (运动员) 让 CountDownLatch<br>维护的数值 counter 减到 0 为止。另一个 startSignal 用于让 main 线程对其他线程进行 “发号施令”, startSignal 引用的 CountDownLatch 初始值为 1,<br>而其他线程执行的 run 方法中都会先通过 startSignal.await() 让这些线程都被阻塞, 直到 main 线程通过调用 startSignal.countDown() 将<br>值 N 减 1, CountDownLatch 维护的数值 counter 为 0 后, 其他线程才能往下执行, 并且, 每个线程执行的 run 方法中都会通过 endSignal.countDown(),<br>对 endSignal 维护的数值进行减一, 由于往线程池提交了 6 个任务, 会被减 6 次, 所以 endSignal 维护的值最终会变为 0, 因此 main 线程在<br>latch.await() 阻塞结束, 才能继续往下执行。</p><p>另外, 需要注意的是, 当调用 CountDownLatch 的 countDown 方法时, 当前线程是不会被阻塞, 会继续往下执行, 比如在该例中会继续输出<br>pool-1-thread-4 到达终点。</p><h2 id="2-CountDownLatch-的方法"><a href="#2-CountDownLatch-的方法" class="headerlink" title="2 CountDownLatch 的方法"></a>2 CountDownLatch 的方法</h2><p>先从 CountDownLatch 的构造方法看起:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"count &lt; 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sync</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>构造方法会传入一个整数 count, 表示当前的计算器的起始值。<br>这个值会在 CountDownLatch 的 countDown 方法被调用时 - 1, 直到减到 0 为止, 就会唤醒调用 CountDownLatch await 方法的线程, 让他继续执行下去。</p><p>CountDownLatch 的方法不是很多, 这里列举几个比较常用的:</p><blockquote><ol><li>await() throw InterruptedException: 调用该方法的线程被挂起, 直到构造方法传入的 count 减到 0 的时候, 才能继续往下执行</li><li>await(long timeout, TimeUnit unit): 与上面的 await 方法功能一致, 只不过这里有了时间限制, 调用该方法的线程等到指定的 timeout 时间后, 不管 count 是否减至为 0, 都会继续往下执行</li><li>countDown(): 使 CountDownLatch 计数值 count 减 1</li><li>long getCount(): 获取当前 CountDownLatch 当前的计数值</li></ol></blockquote><h2 id="3-CountDownLatch-的源码实现"><a href="#3-CountDownLatch-的源码实现" class="headerlink" title="3 CountDownLatch 的源码实现"></a>3 CountDownLatch 的源码实现</h2><p><strong>CountDownLatch 内部是通过 AQS 的共享锁实现的</strong>, 所以只要理解了 CountDownLatch 的同步器, 基本就能了解大体的实现了。</p><h3 id="3-1-CountDownLatch-的同步器"><a href="#3-1-CountDownLatch-的同步器" class="headerlink" title="3.1 CountDownLatch 的同步器"></a>3.1 CountDownLatch 的同步器</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatch</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 这里的 count 就是声明 CountDownLatch 构造函数传入的计算器</span>            <span class="token function">setState</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 状态值 == 0 的话, 获取共享锁成功, 否则失败</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// cas 交换状态值</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 状态值 == 0, 是否锁失败</span>                <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">// 否则 状态值减 1     </span>                <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// 减到状态值为 0 释放锁成功</span>                    <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>简简单单的一个同步器, 实现了共享锁的获取和释放的判断规则</p><h3 id="3-2-CountDownLatch-的-await-方法"><a href="#3-2-CountDownLatch-的-await-方法" class="headerlink" title="3.2 CountDownLatch 的 await 方法"></a>3.2 CountDownLatch 的 await 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatch</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 先调用到 AbstractQueuedSynchronizer 的 acquireSharedInterruptibly</span>        <span class="token comment">// 2. 在 AQS 的 acquireSharedInterruptibly 中先通过 CountDownLatch 自定义的 Sync 的 tryAcquireShared() 方法判断是否可以获取锁</span>        <span class="token comment">// 在 tryAcquireShared 方法中只要状态值, 即设置的计数值不等于 0, 都是获取锁失败</span>        <span class="token comment">// 3. 获取锁失败后, 会加入同步队列, 等待唤醒</span>        sync<span class="token punctuation">.</span><span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>await(long timeout, TimeUnit unit) 方法这里就不展开了, 实质就是带超时时间的 await 方法,<br>将内部调用的 acquireSharedInterruptibly 方法换成了带超时时间的 acquireSharedInterruptibly 的方法就是了。</p><h3 id="3-3-CountDownLatch-的-countDown-方法"><a href="#3-3-CountDownLatch-的-countDown-方法" class="headerlink" title="3.3 CountDownLatch 的 countDown 方法"></a>3.3 CountDownLatch 的 countDown 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatch</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 先调用到 AbstractQueuedSynchronizer 的 releaseShared</span>        <span class="token comment">// 2. 在 AQS 的 releaseShared 中先通过 CountDownLatch 自定义的 Sync 的 tryReleaseShared() 方法判断是否可以获取锁</span>        <span class="token comment">// 在 tryReleaseShared 方法中, 获取到当前的状态值, 即计数值, 等于 0, 直接释放锁失败</span>        <span class="token comment">// 否则就给计数值 - 1, 减 1 后, 如果最新的计数值为 0 了, 释放锁就成功了, 同时唤醒阻塞在同步队列中的线程</span>        sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>总的来说 CountDownLatch 是一个很简单的类, 全部的实现都是通过 AbstractQueuedSynchronizer 的共享锁实现的。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><a href="https://blog.csdn.net/t194978/article/details/123610589">CountDownLatch与CyclicBarrier</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java CyclicBarrier 介绍</title>
      <link href="/article/2021/291477745/"/>
      <url>/article/2021/291477745/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>在多线程编程中, 协调和同步线程的执行是至关重要的。Java 提供了许多并发工具来帮助开发人员有效地管理多线程应用程序。<br>其中之一是 CyclicBarrier, 它是一个强大的同步辅助类, 可用于在多个线程之间创建同步点, 以便它们可以在同一时间点协调执行某个任务。</p><p>CyclicBarrier 和 CountDownLatch 一样具有等待计数的功能, 但是相比于 CountDownLatch 功能更加强大。</p><p>其本身具备了以下特点</p><blockquote><ol><li>同步多个线程: 允许多个线程在达到共同的同步点之前进行等待, 然后同时开始执行</li><li>可重用性: 一旦所有等待线程达到同步点, CyclicBarrier 会重置计数器, 可以被重复使用。这使得它适用于循环的多阶段任务</li><li>自定义回调动作: 可以在所有线程达到同步点后执行自定义的回调动作, 以便在同步完成后执行一些特定的逻辑</li><li>指定等待时间: 提供了一个带有超时参数的 await() 方法, 允许等待一段指定的时间后, 即使没有足够的线程达到同步点, 也会继续执行</li><li>可检测是否被破坏: 提供的 isBroken() 方法允许检测在等待过程中是否有线程被中断, 以及是否有异常发生</li><li>内存一致性效果: 在所有线程达到同步点时, 对于之前的所有写入操作, 对于当前线程都是可以见的</li></ol></blockquote><p>为了理解 CyclicBarrier, 这里举一个通俗的例子。<br>开运动会时, 会有跑步这一项运动, 我们来模拟下运动员入场时的情况。<br>假设有 6 条跑道, 在比赛开始时, 就需要 6 个运动员在比赛开始的时候都站在起点了, 裁判员吹哨后才能开始跑步。跑道起点就相当于 “barrier”, 是临界点,<br>而这 6 个运动员就类比成线程的话, 就是这 6 个线程都必须到达指定点了, 意味着凑齐了一波, 然后才能继续执行, 否则每个线程都得阻塞等待, 直至凑齐一<br>波即可。cyclic 是循环的意思, 也就是说 CyclicBarrier 当多个线程凑齐了一波之后, 仍然有效, 可以继续凑齐下一波。CyclicBarrier的执行。</p><p>示意图如下:<br><img src="https://pic.imgdb.cn/item/6584473ac458853aef0c617c.png" alt="Alt &#39;CyclicBarrier 效果图&#39;"></p><p>当多个线程都达到了指定点后, 才能继续往下继续执行。这就有点像报数的感觉, 假设 6 个线程就相当于 6 个运动员, 到赛道起点时会报数进行统计, 如果刚好是 6 的话, 这一波就凑齐了, 才能往下执行。<br><strong>CyclicBarrier 在使用一次后, 可以进行重置, 继续当做计数器使用, 这是与 CountDownLatch 的区别之一</strong>。</p><h2 id="2-CyclicBarrier-的方法"><a href="#2-CyclicBarrier-的方法" class="headerlink" title="2 CyclicBarrier 的方法"></a>2 CyclicBarrier 的方法</h2><p>上面说到的 6 个运动员, 6 个线程, 指的就是计数器的初始值 6, 可以通过 CyclicBarrier 的构造方法传入的</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrier</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>parties<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// barrierAction 指定了回调函数, 在维护的个数达到了 0 了, 就会执行这个函数</span>    <span class="token keyword">public</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">,</span> <span class="token class-name">Runnable</span> barrierAction<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parties <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>parties <span class="token operator">=</span> parties<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> parties<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>barrierCommand <span class="token operator">=</span> barrierAction<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>CyclicBarrier 的主要方法</p><blockquote><ol><li>await() throws InterruptedException, BrokenBarrierException : 等到所有的线程都到达指定的临界点</li><li>await(long timeout, TimeUnit unit) : 与上面的 await 方法功能一致, 只不过这里有了时间限制, 调用该方法的线程等到指定的 timeout 时间后, 不管 N 是否减至为 0, 都会继续往下执行</li><li>getNumberWaiting() : 获取当前距离线程执行还差多少值</li><li>reset(): CyclicBarrier 状态重置, 重新开始</li><li>isBroken(): 判断当前的 CyclicBarrier 是否为一个打破状态, 可以理解为当前的栅栏被破坏了, 无法继续使用了, 线程这时在调用 await 方法会抛出异常</li></ol></blockquote><p>CyclicBarrier 进入打破状态的场景</p><blockquote><ol><li>线程被设置了中断标识为 true 的情况下, 调用了 await 方法</li><li>调用了 await 带超时时间的方法, 超时了也会进入 break 状态</li><li>线程调用 await, 这时需要等待的线程数为 0 了, 执行回调函数, 这个过程失败了, 也会进入 break 状态</li><li>调用 reset 方法, 也会先设置为 break 状态, 在重试设置为 false</li></ol></blockquote><p>下面用一个具体的例子来说明 CyclicBarrier 的具体用法:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrierDemo</span> <span class="token punctuation">&#123;</span>     <span class="token comment">//指定必须有 6 个运动员到达才行, 同时搭配一个线程数达到了, 就执行的回调的函数</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">CyclicBarrier</span> barrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有运动员入场, 裁判员一声令下！！！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"运动员准备进场, 全场欢呼............"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 运动员, 进场"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 线程挂起, 得到计数器达到了 0 </span>                    barrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 线程又被唤醒, 继续执行</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"  运动员出发"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>输出结果:</p><pre class="language-log" data-language="log"><code class="language-log">运动员准备进场<span class="token punctuation">,</span> 全场欢呼<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> 运动员<span class="token punctuation">,</span> 进场pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> 运动员<span class="token punctuation">,</span> 进场pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> 运动员<span class="token punctuation">,</span> 进场pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> 运动员<span class="token punctuation">,</span> 进场pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> 运动员<span class="token punctuation">,</span> 进场pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">6</span> 运动员<span class="token punctuation">,</span> 进场所有运动员入场<span class="token punctuation">,</span> 裁判员一声令下！！！！！pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">6</span>  运动员出发pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span>  运动员出发pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span>  运动员出发pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span>  运动员出发pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span>  运动员出发pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span>  运动员出发</code></pre><h2 id="3-CyclicBarrier-的源码实现"><a href="#3-CyclicBarrier-的源码实现" class="headerlink" title="3 CyclicBarrier 的源码实现"></a>3 CyclicBarrier 的源码实现</h2><p><strong>CyclicBarrier 内部是通过 ReentrantLock 和 Condition 实现的</strong>。<br>而 ReentrantLock 和 Condition 是基于 AQS 实现的, 所以还有 AQS 的基础, 就能很容易理解。</p><h3 id="3-1-CyclicBarrier-中的-Generation"><a href="#3-1-CyclicBarrier-中的-Generation" class="headerlink" title="3.1 CyclicBarrier 中的 Generation"></a>3.1 CyclicBarrier 中的 Generation</h3><p>CyclicBarrier 内部定义了一个很简单的内部类 Generation</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Generation</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Generation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>         <span class="token comment">// 默认值为 false, 表示当前的栅栏是否为破坏状态, 也就是当前的 CyclicBarrier 已经遭到了破坏, 不适用了</span>    <span class="token keyword">boolean</span> broken<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-2-CyclicBarrier-的-await-方法"><a href="#3-2-CyclicBarrier-的-await-方法" class="headerlink" title="3.2 CyclicBarrier 的 await 方法"></a>3.2 CyclicBarrier 的 await 方法</h3><p>CyclicBarrier 的 await 方法可以让线程进行等待所有线程的到齐, 一起执行, 没到齐的情况进行挂起的操作。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrier</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">BrokenBarrierException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 参数 1: 是否会超时</span>            <span class="token comment">// 参数 2: 0L 超时时间 0 纳秒, 即不超时</span>            <span class="token keyword">return</span> <span class="token function">dowait</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TimeoutException</span> toe<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>toe<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">dowait</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">BrokenBarrierException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        <span class="token comment">// 获取可重入锁, 加锁, 加锁失败会被阻塞</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">final</span> <span class="token class-name">Generation</span> g <span class="token operator">=</span> generation<span class="token punctuation">;</span>            <span class="token comment">// 当前的栅栏状态已经为破坏状态, 直接抛出异常</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BrokenBarrierException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 线程是中断状态</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 直接将栅栏设置为破坏状态, 通过 condition 将所有在等待的队列的线程移到同步队列, 等待获取锁唤醒</span>                <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                <span class="token comment">// 还需要等待的线程数 - 1</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token operator">--</span>count<span class="token punctuation">;</span>            <span class="token comment">// 还需要等待的线程数为 0 了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">boolean</span> ranAction <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">final</span> <span class="token class-name">Runnable</span> command <span class="token operator">=</span> barrierCommand<span class="token punctuation">;</span>                    <span class="token comment">// 有设置了回调函数, 执行回调函数</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                        command<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    ranAction <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token function">nextGeneration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ranAction<span class="token punctuation">)</span>                        <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 把当前的线程放到等待队列, 等待唤醒</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timed<span class="token punctuation">)</span>                        trip<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">></span> <span class="token number">0L</span><span class="token punctuation">)</span>                        nanos <span class="token operator">=</span> trip<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ie<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">==</span> generation <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">throw</span> ie<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>                   <span class="token comment">// 线程唤醒了, 继续执行其他的逻辑</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BrokenBarrierException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 唤醒后, 保留的 Generation 引用和最新的 Generation 不一样了, 直接返回当前的 index, 既还需要等待多少个线程</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">!=</span> generation<span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>                 <span class="token comment">// 设置了超时, 同时超时时间小于等于 0 了</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> nanos <span class="token operator">&lt;=</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 直接将栅栏设置为爆破状态, 通过 condition 将所有在等待的队列的线程移到同步队列, 等待获取锁唤醒</span>                    <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                   <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 设置 Generation 的 broken 为 true,</span>        generation<span class="token punctuation">.</span>broken <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        count <span class="token operator">=</span> parties<span class="token punctuation">;</span>        <span class="token comment">// 将在等待队列中的线程移到同步队列</span>        trip<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">nextGeneration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 将在等待队列中的线程移到同步队列</span>        trip<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新新的计算值</span>        count <span class="token operator">=</span> parties<span class="token punctuation">;</span>        <span class="token comment">// 重试设置一个新的  Generation, broken 默认为 false</span>        generation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Generation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-3-CyclicBarrier-的-isBroken-方法"><a href="#3-3-CyclicBarrier-的-isBroken-方法" class="headerlink" title="3.3 CyclicBarrier 的 isBroken 方法"></a>3.3 CyclicBarrier 的 isBroken 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrier</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBroken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 加锁</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 返回当前的 Generation 的 broken 状态</span>            <span class="token keyword">return</span> generation<span class="token punctuation">.</span>broken<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-3-CyclicBarrier-的-reset-方法"><a href="#3-3-CyclicBarrier-的-reset-方法" class="headerlink" title="3.3 CyclicBarrier 的 reset 方法"></a>3.3 CyclicBarrier 的 reset 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrier</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 设置为 break 状态, 更新新的等待线程个数</span>            <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 设置一个新的 Generation</span>            <span class="token function">nextGeneration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="4-CountDownLatch-与-CyclicBarrier-的比较"><a href="#4-CountDownLatch-与-CyclicBarrier-的比较" class="headerlink" title="4 CountDownLatch 与 CyclicBarrier 的比较"></a>4 CountDownLatch 与 CyclicBarrier 的比较</h2><p>CountDownLatch 与 CyclicBarrier 都是用于控制并发的工具类, 都可以理解成维护的就是一个计数器, 但是这两者还是各有不同侧重点的:</p><blockquote><ol><li>CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后, 它才执行; 而 CyclicBarrier 一般用于一组线程互相等待至某个状态,<br>  然后这一组线程再同时执行; CountDownLatch 强调一个线程等多个线程完成某件事情。CyclicBarrier 是多个线程互等, 等大家都完成, 再携手共进。</li><li>调用 CountDownLatch 的 countDown 方法后, 当前线程并不会阻塞, 会继续往下执行; 而调用 CyclicBarrier 的 await 方法, 会阻塞当前<br>  线程, 直到 CyclicBarrier 指定的线程全部都到达了指定点的时候, 才能继续往下执行</li><li>CountDownLatch 方法比较少, 操作比较简单, 而 CyclicBarrier 提供的方法更多, 比如能够通过 getNumberWaiting(), isBroken() 这些<br>  方法获取当前多个线程的状态, 并且 CyclicBarrier 的构造方法可以传入 barrierAction, 指定当所有线程都到达时执行的业务功能</li><li>CountDownLatch 是不能复用的, 而 CyclicLatch 是可以复用的, 可以通过 reset 方法进行重置</li></ol></blockquote><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><a href="https://github.com/CL0610/Java-concurrency/blob/master/25.%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%AF%B4java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-CountDownLatch%EF%BC%8CCyclicBarrier/%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%AF%B4java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-CountDownLatch%EF%BC%8CCyclicBarrier.md">大白话说java并发工具类-CountDownLatch, CyclicBarrier</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java AbstractQueuedSynchronizer 中的 Condition</title>
      <link href="/article/2021/2602151715/"/>
      <url>/article/2021/2602151715/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>任何一个 Java 对象都天然继承于 Object 类, 在线程间实现通信的往往会应用到 Object 的几个方法, 比如 wait(), wait(long timeout), wait(long timeout, int nanos) 与 notify(), notifyAll()<br>几个方法实现等待 &#x2F; 通知机制。同样的, 在 Java Lock 体系下也有同样的方法实现等待&#x2F;通知机制。</p><p>从整体上来看 <strong>Object 的 wait 和 notify &#x2F; notify 是与对象监视器配合完成线程间的等待&#x2F;通知机制, 而 Condition 与 Lock 配合完成等待通知机制,<br>前者是 Java 底层级别的, 后者是语言级别的, 具有更高的可控制性和扩展性</strong>。  </p><p>两者除了在使用方式上不同外, 在<strong>功能特性</strong>上还是有很多的不同:</p><blockquote><ol><li>Condition 能够支持不响应中断, 而通过使用 Object 方式不支持</li><li>Condition 能够支持多个等待队列 (new 多个 Condition 对象), 而 Object 方式只能支持一个</li><li>Condition 能够支持超时时间的设置, 而 Object 不支持</li></ol></blockquote><p>参照 Object 的 wait 和 notify &#x2F; notifyAll 方法, Condition 也提供了同样的方法</p><h2 id="2-Condition-实现原理分析"><a href="#2-Condition-实现原理分析" class="headerlink" title="2 Condition 实现原理分析"></a>2 Condition 实现原理分析</h2><p>看一下 Condition 的示意图, 方便后续的理解</p><p><img src="https://pic.imgdb.cn/item/65f3ab909f345e8d0304cd6c.png" alt="Alt &#39;AQS 的 Condition 实现&#39;"></p><h3 id="2-1-等待队列"><a href="#2-1-等待队列" class="headerlink" title="2.1 等待队列"></a>2.1 等待队列</h3><p>创建一个 Condition 对象是通过 lock.newCondition(), 而这个方法实际上是会 new 出一个 ConditionObject 对象, 该类是 AQS 的一个内部类。<br>Condition 是要和 lock 配合使用的, 也就是 Condition 和 Lock 是绑定在一起的。</p><p>我们知道在 Lock 是借助 AQS 实现的, 而 AQS 内部维护了一个同步队列, 如果是独占式锁的话, 所有获取锁失败的线程的会尾插入到同步队列。<br>同样的, Condition 内部也是使用同样的方式, 内部维护了一个等待队列, 所有调用 Condition.await 方法的线程会加入到等待队列中, 并且线程状态转换为等待状态。</p><p>另外注意到 ConditionObject 中有两个成员变量:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">/** First node of condition queue. */</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Node</span> firstWaiter<span class="token punctuation">;</span><span class="token comment">/** Last node of condition queue. */</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Node</span> lastWaiter<span class="token punctuation">;</span></code></pre><p>Node 类有这样一个属性:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//后继节点</span><span class="token class-name">Node</span> nextWaiter<span class="token punctuation">;</span></code></pre><p>进一步说明, 等待队列是一个单向队列。调用 Condition.await 方法后线程依次尾插入到等待队列中。<br>总的来说 ConditionObject 内部的队列的样子是这样的:</p><p><img src="https://pic.imgdb.cn/item/65f3ab929f345e8d0304d471.png" alt="Alt &#39;Condition 队列的数据结构&#39;"></p><p>同时还有一点需要注意的是: 可以多次调用 lock.newCondition() 方法创建多个 condition 对象, 也就是一个 lock 可以持有多个等待队列。<br>而在利用 Object 的在实现上只能借助<strong>对象 Object 对象监视器上的一个同步队列和一个等待队列, 而并发包中的 Lock 拥有一个同步队列和多个等待队列</strong>。</p><p>如图所示:</p><p>MultiConditionInAbstractQueuedSynchronizer<br><img src="https://pic.imgdb.cn/item/65f3ab949f345e8d0304dc11.png" alt="Alt &#39;AQS 中的多个 Condition&#39;"></p><p>如图所示, ConditionObject 是 AQS 的内部类, 因此每个 ConditionObject 能够访问到 AQS 提供的方法, 相当于每个 Condition 都拥有所属同步器的引用。</p><h2 id="3-await-的实现原理"><a href="#3-await-的实现原理" class="headerlink" title="3 await 的实现原理"></a>3 await 的实现原理</h2><p><strong>当调用 Condition.await() 方法后会使得当前获取 lock 的线程进入到等待队列, 如果该线程能够从 await() 方法返回的话一定是该线程获取了与 Condition 相关联的 lock 或者被中断</strong>。</p><p>await() 方法源码为:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 当前线程为中断状态</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1. 把当前的线程封装为 Node 节点, 放到队列的尾部, 同时返回这个节点    </span>    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2. 释放当前线程所占用的 lock, 在释放的过程中会唤醒同步队列中的下一个节点</span>    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 判断当前节点是否在 AQS 的同步队列里面</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 3. 把当前线程挂起, 进入阻塞状态</span>        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 0 不是被中断, 结束循环了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 4. 自旋等待获取到同步状态, 既 Lock </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> <span class="token constant">THROW_IE</span><span class="token punctuation">)</span>        interruptMode <span class="token operator">=</span> <span class="token constant">REINTERRUPT</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 5. 处理被中断的状态    </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>大概的流程是这样的:<br><strong>当前线程调用 Condition.await() 方法后, 会使得当前线程释放 lock, 然后加入到等待队列中, 直至被 signal&#x2F;signalAll 后会使得当前线程从等待队列中移至到同步队列中去, 再次获得了 lock 后才会从 await 方法返回, 或者在等待时被中断会做中断处理</strong>。</p><p>这里涉及几个问题</p><blockquote><ol><li>是怎样将当前线程添加到等待队列中去的</li><li>释放锁的过程</li><li>怎样才能从 await 方法退出</li></ol></blockquote><h3 id="3-1-await-中的入队操作-addConditionWaiter-方法"><a href="#3-1-await-中的入队操作-addConditionWaiter-方法" class="headerlink" title="3.1 await 中的入队操作 - addConditionWaiter 方法"></a>3.1 await 中的入队操作 - addConditionWaiter 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 当前线程是否为持有锁的线程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 取到最后的节点    </span>    <span class="token class-name">Node</span> t <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span>        <span class="token comment">// 尾节点不为空, 同时状态不为 CONDITION (-2)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">CONDITION</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 把当前链表里面状态值不是 Conditon 的进行删除</span>        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 重试设置 t 为新的尾节点</span>        t <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 把当前节点封装为 Node</span>    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">CONDITION</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 尾节点为空, 当前节点就是头节点了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        firstWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment">// 把当前节点放到队列的尾部</span>        t<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token comment">// 更新当前节点为尾节点    </span>    lastWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 头节点</span>    <span class="token class-name">Node</span> t <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span>    <span class="token comment">// 记录最后一个状态是 Condition 的节点, 用于后面赋值给尾节点</span>    <span class="token class-name">Node</span> trail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// t 节点不为空</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取下一个节点</span>        <span class="token class-name">Node</span> next <span class="token operator">=</span> t<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">;</span>        <span class="token comment">// t 节点的状态不为 CONDITION</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">CONDITION</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 设置 t 的下一个节点为 null</span>            t<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token comment">// 因为 trail 记录的是遍历中最新的一个状态不是 Condition 的节点</span>            <span class="token comment">// 为 null, 当前一直在移动头节点, 那么只需要把 状态不为 Condition 的 t 节点的下一个节点为头节点即可</span>            <span class="token comment">// 不为 null, trail 表示当前遍历中, 最新的那个状态为 Condition 的节点, 将 t 节点的下一个节点设置到 trail 后面即可</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>trail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token comment">// 设置当前的头节点为 t 节点的下一个节点</span>                firstWaiter <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token comment">// trail 的下一个节点等于 t 节点的下一个节点</span>                trail<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> next<span class="token punctuation">;</span>                        <span class="token comment">// 没有下一个节点了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token comment">// 将尾节设置为 trail</span>                lastWaiter <span class="token operator">=</span> trail<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">else</span>            <span class="token comment">// 设置 trail = t</span>            trail <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token comment">// t = t 的下一个节点    </span>        t <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-2-await-中的锁释放操作-fullyRelease-方法"><a href="#3-2-await-中的锁释放操作-fullyRelease-方法" class="headerlink" title="3.2 await 中的锁释放操作 - fullyRelease 方法"></a>3.2 await 中的锁释放操作 - fullyRelease 方法</h3><p>将当前节点插入到等待对列之后, 会使当前线程释放 lock, 由 fullyRelease 方法实现, fullyRelease 源码为: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取同步状态</span>        <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 调用 AQS 的方法释放锁</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">release</span><span class="token punctuation">(</span>savedState<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment">// 释放成功</span>            <span class="token keyword">return</span> savedState<span class="token punctuation">;</span>        <span class="token comment">// 释放失败, 抛出异常    </span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 释放锁的节点的状态修改为 Cancelled 取消状态</span>        node<span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">CANCELLED</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>调用 AQS 的模板方法 release 方法释放 AQS 的同步状态并且唤醒在同步队列中头节点的后继节点引用的线程。</p><p>如果释放成功则正常返回, 若失败的话就抛出异常。这样就解决了上面的第 2 个问题了。</p><h3 id="3-3-await-中的判断当前节点是否在等待队列的操作-isOnSyncQueue-方法"><a href="#3-3-await-中的判断当前节点是否在等待队列的操作-isOnSyncQueue-方法" class="headerlink" title="3.3 await 中的判断当前节点是否在等待队列的操作 - isOnSyncQueue 方法"></a>3.3 await 中的判断当前节点是否在等待队列的操作 - isOnSyncQueue 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 当前节点的状态为 condition 或没有上一个节点, 也就是头节点了, 直接返回 false</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>waitStatus <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">CONDITION</span> <span class="token operator">||</span> node<span class="token punctuation">.</span>prev <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">// 没有下一个节点, 也就是理论理论上的头节点, 直接返回 true</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment">// 从链表的尾节点开始向上找, 是否有等于这个节点</span>    <span class="token keyword">return</span> <span class="token function">findNodeFromTail</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">findNodeFromTail</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 从尾节点一直往前找</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> p <span class="token operator">=</span> tail<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 当前节点和 node 一样 返回 true</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> node<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">// p 节点为 null, 没有数据了, 返回 false    </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>整理一下, 逻辑如下</p><blockquote><ol><li>当前节点为 condition 状态或者没有上一节点, 也就是头节点, 直接返回 false</li><li>当前节点没有下一个节点了, 也就是理论上的头节点,  直接返回 true</li><li>从链表的尾节点开始往前找是否有和判断的节点一样的, 有返回 ture, 没有 false</li></ol></blockquote><h3 id="3-4-await-中的线程线程唤醒中断判断-checkInterruptWhileWaiting-方法"><a href="#3-4-await-中的线程线程唤醒中断判断-checkInterruptWhileWaiting-方法" class="headerlink" title="3.4 await 中的线程线程唤醒中断判断 - checkInterruptWhileWaiting 方法"></a>3.4 await 中的线程线程唤醒中断判断 - checkInterruptWhileWaiting 方法</h3><p>这里简单说一下 Condition.signal() 方法的原理</p><blockquote><ol><li>找到当前的等待队列的头节点</li><li>通过 CAS 将头节点的状态从 condition 设置为 0 (加入等待队列的线程的状态默认为 condition)</li><li>第二步的 CAS 失败了, 会重新从等待队列中找下一个节点, 然后从第二步继续开始</li><li>第二步的 CAS 成功了, 把当前的节点放到同步队列的尾部, 同时返回上一次的尾节点</li><li>上一次的尾节点的状态为取消状态, 或者通过 CAS 将上一次的尾节点的状态设置为 signal 状态失败的话, 调用 LockSupport.unpark(上一次尾节点里面的线程), 对齐进行唤醒</li></ol></blockquote><p>上面大体就是 signal 的步骤, 理解完上面的步骤, 才能理解下面的代码, 重点, 重点。</p><p>在上面 await 方法的源码中, 知道线程是通过 <code>LockSupport.park(this)</code> 挂起的。 那么什么时候这个阻塞的方法会继续执行, 也就是对应的线程苏醒。</p><blockquote><ol><li>通过调用 LockSupport.unpark(当前线程), 唤醒当前线程</li><li>别的线程调用了当前线程的 interrupt 方法, 中断当前线程, 这是 LockSupport.park(this), 也会被唤醒, 不会抛中断异常的</li><li>线程假唤醒</li></ol></blockquote><p>所以线程在 <code>LockSupport.park(this)</code> 处苏醒, 继续走下去的, 可能性有 3 种, 这时候需要先判断当前线程是否为中断导致的属性</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 判断当前线程在等待期间, 是否被设置了中断标识, 这个方法会返回 3 种情况</span>    <span class="token comment">// 0: 正常情况, 没有设置中断标识, 表示是正常的同步队列唤醒或者外部直接通过 LockSupport.unpark() 唤醒这个线程</span>    <span class="token comment">// THROW_IE (-1): 线程唤醒后, 抛出异常</span>    <span class="token comment">// REINTERRUPT (1): 线程唤醒后, 设置中断标识为 true</span>    <span class="token comment">// THROW_IE 和 REINTERRUPT 都是表示线程在等待中被设置了中断标识, 他们是如何区别的?</span>    <span class="token comment">// 需要分析 transferAfterCancelledWait 方法中的, 将当前节点的状态通过 CAS 从 condition 设置为 0 是否成功</span>    <span class="token comment">// 那么什么时候是成功, 什么时候会失败, 这时就涉及到上面说的 signal()/signalAll() 方法的流程了</span>    <span class="token comment">// 1. 直接调用了这个线程的 interrupt() 方法, 这时候节点的状态还是 condition 的, 成功</span>    <span class="token comment">// 2. 一个线程调用了 signal()/ signalAll() 方法, 这时候执行到了上面步骤的第二步, 并成功了, 这时候另一个线程直接中断了线程, 这时候节点的状态不是 condition 的, 失败了</span>    <span class="token comment">// 3. 一个线程调用了 signal()/ signalAll() 方法, 这时候还未执行到上面步骤的第二步, 这时候另一个线程直接中断了线程, 这时候节点的状态还是 condition 的, 成功</span>        <span class="token comment">// 上面 3 种情况, 可以简单的概况为 </span>    <span class="token comment">// 1. 调用了 signal()/ signalAll() 后, 中断线程</span>    <span class="token comment">// 2. 中断了线程后, 调用了 signal()/ signalAll()</span>    <span class="token comment">// 如果是第一种情况, 则由 signal() / signalALl() 将中断线程的节点放到同步队列的尾部</span>    <span class="token comment">// 如果是第二种情况, 则由 transferAfterCancelledWait() 将中断线程的节点放到同步队列的尾部</span>    <span class="token comment">// 在第一种情况下, 存在将中断线程的节点从等待队列移动到同步队列的过程, </span>    <span class="token comment">// 这个过程会出现一个很端的时间, 在同步队列找不到这个节点, 所以在后面做多了一层判断, 直到在同步队列中找到了线程的节点, 才返回</span>    <span class="token comment">// 2 种不同的中断方式</span>    <span class="token comment">// 第一种返回了 REINTERRUPT, 线程唤醒后, 设置中断标识为 true</span>    <span class="token comment">// 第二种返回了 THROW_IE, 线程唤醒后, 抛出异常</span>    <span class="token keyword">return</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token function">transferAfterCancelledWait</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">THROW_IE</span> <span class="token operator">:</span> <span class="token constant">REINTERRUPT</span><span class="token punctuation">)</span> <span class="token operator">:</span>  <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferAfterCancelledWait</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 把 node 节点的状态从 condition 设置为 0,</span>    <span class="token comment">// 设置成功, 把节点放到同步队列的尾部, 返回 true</span>        <span class="token comment">// 在 signal/signalAll 中会先将节点设置为 signal 状态, 即 0, 然后把节点从等待队列移动到同步队列</span>    <span class="token comment">// 在这里将节点的状态从 condition 设置为 0, 设置成功了, 表示在 signal/signalAll 之前, 线程就被中断了</span>    <span class="token comment">// 设置失败, 在表示在 signal/signalAll 之后, 线程才被中断</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">CONDITION</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将中断线程的节点从等待队列移动到同步队列的过程, 存在极端时间的节点找不到</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-5-await-的退出流程"><a href="#3-5-await-的退出流程" class="headerlink" title="3.5 await 的退出流程"></a>3.5 await 的退出流程</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 当前节点是否在等待队列中</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 不在的话, 挂起当前线程</span>        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 唤醒后判断当前线程的是否被中断过</span>        <span class="token comment">// 等于 0, 表示没有被中断</span>        <span class="token comment">// 不等于 0, 表示中断过, 存在 2 种中断方式</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// acquireQueued 的返回值, true 线程需要中断, false 线程不需要中断</span>        <span class="token comment">// acquireQueued 返回需要中断, 则将不是 THROW_IE 的中断模式设置为 REINTERRUPT</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> <span class="token constant">THROW_IE</span><span class="token punctuation">)</span>        <span class="token comment">// 也就是将 0 的情况也设置为 REINTERRUPT</span>        interruptMode <span class="token operator">=</span> <span class="token constant">REINTERRUPT</span><span class="token punctuation">;</span>    <span class="token comment">// 节点的下一个节点不为 null, 移除当前链表中的取消状态的节点    </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 中断模式不为 0, 根据中断模式设置线程的中断状态   </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span><span class="token keyword">int</span> interruptMode<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 中断模式为 THROW_IE, 抛出异常</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">==</span> <span class="token constant">THROW_IE</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 中断模式为 REINTERRUPT, 设置线程的中断标识为 true    </span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">==</span> <span class="token constant">REINTERRUPT</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上面就是 await() 方法的整体流程梳理。</p><p>上面的第 3 个问题: <strong>怎样才能从 await 方法退出</strong> 也就能得到答案了</p><blockquote><ol><li>当前线程被中断, 从等待队列移动到同步队列后, 重新获取锁</li><li>调用 signal&#x2F;signalAll 将当前线程的节点从等待队列移到同步队列, 重新获取锁</li></ol></blockquote><h3 id="3-6-await-类似的其他挂起线程的方法"><a href="#3-6-await-类似的其他挂起线程的方法" class="headerlink" title="3.6 await 类似的其他挂起线程的方法"></a>3.6 await 类似的其他挂起线程的方法</h3><h4 id="3-6-1-超时机制的支持"><a href="#3-6-1-超时机制的支持" class="headerlink" title="3.6.1 超时机制的支持"></a>3.6.1 超时机制的支持</h4><p>condition 还额外支持了超时机制, 使用者可调用方法 awaitNanos(), awaitUtil() 这两个方法的实现原理, 基本上与 AQS 中的 tryAcquire 方法如出一辙。</p><p>2 者的实现方式和 await 类似, 只是在死循环中添加了对超时时间的判断。同时在超时后, <strong>将当前线程的节点的状态从 condition 设置为 0, 追加到同步队列的尾部</strong></p><h4 id="3-6-2-不响应中断的支持"><a href="#3-6-2-不响应中断的支持" class="headerlink" title="3.6.2 不响应中断的支持"></a>3.6.2 不响应中断的支持</h4><p>要想不响应中断可以调用 condition.awaitUninterruptibly() 方法, 该方法的源码为: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">awaitUninterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 节点入到等待队列</span>    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 释放锁</span>    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 是否需要设置中断标识</span>    <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">// 判断当前节点不在同步队列中, 在的话, 结束循环</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 挂起线程</span>        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 线程苏醒后, 判断中断标识是否为 true</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 从同步队列中获取锁成功了, 同时返回需要设置中断 或者上面的判断后需要中断</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">||</span> interrupted<span class="token punctuation">)</span>        <span class="token comment">// 设置线程的中断标识为 true</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>这段方法与上面的 await 方法基本一致, 只不过减少了对中断的处理, 并省略了 reportInterruptAfterWait 方法抛被中断的异常。</p><h2 id="4-signal-signalAll-实现原理"><a href="#4-signal-signalAll-实现原理" class="headerlink" title="4 signal&#x2F;signalAll 实现原理"></a>4 signal&#x2F;signalAll 实现原理</h2><p><strong>调用 condition 的 signal 或者 signalAll 方法可以将等待队列中等待时间最长的节点移动到同步队列中</strong>, 使得该节点能够有机会获得 lock。<br>按照等待队列是先进先出 (FIFO) 的, 所以等待队列的头节点必然会是等待时间最长的节点, 也就是每次调用 condition 的 signal 方法是将头节点移动到同步队列中。  </p><p>signal 方法源码为:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 检测当前线程是否持有锁</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment">// 没有锁, 抛出异常</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取头节点    </span>    <span class="token class-name">Node</span> first <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token comment">// 尝试将头节点移动到同步队列</span>        <span class="token function">doSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> first<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 设置头节点为当前头节点的下一个节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>firstWaiter <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">// 当前的头节点为空, 设置尾节点也为空</span>            lastWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 置空需要移动的节点的下一个节点    </span>        first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">// transferForSignal 进行节点的真正处理</span>    <span class="token comment">// 在 transferForSignal 处理失败时, 最新的头节点不为空, 继续处理新的头节点</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>  <span class="token punctuation">(</span>first <span class="token operator">=</span> firstWaiter<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferForSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1. 将节点的状态从 condition 设置为 0</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">CONDITION</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 把这个节点放到 AQS 里面的同步队列的尾部, 同时获取到上一次的尾节点</span>    <span class="token class-name">Node</span> p <span class="token operator">=</span> <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> p<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token comment">// 上一次的尾节点状态为 1 (取消状态) 或者 通过 CAS 将这个节点的状态设置为 signal 失败, 则唤醒这个线程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span>p<span class="token punctuation">.</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">SIGNAL</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>signal方法的逻辑</strong>:</p><blockquote><ol><li>将头节点的状态更改为CONDITION</li><li>调用 enq 方法, 将该节点尾插入到同步队列中</li></ol></blockquote><p>现在我们可以得到结论: 调用 condition 的 signal 的前提条件是当前线程已经获取了 lock, 该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列, 而移入到同步队列后才有机会使得等待线程被唤醒,<br>即从 await 方法中的 LockSupport.park(this) 方法中返回, 从而才有机会使得调用 await 方法的线程成功退出。</p><p><strong>signalAll</strong>  </p><p>sigllAll 与 sigal 方法的区别体现在 doSignalAll 方法上, 前面我们已经知道 <strong>doSignal 方法只会对等待队列的头节点进行操作</strong>, 而 doSignalAll 的源码:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignalAll</span><span class="token punctuation">(</span><span class="token class-name">Node</span> first<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 将头尾节点都设置为 null</span>    lastWaiter <span class="token operator">=</span> firstWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取头节点的下一个节点</span>        <span class="token class-name">Node</span> next <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">;</span>        <span class="token comment">// 设置投节点的下一个节点为 null</span>        first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 尝试将头节点设置到同步队列的尾部</span>        <span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 头节点等于头节点的下一个节点</span>        first <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>该方法会不断地将等待队列中的每一个节点都移入到同步队列中, 即 “通知” 当前调用 condition.await() 方法的每一个线程。</p><h2 id="5-await-与-signal-signalAll-的结合思考"><a href="#5-await-与-signal-signalAll-的结合思考" class="headerlink" title="5 await 与 signal-signalAll 的结合思考"></a>5 await 与 signal-signalAll 的结合思考</h2><p>文章开篇提到等待&#x2F;通知机制, 通过使用 condition 提供的 await 和 signal&#x2F;signalAll 方法就可以实现这种机制, 而这种机制能够解决最经典的问题就是 “生产者与消费者问题”。<br>await 和 signal 和 signalAll 方法就像一个开关控制着线程 A (等待方) 和线程 B (通知方) 。它们之间的关系可以用下面一个图来表现得更加贴切:</p><p><img src="https://pic.imgdb.cn/item/65f3ab969f345e8d0304e407.png" alt="Alt &#39;Condition 下的 wait 和 notice 机制&#39;"></p><p>如图:</p><blockquote><ol><li>线程 awaitThread 先通过 lock.lock() 方法获取锁成功后调用了 condition.await 方法进入等待队列</li><li>另一个线程 signalThread 通过 lock.lock() 方法获取锁成功后调用了condition.signal 或者 signalAll 方法, 使得线程 awaitThread 能够有机会移入到同步队列中,</li><li>当其他线程释放 lock 后使得线程 awaitThread 能够有机会获取 lock, 从而使得线程 awaitThread 能够从 await 方法中退出执行后续操作。如果 awaitThread 获取 lock 失败会直接进入到同步队列</li></ol></blockquote><p>举个例子</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AwaitSignal</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Condition</span> condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Thread</span> waiter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Waiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        waiter<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> signaler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Signaler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        signaler<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Waiter</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"当前条件不满足等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                        condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"接收到通知条件满足"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Signaler</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>输出结果</p><pre class="language-none"><code class="language-none">Thread-0当前条件不满足等待  Thread-0接收到通知, 条件满足</code></pre><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h2><p><a href="https://www.codercc.com/post/d6505c50.html">详解Condition的await和signal等待&#x2F;通知机制</a><br><a href="https://blog.csdn.net/luonanqin/article/details/41894755">Condition的await-signal流程详解</a>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java AbstractQueuedSynchronizer</title>
      <link href="/article/2021/3504676988/"/>
      <url>/article/2021/3504676988/</url>
      
        <content type="html"><![CDATA[<h2 id="1-AQS-简介"><a href="#1-AQS-简介" class="headerlink" title="1 AQS 简介"></a>1 AQS 简介</h2><p>在同步组件的实现中, AQS 是核心部分, 同步组件的实现者通过使用 AQS 提供的模板方法实现同步组件语义。<br>AQS 则实现了对<strong>同步状态的管理, 以及对阻塞线程进行排队, 等待通知</strong>等一些底层的实现处理。<br>AQS 的核心也包括了这些方面: <strong>同步队列, 独占式锁的获取和释放, 共享锁的获取和释放以及可中断锁, 超时等待锁获取这些特性的实现</strong>,<br>而这些实际上则是 AQS 提供出来的模板方法, 归纳整理如下:</p><p>在 Java 并发编程领域中, AbstractQueuedSynchronizer (AQS) 是一项功能强大且设计精巧的工具。<br>它为开发人员提供了一种高效的同步机制, 用于安全地控制多线程环境下的资源访问和状态管理。</p><p>其本身的设计很简单, 内部维护 1 个 int 的状态和 1 个链表</p><blockquote><ol><li>一个线程过来获取锁 (本质就是通过 cas 修改 int 的状态), 获取锁成功 (int 状态修改成功), 线程继续执行</li><li>一个线程过来获取锁, 获取锁失败, 则将线程封装为链表的一个节点, 放入链表中, 然后挂起</li><li>获取锁的线程执行完逻辑, 释放锁, 就唤醒链表的头节点, 重新尝试获取锁, 获取成功, 从链表移除, 执行逻辑 (这个过程可能有从外部来的线程进行竞争)</li></ol></blockquote><p>上面是 AQS 非公平锁的大体过程, AQS 本身还提供了公平锁的实现, 为了实现这些锁的逻辑,<br>AQS 本身还需要支持 <strong>同步队列, 独占式锁的获取和释放, 共享锁的获取和释放以及可中断锁, 超时等待锁获取等功能</strong>。<br>而这些功能本身复杂度高同时还是高频的逻辑, 所以 AQS 本身借助了模板方法的设计模式, 将常用的逻辑封装起来, 然后让子类去实现自己锁获取释放的逻辑。<br>大体的逻辑如下:  </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 尝试获取锁</span>        <span class="token comment">// 由子类决定当前线程是否获取锁成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 获取成功, 直接返回</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 2. 获取锁失败, 将线程封装为节点, 放入队列, 然后挂起</span>        <span class="token comment">// 这些逻辑由 AQS 内部进行实现</span>        <span class="token function">addNodeToQueueAndPark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 由子类进行实现</span>    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>而这些实际上则是 AQS 提供出来的模板方法, 归纳整理如下:</p><p><strong>独占式锁相关的方法</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 独占式获取同步状态, 如果获取失败则插入同步队列进行等待</span><span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 与 acquire 方法相同, 但在同步队列中进行等待的时候可以检测中断</span><span class="token keyword">void</span> <span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 在 acquireInterruptibly 基础上增加了超时等待功能, 在超时时间内没有获得同步状态返回 false</span><span class="token keyword">boolean</span> <span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 释放同步状态, 该方法会唤醒在同步队列中的下一个节点</span><span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>共享式锁相关的方法</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 共享式获取同步状态, 与独占式的区别在于同一时刻有多个线程获取同步状态</span><span class="token keyword">void</span> <span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 在 acquireShared 方法基础上增加了能响应中断的功能</span><span class="token keyword">void</span> <span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 在 acquireSharedInterruptibly 基础上增加了超时等待的功能</span><span class="token keyword">boolean</span> <span class="token function">tryAcquireSharedNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 共享式释放同步状态</span><span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>本身了解这些模板方法的逻辑, 就能够很好的理解 AQS 的设计思想, 以及后续的同步组件的实现。</p><h2 id="2-AQS-同步队列"><a href="#2-AQS-同步队列" class="headerlink" title="2 AQS 同步队列"></a>2 AQS 同步队列</h2><p>AQS 内部核心的 2 个变量, 1 个 int 的状态值, 1 个同步队列。<br>int 的状态值本身没有多大的问题, 但是链表本身有一点设计, 所以这里对 AQS 的链表做个简单的介绍, 便于后面 AQS 的理解。</p><p>在 AQS 有一个静态内部类 Node (只列举了部分重要的属性)</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/******************** 属性  **************************/</span>    <span class="token comment">// 节点状态</span>    <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span>        <span class="token comment">// 当前节点的前驱节点</span>    <span class="token keyword">volatile</span> <span class="token class-name">Node</span> prev<span class="token punctuation">;</span>        <span class="token comment">// 当前节点的后驱节点</span>    <span class="token keyword">volatile</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>        <span class="token comment">// 加入同步队列的线程引用</span>    <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>        <span class="token comment">// 等待队列中的下一个节点</span>    <span class="token class-name">Node</span> nextWaiter<span class="token punctuation">;</span>    <span class="token comment">/******************** 节点模式  **************************/</span>    <span class="token comment">// 标识节点为独占模式</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> <span class="token constant">SHARED</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 标识节点为独占模式</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> <span class="token constant">EXCLUSIVE</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">/******************** 节点状态  **************************/</span>        <span class="token comment">// 节点从同步队列中取消</span>    <span class="token keyword">int</span> <span class="token constant">CANCELLED</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment">// 等待唤醒的状态</span>    <span class="token keyword">int</span> <span class="token constant">SIGNAL</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 当前节点进入等待队列中</span>    <span class="token keyword">int</span> <span class="token constant">CONDITION</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">// 在共享锁的释放中, 会从头节点向后逐个唤醒状态为 signal 的节点的线程, 直到遇到第一个状态为 0 的, 停下来, 会将其从 0 设置为 -3</span>    <span class="token comment">// 表示下一次共享式同步状态获取将会无条件传播下去</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATE</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>        <span class="token comment">// 初始状态</span>    <span class="token keyword">int</span> <span class="token constant">INITIAL</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>从上面的节点的属性可以知道每个节点有前驱节点 prev 和后驱节点 next, 所以可以知道同步队列的真实实现是一个双向链表。</p><p>另外 AQS 自身的属性中有两个重要的成员变量:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 同步队列的头节点</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> head<span class="token punctuation">;</span>    <span class="token comment">// 同步队列的尾节点</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> tail<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>结合 2 个属性, 可以得出 AQS 中维护的同步队列的结构如下:</p><p><img src="https://pic.imgdb.cn/item/65f169069f345e8d03eda96f.png" alt="Alt &#39;AQS 双向链表的结构&#39;"></p><p>同时, 我们也可以大概分析出节点加入同步队列的过程:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 1. 将线程封装为节点</span><span class="token comment">// 2. 将节点设置到双写链表的尾部</span><span class="token comment">// 3. 修改 AQS 的 tail 指向新的节点</span></code></pre><p>退出链表的逆推就行了, 这里就不再赘述了。</p><h2 id="3-AQS-中的独占锁实现"><a href="#3-AQS-中的独占锁实现" class="headerlink" title="3 AQS 中的独占锁实现"></a>3 AQS 中的独占锁实现</h2><h3 id="3-1-独占锁的获取-acquire-方法"><a href="#3-1-独占锁的获取-acquire-方法" class="headerlink" title="3.1 独占锁的获取 - acquire 方法"></a>3.1 独占锁的获取 - acquire 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用需要子类实现的 tryAcquire() 方法, 尝试获取锁</span>            <span class="token comment">// 1. 获取锁成功了, 方法结束</span>    <span class="token comment">// 2. 获取锁失败, 将当前线程封装为 Node 节点, 放到等待队列中, 等待唤醒</span>    <span class="token comment">// 3. acquireQueued 方法返回 true 表示当前线程需要中断了, 设置线程的中断标识为 true</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">EXCLUSIVE</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment">// 设置当前的线程的中断标识为 true </span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="3-1-1-acquire-中的入队操作-addWaiter-方法"><a href="#3-1-1-acquire-中的入队操作-addWaiter-方法" class="headerlink" title="3.1.1 acquire 中的入队操作 - addWaiter 方法"></a>3.1.1 acquire 中的入队操作 - addWaiter 方法</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 当前使用的为 OpenJdk 11 版本, 可能会有出入</span><span class="token comment">// 入参的 mode 为 Node.EXCLUSIVE 或者 Node.SHARED, 表示当前节点的模式为独占模式或者共享模式</span><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span> mode<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 1 将当前线程封装成一个 Node 节点, 这个节点的下一个等待的节点的模式, 既 Node.EXCLUSIVE 或 Node.SHARED</span>    <span class="token comment">// 通过这个下一个节点的模式可以间接等待当前节点模式</span>    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 死循环</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">// 取到当前链表的尾节点</span>        <span class="token class-name">Node</span> oldTail <span class="token operator">=</span> tail<span class="token punctuation">;</span>        <span class="token comment">// 2 当前尾节点是否为 null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 2.2 设置新的节点的前驱节点为当前链表的尾节点</span>            node<span class="token punctuation">.</span><span class="token function">setPrevRelaxed</span><span class="token punctuation">(</span>oldTail<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 通过 CAS 把当前节点设置为尾节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>oldTail<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">// 旧的尾节点的下一个节点为当前的新节点</span>                oldTail<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>                <span class="token keyword">return</span> node<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 2.1 当前同步队列尾节点为 null, 说明当前线程是第一个加入同步队列进行等待的线程, 初始化同步队列</span>            <span class="token comment">// 同步队列这时候不为空了, 又执行一次循环</span>            <span class="token function">initializeSyncQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">initializeSyncQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span> h<span class="token punctuation">;</span>    <span class="token comment">// 创建出一个空的 Node 节点, 通过 CAS 操作尝试将其变为头节点, 再将尾节点的指针指向新创建的节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">HEAD</span><span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        tail <span class="token operator">=</span> h<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>分析可以看上面的注释。<br>程序的逻辑主要分为两个部分:</p><blockquote><ol><li>当前同步队列的尾节点为 null, 调用方法 initializeSyncQueue(), 初始出一个头部没有任何信息的链表, 然后回来, 重写回到循环, 再次尝试把当前节点放到链表的尾部</li><li>当前队列的尾节点不为 null, 则采用尾插入 (compareAndSetTail() 方法) 的方式入队</li></ol></blockquote><h4 id="3-1-2-acquire-中的在等待队列唤醒-acquireQueued-方法"><a href="#3-1-2-acquire-中的在等待队列唤醒-acquireQueued-方法" class="headerlink" title="3.1.2 acquire 中的在等待队列唤醒 - acquireQueued 方法"></a>3.1.2 acquire 中的在等待队列唤醒 - acquireQueued 方法</h4><p>获取独占式锁失败的线程会包装成 Node, 然后插入等待同步队列。<br>在同步队列中的节点 (线程) 会做什么事情来保证自己能够有机会获得独占式锁了?<br>带着这样的问题我们就来看看 acquireQueued() 方法, 从方法名就可以很清楚, 这个方法的作用就是排队获取锁的过程, 源码如下: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 是否需要通知当前线程中断</span>    <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 获取当前节点的前驱节点</span>            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 2 前驱节点是头节点并且成功获取同步状态, 即可以获得独占式锁</span>            <span class="token comment">// 在上面创建 addWaiter 方法可以知道, 同步队列为空, 会创建一个默认值的头节点 head, 再把新节点放到这个头节点前面</span>            <span class="token comment">// 如果一个节点的前驱节点为头节点, 就可以判断出这个节点为链表中真正数据的第一个节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 当前节点设置为 头节点</span>                <span class="token comment">// 设置头节点 = node</span>                <span class="token comment">// 设置 node.thread = null</span>                <span class="token comment">// 设置 node.prev = null</span>                <span class="token comment">// 这时候头节点的状态为 signal (-1)</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                        <span class="token comment">// 3 获取锁失败, 线程进入等待状态等待获取独占式锁</span>            <span class="token comment">// shouldParkAfterFailedAcquire 主要是判断当前的节点里面的线程是否可以挂起, </span>            <span class="token comment">// 返回 true 的条件: node 的前驱节点的状态为 signal (等待唤醒的状态), 前驱在等待唤醒, 那么这个节点先挂起</span>            <span class="token comment">// parkAndCheckInterrupt 这时会挂起线程, 阻塞住, 直到被唤醒获取中断</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment">// | 或运算, 只要有一个真, 就是真</span>                <span class="token comment">// interrupted 默认为 false, parkAndCheckInterrupt() 返回了 true, 那么 interrupted 就会为 true</span>                interrupted <span class="token operator">|=</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 上面的逻辑出现了异常了, 正常的情况就是线程的中断标识为 true, 但是挂起了, 或者挂起中, 被中断了</span>        <span class="token comment">// 取消获取锁</span>        <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 需要设置中断标识, </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>interrupted<span class="token punctuation">)</span>            <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span><span class="token class-name">Node</span> pred<span class="token punctuation">,</span> <span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token comment">// 前驱节点的状态为 signal </span>    <span class="token comment">// signal 表示等待唤醒的状态, 安全的, 当前线程可以挂起</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">SIGNAL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment">// > 0, 状态为取消状态</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 从当前节点一直往前找到第一个状态不为 CANCELLED (1) 的节点,</span>        <span class="token comment">// 也就是找到链表中前面中最接近当前节点, 同时状态不为 CANCELLED (1), 将当前节点放到这个节点的后面, 中间的节点舍弃掉</span>        <span class="token comment">// 效果: 从当前节点到第一个不为 CANCELLED 状态的节点之间所有的 CANCELLED 状态的节点都被删除</span>        <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 将前驱节点设置为 SIGNAL 状态, 表示节点里面的线程等待唤醒</span>        pred<span class="token punctuation">.</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">SIGNAL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 返回 false, 表示当前的线程还不能挂起, 再走一遍循环</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 使当前线程挂起, 直到被唤醒</span>    <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回当前线程的中断标识</span>    <span class="token keyword">return</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>到这里就应该清楚了, acquireQueued() 在自旋过程中主要完成了两件事情:</p><blockquote><p>1 如果当前节点的前驱节点是头节点, 并且再次尝试, 能够获取到同步状态的话 (即获取到锁), 直接返回, 让线程能哥继续执行, 否则进入下一步<br>2 获取锁失败的话, 会根据前驱节点的状态进行处理 (如下)</p><blockquote><p>2.1 前驱节点的状态为 CANCELLED, 从当前节点一直往前找到第一个不是取消状态的节点, 将当前节点放到其后面, 重新执行 acquireQueued 方法的逻辑<br>2.2 前驱节点不是 SIGNAL 和 CANCELLED, 将前驱节点设置为 SIGNAL 状态, 重新执行 acquireQueued 方法的逻辑<br>2.3 前驱节点为 SIGNAL 状态, 把当前线程挂起来。等待被唤醒</p></blockquote></blockquote><p>到这里可以看出独占锁的特点</p><blockquote><ol><li>线程进来, 就直接尝试获取同步状态, 获取成功, 直接返回</li><li>获取失败, 就将线程封装为节点, 放入等待链表, 然后挂起</li></ol></blockquote><h4 id="3-1-3-acquire-中等待队列唤醒异常-cancelAcquire-方法"><a href="#3-1-3-acquire-中等待队列唤醒异常-cancelAcquire-方法" class="headerlink" title="3.1.3 acquire 中等待队列唤醒异常 - cancelAcquire 方法"></a>3.1.3 acquire 中等待队列唤醒异常 - cancelAcquire 方法</h4><p>在上面的 acquireQueued 方法中, 线程的中断标识为 true, 尝试挂起会失败, 这时候会让这个线程取消获取锁的逻辑</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 节点为 null, 直接结束</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 设置节点的线程为 null </span>    node<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token class-name">Node</span> pred <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token comment">// 从当前的节点往前找到第一个状态为取消状态 (1) 的节点, 也就是当前链表中最后一个状态为取消状态的节点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment">// 设置当前节点的前缀节点为这个取消状态节点的前驱节点</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token comment">// 这里的 predNext 就是当前链表中最后一个状态为取消状态的节点, 为下面的 cas 使用</span>    <span class="token class-name">Node</span> predNext <span class="token operator">=</span> pred<span class="token punctuation">.</span>next<span class="token punctuation">;</span>       <span class="token comment">// 当前节点的状态设置为取消状态(1)</span>    node<span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">CANCELLED</span><span class="token punctuation">;</span>     <span class="token comment">// 当前节点就是为节点, 通过 cas 将当前链表的尾节点从当前节点设置为找到的节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> tail <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> pred<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 设置找到的节点的下一个节点从 predNext 设置为 null</span>        pred<span class="token punctuation">.</span><span class="token function">compareAndSetNext</span><span class="token punctuation">(</span>predNext<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ws<span class="token punctuation">;</span>        <span class="token comment">// 找到的节点不是头节点, 同时节点的线程不为空</span>        <span class="token comment">// 加上 节点的状态为 signal 或者 不是取消状态下, 能设置为 signal 状态</span>        <span class="token comment">// 后面的判断最少为了确保找到的节点为 signal 状态</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> head <span class="token operator">&amp;&amp;</span> pred<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">SIGNAL</span> <span class="token operator">||</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> pred<span class="token punctuation">.</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">SIGNAL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 当前节点的下一个节点</span>            <span class="token class-name">Node</span> next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment">// 下一个节点不为空, 同时状态不是取消状态, 将找到的节点的下一个节点设置为当前节点的下一个节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> next<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                pred<span class="token punctuation">.</span><span class="token function">compareAndSetNext</span><span class="token punctuation">(</span>predNext<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 找到的节点为头节点</span>            <span class="token comment">// 找到的节点的线程为空</span>            <span class="token comment">// 找到的节点的状态为取消状态</span>            <span class="token comment">// 都会执行到这个方法, 唤醒这个节点后面的第一个状态小于等于 0 的线程</span>            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 协助 gc</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token comment">// 当前的节点状态为不是初始状态或者取消状态, 设置为默认值 0, 初始状态</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        node<span class="token punctuation">.</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 下一个节点</span>    <span class="token class-name">Node</span> s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 从后往前找到, 找到第一个状态不为取消的节点和初始状态的节点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> p <span class="token operator">=</span> tail<span class="token punctuation">;</span> p <span class="token operator">!=</span> node <span class="token operator">&amp;&amp;</span> p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>prev<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                s <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>      <span class="token comment">// 找到了进行唤醒</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre><p>取消获取锁的过程看起来很绕, 实际整理起来很简单</p><blockquote><ol><li>清除当前节点和<strong>它前面的到第一个非取消状态的节点</strong>之间所有取消状态的节点</li><li>如果找到的节点为头节点 (注意了头节点为没有任何信息的节点), 尝试从当前节点往后找到第一个不为取消状态的节点, 唤醒它</li></ol></blockquote><h3 id="3-2-独占锁的释放-release-方法"><a href="#3-2-独占锁的释放-release-方法" class="headerlink" title="3.2 独占锁的释放 - release 方法"></a>3.2 独占锁的释放 - release 方法</h3><p>独占锁的释放就相对来说比较容易理解了, 废话不多说先来看下源码: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">// 头节点存在, 同时状态不为 0 (初始状态)</span>        <span class="token comment">// 判断 != 0 的作用下面分析</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment">// 唤醒头节点的下一个节点</span>            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>首先获取头节点的后驱节点, 后驱节点存在并且状态不为取消状态, 唤醒这个线程。  </p><p>如果不存在后驱节点或者后驱节点为取消状态, 会尝试从尾节点往前找到第一个状态不为取消状态和初始状态的节点, 同时这个节点不是当前的节点, 找到了会唤醒这个节点对应的线程。</p><blockquote><ol><li>假设现在有一个锁, 线程 A 通过 acquire 获取到了锁, 经过上面的上面的代码, 可以知道, 这时没有同步队列还没创建</li><li>线程 B 这时候通过 acquire 尝试获取锁失败了, 会创建出一个链表, 把自己封装为节点 B 放到链表的后面</li><li>acquireQueued 方法中的死循环会一直判断到当前的节点的前驱节点为头节点, 会不断重试获取锁, 而不会挂起</li><li>这时候线程 A 要释放锁了, 不需要唤醒头节点的下一个节点, 在第三步中会自己唤醒</li><li>在线程 A 释放锁之前, 又要线程 C 尝试获取锁, 失败了, 拼接到节点 B 的后面, 节点 C, 这时候会被挂起</li><li>第三步中, 线程 B 获取锁成立, 会将 B 节点设置为头节点, 清空里面的前驱节点, 线程信息等, 保留下了状态 signal (-1)</li><li>后面线程 B 释放锁, 状态不为 0 了, 就能进入唤醒 C 的过程</li><li>C 唤醒后, 重新执行 acquireQueued 的方法, 这是 C 的前置节点为原本的节点 B, 将自己的节点 C 设置为头节点, 这时候的链表只有一个原本节点 C 的节点了</li></ol></blockquote><p>所以最终的独占锁的处理如下:</p><blockquote><ol><li>线程获取锁失败, 线程被封装成 Node 进行入队操作, 核心方法在于 addWaiter(), 同时 addWaiter() 会在队列为 null 的时候进行初始化。同时通过不断的 CAS 操作将节点存到当前队列的尾部</li><li>线程获取锁是一个自旋的过程, 当且仅当当前节点的前驱节点是头节点并且成功获得同步状态时, 节点出队即该节点引用的线程获得锁, 否则, 当不满足条件时就会调用 LookSupport.park() 方法使得线程阻塞</li><li>释放锁的时候会唤醒后继节点</li></ol></blockquote><p>总体来说:<br><strong>在获取同步状态时, AQS 维护一个同步队列, 获取同步状态失败的线程会加入到链表中进行挂起, 从链表移除 (或唤醒) 的条件是前驱节点是头节点并且成功获得了同步状态。在释放同步状态时, 同步器会调用 unparkSuccessor() 方法唤醒后驱节点</strong></p><h3 id="3-3-可中断式独占锁的获取-acquireInterruptibly-方法"><a href="#3-3-可中断式独占锁的获取-acquireInterruptibly-方法" class="headerlink" title="3.3 可中断式独占锁的获取 - acquireInterruptibly 方法"></a>3.3 可中断式独占锁的获取 - acquireInterruptibly 方法</h3><p>我们知道 lock 相较于 synchronized 有一些更方便的特性, 比如能响应中断以及超时等待等特性, 现在我们依旧采用通过学习源码的方式来看看能够响应中断是怎么实现的。<br>可响应中断式锁可调用方法 lock.lockInterruptibly()。</p><p>而该方法其底层会调用 AQS 的 acquireInterruptibly 方法, 源码为: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 线程的中断标识为 true, 直接抛出异常</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 尝试获取锁失败   </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">doAcquireInterruptibly</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 将节点存入到 同步等待链表</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">EXCLUSIVE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 获取前驱节点</span>            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// help GC</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                 <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// shouldParkAfterFailedAcquire 判断当前线程是否可以挂起</span>            <span class="token comment">// parkAndCheckInterrupt 挂起当前线程, 唤醒后, 判断线程的中断标识是否为 true, 这里为 true, 就会直接抛出异常, 结束死循环, 进入 catch 里面的逻辑</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 取消获取锁</span>        <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>与 acquire 方法逻辑几乎一致, 唯一的区别是当 <strong>parkAndCheckInterrupt</strong> 返回 true, 即线程阻塞时该线程被中断, 代码抛出被中断异常。</p><h3 id="3-4-带超时等待时间的独占锁的获取-tryAcquireNanos-方法"><a href="#3-4-带超时等待时间的独占锁的获取-tryAcquireNanos-方法" class="headerlink" title="3.4 带超时等待时间的独占锁的获取 - tryAcquireNanos 方法"></a>3.4 带超时等待时间的独占锁的获取 - tryAcquireNanos 方法</h3><p>通过调用 lock.tryLock(timeout,TimeUnit) 方式达到超时等待获取锁的效果, 该方法会在三种情况下才会返回:</p><blockquote><ol><li>在超时时间内, 当前线程成功获取了锁</li><li>当前线程在超时时间内被中断</li><li>超时时间结束, 仍未获得锁返回 false</li></ol></blockquote><p>该方法会调用 AQS 的方法 tryAcquireNanos(), 源码为</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 线程的中断标识为 true</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 先尝试获取锁, 获取锁成功, 直接返回</span>    <span class="token comment">// 获取锁失败, 调用实现超时等待的方法</span>    <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">doAcquireNanos</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> nanosTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">doAcquireNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 等待的时间小于 0, 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nanosTimeout <span class="token operator">&lt;=</span> <span class="token number">0L</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">// 得到最终结束等待的时间点    </span>    <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanosTimeout<span class="token punctuation">;</span>       <span class="token comment">// 把当前节点加入到等待链表</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">EXCLUSIVE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 前驱节点为头结点, 同时获取锁成功, 将当前节点置为头结点</span>            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 1 计算超时时间</span>            nanosTimeout <span class="token operator">=</span> deadline <span class="token operator">-</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 2 判断是否到了结束的时间点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanosTimeout <span class="token operator">&lt;=</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 将当前节点从队列里面删除</span>                <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                        <span class="token comment">// 3</span>            <span class="token comment">// 判断可以挂起线程, 同时设置的超时时间 > SPIN_FOR_TIMEOUT_THRESHOLD = 1000L, 即超时时间大于 1 秒</span>            <span class="token comment">// 带超时时间的挂起线程</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nanosTimeout <span class="token operator">></span> <span class="token constant">SPIN_FOR_TIMEOUT_THRESHOLD</span><span class="token punctuation">)</span>                <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanosTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 线程的中断标识为 true</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 取消获取锁</span>        <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>程序逻辑同独占锁可响应中断式获取基本一致, 唯一的不同在于获取锁失败后, 对超时时间的处理上。<br>先计算出按照现在时间和超时时间计算出理论上的截止时间 deadline, 然后 <strong>deadline - System.nanoTime()</strong> 计算出来就是一个负数, 自然而然会在第 2 步中的 if 判断之间返回 false。<br>如果还没有超时即第 2 步中的 if 判断为 true 时就会继续执行第 3 步。</p><h2 id="4-AQS-中的共享锁实现"><a href="#4-AQS-中的共享锁实现" class="headerlink" title="4 AQS 中的共享锁实现"></a>4 AQS 中的共享锁实现</h2><h3 id="4-1-共享锁的获取-acquireShared-方法"><a href="#4-1-共享锁的获取-acquireShared-方法" class="headerlink" title="4.1 共享锁的获取 - acquireShared 方法"></a>4.1 共享锁的获取 - acquireShared 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用子类重写的获取共享锁方法</span>    <span class="token comment">// 返回了大于 0 的值, 表示获取锁</span>    <span class="token comment">// 共享锁的 tryAcquireShared 的返回值, 代表了锁当前有多少个持有者</span>    <span class="token comment">// 0 表示无锁状态, 返回 1 表示有 1 个持有者, 返回 2 表示锁已经有 2 个持有者</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">doAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 把节点加入等待链表中</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">SHARED</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 获取前驱节点</span>            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 前驱节点为头节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 获取锁</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 获取锁成功</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 判断是否可以挂起线程</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span>                interrupted <span class="token operator">|=</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>interrupted<span class="token punctuation">)</span>            <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>共享锁的获取逻辑和独占式锁的获取差不多, 这里的线程退出死循环的条件: <strong>当前节点的前驱节点是头节点并且 tryAcquireShared(arg) 返回值大于等于 0 即能成功获得同步状态</strong>。</p><p>和独占锁的获取不同的点在于</p><blockquote><ol><li>独占锁的获取成功, 只会把自己的节点移除</li><li>共享锁的获取成功, 则复杂了很多, 除了唤醒自己, 还需要把其他共享的节点也唤醒</li></ol></blockquote><h3 id="4-1-1-acquireShard-中在等待代理中唤醒后的行为-setHeadAndPropagate-方法"><a href="#4-1-1-acquireShard-中在等待代理中唤醒后的行为-setHeadAndPropagate-方法" class="headerlink" title="4.1.1 acquireShard 中在等待代理中唤醒后的行为 - setHeadAndPropagate 方法"></a>4.1.1 acquireShard 中在等待代理中唤醒后的行为 - setHeadAndPropagate 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> propagate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment">// 将当前节点设置为头节点, 清空线程信息</span>    <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 持有共享锁的线程数大于 0 </span>    <span class="token comment">// 头节点为 null</span>    <span class="token comment">// 头节点的状态为不是取消状态</span>    <span class="token comment">// 新的头节点为 null</span>    <span class="token comment">// 新的头节点的状态不是取消状态</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>propagate <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> h <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>  <span class="token punctuation">(</span>h <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment">// 下一个节点为 null 或者为共享节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment">// 尝试是否共享锁</span>            <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 从当前的头节点开始, 向后处理, 把后面所有的状态为 signal 的节点唤醒,</span>    <span class="token comment">// 直到遇到第一个节点状态不为 SIGNAL 的, 停止, 同时把这个节点的状态设置为 PROPAGATE</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取头节点</span>        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">// 头节点不为 null 同时 头节点不等于尾节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h <span class="token operator">!=</span> tail<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 获取头节点的状态</span>            <span class="token keyword">int</span> ws <span class="token operator">=</span> h<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>            <span class="token comment">// 头节点的状态等于 signal </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">SIGNAL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 通过 cas 将头节点从 signal 设置为 0</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>h<span class="token punctuation">.</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">SIGNAL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// 设置失败了, 重新开始循环</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                  <span class="token comment">// 获取后驱节点    </span>                <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 状态为 0, 则通过 cas 将其从 0 设置为 -3, 设置失败了, 则继续回到头部,</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>h<span class="token punctuation">.</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">PROPAGATE</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> head<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>大体的逻辑如下:</p><blockquote><ol><li>把当前的节点设置为头节点</li><li>如果头节点的下一个节点为共享节点, 向后处理, 把后面所有的状态为 signal 的节点唤醒, 直到遇到第一个节点状态为 0 的, 停止, 同时把这个节点的状态设置为 PROPAGATE</li></ol></blockquote><h3 id="4-2-共享锁的释放-releaseShared-方法"><a href="#4-2-共享锁的释放-releaseShared-方法" class="headerlink" title="4.2 共享锁的释放 - releaseShared 方法"></a>4.2 共享锁的释放 - releaseShared 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 尝试释放锁</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 从当前的头节点开始, 向后处理, 把后面所有的状态为 signal 的节点唤醒, 直到遇到第一个节点状态为 0 的, 停止, 同时把这个节点的状态设置为 PROPAGATE</span>        <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="4-3-共享锁的其他方法"><a href="#4-3-共享锁的其他方法" class="headerlink" title="4.3 共享锁的其他方法"></a>4.3 共享锁的其他方法</h3><blockquote><ol><li>可中断式的共享锁获取 acquireSharedInterruptibly</li><li>带超时等待时间的共享锁获取 tryAcquireSharedNanos</li></ol></blockquote><p>其实现和独占式锁可中断获取锁以及超时等待的实现几乎一致, 具体的就不再说了</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><a href="https://github.com/CL0610/Java-concurrency/blob/master/09.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer(AQS)/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer(AQS).md">深入理解AbstractQueuedSynchronizer(AQS)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java AbstractQueuedSynchronizer (AQS) 初识</title>
      <link href="/article/2021/3002099553/"/>
      <url>/article/2021/3002099553/</url>
      
        <content type="html"><![CDATA[<p>AQS，全称为 AbstractQueuedSynchronizer，是 Java 并发包 <code>java.util.concurrent</code> 中的一个抽象类，它为实现依赖于先进先出 (FIFO) 等待队列的阻塞锁<br>和相关同步器（信号量、事件，等等）提供了一个框架。</p><p>从包名就可以知道这是一个关于并发的类, 如 ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock 等这些工具的实现都依赖于 AQS。<br>这篇文章会对 AQS 做一个比较简单的介绍。</p><h2 id="1-AbstractQueuedSynchronizer-AQS-简介"><a href="#1-AbstractQueuedSynchronizer-AQS-简介" class="headerlink" title="1 AbstractQueuedSynchronizer (AQS) 简介"></a>1 AbstractQueuedSynchronizer (AQS) 简介</h2><p>在源码中, 对 AQS 的解释 (可以查看 AbstractQueuedSynchronizer 的类注释)</p><pre class="language-none"><code class="language-none">Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues.This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic &#123;@code int&#125; value to represent state.提供了一个框架, 用于实现依赖于先进先出 (FIFO) 的等待队列的阻塞锁和相关的同步器 (例如: 信号量, 事件等)。  这个类是被设计用来作为一个有用的基础, 为大部分的依靠一个单独的原子变量来表示状态的同步器。</code></pre><p>AQS (同步器) 是用来构建锁和其他同步组件的基础框架, 它的实现主要依赖一个 <strong>int 成员变量</strong>来表示同步状态以及通过一个 <strong>FIFO 队列</strong>构成等待队列。<br>它本身是一个抽象类, 内部已经将大部分的线程排队, 阻塞机制逻辑封装完成了, 但是 <strong>还是有几个 protected 修饰的用来改变同步状态的方法需要子类进行实现</strong>。</p><p>在实际地使用中, 它的子类被<strong>推荐定义为同步组件的静态内部类</strong>, AQS 自身没有实现任何同步接口, 它仅仅是定义了若干同步状态的获取和释放方法来供自定义同步组件的使用。<br>AQS 既支持独占式获取同步状态, 也可以支持共享式获取同步状态, 这样就可以方便的实现不同类型的同步组件。</p><p>AQS 是实现锁 (也可以是任意同步组件) 的关键, 在锁的实现中聚合 AQS, 利用 AQS 实现锁的语义。<br>可以这样理解二者的关系: <strong>锁是面向使用者, 它定义了使用者与锁交互的接口, 隐藏了实现细节, 而 AQS 是面向锁的实现者, 它简化了锁的实现方式, 屏蔽了同步状态的管理, 线程的排队, 等待和唤醒等底层操作</strong>。<br>锁和 AQS 很好的隔离了使用者和实现者所需关注的领域。</p><h2 id="2-AQS-的模板方法设计模式"><a href="#2-AQS-的模板方法设计模式" class="headerlink" title="2 AQS 的模板方法设计模式"></a>2 AQS 的模板方法设计模式</h2><p>AQS 的设计是使用模板方法设计模式, 它将**一些方法开放给子类进行重写, 而 AQS 给同步组件所提供模板方法又会重新调用被子类所重写的方法( 也就是重载)**。<br>例如, AQS 中需要重写的方法 tryAcquire</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>ReentrantLock 中 NonfairSync (继承 AQS) 会重写该方法为:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 不公平的尝试获取锁</span>    <span class="token keyword">return</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>而 AQS 中的获取锁的模板方法为 acquire(), 它的实现如下:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用到子类的 tryAcquire 方法来判断是否获取锁成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">EXCLUSIVE</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>acquire 会调用 tryAcquire 方法, 而此时当继承 AQS 的 NonfairSync 调用模板方法 acquire 时就会调用已经被 NonfairSync 重写的 tryAcquire 方法。<br>这就是使用 AQS 的方式, 在弄懂这点后, 对 Lock 的实现理解有很大的提升。</p><p>可以归纳总结为这么几点:</p><blockquote><ol><li>同步组件 (这里不仅仅指锁, 还包括 CountDownLatch 等) 的实现依赖于同步器 AQS, 在同步组件实现中, 使用 AQS 的方式被推荐定义继承 AQS 的静态内存类</li><li>AQS 采用模板方法进行设计, AQS 的 protected 修饰的方法需要由继承 AQS 的子类进行重写实现, 当调用 AQS 的子类的方法时就会调用被重写的方法</li><li>AQS 负责同步状态的管理, 线程的排队, 等待和唤醒这些底层操作, 而 Lock 等同步组件主要专注于实现同步语义；</li></ol></blockquote><p>AQS 可重写的方法如下  </p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">protected boolean tryAcquire(int arg)</td><td align="center">独占式获取同步状态, 实现该方法需要查询当前状态并判断同步状态是否符合预期, 然后再进行 CAS 设置同步状态</td></tr><tr><td align="center">protected boolean tryRelease(int arg)</td><td align="center">独占式释放同步状态, 等待获取同步状态的线程将有机会获取同步状态</td></tr><tr><td align="center">protected int tryAcquireShared(int arg)</td><td align="center">共享式获取同步状态, 返回大于等于 0 的值, 表示获取成功, 反之, 失败</td></tr><tr><td align="center">protected boolean tryReleaseShared(int arg)</td><td align="center">共享式释放同步状态</td></tr><tr><td align="center">protected boolean isHeldExclusively()</td><td align="center">当前同步器是否在独占模式下被线程占有, 一般该方法表示锁是否被当前线程所独占</td></tr></tbody></table><p>在实现同步组件时 AQS 提供的模板方法, 也是各种同步组件真正会调用到的方法</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void acquire(int arg)</td><td align="center">独占式获取同步状态, 如果当前线程获取同步状态成功, 则由该方法进行返回。否则将会进入同步队列进行等待, 该方法会调用重写的 tryAcquire(int arg) 方法</td></tr><tr><td align="center">void acquireInterruptibly(int arg)</td><td align="center">与 acquire(int arg) 作用相同, 但是该方法可以相应中断, 如果当前线程被中断, 会抛出异常。如果没有, 则按照 acquire(int arg) 进行执行</td></tr><tr><td align="center">boolean tryAcquireNanos(int arg, long nanosTimeout)</td><td align="center">在 acquireInterruptibly(int arg) 的基础上, 增加了时间限制, 如果在指定的时候内获取到了同步状态, 返回 true, 否则返回 false</td></tr><tr><td align="center">boolean release(int arg)</td><td align="center">独占式的释放同步状态, 该方法会在释放同步状态后, 将同步队列的第一个节点包含的线程唤醒</td></tr><tr><td align="center">void acquireShared(int arg)</td><td align="center">共享式获取同步状态, 如果当前线程没有获取到同步状态, 将会进行到同步队列等待, 和独占式的区别在于, 同一时刻可以有多个线程获取到同步状态</td></tr><tr><td align="center">void acquireSharedInterruptibly(int arg)</td><td align="center">同 acquireShared(int arg) 相同, 该方法可以响应中断</td></tr><tr><td align="center">boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</td><td align="center">在 acquireSharedInterruptibly(int arg) 的基础上, 加上了时间限制</td></tr><tr><td align="center">boolean releaseShared(int arg)</td><td align="center">共享式的状态的释放</td></tr><tr><td align="center">Collection<Thread> getQueuedThreads()</td><td align="center">获取在等待同步队列上等待的线程</td></tr></tbody></table><p>AQS 提供的模板方法可以分为3类:</p><blockquote><ol><li>独占式获取与释放同步状态</li><li>共享式获取与释放同步状态</li><li>查询同步队列中等待线程情况</li></ol></blockquote><h2 id="3-一个例子"><a href="#3-一个例子" class="headerlink" title="3 一个例子"></a>3 一个例子</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Mutex</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 定义我们内部自己的同步器,  继承 AQS 的静态内存类重写方法</span>    <span class="token comment">// 将原子变量从 0 设置为 1 成功, 表示上锁成功</span>    <span class="token comment">// 将原子变量从 1 设置为 0 成功, 表示释放锁成功</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 判断当前是否处于上锁状态</span>        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 获取锁: 通过 cas 将 state 从 0 设置为 1</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">assert</span> acquires <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 释放锁: 通过 cas 将 state 从 1 设置为 0</span>        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">assert</span> releases <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>               <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 提供给一个 Condition</span>        <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConditionObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 声明我们自己的同步器</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//使用同步器的模板方法实现自己的同步语义</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sync<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">hasQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        sync<span class="token punctuation">.</span><span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>使用</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MutextDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Mutex</span> mutex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>                mutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                    mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>执行情况:</p><p><img src="https://pic.imgdb.cn/item/65eeec249f345e8d030ea97e.png" alt="Alt &#39;自定义 AQS 同步器执行线程状态&#39;"></p><p>上面的这个例子实现了独占锁的语义, 在同一个时刻只允许一个线程占有锁。<br>MutexDemo 新建了 10 个线程, 分别睡眠 3s, 从执行情况也可以看出来当前 Thread-6 正在执行占有锁, 而其他线程, 如 Thread-7, Thread-8 等线程处于 WAIT 状态。</p><p>按照推荐使用的方式, Mutex 定义了一个<strong>继承 AQS 的静态内部类 Sync</strong>, 并且重写了 AQS 的 tryAcquire 等方法, 而对 state 的更新也是利用了 setState(), getState(), compareAndSetState() 这三个方法。<br>在实现 Lock 接口中的方法也只是调用了 AQS 提供的模板方法 (因为 Sync 继承 AQS )。</p><p>从这个例子就可以很清楚的看出来, 在同步组件的实现上主要是利用了 AQS, 而 AQS “屏蔽” 了同步状态的修改, 线程排队等底层实现,<br>通过 AQS 的模板方法可以很方便的给同步组件的实现者进行调用。而针对用户来说, 只需要调用同步组件提供的方法来实现并发编程即可。</p><p>在新建一个同步组件时需要把握的两个关键点是:</p><blockquote><ol><li>实现同步组件时推荐定义继承 AQS 的静态内存类, 并重写需要的 protected 修饰的方法</li><li>同步组件语义的实现依赖于 AQS 的模板方法, 而 AQS 模板方法又依赖于被 AQS 的子类所重写的方法</li></ol></blockquote><p>同步组件实现者的角度:<br>通过可重写的方法:</p><blockquote><ol><li><strong>独占式:</strong> tryAcquire() (独占式获取同步状态), tryRelease() (独占式释放同步状态)</li><li><strong>共享式:</strong>  tryAcquireShared()(共享式获取同步状态), tryReleaseShared()(共享式释放同步状态)<br>  <strong>告诉AQS怎样判断当前同步状态是否成功获取或者是否成功释放</strong>。</li></ol></blockquote><p>同步组件专注于对当前同步状态的逻辑判断, 从而实现自己的同步语义。<br>这句话比较抽象, 举例来说, 上面的 Mutex 例子中通过 tryAcquire 方法实现自己的同步语义, 在该方法中如果当前同步状态为 0 (即该同步组件没被任何线程获取) , 当前线程可以获取同时将状态更改为 1 返回 true,<br>否则, 该组件已经被线程占用返回 false。很显然, 该同步组件只能在同一时刻被线程占用, Mutex 专注于获取释放的逻辑来实现自己想要表达的同步语义。</p><p>AQS 的角度<br>而对 AQS 来说, 只需要同步组件返回的 true 和 false 即可, 因为 AQS 会对 true 和 false 会有不同的操作, true 会认为当前线程获取同步组件成功直接返回, 而 false 的话就 AQS 也会将当前线程插入同步队列等一系列的方法。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><a href="https://github.com/CL0610/Java-concurrency/blob/master/08.%E5%88%9D%E8%AF%86Lock%E4%B8%8EAbstractQueuedSynchronizer(AQS)/%E5%88%9D%E8%AF%86Lock%E4%B8%8EAbstractQueuedSynchronizer(AQS).md">初识Lock与AbstractQueuedSynchronizer(AQS)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发三大特性</title>
      <link href="/article/2021/2392679864/"/>
      <url>/article/2021/2392679864/</url>
      
        <content type="html"><![CDATA[<p>在 Java 的高并发中，对于线程并发问题的分析通常可以通过 2 个主核心进行分析</p><blockquote><ol><li>JMM 抽象内存模型和 Happens-Before 规则</li><li>三大特性: 原子性, 有序性和可见性</li></ol></blockquote><p>JMM 抽象内存模型和 Happens-Before 规则, 前面我们讨论过了。这里讨论一下三大特性。</p><h2 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1 原子性"></a>1 原子性</h2><p>定义: 一个操作或者多个操作<strong>要么全部执行并且执行的过程不会被任何因素打断</strong>，<strong>要么就都不执行</strong>。</p><p>简单地说就是一个操作被定义为原子性了, 那么不管这个操作里面包含多少个步骤, 他们都是一个整体的, 这个整体只有执行成功, 或不执行, 不存在任何的中间态, 比如只执行一半, 或者一半成功, 一半失败。</p><p>而回到 Java 中, 很多操作看起来就一个操作, 好像是具备原子性, 但是实际中却不具备原子性。</p><p>猜猜下面的操作哪些是原子操作?  </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 1</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 2</span>a<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 3</span><span class="token keyword">int</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 4</span>a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><p>答案是: 只有第一个。  </p><p>a++ 操作可以拆分为下面 3 步：</p><blockquote><ol><li>读取 a 的值</li><li>a 的值加 1</li><li>将计算后的值重新赋值给 a</li></ol></blockquote><p>其他 2 个的分析类似。</p><h3 id="1-1-原子操作"><a href="#1-1-原子操作" class="headerlink" title="1.1 原子操作"></a>1.1 原子操作</h3><p>在 Java 内存模型中定义了 8 种原子操作</p><table><thead><tr><th align="center">操作</th><th align="center">作用对象</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">lock (锁定)</td><td align="center">主内存中的变量</td><td align="left">把一个变量标识为一个线程独占的状态</td></tr><tr><td align="center">unlock (解锁)</td><td align="center">主内存中的变量</td><td align="left">把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</td></tr><tr><td align="center">read (读取)</td><td align="center">主内存的变量</td><td align="left">把一个变量的值从主内存传输到线程的工作内存中，以便后面的 load 动作使用</td></tr><tr><td align="center">load (载入)</td><td align="center">工作内存中的变量</td><td align="left">把 read 操作从主内存中得到的变量值放入工作内存中的变量副本</td></tr><tr><td align="center">use (使用)</td><td align="center">工作内存中的变量</td><td align="left">把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作</td></tr><tr><td align="center">assign (赋值)</td><td align="center">工作内存中的变量</td><td align="left">把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</td></tr><tr><td align="center">store (存储)</td><td align="center">工作内存的变量</td><td align="left">把工作内存中一个变量的值传送给主内存中以便随后的write操作使用</td></tr><tr><td align="center">write (操作)</td><td align="center">主内存的变量</td><td align="left">把 store 操作从工作内存中得到的变量的值放入主内存的变量中</td></tr></tbody></table><p>上面的这些指令操作是相当底层的，可以作为扩展知识面掌握下。  </p><p>需要注意的一点就是: 指令与指令之间组合起来达到某个效果。<br>但是 Java 内存模型只要求这些组合指令之间是顺序执行的，不强制他们一定是连续执行的。  </p><p>比如把一个变量从主内存中复制到工作内存中就需要执行 read, load 操作，将工作内存同步到主内存中就需要执行 store, write 操作。<br>也就是说 read 和 load 之间可以插入其他指令，store 和 writer 可以插入其他指令。<br>比如对主内存中的 a, b 进行访问就可以出现这样的操作顺序: <strong>read a, read b, load b, load a</strong>。</p><p>支持变量操作的原子操作的有 read, load, use, assign, store, write。  基础数据类型比较简单, 基本只有使用到其中的一条, 所以可以看为<strong>基本数据类型的访问读写具备原子性 (long 和 double 的操作不具备操作性)</strong>, 如上面的 int a &#x3D; 1;</p><h3 id="1-2-synchronized-和-volatile-对原子性的支持"><a href="#1-2-synchronized-和-volatile-对原子性的支持" class="headerlink" title="1.2 synchronized 和 volatile 对原子性的支持"></a>1.2 synchronized 和 volatile 对原子性的支持</h3><p><strong>synchronized</strong></p><p>上面一共有八条原子操作，其中六条可以满足基本数据类型的访问读写具备原子性，还剩下 lock 和 unlock 两条原子操作。这 2 个可以用于支持更大范围的原子性操作。<br>尽管 JVM 没有把 lock 和 unlock 开放给我们使用，但 JVM 以更高层次的指令 monitorenter 和 monitorexit 指令开放给我们使用,<br>映射到 Java 代码中就是— synchronized 关键字, 也就是说 synchronized 满足原子性。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        b <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>volatile</strong></p><p>而说到关键字, Java 中另一个和并发相关的高频关键字 <strong>volatile</strong>, 是否可以保证原子性了。<br>先举一个例子。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileExample</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 启动 10 个线程</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                        counter<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>如上: counter 是 volatile 修饰的。<br>开启 10 个线程，每个线程都自加 10000 次，如果不出现线程安全的问题最终的结果应该就是：10 <code>*</code> 10000 &#x3D; 100000。<br>但是运行多次都是小于 100000 的结果, 也就是说明: <strong>volatile 不能保证原子性</strong>。  </p><p>从上面的说明可以知道 counter++ 不是原子性操作。如果线程 A 读取 counter 到工作内存后，其他线程对这个值已经做了自增操作后，那么线程 A 的这个值自然而然就是一个过期的值，因此，总结果必然会是小于 100000 的。</p><p>如果让 volatile 保证原子性，必须符合以下两条规则：</p><blockquote><ol><li>运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值</li><li>变量不需要与其他的状态变量共同参与不变约束 (volatile 变量的变化不会与其它变量的变化有任何联系)</li></ol></blockquote><h2 id="2-有序性"><a href="#2-有序性" class="headerlink" title="2 有序性"></a>2 有序性</h2><p>定义: 程序执行的顺序按照代码的先后顺序执行。</p><p>例如:  </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// 语句1  </span>flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          <span class="token comment">// 语句2</span></code></pre><p>先给变量 i 赋值，然后给 flag 赋值，语句 1 在 语句 2 的前面。<br>但是在编译器和处理器可能会为了性能对其进行重排序 (指令重排序), 因为语句 1 和 语句 2 之间没有依赖关系，所以语句 2 可能被重排序到语句 1 的前面。</p><h3 id="2-1-synchronized-和-volatile-对有序性的支持"><a href="#2-1-synchronized-和-volatile-对有序性的支持" class="headerlink" title="2.1 synchronized 和 volatile 对有序性的支持"></a>2.1 synchronized 和 volatile 对有序性的支持</h3><p><strong>synchronized</strong>  </p><p>synchronized 语义表示锁在同一时刻只能由一个线程进行获取，当锁被占用后，其他线程只能等待。<br>因此, synchronized 语义就要求线程在访问读写共享变量时只能 “串行” 执行, 因此 synchronized 具有有序性。</p><p>但是在 synchronized 内部的代码块的逻辑, JVM 没有禁止重排序, 也就是支持处理器为了性能, 在不影响结果的情况下, 调整执行顺序。</p><p>例子:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 1</span>        b <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token comment">// 2</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>上面 1,2 2 个操作没有存在结果的依赖, 如果为了性能, 处理器仍然可以对他们进行重排序, 变为 2, 1 的执行顺序。</p><p><strong>volatile</strong>  </p><p>在 Java 内存模型中说过，为了性能优化，编译器和处理器会进行指令重排序。<br>也就是说 Java 程序天然的有序性可以总结为：如果在本线程内观察，所有的操作都是有序的, 如果在一个线程观察另一个线程，所有的操作都是无序的。那么 volatile 具备有序性吗?</p><p>先看一个例子：volatile 和 双重检验锁定的方式（Double-checked Locking）的关系:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>这里的 instance 为什么要加 volatile 修饰？<br>创建一个对象，实际是经过 3 步实现的 </p><blockquote><ol><li>分配对象内存空间</li><li>初始化对象</li><li>将对象指向我们刚刚分配的内存</li></ol></blockquote><p>但是不加 volatile 在重排序的作用下, 可能会出现下面的执行顺序：</p><p><img src="https://pic.imgdb.cn/item/657e92f2c458853aef577138.png" alt="Alt &#39;ObjectInitWithoutVolatile&#39;"></p><p>如果 2 和 3 进行了重排序的话，线程 B 进行判断 if( instance &#x3D;&#x3D; null) 时就会为 true，而实际上这个 instance 并没有初始化成功，显而易见对线程 B 来说之后的操作就会是错的。<br>而用 <strong>volatile</strong> 修饰的话，可以禁止 2 和 3 操作重排序，从而避免这种情况。volatile 包含<strong>禁止指令重排序的语义</strong>, 其具有有序性。</p><h2 id="3-可见性"><a href="#3-可见性" class="headerlink" title="3 可见性"></a>3 可见性</h2><p>当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 线程 1 执行的代码</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 线程 2 执行的代码</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span></code></pre><p>假若执行线程 1 的是 CPU1，执行线程 2 的是 CPU2。由上面的分析可知:<br>当线程 1 执行 i &#x3D; 10 这句时，会先把 i 的初始值加载到 CPU1 的本地缓存，然后赋值为 10，那么在 CPU1 的本地缓存中把 i 的值变为 10，却没有立即写入到主存当中。  </p><p>此时线程 2 执行 j &#x3D; i，它会先去主存读取 i 的值并加载到 CPU2 的本地缓存当中，此时内存当中 i 的值还是 0，那么就会使得 j 的值为 0，而不是 10。<br>这就是可见性问题，线程 1 对变量 i 修改了之后，线程 2 没有立即看到线程 1 修改的值。</p><h3 id="3-1-synchronized-和-volatile-对有序性的支持"><a href="#3-1-synchronized-和-volatile-对有序性的支持" class="headerlink" title="3.1 synchronized 和 volatile 对有序性的支持"></a>3.1 synchronized 和 volatile 对有序性的支持</h3><p><strong>synchronized</strong><br>通过对 synchronized 的内存语义进行了分析，当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。所以 synchronized 具有可见性 (Happens-Before 的 Monitor 规则保证)。</p><p><strong>volatile</strong></p><p>volatile 修饰的变量在写的时候，底层会在后面在添加 <strong>lock 指令</strong>，确保将修改的值刷新到主内存，所以 volatile 具备可见性。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>synchronized 具有: 原子性, 有序性, 可见性。  </p><p>volatile 具有：有序性，可见性。</p><p>synchronized 是否保证有序性呢? 从上面的双重检测看起来, synchronized 貌似不保证有序性, 但是 synchronized 还是保证有序性的, 只是和 volatile 的有序性不一样。  </p><p>volatile 关键字禁止 JVM 编译器和处理器对其进行重排序, 而 synchronized 保证的有序性是<strong>只有单线程可以获取锁, 串行地执行同步代码</strong>的结果, 但是同步代码里的语句是会发生指令重排序。<br>进入 synchronized 代码块前, 底层先添加一个 acquire barrier, 在最后添加一个 release barrier, 保证同步代码块中的代码不能和同步代码块外面的代码进行指令重排, 在其内部还是会发生指令重排但基本不会影响结果。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSynchronized</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 2</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">TestDemo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 2.1</span>        a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">// 2.2</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token comment">// 2.3</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 3</span>    a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>将 synchronized 内的代码块看着整个整体, 在 synchronized 的作用下, 1, 2, 3 是有序的,<br>但是 synchronized 不保证代码块内的代码是有序的, 在没有数据依赖的条件下, 运行指令重排序, 也就是可能存在 2.1 - 2.3 - 2.2 等情况。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><a href="https://github.com/CL0610/Java-concurrency/blob/master/07.%E4%B8%89%E5%A4%A7%E6%80%A7%E8%B4%A8%E6%80%BB%E7%BB%93%EF%BC%9A%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%9C%89%E5%BA%8F%E6%80%A7/%E4%B8%89%E5%A4%A7%E6%80%A7%E8%B4%A8%E6%80%BB%E7%BB%93%EF%BC%9A%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%9C%89%E5%BA%8F%E6%80%A7.md">三大性质总结：原子性、可见性以及有序性</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JMM 的一些理解</title>
      <link href="/article/2021/420633969/"/>
      <url>/article/2021/420633969/</url>
      
        <content type="html"><![CDATA[<p>JMM 全称: Java Memory Model (Java 内存模式)。<br>它是一种虚拟机规范, 用于屏蔽掉各种硬件和操作系统的内存访问差异, 以实现 Java 程序在各种平台下都能达到一致的并发效果。<br>主要规定了以下两点</p><blockquote><ol><li>一个线程<strong>如何以及何时</strong>可以看到其他线程修改过后的共享变量的值, 即线程之间<strong>共享变量的可见性</strong></li><li>如何在需要的时候对共享变量进行同步</li></ol></blockquote><p>了解 JMM 大体的概念, 可以帮忙我们了解 Java 并发的一些设计。</p><h2 id="1-线程通信和线程同步"><a href="#1-线程通信和线程同步" class="headerlink" title="1 线程通信和线程同步"></a>1 线程通信和线程同步</h2><h3 id="1-1-线程通信"><a href="#1-1-线程通信" class="headerlink" title="1.1 线程通信"></a>1.1 线程通信</h3><p>通信是指线程之间以何种机制来交换信息。<br>在命令式的编程中, 线程之间的通信机制有两种: <strong>共享内存</strong>和<strong>消息传递</strong>。</p><p>在<strong>共享内存并发的模型</strong>里, 线程之间共享程序的<strong>公共状态</strong>, 线程之间通过读 - 写内存中的公共状态来隐式进行通信。<br>在<strong>消息传递的并发模型</strong>里, 线程之间没有公共状态, 线程之间必须通过明确的发送消息来显示进行通信, 在 Java 中典型的消息传递方式就是 wait() 和 notify()。</p><p>Java 的并发采用的就是 <strong>共享内存模型</strong>, Java 线程之间的通信总是隐式进行的, 整个通信过程对程序员是完全透明的。<br>这里提到的共享内存模型指的就是 Java 内存模型 (简称 JMM )。</p><h3 id="1-2-线程同步"><a href="#1-2-线程同步" class="headerlink" title="1.2 线程同步"></a>1.2 线程同步</h3><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。  </p><p>在<strong>共享内存并发的模型</strong>里, 同步是显式进行的。程序必须显式指定某个方法或某段代码需要在线程之间互斥执行。<br>在<strong>消息传递的并发模型</strong>里, 由于消息的发送必须在消息的接收之前, 因此同步是隐式进行的。</p><h2 id="2-Java-对-JMM-的实现"><a href="#2-Java-对-JMM-的实现" class="headerlink" title="2 Java 对 JMM 的实现"></a>2 Java 对 JMM 的实现</h2><h3 id="2-1-JMM-在-Java-实现中的抽象结构模型"><a href="#2-1-JMM-在-Java-实现中的抽象结构模型" class="headerlink" title="2.1 JMM 在 Java 实现中的抽象结构模型"></a>2.1 JMM 在 Java 实现中的抽象结构模型</h3><p>JMM 定义了线程和主内存之间的抽象关系:<br>线程之间的共享变量存储在主内存 (Main Memory) 中, 每个线程都有一个私有的本地内存 (Local Memory), 本地内存中存储了该线程已读&#x2F;写共享变量的副本。<br>本地内存是 JMM 的一个抽象概念, 并不真实存在。它涵盖了缓存, 写缓冲区, 寄存器以及其他的硬件和编译器优化。</p><p><img src="https://pic.imgdb.cn/item/65759358c458853aef048811.png" alt="Alt &#39;JMM 抽象模型&#39;"></p><p>从上图来看, 线程 A 与线程 B 之间如要通信的话, 必须要经历下面 2 个步骤</p><blockquote><ol><li>线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去</li><li>线程 B 到主内存中去读取线程 A 更新的共享变量</li></ol></blockquote><h3 id="2-2-JMM-在-Java-的具体实现"><a href="#2-2-JMM-在-Java-的具体实现" class="headerlink" title="2.2 JMM 在 Java 的具体实现"></a>2.2 JMM 在 Java 的具体实现</h3><p>通过 JMM 抽象结构模型, 可以知道 Java 就是变量的传递, 达到了<strong>隐式通信</strong>的效果, 而这个过程需要借助 2 个重要的数据存储才能实现</p><blockquote><ol><li>本地内存</li><li>主内存</li></ol></blockquote><p>而 JVM 是如何实现这 2 个地方的呢?</p><p><img src="https://pic.imgdb.cn/item/6575934fc458853aef046c95.png" alt="Alt &#39;JVM 内存模型&#39;"></p><p>JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干不同的数据区域, 这些区域都有各自的用途以及创建和销毁的时间。</p><p>主要包含 2 类: </p><p><strong>1. 线程共享区域</strong></p><blockquote><p>方法区 (Method Area): 方法区是各个线程共享的内存区域, 它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据<br>堆 (Heap): 用来保存程序运行中所创建的所有对象、数组元素等</p></blockquote><p><strong>2. 线程私有区域</strong></p><blockquote><p>虚拟机栈 (VM Stack): 运行在 Java 虚拟机上的线程都拥有自己的线程栈, 主要用于存储线程执行方法时的各种状态数据等信息<br>本地方法栈 (Native Method Stack): 本地方法栈与虚拟机栈的作用相似, 不同之处在于虚拟机栈为虚拟机执行的 Java 方法服务, 而本地方法栈则为虚拟机使用到的 Native 方法服务<br>程序计数器 (PC Register) : 程序计数器保存着每一条线程下一次执行指令位置</p></blockquote><h2 id="3-JMM-在并发编程中需要解决的一些问题"><a href="#3-JMM-在并发编程中需要解决的一些问题" class="headerlink" title="3 JMM 在并发编程中需要解决的一些问题"></a>3 JMM 在并发编程中需要解决的一些问题</h2><h3 id="3-1-主内存和本地内存设计带来的问题"><a href="#3-1-主内存和本地内存设计带来的问题" class="headerlink" title="3.1 主内存和本地内存设计带来的问题"></a>3.1 主内存和本地内存设计带来的问题</h3><p>备注:<br>我们知道操作系统之间, CPU 的运算速度很快, 而 IO 的效率和他比起来慢了很多, 即便是直接读取内存, 所以 CPU 和内存之间存在着多层高速缓存, 以保证 CPU 可以保持自己运算能力, 不受 IO 的影响。<br>同理, 线程在主内存之间, 维护了一套自己的<strong>本地内存</strong>, 也是为了保持自己的执行效率。<br>而这样的设计, 就和操作系统类似, 带来了一些其他问题。</p><h4 id="3-1-1-可见性问题"><a href="#3-1-1-可见性问题" class="headerlink" title="3.1.1 可见性问题"></a>3.1.1 可见性问题</h4><p><img src="https://pic.imgdb.cn/item/6575935cc458853aef04960d.png" alt="Alt &#39;JVM 可见性问题&#39;"></p><p>如上图, 3 个共享变量 count, 2 个为副本。<br>启动 2 个线程分别对共享变量操作, 假设原本共享变量 count 为 0。</p><blockquote><ol><li>线程 A 从主内存将这个共享变量 count 加载到自己的本地内存, 值为 0</li><li>线程 B 执行同样的加载操作, 值为 0</li><li>线程 A 对这个共享变量 count + 1, count 的值变为 1, 没有将这个值同步到主内存</li><li>线程 B 这时候同样需要对这个共享变量 count + 1, 但是这时候 B 中的 count 还是 0, 没有感知到 A 对其做的修改</li></ol></blockquote><p>在多线程的环境下, 如果某个线程首次读取共享变量, 则首先到主内存中获取该变量, 然后存入工作内存中, 以后只需要在工作内存中读取该变量即可。<br>同样如果对该变量执行了修改的操作, 则先将新值写入工作内存中, 然后再刷新至主内存中, 这个刷新时间虽然很短但并不确定。</p><h4 id="3-1-2-竞争问题"><a href="#3-1-2-竞争问题" class="headerlink" title="3.1.2 竞争问题"></a>3.1.2 竞争问题</h4><p><img src="https://pic.imgdb.cn/item/6575935fc458853aef049dba.png" alt="Alt &#39;JVM 竞争问题&#39;"></p><p>如上图:<br>如果这两个加 1 操作是串行的, 最终主内存中的 count 的值应该是 3。<br>然而图中两个加 1 操作是并行的, 当它们值更新到工作内存的副本后, 会争相刷新主内存。在这里, 不管是线程 1 还是线程 2 先刷新计算结果到主内存, 最终主内存中的值只能是 2。</p><h4 id="3-1-3-主内存和本地内存"><a href="#3-1-3-主内存和本地内存" class="headerlink" title="3.1.3 主内存和本地内存"></a>3.1.3 主内存和本地内存</h4><p>为了解决上面提到的问题, JVM 提供了很多的工具类和关键字, 达到加锁串行操作, 本地内存失效, 数据强制刷新主内存等效果, 达到解决问题</p><blockquote><ol><li>synchronized 让线程之间串行的执行</li><li>volatile 让变量变更立即刷入主内存, 其他线程相关的缓存失效</li><li>Lock 加锁, 串行执行</li></ol></blockquote><p>这些不是本篇的重点, 就不展开了</p><h3 id="3-2-重排序的影响"><a href="#3-2-重排序的影响" class="headerlink" title="3.2 重排序的影响"></a>3.2 重排序的影响</h3><p>在上面, 我们讨论了主内存和本地内存在多线程的情况带来的影响: <strong>可见性 + 竞争</strong>。<br>这 2 个都是由<strong>本地内存和主内存</strong>带来的。  </p><p>而在并发过程中, 除了这 2 个地方会引起问题外, 在编译器中还存在重排序问题: 在执行程序时, 为了提高性能, 编译器和处理器常常会对指令 (我们写的代码, 最终会被转为 1 到多条指令, 然后逐个执行) 做重排序。<br>这些系统内部的优化大部分都是有效的, 但是有时在并发编程中, 则会带来某些问题。</p><h4 id="3-2-1-重排序的类型"><a href="#3-2-1-重排序的类型" class="headerlink" title="3.2.1 重排序的类型"></a>3.2.1 重排序的类型</h4><p>一个好的内存模型实际上会放松对处理器和编译器规则的束缚, 也就是说软件技术和硬件技术都为同一个目标而进行奋斗: 在不改变程序执行结果的前提下, 尽可能提高并行度。<br>JMM 对底层约束比较少, 使其能够发挥自身优势。因此, 在执行程序时, <strong>为了提高性能, 编译器和处理器常常会对指令进行重排序</strong>。一般重排序可以分为如下三种:</p><p><img src="https://pic.imgdb.cn/item/6575935ac458853aef048dfb.png" alt="Alt &#39;JVM 重排序类型&#39;"></p><blockquote><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下, 可以重新安排语句的执行顺序</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果<strong>不存在数据依赖性</strong>, 处理器可以改变语句对应机器指令的执行顺序</li><li>内存系统的重排序。由于处理器使用缓存和读 &#x2F; 写缓冲区, 这使得加载和存储操作看上去可能是在乱序执行的。</li></ol></blockquote><p>注: 指令并行重排序和内存系统重排序统称为<strong>处理器排序</strong></p><h4 id="3-2-2-重排序的影响"><a href="#3-2-2-重排序的影响" class="headerlink" title="3.2.2 重排序的影响"></a>3.2.2 重排序的影响</h4><p>我们知道重排序是编译器或者系统的优化。<br>但是如果有些指令存在依赖性的话, 进行重排序会导致错误。</p><p><strong>数据依赖性</strong><br>如果两个操作访问同一个变量, 且这两个操作中有一个为写操作, 此时这两个操作之间就存在数据依赖性。<br>数据依赖分为下列 3 种类型, 这 3 种情况, 只要重排序两个操作的执行顺序, 程序的执行结果就会被改变。</p><table><thead><tr><th align="center">名称</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">写后读</td><td align="center">写一个变量, 再读这个变量</td><td align="center">a &#x3D; 1; b &#x3D; a;</td></tr><tr><td align="center">写后写</td><td align="center">写一个变量, 再写这个变量</td><td align="center">a &#x3D; 1; a &#x3D; 2;</td></tr><tr><td align="center">读后写</td><td align="center">读一个变量, 再写这个变量</td><td align="center">a &#x3D; b; b &#x3D; 1;</td></tr></tbody></table><p>这三种操作都存在数据依赖性, 如果重排序最终会导致结果受到影响。</p><p><strong>控制依赖性</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> a <span class="token operator">*</span> a<span class="token punctuation">;</span>        <span class="token keyword">return</span> num<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>在上面的代码中, 变量 num 的值依赖于 <strong>if (flag)</strong> 的判断值, 这里就叫控制依赖。  </p><p>控制依赖在单线程的情况下, 对存在控制依赖的操作重排序, 不会改变执行结果。<br>但是在多线程的情况下, 就有可能出现问题。</p><p>比如下面的例子: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 步骤 1</span>        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 步骤 2</span>        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 步骤 3</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 步骤 4</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> a <span class="token operator">*</span> a<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>在程序中, 当代码中存在控制依赖性时, 会影响指令序列<strong>执行的并行度</strong>。为此, 编译器和处理器会采用猜测 (Speculation) 执行来克服控制相关性对并行度的影响。 </p><p>以处理器的猜测执行为例:<br>假设现在有 2 个线程 A, B, A 执行到了 init 方法, 线程 B 执行到了 use 方法。<br>执行线程 B 的处理器可以提前读取并计算 a*a, 然后把计算结果临时保存到一个名为重排序缓冲 (Reorder Buffer, ROB) 的硬件缓存中。<br>当步骤 3 的条件判断为真时, 就把该计算结果写入变量 i 中。<br>猜测执行实质上对操作 3 和 4 做了重排序, 问题在于这时候, a 的值可能还没被线程 A 赋值。</p><p>当步骤 1 和步骤 2 重排序, 步骤 3 和步骤 4 重排序时, 可能会产生什么效果?<br>步骤 1 和步骤 2 做了重排序。程序执行时, 线程 A 首先写标记变量 flag, 随后线程 B 读这个变量。由于条件判断为真, 线程 B 将读取变量 a。<br>此时, 变量 a 还没有被线程 A 写入, 这时就会发生错误！</p><p>所以在多线程程序中, 对存在控制依赖的操作重排序, 可能会改变程序的执行结果。</p><h4 id="3-2-3-禁止重排序"><a href="#3-2-3-禁止重排序" class="headerlink" title="3.2.3 禁止重排序"></a>3.2.3 禁止重排序</h4><p>通过上面的分析, 重排序可能导致线程安全的问题, 不做任何的限制, 会导致一些意向不到的事情。</p><p>所以对于重排序, JMM 对 Java 编译器做了一些限制要求</p><blockquote><ol><li>针对编译器重排序, Java 编译器按照规则禁止一些特定类型的编译器重排序</li><li>针对处理器重排序, Java 编译器在生成指令序列的时候会通过插入<strong>内存屏障指令</strong>来禁止某些特殊的处理器重排序</li></ol></blockquote><p>当然也不是全面禁止掉重排序, 在数据没有任何依赖性时, 重排序还是允许的。</p><p>举个例子: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 步骤 1</span><span class="token keyword">double</span> pai <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span class="token comment">// 步骤 2</span><span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 步骤 3</span><span class="token keyword">double</span> area <span class="token operator">=</span> pai <span class="token operator">*</span> r <span class="token operator">*</span> r<span class="token punctuation">;</span></code></pre><p>上面是计算圆面积的代码, 步骤 1, 2 之间没有任何的关联, 所以 2 者之间可以重排序, 也可以说步骤 1 和 2 之间没有<strong>数据依赖性</strong> (如果两个操作访问同一个变量, 且这两个操作有一个为写操作, 此时这两个操作就存在数据依赖)。<br>这里可以分为 3 种情况: 读后写 &#x2F; 写后读 &#x2F; 写后写, 这 3 种情况, 无论哪一种发生了重排序, 最终执行结果会存在影响。</p><p>最终的结论 <strong>Java 编译器通过禁止特定的编译器和内存屏障指令, 让编译器和处理器在重排序时, 会遵守数据依赖性, 不会改变存在数据依赖性关系的两个操作的执行顺序</strong>。</p><h2 id="4-Happens-Before-JMM-对操作系统的屏蔽"><a href="#4-Happens-Before-JMM-对操作系统的屏蔽" class="headerlink" title="4 Happens-Before - JMM 对操作系统的屏蔽"></a>4 Happens-Before - JMM 对操作系统的屏蔽</h2><p><strong>Happens-Before, 中文译名应该, 先行发生, 大体要表达的意思就是: A 操作会先于 B 操作执行</strong>。</p><p>在上面的分析中, 主要是分析了<strong>线程的双内存</strong>和<strong>重排序</strong>, 在并发中带来的问题, 涉及了大量的底层知识。<br>如果在编程中需要考虑这么多底层的知识, 那么对于编写程序的人的负担是很大的。   </p><p>因此, JMM 为程序员在提供了一套 Happens-Before 的规则, 保证程序员编写的代码在满足对应的条件, 代码的效果都是都是遵循里面的规则。<br>这样程序员完全可以根据这套规则去和编写并发程序和解决并发的的各种问题, 而不必去思考操作系统底层具体操作, 如内存同步, 重排序等。</p><p>JMM 这么做的原因是: 程序员对于这两个操作的底层实现并不关心, 程序员关心的是程序执行时的语义不能被改变 (即执行结果不能被改变)。</p><p>大体的效果如下: </p><p><img src="https://pic.imgdb.cn/item/65759361c458853aef04a508.png" alt="Alt &#39;JMM HappensBefore 效果&#39;"></p><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><blockquote><ol><li>如果一个操作 Happens-Before 另一个操作, 那么第一个操作的执行结果将对第二个操作可见, 而且第一个操作的执行顺序排在第二个操作之前</li><li>两个操作之间存在 Happens-Before 关系, 并不意味着 Java 平台的具体实现必须要按照 Happens-Before 关系指定的顺序来执行。<br>如果重排序之后的执行结果, 与按 Happens-Before 关系来执行的结果一致, 那么这种重排序并不非法 (也就是说, JMM 允许这种重排序)</li></ol></blockquote><p>第一条是 JMM 对程序员的保证。<br>如果 A Happens-Before B, 那么 JMM 将向程序员保证 —— A 操作的结果将对 B 可见, 且 A 的执行顺序排在 B 之前。</p><p>第二条是 JMM 对编译器和处理器重排序的约束原则。<br>JMM 允许两个操作之间存在 Happens-Before 关系, 不要求 Java 平台的具体实现必须要按照 Happens-Before 关系指定的顺序来执行。<br>如果重排序之后的执行结果, 与按 Happens-Before 关系来执行的结果一致, 那么这种重排序是允许的。</p><h3 id="4-2-具体的规则"><a href="#4-2-具体的规则" class="headerlink" title="4.2 具体的规则"></a>4.2 具体的规则</h3><h4 id="4-2-1-程序顺序规则-Program-Order-Rule"><a href="#4-2-1-程序顺序规则-Program-Order-Rule" class="headerlink" title="4.2.1 程序顺序规则 (Program Order Rule)"></a>4.2.1 程序顺序规则 (Program Order Rule)</h4><p>在一个线程中，按照代码的顺序，前面的操作 Happens-Before 于后面的任意操作。<br>简单理解: 同一个线程 A 中前面的所有写操作对后面的操作可见。</p><p>例子</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><p><strong>在同一个线程</strong>, 对 a 的赋值操作的结果 (a &#x3D; 1), 对于后面的操作 (int b &#x3D; a + 1), 都是可以明确知道的, 即后面操作中, a 一定是 1, 不会是其他值。  </p><p>备注:<br>这个结果的保证, 作为程序员的我们无需去关心底层是如何实现的, 内存如何同步, 是否重排序等。我们只需要知道 JVM 遵循了 Happens-Before 原则, 一定是这样的就行。</p><h4 id="4-2-2-监视器锁规则-Monitor-Lock-Rule"><a href="#4-2-2-监视器锁规则-Monitor-Lock-Rule" class="headerlink" title="4.2.2 监视器锁规则 (Monitor Lock Rule)"></a>4.2.2 监视器锁规则 (Monitor Lock Rule)</h4><p>同一个锁的 unlock 操作 Happens-Before 此锁的 lock 操作。<br>简单理解: 线程 A 获取锁成功, 做了一些数据的变更, 然后线程 A 释放锁, 线程 B 获取同一个锁成功了, 那么线程 A 释放锁前做的所有数据变更, B 线程都是可见的。</p><h4 id="4-2-3-volatile-变量规则-volatile-Variable-Rule"><a href="#4-2-3-volatile-变量规则-volatile-Variable-Rule" class="headerlink" title="4.2.3 volatile 变量规则 (volatile Variable Rule)"></a>4.2.3 volatile 变量规则 (volatile Variable Rule)</h4><p>对一个 volatile 变量的写操作 Happens-Before 后续每一个对该变量的读操作。<br>简单理解: 线程 A 对 volatile 修饰的变量 v 进行操作, 后面其他的线程对变量 v 的读取, 结果都是线程 A 对变量 v 的操作后的结果, 对其他线程 (包括自己) 是可见的。</p><h4 id="4-2-4-线程启动规则-Thread-Start-Rule"><a href="#4-2-4-线程启动规则-Thread-Start-Rule" class="headerlink" title="4.2.4 线程启动规则 (Thread Start Rule)"></a>4.2.4 线程启动规则 (Thread Start Rule)</h4><p>Thread 的 start 方法 Happens-Before 调用 start 方法的线程前的每一个操作。<br>简单理解: 线程 T1 做了很多操作, 然后调用线程 T2 的 start 方法启动一个新的线程, 这时 T1 在调用 T2 的 start 方法前做到所有变更, 对线程 T2 都是可见的。</p><h4 id="4-2-5-线程终止规则-Thread-Termination-Rule"><a href="#4-2-5-线程终止规则-Thread-Termination-Rule" class="headerlink" title="4.2.5 线程终止规则 (Thread Termination Rule)"></a>4.2.5 线程终止规则 (Thread Termination Rule)</h4><p>线程中任何操作都 Happens-Before 其它线程检测到该线程已经结束。<br>简单理解: 线程 T1 做了很多操作, 然后线程 T2 感知到线程 T1 已经终止了, 那么线程 T1 做到变更, 对线程 T2 都是可见的。</p><p>例子</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token class-name">Thread</span> theadT1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>theadT1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 等待 T1 执行完成</span>theadT1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 这时当前线程 T2 读取 num 值一定是 2</span></code></pre><h4 id="4-2-6-线程中断规则-Thread-Interruption-Rule"><a href="#4-2-6-线程中断规则-Thread-Interruption-Rule" class="headerlink" title="4.2.6 线程中断规则 (Thread Interruption Rule)"></a>4.2.6 线程中断规则 (Thread Interruption Rule)</h4><p>对线程 interrupt 方法的调用 Happens-Before 于被中断线程的代码检测到中断事件的发生。<br>简单理解: 线程 T1 做了很多操作, 然后调用线程 T2 的中断方法 interrupt, 这时线程 T1 做的操作对于线程 T2 都是可见的。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token class-name">Thead</span> threadT2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 线程 T2 没有被中断, 就一直循环</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 线程 T2 被中断了, 此时线程 T2 读取 num 值一定是 2</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>threadT2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 线程 T1 修改 num 值</span>num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// 线程 T1 调用线程 T2 的中断方法</span>threadT2<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="4-2-7-对象终结规则-Finalizer-Rule"><a href="#4-2-7-对象终结规则-Finalizer-Rule" class="headerlink" title="4.2.7 对象终结规则 (Finalizer Rule)"></a>4.2.7 对象终结规则 (Finalizer Rule)</h4><p>一个对象的初始化完成（构造函数执行结束）Happens-Before 它的 finalize 方法的开始。<br>简单理解一个对象初始化一定在其 finalize 之前 (间接的表明了构造函数其间做的操作在 finalize 方法时都是可见的)。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"对象创建: "</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"对象销毁: "</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 结果</span><span class="token comment">//对象创建: 1</span><span class="token comment">//对象销毁: 2</span><span class="token comment">// 对象创建的日志打印一定在对象销毁之前</span></code></pre><h4 id="4-2-8-传递性-Transitivity"><a href="#4-2-8-传递性-Transitivity" class="headerlink" title="4.2.8 传递性 (Transitivity)"></a>4.2.8 传递性 (Transitivity)</h4><p>如果操作 A Happens-Before B, B Happens-Before C, 那么可以得出操作 A Happens-Before C。<br>简单理解就是 A 操作的结果对 B 操作可见, B 操作对 C 操作可见, 那么 A 操作对 C 操作同样可见。</p><h3 id="4-3-Happens-Before-规则的真正意义"><a href="#4-3-Happens-Before-规则的真正意义" class="headerlink" title="4.3 Happens-Before 规则的真正意义"></a>4.3 Happens-Before 规则的真正意义</h3><p>我们已经知道, 导致多线程间可见性问题的两个原因: CPU 缓存和重排序。<br>一种极端的解决多线程可见性问题的方式就是: 禁止所有 CPU 缓存和重排序。可行, 但是会极端影响处理器的性能。  </p><p>为了解决多线程的可见性问题, 但是尽可能少的影响处理器性能, 可以选择一种折中的方法:<br>通过分割线将整个程序划分为若干个程序块</p><blockquote><ol><li>程序块内指令可以重排序, 但是程序块之间只能不能重排序</li><li>在程序块内, CPU 不需要和主内存交互, 直接使用自己的本地内存即可, 但是到了分割线处, 必须将执行结果同步到主内存, 同时从主内存读取最新的变量到本地内存</li></ol></blockquote><p>而在这个方法中, Happens-Before 就是定义了这些程序块的分割线。  </p><p><img src="https://pic.imgdb.cn/item/65759351c458853aef0474a5.png" alt="Alt &#39;JMM HappensBefore 例子&#39;"></p><p>如图所示, 这里的 unlock M 和 lock M 就是划分程序的分割线。<br>在这里, 红色区域和绿色区域的代码内部是可以进行重排序的, 但是 unlock 和 lock 操作是不能与它们进行重排序的。<br>即第一个图中的红色部分必须要在 unlock M 指令之前全部执行完, 第二个图中的绿色部分必须全部在 lock M 指令之后执行。<br>并且在 unlock M 指令处, 红色部分的执行结果要全部刷新到主存中, 在 lock M 指令处, 绿色部分用到的变量都要从主存中重新读取。</p><p>在程序中加入分割线将其划分成多个程序块, 虽然在程序块内部代码仍然可能被重排序, 但是保证了程序代码在宏观上是有序的。并且可以确保在分割线处, CPU 一定会和主内存进行交互。<br>Happens-Before 原则就是定义了程序中什么样的代码可以作为分隔线。并且无论是哪条 Happens-Before 原则, 它们所产生分割线的作用都是相同的。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>JMM, Java Memory Model, 其本身只是一个虚拟机规范, 制定了 Java 虚拟机的内存抽象模式: 本地内存 + 主内存。<br>而<strong>双内存模式</strong>和系统本身的指令重排序, 在并发编程中都会导致可见性问题, 所以 JMM 对实现者提供了一些规则进行确保程序的准确性。</p><p>同时为了减轻使用者对并发编程的要求, 提供了一套 Happens-Before 规则帮助使用者屏蔽底层的实现, 只需要使用者按照 Happens-Before 规则进行编程, 就能保证程序的可见性。</p><p>所以, 在整个 JMM 规范中 2 个比较重要的组成</p><blockquote><ol><li>内存模型的抽象</li><li>Happens-Before 的保障</li></ol></blockquote><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h2><p>《Java并发编程的艺术》<br>《Java 多线程编程实践实战指南 (核心篇) 》<br><a href="https://github.com/CL0610/Java-concurrency/blob/master/03.java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8Ahappens-before%E8%A7%84%E5%88%99/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8Ahappens-before.md">JMM的介绍</a><br><a href="https://www.hollischuang.com/archives/2550">再有人问你Java内存模型是什么, 就把这篇文章发给他。</a><br><a href="https://juejin.im/post/5d3eafe95188255d3d296e09">Java 内存模型详解</a><br><a href="https://www.codercc.com/post/812b4c63.html">java内存模型以及happens-bofore原则</a><br><a href="https://www.jianshu.com/p/8a58d8335270">JMM和底层实现原理</a><br><a href="https://blog.csdn.net/weixin_44367006/article/details/99656558">大厂很可能会问到的JMM底层实现原理</a><br><a href="https://segmentfault.com/a/1190000011458941">从Java多线程可见性谈Happens-Before原则</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java ThreadPool</title>
      <link href="/article/2021/2781692877/"/>
      <url>/article/2021/2781692877/</url>
      
        <content type="html"><![CDATA[<h2 id="1-为什么使用线程池"><a href="#1-为什么使用线程池" class="headerlink" title="1 为什么使用线程池"></a>1 为什么使用线程池</h2><p>在实际使用中, 线程是很占用系统资源的, 如果对线程管理不善很容易导致系统问题。<br>因此, 在大多数并发框架中都会使用线程池来管理线程, 使用线程池管理线程主要有如下好处: </p><blockquote><ol><li>降低资源消耗。通过复用已存在的线程和降低线程关闭的次数来尽可能降低系统性能损耗</li><li>提升系统响应速度。通过复用线程, 省去创建线程的过程, 因此整体上提升了系统的响应速度</li><li>提高线程的可管理性。线程是稀缺资源, 如果无限制的创建, 不仅会消耗系统资源, 还会降低系统的稳定性, 因此, 需要使用线程池来管理线程。</li></ol></blockquote><h2 id="2-线程池添加任务的流程"><a href="#2-线程池添加任务的流程" class="headerlink" title="2 线程池添加任务的流程"></a>2 线程池添加任务的流程</h2><p><img src="https://pic.imgdb.cn/item/65859456c458853aefc95151.png" alt="Alt &#39;线程池提交任务流程&#39;"></p><p>上面是向线程池中添加任务的流程图:</p><blockquote><ol><li>判断<strong>线程池的线程个数是否大于核心线程池个数</strong>, 如果不是, 则新创建一个线程执行刚提交的任务, 否则进入第 2 步</li><li>判断当前阻塞队列是否已满, 如果未满, 则将提交的任务放置在阻塞队列中, 否则进入第 3 步</li><li>判断<strong>线程池的线程个数是否大于最大线程个数</strong>, 如果没有, 则创建一个新的线程来执行任务, 否则进入第 4 步</li><li>按照配置的拒绝策略 (没有配置有默认值) 进行处理</li></ol></blockquote><h2 id="3-创建线程池"><a href="#3-创建线程池" class="headerlink" title="3 创建线程池"></a>3 创建线程池</h2><h3 id="3-1-创建线程池的几个重要参数"><a href="#3-1-创建线程池的几个重要参数" class="headerlink" title="3.1 创建线程池的几个重要参数"></a>3.1 创建线程池的几个重要参数</h3><p>从上面的流程图可以知道向线程池添加任务的流程, 从中可以提取出几个关键的参数</p><blockquote><ol><li>核心线程个数</li><li>最大线程个数</li><li>阻塞队列</li><li>拒绝策略</li></ol></blockquote><p>线程池中的线程数个数是逐渐增长的, 不是一开始就创建好的。<br>线程个数先从 0 增长到核心线程个数, 核心个数的线程一旦达到了就不会增加了。<br>后续如果核心线程不够处理任务了, 线程数还会继续增加, 一直达到最大线程个数。<br>和核心线程数不同的是, 不是核心线程的这些线程在空闲的时候, 会销毁的。</p><p>所以在创建线程池除了需要指定上面的 4 个参数, 还有指定另外 3 个</p><blockquote><ol><li>线程空闲多长时间进行销毁</li><li>线程空闲多长时间的单位: 秒, 分钟等</li><li>线程工厂, 用于线程池中创建线程</li></ol></blockquote><h3 id="3-2-线程池的定义"><a href="#3-2-线程池的定义" class="headerlink" title="3.2 线程池的定义"></a>3.2 线程池的定义</h3><p><img src="https://pic.imgdb.cn/item/65859457c458853aefc958f4.png" alt="Alt &#39;线程池类图&#39;"></p><p>从 Java 线程池 Executor 框架体系可以看出 ThreadPoolExecutor 是线程池的定义。</p><h3 id="3-2-ThreadPoolExecutor-的构造函数"><a href="#3-2-ThreadPoolExecutor-的构造函数" class="headerlink" title="3.2 ThreadPoolExecutor 的构造函数"></a>3.2 ThreadPoolExecutor 的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutor</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExecutorService</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 指定 核心线程数 最大线程数 存活时间 存活时间单位 阻塞队列</span>    <span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> workQueue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//调用自身 7 个参数的构造函数, 默认工厂 Executors.DefaultThreadFactory 默认拒绝策略 AbortPolicy</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> defaultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 指定 核心线程数 最大线程数 存活时间 存活时间单位 阻塞队列 线程工厂</span>    <span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> workQueue<span class="token punctuation">,</span> <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//调用自身 7 个参数的构造函数, 默认拒绝策略 AbortPolicy</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span> threadFactory<span class="token punctuation">,</span> defaultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 指定 核心线程数 最大线程数 存活时间 存活时间单位 阻塞队列 拒绝策略</span>    <span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> workQueue<span class="token punctuation">,</span> <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//调用自身 7 个参数的构造函数, 默认工厂 Executors.DefaultThreadFactory </span>        <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 指定 核心线程数 最大线程数 存活时间 存活时间单位 阻塞队列 线程工厂 拒绝策略</span>    <span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> workQueue<span class="token punctuation">,</span> <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span> <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 核心线程, 最大线程 存活时间 必须大于 0, 最大线程数必须大于等于核心线程数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span> keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 阻塞队列 线程工厂 拒绝策略 不能为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> threadFactory <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> handler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>acc <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token class-name">AccessController</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>corePoolSize</strong><br>核心线程个数。 当提交一个任务时, 如果当前核心线程池的线程个数没有达到corePoolSize, 则会创建新的线程来执行所提交的任务, 即使当前核心线程池有空闲的线程。<br>如果当前核心线程的个数已经达到了 corePoolSize, 则不再重新创建线程。</p><p><strong>maximumPoolSize</strong><br>线程池能创建线程的最大个数。 如果当阻塞队列已满时, 并且当前线程池线程个数没有超过 maximumPoolSize 的话, 就会创建新的线程来执行任务。</p><p><strong>keepAliveTime</strong><br>空闲线程存活时间。如果当前线程池的线程个数已经超过了 corePoolSize, 并且线程空闲时间超过了 keepAliveTime 的话, 就会将这些空闲的非核心线程销毁, 这样可以尽可能降低系统资源消耗。</p><p>线程池中维护了一个变量 <strong>allowCoreThreadTimeOut</strong>,  这个字段决定了能回收的线程是否包含核心线程。<br>allowCoreThreadTimeOut, 默认为 false, 表示线程回收只针对非核心线程数。<br>allowCoreThreadTimeOut, 为 true, 则核心线程超过了空闲时间, 也会被回收, 但是这种做法违背了线程池的理念: 线程复用。</p><p>可以通过 线程池的 <strong>allowsCoreThreadTimeOut()</strong> 方法进行设置。</p><p><strong>unit</strong><br>时间单位。为 keepAliveTime 指定时间单位。</p><p><strong>workQueue</strong><br>阻塞队列。用于保存任务的阻塞队列, 可以使用 ArrayBlockingQueue,  LinkedBlockingQueue,  SynchronousQueue,  PriorityBlockingQueue 等。</p><p><strong>threadFactory</strong><br>创建线程的工程类。可以通过指定线程工厂为每个创建出来的线程设置更有意义的名字, 如果出现并发问题, 也方便查找问题原因。</p><p><strong>handler</strong><br>拒绝策略。 当线程池的阻塞队列已满和指定的线程都已经开启, 说明当前线程池已经处于饱和状态了, 那么就需要采用一种策略来处理这种情况。  </p><h3 id="3-3-阻塞队列"><a href="#3-3-阻塞队列" class="headerlink" title="3.3 阻塞队列"></a>3.3 阻塞队列</h3><p>创建 ThreadPoolExecutor 时需要指定一个阻塞队列。官方推荐的有 3 个</p><p><strong>1. SynchronousQueue</strong> 同步队列, 内部没有任何容量的阻塞队列, 任何一次插入操作的元素都要等待另一边执行删除&#x2F;读取操作, 否则进行插入操作的线程就要一直等待。</p><p><strong>2. LinkedBlockingQueue</strong> 基于链表结构实现的无界限 (理论上的无界限, 最大值为 Integer.MAX_VALUE) 的队列。 因为队列是无限的, 不会达到上限, 所以不会触发线程达到最大线程数的情况, 所以的线程都是核心线程。<br>这种队列可以提高线程池吞吐量, 但代价是牺牲内存空间, 甚至会导致内存溢出。 LinkedBlockingQueue 可以在声明的时候指定容量, 指定了容量的话, 就会变成一个有限队列</p><p><strong>3. ArrayBlockingQueue</strong> 基于数组实现的有限队列。 这种有界队列有利于防止资源耗尽, 但可能更难调整和控制</p><p>Java 还提供了另外 4 种队列可以选择</p><p><strong>1. PriorityBlockingQueue</strong> 支持优先级排序的无界阻塞队列。存储在里面的元素要么实现了 Comparable 接口或者在内部指定了比较器 Comparator, 才能对里面的元素进行比较。PriorityBlockingQueue 只保证优先级最高的元素始终排在队列的头部,<br>但是不保证优先级一样的元素的顺序, 也不保证除了优先级最高的元素以外的元素, 都能处于正确排序的位置</p><p><strong>2. DelayQueue</strong> 基于二叉堆实现的延迟队列, 时间没到任务取不出来。同时具备: 无界队列、阻塞队列、优先队列的特征。存储在里面的元素需要实现 Delayed 接口。</p><p><strong>3. LinkedBlockingDeque</strong> 双端队列。基于链表实现, 既可以从尾部插入&#x2F;取出元素, 还可以从头部插入元素&#x2F;取出元素</p><p><strong>4. LinkedTransferQueue</strong> 由链表结构组成的无界阻塞队列。这个队列比较特别的时, 采用一种预占模式。消费者线程取元素时, 如果队列不为空, 直接获取。为空, 生成一个节点 (节点元素为 null) 入队, 消费者线程被等待在这个节点上, 后面生产者线程入队时发现有一个元素为null的节点, 生产者线程就不入队了, 直接就将元素填充到该节点, 并唤醒该节点等待的线程, 被唤醒的消费者线程取走元素。</p><h3 id="3-4-拒绝策略"><a href="#3-4-拒绝策略" class="headerlink" title="3.4 拒绝策略"></a>3.4 拒绝策略</h3><p><strong>AbortPolicy</strong><br>直接拒绝所提交的任务, 并抛出 RejectedExecutionException 异常  </p><p><strong>CallerRunsPolicy</strong><br>只用调用者所在的线程来执行任务</p><p><strong>DiscardPolicy</strong><br>不处理直接丢弃掉任务</p><p><strong>DiscardOldestPolicy</strong><br>丢弃掉阻塞队列中存放时间最久的任务, 执行当前任务</p><h2 id="4-线程池状态"><a href="#4-线程池状态" class="headerlink" title="4 线程池状态"></a>4 线程池状态</h2><p>线程池有 5 种状态</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SIZE</span> <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span><span class="token comment">// Integer.SIZE = 32, count_bits = 32 - 3 = 29</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">COUNT_BITS</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">SIZE</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">// 当创建线程池后, 初始时, 线程池处于 RUNNING 状态</span><span class="token comment">// -536870912, 二进制 11100000 00000000 00000000 00000000, 最高位是 111 表示运行中</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">RUNNING</span>    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span><span class="token comment">// 如果调用了 shutdown() 方法, 则线程池处于 SHUTDOWN 状态, 此时线程池不能够接受新的任务, 它会等待所有任务执行完毕</span><span class="token comment">// 0,  二进制  00000000 00000000 00000000 00000000,  最高位是 000 表示关闭</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SHUTDOWN</span>   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span><span class="token comment">// 如果调用了shutdownNow() 方法, 则线程池处于 STOP 状态, 此时线程池不能接受新的任务, 并且会去尝试终止正在执行的任务</span><span class="token comment">// 536870912, 二进制 00100000 00000000 00000000 00000000,  最高位是 001 表示停止</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">STOP</span>       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span><span class="token comment">// 线程池中的所有任务都已终止, 则会变为, 都是从 stop / shutdown 转为 tidying</span><span class="token comment">// 1073741824, 二进制 01000000 00000000 00000000 00000000, 最高位是 010 表示终止前的事项都准备完成</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TIDYING</span>    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span><span class="token comment">// 线程池彻底终止</span><span class="token comment">// 1610612736, 二进制 01100000 00000000 00000000 00000000, 最高位是 010 表示最终的停止</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TERMINATED</span> <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span></code></pre><p>线程池状态的切换过程:<br><img src="https://pic.imgdb.cn/item/65859459c458853aefc95eeb.png" alt="Alt &#39;线程池状态切换&#39;"></p><h2 id="5-线程池的使用"><a href="#5-线程池的使用" class="headerlink" title="5 线程池的使用"></a>5 线程池的使用</h2><h3 id="5-1-自定义线程池-ThreadPoolExecutor"><a href="#5-1-自定义线程池-ThreadPoolExecutor" class="headerlink" title="5.1 自定义线程池 ThreadPoolExecutor"></a>5.1 自定义线程池 ThreadPoolExecutor</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 自定义线程工厂类</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> threadNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token string">"My-Thread"</span> <span class="token operator">+</span> threadNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> corePoolSize <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> maximumPoolSize <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> keepAliveTime <span class="token operator">=</span> <span class="token number">1000L</span><span class="token punctuation">;</span>    <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> workQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 创建线程池</span>    <span class="token class-name">ThreadPoolExecutor</span> threadPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MyThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 自定义 Runable 任务</span>    <span class="token class-name">Runnable</span> task <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Finish"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 提交任务</span>    threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 关闭线程池</span>    threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre><h3 id="5-2-官方提供的线程池工具类-Executors"><a href="#5-2-官方提供的线程池工具类-Executors" class="headerlink" title="5.2 官方提供的线程池工具类 Executors"></a>5.2 官方提供的线程池工具类 Executors</h3><p>Exceutors 内部提供了几种常用的线程池配置</p><table><thead><tr><th align="center">线程池名</th><th align="center">核心线程数</th><th align="center">最大线程数</th><th align="center">线程存活时间 (单位: 毫秒)</th><th align="center">阻塞队列类型</th></tr></thead><tbody><tr><td align="center">FixedThreadPool (固定容量线程池)</td><td align="center">用户配置</td><td align="center">等于核心线程数</td><td align="center">0</td><td align="center">LinkedBlockingQueue</td></tr><tr><td align="center">CachedThreadPool (缓存线程池)</td><td align="center">0</td><td align="center">Integer.MAX_VALUE</td><td align="center">60</td><td align="center">SynchronousQueue</td></tr><tr><td align="center">SingleThreadExecutor (单线程线程池)</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">LinkedBlockingQueue</td></tr><tr><td align="center">ScheduledThreadPool (定时线程池)</td><td align="center">用户配置</td><td align="center">Integer.MAX_VALUE</td><td align="center">0 (内部配置的单位是纳秒)</td><td align="center">DelayedWorkQueue</td></tr></tbody></table><p>上面是比较常见的 4 个线程池, 在 JDK 8 新增了一个<strong>工作窃取线程池</strong></p><h4 id="3-3-2-1-FixedThreadPool"><a href="#3-3-2-1-FixedThreadPool" class="headerlink" title="3.3.2.1 FixedThreadPool"></a>3.3.2.1 FixedThreadPool</h4><p>固定容量线程池。 其特点</p><blockquote><ol><li>最大线程数等于核心线程数</li><li>阻塞队列是理论没有界限的 LinkedBlockQueue</li></ol></blockquote><p>基于上面 2 个的配置, 可以得到 FixedThreadPool 的特点:<br>任务提交后, 会不断创建核心线程, 核心线程个数达到了配置的上限了, 任务会进入到无限的阻塞队列中, 永远不会创建出非核心线程。</p><p>适用于<strong>并发比较高的场景</strong></p><h4 id="3-3-2-2-CachedThreadPool"><a href="#3-3-2-2-CachedThreadPool" class="headerlink" title="3.3.2.2 CachedThreadPool"></a>3.3.2.2 CachedThreadPool</h4><p>缓存线程池。其特点</p><blockquote><ol><li>核心线程是为 0, 最大线程数为 Integer.MAX_VALUE, 理论无上限</li><li>空闲线程存活时间 60 毫秒</li><li>阻塞队列是没有任何容量的 SynchronousQueue</li></ol></blockquote><p>基于上面 3 个配置, 可以得到 CachedThreadPool 的特点:<br>任务提交后, 就不断创建非核心线程数, 或者交给空闲的非核心线程处理, 中间没有队列缓存, 有任务过来必定有线程立即进行处理, 一旦空闲线程时间超过 60 毫秒, 就对其进行销毁。</p><p>适用于<strong>任务量大但耗时低的场景</strong></p><h4 id="3-3-2-3-SingleThreadExecutor"><a href="#3-3-2-3-SingleThreadExecutor" class="headerlink" title="3.3.2.3 SingleThreadExecutor"></a>3.3.2.3 SingleThreadExecutor</h4><p>单线程线程池。其特点</p><blockquote><ol><li>核心线程数和最大线程数都是 1</li><li>阻塞队列是理论没有界限的 LinkedBlockQueue</li></ol></blockquote><p>基于上面 3 个配置, 可以得到 SingleThreadExecutor 的特点:<br>只会有一个核心线程在处理提交的任务, 提交的任务比消费的快时, 任务会缓存在理论无容量上限的阻塞队列中。</p><p>适用于<strong>消费效率比任务产生快或者生产端生产效率慢但是任务耗时高的情景</strong></p><h4 id="3-3-2-4-ScheduledThreadPool"><a href="#3-3-2-4-ScheduledThreadPool" class="headerlink" title="3.3.2.4 ScheduledThreadPool"></a>3.3.2.4 ScheduledThreadPool</h4><p>定时线程池。其特点</p><blockquote><ol><li>最大线程数理论无限</li><li>keepAliveTime 时间为 0, 直接过期</li><li>阻塞队列是延迟队列</li></ol></blockquote><p>基于上面 3 个配置, 可以到的 ScheduledThreadPool 的特点:<br>任务提交后, 延迟处理。在处理中, 和正常的线程池差不多, 优先创建核心线程数, 存入阻塞队列, 创建非核心线程数, 不同的是非核心线程数空闲了, 就立即进行销毁。</p><p>适用于<strong>执行定时或周期性的任务</strong></p><h4 id="3-3-2-5-WorkStealingPool"><a href="#3-3-2-5-WorkStealingPool" class="headerlink" title="3.3.2.5 WorkStealingPool"></a>3.3.2.5 WorkStealingPool</h4><p>WorkStealPool 是一个拥有多个任务队列的线程池, 空闲的线程可以帮助其他的线程处理任务。</p><p>假设共有两个线程同时执行, A, B<br>假如 A 线程中的队列里面分配了 5 个任务, 而 B 线程的队列中分配了 1 个任务, 当 B 线程执行完任务后, 它会主动的去 A 线程中窃取其他的任务进行执行。</p><p>具体的实现是基于一个新的线程池 <strong>ForkJoinPool</strong>, 有兴趣的可以自行了解一下, 这里不展开了。</p><h3 id="5-3-定时线程池"><a href="#5-3-定时线程池" class="headerlink" title="5.3 定时线程池"></a>5.3 定时线程池</h3><p>在 Java 中要实现定时任务的话, 可以使用到哪些现成的类呢?</p><blockquote><ol><li>Timer</li><li>ScheduledThreadPoolExecutor</li></ol></blockquote><p>2 者都能达到周期性执行任务和给定时间延迟执行任务的功能。不同的是 Timer 只能使用一个后台线程执行任务, 而 ScheduledThreadPoolExecutor 则可以通过构造函数来指定后台线程的个数, 能达到这种效果是因为<br>ScheduledThreadPoolExecutor 本身就是一个线程池的实现。</p><p>ScheduledThreadPoolExecutor 类的 UML 图如下:</p><p><img src="https://pic.imgdb.cn/item/6585945dc458853aefc96e8d.png" alt="Alt &#39;定时线程池类图&#39;"></p><p>从 UML图 可以看出, ScheduledThreadPoolExecutor 继承了 ThreadPoolExecutor, 具备了线程的 execute, submit 等提交异步任务的基础功能。<br>同时还实现了 ScheduledExecutorService, 该接口定义了 ScheduledThreadPoolExecutor 能够延时执行任务和周期执行任务的功能的 4 个接口方法</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ScheduledExecutorService</span> <span class="token keyword">extends</span> <span class="token class-name">ExecutorService</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 达到给定的延时时间后, 执行任务。这里传入的是实现 Runnable 接口的任务, 因此通过 ScheduledFuture.get() 获取结果为 null</span>    <span class="token keyword">public</span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">,</span> <span class="token keyword">long</span> delay<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 达到给定的延时时间后, 执行任务。这里传入的是实现Callable接口的任务, 因此, 返回的是任务的最终计算结果</span>    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> callable<span class="token punctuation">,</span> <span class="token keyword">long</span> delay<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 以上一个任务开始的时间计时, period 时间过去后, 检测上一个任务是否执行完毕, 如果上一个任务执行完毕</span>    <span class="token comment">// 则当前任务立即执行, 如果上一个任务没有执行完毕, 则需要等上一个任务执行完毕后立即执行</span>    <span class="token keyword">public</span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">,</span> <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span> <span class="token keyword">long</span> period<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 当达到延时时间 initialDelay 后, 任务开始执行。上一个任务执行结束后到下一次, 任务执行, 中间延时时间间隔为 delay。 以这种方式, 周期性执行任务</span>    <span class="token keyword">public</span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">,</span> <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span> <span class="token keyword">long</span> delay<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="5-4-核心线程池的立即初始"><a href="#5-4-核心线程池的立即初始" class="headerlink" title="5.4 核心线程池的立即初始"></a>5.4 核心线程池的立即初始</h3><p>声明了线程池后, 这时候实际是没有线程的, 单提交了一个任务后, 才会创建出线程进行处理<br>ThreadPoolExecutor 提供了 2 个方法, 可以立即初始化出核心线程: </p><blockquote><ol><li>prestartCoreThread() 立即创建出一个核心线程</li><li>prestartAllCoreThreads() 所有的核心线程都会被创建</li></ol></blockquote><h3 id="5-6-线程池的关闭"><a href="#5-6-线程池的关闭" class="headerlink" title="5.6 线程池的关闭"></a>5.6 线程池的关闭</h3><p>官方提供了 2 个关闭线程池的方法</p><blockquote><ol><li>shutdown(): 不会立即终止线程池, 而是要等所有任务缓存队列中的任务都执行完后才终止, 但再也不会接受新的任务</li><li>shutdownNow(): 立即终止线程池, 并尝试打断正在执行的任务, 并且清空任务缓存队列, 返回尚未执行的任务</li></ol></blockquote><h2 id="6-线程池的代码实现"><a href="#6-线程池的代码实现" class="headerlink" title="6 线程池的代码实现"></a>6 线程池的代码实现</h2><h3 id="6-1-提交任务-execute"><a href="#6-1-提交任务-execute" class="headerlink" title="6.1 提交任务 execute()"></a>6.1 提交任务 execute()</h3><p>execute 在 ThreadPoolExecutor 类中提交任务的入口 (submit 同样最终还是会调用到 execute 方法)。</p><p>在 execute 中主要</p><blockquote><ol><li>对任务做非空判断</li><li>根据各种判断, 做出对任务对应的处理, 如创建核心线程, 添加到阻塞队列等</li></ol></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 任务不能为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ctl 是一个 AtomicInteger, 初始值为 -536870912, 二进制为 11100000 00000000 00000000 00000000</span>    <span class="token comment">// ctl 一个 32 位, 一个字段存储了 2 种信息, 前面 3 位表示当前线程池的状态, 后面 29 位表示当前线程池中的线程个数</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// workerCountOf 用入参的值 &amp; 上 536870911, 二进制 00011111 11111111 11111111 11111111</span>    <span class="token comment">// &amp; 操作, 2 位都是 1, 结果才是 1, 其他的为 0</span>    <span class="token comment">// ctl 后面 29 位存的是当前的线程个数, 所以 workerCountOf 方法得到的是当前线程的个数</span>    <span class="token comment">// 判断线程池当前线程数是否小于核心线程数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 线程数小于核心线程数, 创建核心线程, 处理任务</span>        <span class="token comment">// addWorker 主要是用户创建线程处理指定的任务, 参数二则决定了创建的线程是核心线程还是非核心线程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment">// 获取最新的 control     </span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// isRunning 判断当前的线程池是否为运行中, 内部的逻辑就是判断 入参是否小于状态值 SHUTDOWN</span>    <span class="token comment">// 线程池中的所有状态中只有 Running 的最高位是 1, 也就是负数, 所以无论多少个线程数, 正在运行中的状态一定都是负数, 必定小于其他的状态</span>    <span class="token comment">// 线程池处于运行中, 同时任务添加到阻塞队列</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 再做一次检查</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 线程池从运行中变为非运行中了, 同时删除任务成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment">// 调用拒绝策略处理任务</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 线程池线程个数为 0</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token comment">// 通过上面的 workQueue.offer 明确队列中已经添加了一个任务, 但是这时候线程数为 0, 手动添加一个</span>             <span class="token comment">// 为了保证线程池有一个线程来执行任务 </span>            <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果执行到这里, 有两种情况: </span>    <span class="token comment">// 1. 线程池已经不是 RUNNING 状态；</span>    <span class="token comment">// 2. 线程池是 RUNNING 状态, 但 workerCount >= corePoolSize 并且 workQueue 已满        </span>    <span class="token comment">// 尝试添加一个非核心线程</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment">// 添加失败, 调用拒绝策略处理任务</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>在执行 execute() 方法时如果状态一直是 RUNNING 时, 执行过程如下:</p><blockquote><ol><li>如果 workerCount &lt; corePoolSize, 则创建并启动一个线程来执行新提交的任务</li><li>如果 workerCount &gt;&#x3D; corePoolSize, 且线程池内的阻塞队列未满, 则将任务添加到该阻塞队列中</li><li>如果 workerCount &gt;&#x3D; corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize, 且线程池内的阻塞队列已满, 则创建并启动一个线程来执行新提交的任务</li><li>如果 workerCount &gt;&#x3D; maximumPoolSize, 并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常</li></ol></blockquote><h3 id="6-2-添加工作者线程-addWorker"><a href="#6-2-添加工作者线程-addWorker" class="headerlink" title="6.2 添加工作者线程 addWorker()"></a>6.2 添加工作者线程 addWorker()</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Java 标签</span>    retry<span class="token operator">:</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取当前的线程池的状态</span>        <span class="token comment">// runStateOf 的实现逻辑, 使用入参 &amp; 上 11100000 00000000 00000000 00000000  (&amp; 2 位都是 1 才是 1)</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 条件 1 : 线程池为非运行状态</span>        <span class="token comment">// 条件 2 : 线程池为关闭状态, 并且添加的任务为 null, 同时队列为不为空</span>        <span class="token comment">// 条件 1 满足同时条件 2 不满足的情况下, 直接返回 false</span>                <span class="token comment">// 整理后为, 线程池的状态为 stop/tidying/terminated 并且添加的任务不为空同时队列为空, 直接返回 false</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>rs <span class="token operator">==</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 获取当前的线程个数</span>            <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// CAPACITY = 536870911, 二进制表示  00011111 11111111 11111111 11111111, 能达到的最大线程数</span>            <span class="token comment">// 当前的线程数大于等于最大线程数</span>            <span class="token comment">// 或者需要创建核心线程的话, 当前的线程数大于等于核心线程数</span>            <span class="token comment">// 或者需要创建非核心线程数的话, 当前的线程数大于等于最大线程数</span>            <span class="token comment">// 上面 3 种情况, 满足一种就直接返回 fasle</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> <span class="token constant">CAPACITY</span> <span class="token operator">||</span> wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment">// 通过 CAS 给 ctl 加 1 </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// CAS 加 1 成功, 调节池 retry 指定的循环, 执行下面的操作</span>                <span class="token keyword">break</span> retry<span class="token punctuation">;</span>            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// CAS 给 ctl 加 1 失败, 重新获取新的状态</span>            <span class="token comment">// 状态值改变了, 重新回到 retry 标签, 开始新的循环</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>                <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>            <span class="token comment">// 线程池数量 + 1 成功后, 开始工作线程的创建</span>        <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token class-name">Worker</span> w <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 创建一个工作者线程, Worker 对任务和工作线程等进行了包装, 后面分析</span>            w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 获取里面的线程</span>            <span class="token keyword">final</span> <span class="token class-name">Thread</span> t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 获取线程池维护的 ReentrantLock </span>                <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>                <span class="token comment">// 上锁</span>                mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 获取当前的线程池状态</span>                    <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 当前的线程池状态为运行中 或者 (线程池状态为 shutdown 并且 任务为 null)</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">||</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 线程 t 已经启动了</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 将当前的工作线程添加到 ThreadPoolExecutor 的 HashSet 中    </span>                        workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 获取当前的工作线程数</span>                        <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                <span class="token comment">// 确保 ThreadPoolExecutor 的出现过最大线程池数的 largestPoolSize 为最大值</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>                            largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                        <span class="token comment">// 添加成功    </span>                        workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                    mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// 工作线程添加成功</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 启动工作线程</span>                    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 工作线程启动失败</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>workerStarted<span class="token punctuation">)</span>                <span class="token comment">// 1. 尝试从 ThreadPoolExecutor 的 HashSet 移除这个线程</span>                <span class="token comment">// 2. 通过 CAS 给 ctl - 1</span>                <span class="token comment">// 3. 尝试关闭线程池</span>                <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>上面的逻辑基本就是添加工作线程的逻辑。而工作线程如何执行任务的逻辑在 Worker 这个内部类。</p><h3 id="6-3-工作线程-Worker-定义"><a href="#6-3-工作线程-Worker-定义" class="headerlink" title="6.3 工作线程 Worker 定义"></a>6.3 工作线程 Worker 定义</h3><p>Worker 是 ThreadPoolExecutor 的内部类, 继承了 AbstractQueuedSynchronizer (AQS) 和 实现了 Runnable 2 个接口。</p><p>AbstractQueuedSynchronizer: 抽象类, 提供了一套简单的锁分配机制。<br>简单的来说 AQS 用 volatile 修饰共享变量 state, 线程通过 CAS 去改变状态符, 成功则获取锁成功, 失败则进入等待队列, 等待被唤醒。</p><p>这里不直接使用 ReentrantLock, 是因为 Worker 的获取锁是要不可重入的, 所以自身实现 AbstractQueuedSynchronizer, 自定义获取锁不可重入。    </p><p>这里的 Worker 可以看做是一个包装类, 包装了任务执行者的 Thread 和执行的任务 Runnable。<br>一般情况下, 他都是以任务的角色存在, 当调用了 Worker 内 Thread 的 start 方法, 将会转变为任务执行者。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>    <span class="token class-name">Runnable</span> firstTask<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>    <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 设置 AbstractQueuedSynchronizer 的中的状态为 -1</span>        <span class="token comment">// -1 为初始值, 0 为 unlock 状态, 1 为 lock 状态</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// worker 执行的逻辑</span>        <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="6-4-工作线程-Woker-执行任务-runWorker"><a href="#6-4-工作线程-Woker-执行任务-runWorker" class="headerlink" title="6.4 工作线程 Woker 执行任务 runWorker()"></a>6.4 工作线程 Woker 执行任务 runWorker()</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// worker 启动时执行的逻辑</span>        <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 执行的逻辑, 可以把上面的 Worker 当然任务, 不包含线程的功能</span>                <span class="token comment">// 获取当前的线程</span>        <span class="token class-name">Thread</span> wt <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取入参 worker 的任务</span>        <span class="token class-name">Runnable</span> task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>        <span class="token comment">// 将入参的任务置为 null</span>        w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 将 AQS 的 state 设置为无锁状态, 即设置为 0</span>        w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 是否因为异常退出循环</span>        <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 死循环  入参的 work 的任务不为空或者从其他 worker 获取任务不为空</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 给入参的 worker 上锁, 设置 state 为 1</span>                w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// interrupt 设置线程的中断标识为 true</span>                <span class="token comment">// interrupted() 将当前线程的中断标识设置为 false, 返回值为上次的中断标识</span>                <span class="token comment">// isInterrupted() 判断线程的中断标识是什么, true 为需要中断</span>                <span class="token comment">// 下面的逻辑整理后如下: </span>                <span class="token comment">// 1. 当前的线程池状态为 STOP/TIDYING/TERMINATED, 当前线程的中断标识为 false</span>                <span class="token comment">// 2. 当前的线程池状态为 STOP/TIDYING/TERMINATED, 当前线程的中断标识为 true, 将当前线程的中断标识先设置为 false</span>                <span class="token comment">// 作用, 保证线程池状态为 STOP/TIDYING/TERMINATED 下, 当前线程的中断标识为 true</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// 尝试中断当前线程 (设置中断标识为 true)</span>                    wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 空方法</span>                    <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">Throwable</span> thrown <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 执行任务</span>                        task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        thrown <span class="token operator">=</span> x<span class="token punctuation">;</span>                         <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        thrown <span class="token operator">=</span> x<span class="token punctuation">;</span>                         <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        thrown <span class="token operator">=</span> x<span class="token punctuation">;</span>                         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 空方法</span>                        <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 任务置为 null </span>                    task <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token comment">// 设置入参的 Worker 完成的任务数 + 1</span>                    w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token comment">// 解锁</span>                    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token comment">// 当前是 Worker 线程正常的结束, 不是因为异常结束</span>            completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 线程退出逻辑处理</span>            <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span></code></pre><h4 id="3-4-4-1-工作线程-runWorker-子流程获取任务-getTask"><a href="#3-4-4-1-工作线程-runWorker-子流程获取任务-getTask" class="headerlink" title="3.4.4.1 工作线程 runWorker() 子流程获取任务 getTask()"></a>3.4.4.1 工作线程 runWorker() 子流程获取任务 getTask()</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取任务</span>    <span class="token keyword">private</span> <span class="token class-name">Runnable</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 上一次获取任务是否超时</span>        <span class="token comment">// 第一次默认为 false, 经过下面的流程, 获取任务为 null, 会变成 true, 然后回到循环的开头</span>        <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 当前线程池的状态</span>            <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 线程池进入关闭了</span>            <span class="token comment">// 1. 线程池状态为 SHUTDOWN/STOP/TERMINATED 状态</span>            <span class="token comment">// 2. 线程池状态为 STOP/TERMINATED 状态或 workQueue 为空</span>            <span class="token comment">// 上面 2 个条件都为 true, 返回 null, 让执行线程结束</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> <span class="token constant">STOP</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 通过 CAS 给 ctrl - 1</span>                <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 返回 null</span>                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 当前线程池的线程个数</span>            <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 线程获取任务是否可以超时  核心线程配置了可以超时消耗 或者 当前的线程数大于核心线程数</span>            <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">></span> corePoolSize<span class="token punctuation">;</span>            <span class="token comment">// getTask 方法返回 null 会导致当前线程消耗</span>            <span class="token comment">// 所以在线程池个数大于 1 或者队列为空的情况下, 可以尝试判断当前线程是否需要销毁</span>            <span class="token comment">// 1. 当前的线程大于最大线程数</span>            <span class="token comment">// 2. 线程获取任务可以超时同时上一次获取任务已经超时了</span>            <span class="token comment">// 2 个条件满足一个, 这个线程就可以销毁了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">></span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 通过 CAS 给 ctl 减 1    </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// 返回 null 结束</span>                    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token comment">// 通过 CAS 给 ctl 减 1 失败, 重试    </span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 获取任务可以超时的话, 用带时间的阻塞方法从队列中获取任务</span>                <span class="token class-name">Runnable</span> r <span class="token operator">=</span> timed <span class="token operator">?</span> workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">NANOSECONDS</span><span class="token punctuation">)</span> <span class="token operator">:</span> workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 有结果, 返回结果</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> r<span class="token punctuation">;</span>                <span class="token comment">// 设置这次获取任务超时了    </span>                timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre><h4 id="3-4-4-3-工作线程-runWorker-子流程共享线程的退出-processWorkerExit"><a href="#3-4-4-3-工作线程-runWorker-子流程共享线程的退出-processWorkerExit" class="headerlink" title="3.4.4.3 工作线程 runWorker() 子流程共享线程的退出 processWorkerExit()"></a>3.4.4.3 工作线程 runWorker() 子流程共享线程的退出 processWorkerExit()</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processWorkerExit</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">,</span> <span class="token keyword">boolean</span> completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 参数二 completedAbruptly: 是否有线程中断导致的退出, 正常的退出为 false</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>completedAbruptly<span class="token punctuation">)</span>             <span class="token comment">// 通过 CAS 给 ctl 减 1</span>            <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取 ThreadPoolExecutor 的可重入锁    </span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>        mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 已经完成的任务数追加 w 已经完成的任务数</span>            completedTaskCount <span class="token operator">+=</span> w<span class="token punctuation">.</span>completedTasks<span class="token punctuation">;</span>            <span class="token comment">// workers 集合异常这个线程</span>            workers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>           <span class="token comment">// 尝试终止</span>        <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 当前线程池的状态为 RUNNING 或 SHUTDOWN</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateLessThan</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 当前线程是正常退出的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 允许存活的线程数 允许核心线程过期的话, 等于 0 否则等于核心线程数</span>                <span class="token keyword">int</span> min <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">?</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">:</span> corePoolSize<span class="token punctuation">;</span>                <span class="token comment">// 允许的最小线程数为 0 同时有阻塞队列有任务</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// 最小的线程数变为 1</span>                    min <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// 当前的线程数大于等于最小的线程数, 直接结束    </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">>=</span> min<span class="token punctuation">)</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token comment">// 当前线程是因异常需要结束 或 当前的线程数小于需要的最小线程数</span>            <span class="token comment">// 创建一个任务为空的非核心线程</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 当前的线程池为运行状态</span>            <span class="token comment">// 当前的线程池的状态为 TIDYING 或 TERMINATED</span>            <span class="token comment">// 当前线程池状态为 SHUTDOWN 同时阻塞队列不为空</span>            <span class="token comment">// 三个满足其中一个直接结束</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>                 <span class="token operator">||</span> <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token constant">TIDYING</span><span class="token punctuation">)</span>                 <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token comment">// 线程池线程个数不等于 0 </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                 <span class="token comment">// ONLY_ONE 为 true</span>                <span class="token comment">// 从线程集合 HashSet&lt;Worker> workers 中获取一个进行中断</span>                <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token constant">ONLY_ONE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>              <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>            mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 通过 CAS 将 ctl 设置为 1073741824, 二进制 01000000 00000000 00000000 00000000, 也就是把线程数设置为 0, 状态修改为 tidying</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token constant">TIDYING</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 空方法, 子类进行重新</span>                        <span class="token function">terminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 通过 CAS 将 ctl 设置为 1610612736, 二进制 01100000 00000000 00000000 00000000, 状态修改为 terminated</span>                        ctl<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token constant">TERMINATED</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 唤醒所有阻塞在 ThreadPoolExecutor 的可重入锁 ReentrantLock mainLock 的线程</span>                        termination<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="6-5-线程池的关闭-shutdown"><a href="#6-5-线程池的关闭-shutdown" class="headerlink" title="6.5 线程池的关闭 shutdown()"></a>6.5 线程池的关闭 shutdown()</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 通过 SecurityManager 设置当前线程池中的线程都是不可访问的</span>        <span class="token function">checkShutdownAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置线程池的状态为 shutdown</span>        <span class="token function">advanceRunState</span><span class="token punctuation">(</span><span class="token constant">SHUTDOWN</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将线程池中的所有线程打上中断标识, 即调用线程的 interrupt 方法</span>        <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 空方法, 回调</span>        <span class="token function">onShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 再次调用 tryTerminate 进行线程池的状态改变和线程的关闭</span>    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="6-5-线程池的关闭-shutdownNow"><a href="#6-5-线程池的关闭-shutdownNow" class="headerlink" title="6.5 线程池的关闭 shutdownNow()"></a>6.5 线程池的关闭 shutdownNow()</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> <span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> tasks<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 通过 SecurityManager 设置当前线程池中的线程都是不可访问的</span>        <span class="token function">checkShutdownAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置线程池的状态为 stop</span>        <span class="token function">advanceRunState</span><span class="token punctuation">(</span><span class="token constant">STOP</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将线程池中的所有线程打上中断标识, 即调用线程的 interrupt 方法</span>        <span class="token function">interruptWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 清空当前队列中的任务</span>        tasks <span class="token operator">=</span> <span class="token function">drainQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 再次调用 tryTerminate 进行线程池的状态改变和线程的关闭</span>    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回所有未执行的任务</span>    <span class="token keyword">return</span> tasks<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="6-6-定时线程的实现"><a href="#6-6-定时线程的实现" class="headerlink" title="6.6 定时线程的实现"></a>6.6 定时线程的实现</h3><p>从 ScheduledThreadPoolExecutor 实现 ThreadPoolExecutor 可以看出, 其本身的实现基本都是差不多的,<br>不同的是普通的线程池使用的任务的类型为 Runnable 或者 Callable, 而 ScheduledThreadPoolExecutor 调用到 ScheduledExecutorService 的 4 个定时方法, 内部的任务类型实际为 ScheduledFutureTask,<br>对里面的 run 方法进行了重写, 执行完成, 设置下次执行时间等操作, 重新放入自定义的优先级阻塞队列等, 具体的实现可以看一下源码, 有着 ThreadPoolExecutor 的基础, 很容易看懂的 (下面只截了一部分)。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ScheduledFutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">RunnableScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 重复任务的周期 (以纳秒为单位)      * 正值表示固定频率执行,     * 负值表示固定延迟执行,     * 0 表示不是重复任务,     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> period<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 判断 period 是否等于 0, false 表示当前任务就是一个普通的任务 </span>        <span class="token keyword">boolean</span> periodic <span class="token operator">=</span> <span class="token function">isPeriodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 当前线程池是否能运行这个任务</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">canRunInCurrentRunState</span><span class="token punctuation">(</span>periodic<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>periodic<span class="token punctuation">)</span>            <span class="token comment">// 普通任务, 直接执行</span>            <span class="token class-name">ScheduledFutureTask</span><span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 周期任务, 执行完成后同时重置状态</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ScheduledFutureTask</span><span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">runAndReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 操作成功了</span>            <span class="token comment">// 设置下次执行时间</span>            <span class="token function">setNextRunTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 重新投递这个任务</span>            <span class="token function">reExecutePeriodic</span><span class="token punctuation">(</span>outerTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span>     <span class="token keyword">void</span> <span class="token function">reExecutePeriodic</span><span class="token punctuation">(</span><span class="token class-name">RunnableScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> task<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">canRunInCurrentRunState</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 添加到队列中</span>            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">canRunInCurrentRunState</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span>                task<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token comment">// 当前线程数小于核心线程, 创建一个核心线程</span>                <span class="token comment">// 当前的线程数等于 0, 创建一个非核心线程</span>                <span class="token comment">// 总之就是确保有线程执行任务</span>                <span class="token function">ensurePrestart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre><h2 id="7-如何合理配置线程池参数"><a href="#7-如何合理配置线程池参数" class="headerlink" title="7 如何合理配置线程池参数"></a>7 如何合理配置线程池参数</h2><p>要想合理的配置线程池, 就必须首先分析任务特性, 可以从以下几个角度来进行分析</p><blockquote><ol><li>任务的性质: CPU 密集型任务, IO 密集型任务和混合型任务  </li><li>任务的优先级: 高, 中和低</li><li>任务的执行时间: 长, 中和短</li><li>任务的依赖性: 是否依赖其他系统资源, 如数据库连接</li></ol></blockquote><p>任务性质不同的任务可以用不同规模的线程池分开处理。<br>CPU 密集型任务配置尽可能少的线程数量, 如配置 Ncpu+1 个线程的线程池。 IO 密集型任务则由于需要等待 IO 操作, 线程并不是一直在执行任务, 则配置尽可能多的线程, 如 2 x Ncpu。<br>混合型的任务, 如果可以拆分, 则将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务, 只要这两个任务执行的时间相差不是太大, 那么分解后执行的吞吐率要高于串行执行的吞吐率, 如果这两个任务执行时间相差太大, 则没必要进行分解。  </p><p>可以通过 Runtime.getRuntime().availableProcessors 方法获得当前设备的 CPU 个数。</p><p>优先级不同的任务可以使用优先级队列 PriorityBlockingQueue 来处理。它可以让优先级高的任务先得到执行, 需要注意的是如果一直有优先级高的任务提交到队列里, 那么优先级低的任务可能永远不能执行</p><p>执行时间不同的任务可以交给不同规模的线程池来处理, 或者也可以使用优先级队列, 让执行时间短的任务先执行。</p><p>依赖数据库连接池的任务, 因为线程提交 SQL 后需要等待数据库返回结果, 如果等待的时间越长 CPU 空闲时间就越长, 那么线程数应该设置越大, 这样才能更好的利用 CPU</p><p>IO 密集型 &#x3D; Ncpu * 2<br>IO 密集型 &#x3D; Ncpu &#x2F; (1 - 阻塞系数), 阻塞系数 &#x3D; 阻塞时间 &#x2F;(阻塞时间 + 计算时间) </p><h2 id="8-参考"><a href="#8-参考" class="headerlink" title="8 参考"></a>8 参考</h2><p><a href="https://blog.csdn.net/mu_wind/article/details/113806680">深入Java线程池: 从设计思想到源码解读</a><br><a href="https://github.com/CL0610/Java-concurrency/blob/master/21.%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.md">线程池ThreadPoolExecutor实现原理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Thread 介绍</title>
      <link href="/article/2021/3487605900/"/>
      <url>/article/2021/3487605900/</url>
      
        <content type="html"><![CDATA[<p>线程是操作系统调度的最小单元, 也叫轻量级进程。它被包含在进程之中, 是进程中的实际运作单位。<br>同一进程可以创建多个线程, 每个线程都有自己独立的一块内存空间, 并且能够访问共享的内存变量。</p><h2 id="1-线程的分类"><a href="#1-线程的分类" class="headerlink" title="1 线程的分类"></a>1 线程的分类</h2><p>在 Java 中, 线程可以分为 2 种</p><blockquote><ol><li>守护线程: 守护线程是为用户线程服务的线程, 在后台默默地完成一些系统性的服务, 如垃圾回收等</li><li>用户线程: 真正完成业务的工作线程</li></ol></blockquote><p>在一个应用程序中, 如果用户线程全部结束了, 意味着程序需要完成的业务操作已经结束, 系统可以退出了。<br>所以当系统只剩下守护进程的时候, Java 虚拟机会自动退出。<br>反之, 如果程序中的用户进程还在执行中, Java 虚拟机会等待器执行完成才结束。  </p><h2 id="2-线程的创建"><a href="#2-线程的创建" class="headerlink" title="2 线程的创建"></a>2 线程的创建</h2><h3 id="2-1-继承-Thread-类-重写-run-方法"><a href="#2-1-继承-Thread-类-重写-run-方法" class="headerlink" title="2.1 继承 Thread 类, 重写 run 方法"></a>2.1 继承 Thread 类, 重写 run 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 定义自己的线程逻辑</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> extend <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread is running "</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 启动线程</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="2-2-实现-Runnable-接口"><a href="#2-2-实现-Runnable-接口" class="headerlink" title="2.2 实现 Runnable 接口"></a>2.2 实现 Runnable 接口</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 定义自己的线程逻辑</span>    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread is running "</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-3-实现-Callable-接口"><a href="#2-3-实现-Callable-接口" class="headerlink" title="2.3 实现 Callable 接口"></a>2.3 实现 Callable 接口</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token class-name">V</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>Callable 接口和 Runnable 接口类似, call 方法里面就是需要线程执行的逻辑, 不同的是 <strong>Callable 有返回值</strong>。<br>同时还有一个隐藏的不同点, Callable 内部可以抛出异常, 同时这个异常是可以被捕获的, 所以可以通过异常再做一次容错处理。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 实现 Callable 实现线程</span>    <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> callable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread is running "</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token string">"finish"</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 这里借助线程池来实现线程</span>    <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 提交任务到线程池, Future 是对执行结果的封装</span>    <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> future <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 尝试获取执行结果</span>        <span class="token comment">// 注意: Future.get 方法是一个阻塞方法。如果对应的线程这时候还没有执行完成, 调用这个方法, 会阻塞当前线程</span>        <span class="token class-name">String</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread's result:"</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 关闭线程池</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre><h3 id="2-4-创建-FutureTask-实例"><a href="#2-4-创建-FutureTask-实例" class="headerlink" title="2.4 创建 FutureTask 实例"></a>2.4 创建 FutureTask 实例</h3><p>FutureTask 的 UML 图:<br><img src="https://pic.imgdb.cn/item/65634d9dc458853aef71807d.png" alt="Alt &#39;FutureTask 的 UML 图&#39;"></p><p>可以发现: FutureTask 还实现了 Runnable 接口, 所以可 FutureTask 也可以当做 Runnable 使用。<br>同时其还实现了一个 Future 的接口。</p><p>Futrue 接口的定义如下</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterruptIfRunning<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">;</span>    <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>Futrue 主要是用于子线程将自己的执行结果返回给主线程:  </p><blockquote><ol><li>主线程将任务提供给子线程时, 会立即返回一个 Future 的返回值</li><li>一开始这个对象的返回值会是空的, 后续子线程执行完成后, 会把返回值翻到这个对象内</li><li>主线程就可以主动通过这个对象获取到执行结果</li><li>因为主线程主动获取执行结果时, 可能子线程还未执行完成, 所以获取返回结果的方法是阻塞的, 主动获取返回结果时, 如果还未有返回值时, 主线程将会被阻塞等待到有返回结果</li></ol></blockquote><p>通过 Future 的声明, 可以知道 Future 除了获取返回结果外, 还具备了取消任务, 获取任务是否完成等功能。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> callable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread is running "</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token string">"finish"</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 创建 FutureTask 实例</span>    <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 创建线程池</span>    <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// FutrueTask 执行方式一</span>    <span class="token comment">// 此处可以不要返回值, 通过入参的 futureTask 获取执行结果</span>    <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> future <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// FutureTask 执行方式二, 当 Runnable 使用</span>    <span class="token comment">// new Thread(futureTask).start();</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 同样的会阻塞当前线程</span>        <span class="token comment">// 通过 FutureTask 创建的, 返回结果放在自身上, 不在 executorService.submit 的返回值</span>        <span class="token comment">// 通过 future 和 futureTask 都会阻塞当前线程</span>        <span class="token class-name">String</span> result <span class="token operator">=</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread's result:"</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> finish <span class="token punctuation">&#123;</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>4 种方式的对比</strong></p><blockquote><ol><li>Thread: 编写简单, 但是不能再继承其他父类, 其内部实际还是通过 Runnable 实现的</li><li>Runnable: 多个线程可以共用一个 Runnable 对象, 适合多线程处理同一个任务的情况。没法知道线程的执行情况</li><li>Callable: 具备和 Runnable 一样的优势的同时, 可以知道线程的执行情况。但是需要借助 ExecutorService, 没法指定工作线程执行</li><li>FutureTask: 具备了 Runnable 和 Callable 的所有优点, 缺点就是编写复杂</li></ol></blockquote><h2 id="3-线程的属性"><a href="#3-线程的属性" class="headerlink" title="3 线程的属性"></a>3 线程的属性</h2><h3 id="3-1-tid"><a href="#3-1-tid" class="headerlink" title="3.1 tid"></a>3.1 tid</h3><p>线程 Id, 用于标记不同的线程 (某个编号的线程结束后, 这个编号可能别后续创建的线程使用)。</p><h3 id="3-2-name"><a href="#3-2-name" class="headerlink" title="3.2 name"></a>3.2 name</h3><p>线程名称, 面向人的一个属性, 用于区分不同的属性, 默认为 <code>Thread-数字</code>。 在实际开发中, 尽可能的自定义自己的线程名, 这样在后续的问题定位排查有帮助<br>(同时记得不要重复, Java 允许存在线程名相同的情况, 但是这会影响到后面问题的定义)。</p><h3 id="3-3-priority"><a href="#3-3-priority" class="headerlink" title="3.3 priority"></a>3.3 priority</h3><p>用于系统的线程调度用的, 表示希望某个线程能够优先得到运行。Java 定义了 1 - 10 个级别, 值越大, 优先级越高, 默认为 5。在实际使用中, 尽可能的不要自定义优先级, 可能会出现意想不到的问题, 比如线程饥饿。</p><h3 id="3-4-daemon"><a href="#3-4-daemon" class="headerlink" title="3.4 daemon"></a>3.4 daemon</h3><p>是否为守护线程。一个线程是用户线程还是守护线程, 通过这个属性进行区分。<br>true: 表示这个线程为守护线程, 否则为用户线程, 这个属性的设置需要在线程启动之前进行设置才有效, 默认为 false, 用户线程。</p><h3 id="3-5-threadStatus"><a href="#3-5-threadStatus" class="headerlink" title="3.5 threadStatus"></a>3.5 threadStatus</h3><p>线程状态, 标识当前线程的处于什么样的一样状态, 具体的取值后面分析。</p><p>其实 Thread 身上还有其他几个属性, 基本不是什么重要的属性, 就不展开了。</p><h2 id="4-线程状态"><a href="#4-线程状态" class="headerlink" title="4 线程状态"></a>4 线程状态</h2><h3 id="4-1-状态取值"><a href="#4-1-状态取值" class="headerlink" title="4.1 状态取值"></a>4.1 状态取值</h3><table><thead><tr><th align="center">线程状态</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">NEW</td><td align="left">初始状态。线程已创建, 但是未启动, 既未调用 start 方法</td></tr><tr><td align="center">RUNNABLE</td><td align="left">运行状态。她包括 2 个状态: 准备状态 和 运行状态</td></tr><tr><td align="center">BLOCKED</td><td align="left">阻塞状态。线程阻塞于锁 或者 发起了阻塞式 I&#x2F;O 操作 (Socket 读写)</td></tr><tr><td align="center">WAITING</td><td align="left">等待状态。当前线程需要等待其他线程执行一下特定的操作(通知, 中断)</td></tr><tr><td align="center">TIME_WAITING</td><td align="left">超时等待状态。和 WAITING 类似, 区别就是这个状态的等待是有时间限制的</td></tr><tr><td align="center">TERMINATED</td><td align="left">终止状态。线程的需要执行的任务已完成。</td></tr></tbody></table><h3 id="4-2-线程状态的转换"><a href="#4-2-线程状态的转换" class="headerlink" title="4.2 线程状态的转换"></a>4.2 线程状态的转换</h3><p>如图:<br><img src="https://pic.imgdb.cn/item/65634ea2c458853aef75cd4c.png" alt="Alt &#39;线程状态转换&#39;"></p><h4 id="4-2-1-New"><a href="#4-2-1-New" class="headerlink" title="4.2.1 New"></a>4.2.1 New</h4><p>通过 new Thread() 创建出 Thread 实例, 实例的默认的状态就是 New</p><h3 id="4-2-2-Runnable"><a href="#4-2-2-Runnable" class="headerlink" title="4.2.2 Runnable"></a>4.2.2 Runnable</h3><p>Java 中的 Runnalbe 状态实际可以再细分为 Ready 和 Running。线程处于 Runnable 不一定就是在执行中的, 也有可能是在 Ready 中,<br>具体什么时候从 Ready 变为 Running, 完全取决于系统的调度。</p><h3 id="4-2-3-Waiting"><a href="#4-2-3-Waiting" class="headerlink" title="4.2.3 Waiting"></a>4.2.3 Waiting</h3><p>等待中状态, 处于等待状态的线程, 正在等待其他线程去执行一个特定的操作。</p><p>从 Runnable 转到 Waiting 的方式有</p><blockquote><ol><li>Object.join()</li><li>Ojbect.wait()</li><li>Lock.lock(), 尝试获取锁, 获取锁失败时</li><li>LockSupport.park()</li></ol></blockquote><p>从 Waiting 转到 Runnable 的方式有</p><blockquote><ol><li>Object.notify()</li><li>Ojbect.notifyAll()</li><li>LockSupport.uppark(Thread)</li></ol></blockquote><h3 id="4-2-4-Time-Waiting"><a href="#4-2-4-Time-Waiting" class="headerlink" title="4.2.4 Time_Waiting"></a>4.2.4 Time_Waiting</h3><p>带超时时间的等待状态。</p><p>从 Runnable 转到 Timed_waiting 的方式有</p><blockquote><ol><li>Thead.sleep(long)</li><li>Object.wait(long)</li><li>Thread.join(long)</li><li>Lock.tryLock(long, TimeUnit)</li><li>LockSupport.parkNanos()</li><li>LockSupport.parkUntil()</li></ol></blockquote><p>从 Timed_Waiting 转到 Runnable 的方式有</p><blockquote><ol><li>Object.notify()</li><li>Ojbect.notifyAll()</li><li>LockSupport.uppark(Thread)</li></ol></blockquote><h3 id="4-2-5-Blocked"><a href="#4-2-5-Blocked" class="headerlink" title="4.2.5 Blocked"></a>4.2.5 Blocked</h3><p>阻塞状态, 此时线程无任何的处理能力</p><p>从 Runnable 转到 Blocked 的方式有</p><blockquote><ol><li>获取 synchronized 锁失败</li></ol></blockquote><p>从 Blocked 转到 Runnable 的方式有</p><blockquote><ol><li>获取 synchronized 锁成功</li></ol></blockquote><p>备注(待考证):<br>WAITING 和 BLOCKING 之间也存在着转换, 当多个线程阻塞于同一个锁时, 他们都处于 WAITING 状态, 当有一个线程释放锁了, 上面的线程会同时争取锁, 争取到锁的线程会进入到 RUNNABLE, 没有争取到的会进入到 BLOCKED。</p><h3 id="4-2-6-Terminated"><a href="#4-2-6-Terminated" class="headerlink" title="4.2.6 Terminated"></a>4.2.6 Terminated</h3><p>终止状态。<br>线程中的业务业务代码执行完成, 结束逻辑。</p><h2 id="5-线程的一些基本操作"><a href="#5-线程的一些基本操作" class="headerlink" title="5 线程的一些基本操作"></a>5 线程的一些基本操作</h2><h3 id="5-1-sleep"><a href="#5-1-sleep" class="headerlink" title="5.1 sleep"></a>5.1 sleep</h3><p>sleep(long mills) 是 Thread 的一个静态方法。<br>可以让当前线程进入休眠, 休眠的时间由指定的参数决定。  </p><p>调用这个方法会导致线程状态变为 Timed_waiting。</p><h3 id="5-2-wait"><a href="#5-2-wait" class="headerlink" title="5.2 wait"></a>5.2 wait</h3><p>wait() &#x2F; wait(long mills) 是 Object 的一个方法, 可以让执行这个方法的线程暂停 (进入到 Waiting &#x2F; Timed_waiting)。<br>wait() &#x2F; wait(long mills) 在使用之前需要先获取到锁, 才能进入暂停。即只能在同步代码块中使用, 同时内部要调用代码块锁住的对象的 wait()</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Object</span> lock2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 没有在代码块中, 抛异常</span><span class="token comment">//lock.wait();</span><span class="token comment">// 锁住了 lock 对象</span><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 没有锁住 lock2, 调用 lock2.wait 方法会抛异常</span>        <span class="token comment">//lock2.wait();</span>        <span class="token comment">// 正常沉睡</span>        lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>wait 和 sleep 的区别</p><blockquote><ol><li>wait 是 Object 的一个方法, sleep 是 Thread 的一个静态方法</li><li>wait 需要在获取到对应的锁的时候才能使用(也就是在同步代码块, 或者同步方法内), sleep 则不需要</li><li>wait 方法在执行时, 会释放自身的拥有的锁, 而 sleep 如果拥有锁, 则不会释放</li><li>wait(long mills) &#x2F; sleep 方法会在指定的休眠时间达到后, 重新运行。但是 wait() 方法需要其他线程调用对应的锁对象的 notify() 或者 notifyAll() (这 2 个方法也都是需要先获取到对应的锁), 进行通知后, 才有可能继续执行 (有可能同时多个线程在等待, 但是锁只有一个, 只能在等待的线程中选择一个进行唤醒)</li></ol></blockquote><h3 id="5-3-join"><a href="#5-3-join" class="headerlink" title="5.3 join"></a>5.3 join</h3><p>join() &#x2F; join(long mills) 是 Thread 的一个方法。主要用于让当前线程等待指定的线程执行完成。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span> waitThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">30000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"son thread finish"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>waitThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 当前线程(主线程)进入暂停状态, 等待 t 线程执行完。</span>    waitThread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main thread finish"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="5-4-yeild"><a href="#5-4-yeild" class="headerlink" title="5.4 yeild"></a>5.4 yeild</h3><p>yeild() 是 Thread 的一个静态方法。<br>作用: 使当前线程主动放弃其对处理器的占用, 这可能导致当前线程被暂停。这个方法是不可靠的, 有可能调用之后, 前线程还在继续执行。</p><h3 id="5-5-interrupt"><a href="#5-5-interrupt" class="headerlink" title="5.5 interrupt"></a>5.5 interrupt</h3><p>interrupt() 是 Thread 的一个方法, 调用这个方法, 可以向指定的线程发送一个信号, 让其终止, 但是最终是否能够终止, 由线程内部决定。</p><p>原理: </p><blockquote><ol><li>线程内部维护了一个 isInterrupted 的变量 (这个变量不在 Java 代码里面维护, 而是在 JVM 的代码里面), 取值范围为 0 (false), 1 (true)</li><li>调用线程的 interrupt() 方法, 会把这个标志符设为 1</li><li>当线程的状态从 Runnable 变为其他的状态时, 检测到这个标识为 1, 就会抛出 InterruptedException 异常, 同时把标志重新恢复为 0</li><li>线程的 wait&#x2F;sleep&#x2F;join 等方法, 都可以改变线程的状态</li></ol></blockquote><p>复位 (中断标识从 true 恢复回 false): </p><ol><li>可以直接调用 Thread 的 静态方法 interrupted() 可以将中断标志恢复为 false.</li><li>线程抛出 InterruptedException 异常。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java PriorityQueue</title>
      <link href="/article/2021/376265235/"/>
      <url>/article/2021/376265235/</url>
      
        <content type="html"><![CDATA[<p>一般情况下, 我们使用队列是为了能够建造队列的先进先出 (First-In-First-Out) 模式的, 达到一种资源的公平分配, 先到达的任务 (元素) 先处理, 但有时需要在队列中基于优先级处理对象。<br>存入队列中的任务 (元素) 具有优先级, 需要根据优先级修复里面的数据。而在 JDK 1.5 引入的 PriorityQueue, 就具备了这种功能。</p><h2 id="1-PriorityQueue-的实现数据结构"><a href="#1-PriorityQueue-的实现数据结构" class="headerlink" title="1 PriorityQueue 的实现数据结构"></a>1 PriorityQueue 的实现数据结构</h2><p>PriorityQueue 通过二叉小顶堆实现, 具备下面的特点:  </p><blockquote><ol><li>二叉堆就是完全二叉树, 左边最多比右边深 1 层, 不能是右边比左边深, 这是和平衡二叉树不同的地方。在树中的数据变动了 (新增&#x2F;删除等), 具备自行调整的特性。  </li><li>小顶堆: 根节点最小, 父结点的键值总是小于或等于任何一个子节点的键值 (大顶堆, 则是相反的)。</li></ol></blockquote><p>基于上面的 2 个特性, 可以推导出几个特点 (假设当前有一个节点 Node, 从上往下, 从左往右计算, 他是 index 个)</p><blockquote><ol><li>Node 节点的左子节点的位置为 2 * index + 1</li><li>Node 节点的右子节点的位置为 2 * index + 2</li><li>Node 节点的父级节点的位置为 (index - 1) &#x2F; 2</li></ol></blockquote><p>每个节点可以推导出其相关的父子级节点, 所以二叉小顶堆可以通过<strong>数组</strong>优雅的实现。</p><p>如图:<br><img src="https://pic.imgdb.cn/item/65634167c458853aef393e3b.png" alt="Alt &#39;数组实现 PriorityQueue&#39;"></p><h2 id="2-PriorityQueue-中的几比较重要的属性"><a href="#2-PriorityQueue-中的几比较重要的属性" class="headerlink" title="2 PriorityQueue 中的几比较重要的属性"></a>2 PriorityQueue 中的几比较重要的属性</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">transient</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> queue<span class="token punctuation">;</span>     <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> comparator<span class="token punctuation">;</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-1-queue"><a href="#2-1-queue" class="headerlink" title="2.1 queue"></a>2.1 queue</h3><p>PriorityQueue 中数据存储的地方, 可以看到是通过数组实现, 通过数组实现了二叉小顶堆的结构。</p><h3 id="2-2-size"><a href="#2-2-size" class="headerlink" title="2.2 size"></a>2.2 size</h3><p>当前 PriorityQueue 中存储的数据量</p><h3 id="2-3-comparator"><a href="#2-3-comparator" class="headerlink" title="2.3 comparator"></a>2.3 comparator</h3><p>用户自定义的比较器, PriorityQueue 就是借助这个比较器, 对存入的数据进行比较, 决定优先级的。<br>如果用户没有定义这个比较器的话, 那么需要保证存入 PriorityQueue 中的数据是可以比较的, 即实现了 Comparator 接口。<br>而当用户既定义了比较器, 同时数据实现了 Comparator 接口, 优先使用比较器进行比较。</p><h3 id="2-4-modCount"><a href="#2-4-modCount" class="headerlink" title="2.4 modCount"></a>2.4 modCount</h3><p>当前的 PriorityQueue 变更了多少次。</p><h2 id="3-PriorityQueue-的构造方法"><a href="#3-PriorityQueue-的构造方法" class="headerlink" title="3 PriorityQueue 的构造方法"></a>3 PriorityQueue 的构造方法</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 构造函数 1: 无参构造函数</span>    <span class="token keyword">public</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略    </span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 构造函数 2: 指定容量的构造函数</span>    <span class="token keyword">public</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 构造函数 3: 指定容量比较器的构造函数</span>    <span class="token keyword">public</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 构造函数 4: 指定了初始容量和比较器的构造函数</span>    <span class="token keyword">public</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span>  <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 构造函数 5: 指定一个 PriorityQueue 的构造函数</span>    <span class="token keyword">public</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> c<span class="token punctuation">.</span><span class="token function">comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">initFromPriorityQueue</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 构造函数 6: 指定一个  SortedSet 的构造函数</span>    <span class="token keyword">public</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token class-name">SortedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> c<span class="token punctuation">.</span><span class="token function">comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">initElementsFromCollection</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 构造函数 7: 给定一个 Collection 的构造函数</span>    <span class="token keyword">public</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>总共提供了 7 个构造函数, 看起来很多, 实际后面很多都是相同的, 所以需要深入理解的就 1 个, 指定 Collection 的构造函数。</p><h3 id="3-1-无参构造函数"><a href="#3-1-无参构造函数" class="headerlink" title="3.1 无参构造函数"></a>3.1 无参构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 内部调用到自身 2 个参数的构造函数</span>    <span class="token comment">// 同时提供默认值, 初始容量的默认值为 DEFAULT_INITIAL_CAPACITY = 11, Comparator 比较器为null</span>    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-2-指定容量的构造函数"><a href="#3-2-指定容量的构造函数" class="headerlink" title="3.2 指定容量的构造函数"></a>3.2 指定容量的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 同样是内部调用到自身的 2 个参数的构造函数</span>    <span class="token comment">// 初始容量默认值为用户定义的值, Comparator 比较器则为 null</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-3-指定容量比较器的构造函数"><a href="#3-3-指定容量比较器的构造函数" class="headerlink" title="3.3 指定容量比较器的构造函数"></a>3.3 指定容量比较器的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 同样是内部调用到了自身的 2 个参数的构造函数</span>    <span class="token comment">// 初始容量默认为 11, 比较器为用户自定义的</span>    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">,</span> comparator<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-4-指定了初始容量和比较器的构造函数"><a href="#3-4-指定了初始容量和比较器的构造函数" class="headerlink" title="3.4 指定了初始容量和比较器的构造函数"></a>3.4 指定了初始容量和比较器的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span>  <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 初始容量必须大于 1 </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 声明数组</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 将用户声明的比较器赋值给自身的比较器属性</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">=</span> comparator<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-5-指定一个-PriorityQueue-的构造函数"><a href="#3-5-指定一个-PriorityQueue-的构造函数" class="headerlink" title="3.5 指定一个 PriorityQueue 的构造函数"></a>3.5 指定一个 PriorityQueue 的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取队列里面的比较器</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> c<span class="token punctuation">.</span><span class="token function">comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将队列里面的数据读取到自身, 下面集合构造函数分析</span>    <span class="token function">initFromPriorityQueue</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-6-指定一个-SortedSet-的构造函数"><a href="#3-6-指定一个-SortedSet-的构造函数" class="headerlink" title="3.6 指定一个 SortedSet 的构造函数"></a>3.6 指定一个 SortedSet 的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token class-name">SortedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取 SortedSet 里面的比较器</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> c<span class="token punctuation">.</span><span class="token function">comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 从集合里面读取数据到自身, 同样下面的集合构造函数有分析</span>    <span class="token function">initElementsFromCollection</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-7-给定一个-Collection-的构造函数"><a href="#3-7-给定一个-Collection-的构造函数" class="headerlink" title="3.7 给定一个 Collection 的构造函数"></a>3.7 给定一个 Collection 的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token keyword">instanceof</span> <span class="token class-name">SortedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// SortedSet 内部也是有序的, 实现逻辑也是和 PriorityQueue 一样, 所以特殊处理</span>        <span class="token class-name">SortedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> ss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SortedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> c<span class="token punctuation">;</span>        <span class="token comment">// 获取 SortedSet 中的比较器</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> ss<span class="token punctuation">.</span><span class="token function">comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 从 Collection 中获取数据赋值到当前的 PriorityQueue</span>        <span class="token function">initElementsFromCollection</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token keyword">instanceof</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// PriorityQueue 转为 PriorityQueue, 逻辑简单很多, 所以特殊处理</span>        <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> pq <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> c<span class="token punctuation">;</span>        <span class="token comment">// 获取 PriorityQueue 的比较器</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> pq<span class="token punctuation">.</span><span class="token function">comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取数据</span>        <span class="token function">initFromPriorityQueue</span><span class="token punctuation">(</span>pq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 设置当前的 PriorityQueue 的比较器为 null</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 获取数据</span>        <span class="token function">initFromCollection</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 场景一: 从有序的结合中获取数据  */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">initElementsFromCollection</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用这个方法的调用方, Colleciont 是已经有序的</span>    <span class="token comment">// 转换数组</span>    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 不是 ArrayList 类型, 通过 Arrays.copyOf 做一层转换</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token class-name">ArrayList</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>        a <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token punctuation">.</span>length<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// 只有 1 个元素 或者 自定义的比较器不为 null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token comment">// 不能为 null</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 赋值给自身的 queue 数组      </span>    <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token comment">// 当前的个数等于数组的长度</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 场景二: 从 PriorityQueue 中获取数据 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">initFromPriorityQueue</span><span class="token punctuation">(</span><span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 是 PriorityQueue 直接赋值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">initFromCollection</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 场景三: 从普通的集合中获取数据 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">initFromCollection</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用这个方法的调用方, Collection 不一定是有序的, 所以为了满足二叉小顶堆的特点, 需要进行堆化调整</span>    <span class="token comment">// 把 Collection c 中的数据赋值给当前的 Queue</span>    <span class="token function">initElementsFromCollection</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 堆化, 数组调整, 使其满足二叉小顶堆的特点</span>    <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 对于一个杂乱无章的数组, 进行调整的话, 如果直接从第一个元素开始调整, 那么会频繁的调整</span>    <span class="token comment">// 通过分析可以知道, 二叉树没有叶子节点占整棵树节点的一半, 所有的叶子节点暂时不看他们的父级节点, 可以看做是已经满足二叉树的节点</span>    <span class="token comment">// 这一部分看做是满足条件的话, 那么就可以从最后一个有叶子节点的开始往前进行调整, 这样的话, 可以只对数组中的一半进行调整</span>    <span class="token comment">// 从数组的中间开始调整</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token comment">// 下移操作, 后面讲解</span>        <span class="token function">siftDown</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="4-PriorityQueue-的操作方法"><a href="#4-PriorityQueue-的操作方法" class="headerlink" title="4 PriorityQueue 的操作方法"></a>4 PriorityQueue 的操作方法</h2><h3 id="4-1-添加数据"><a href="#4-1-添加数据" class="headerlink" title="4.1 添加数据"></a>4.1 添加数据</h3><p>二叉小顶堆的特点</p><blockquote><ol><li>父结点的键值总是小于或等于任何一个子节点的键值</li><li>于数组实现的二叉堆, 对于数组中任意位置的 n 上元素, 其左孩子在 2n+1 位置上, 右孩子 2(n+1) 位置, 它的父亲则在 n-1&#x2F;2 上, 根节点在 0 位置</li></ol></blockquote><p>为了维护这个特点, 二叉堆在添加元素的时候, 需要一个 “上移” 的动作, “上移” 的过程, 如图:</p><p><img src="https://pic.imgdb.cn/item/656341d0c458853aef3addbd.png" alt="Alt &#39;BinaryHeapShiftUp&#39;"></p><blockquote><ol><li>将元素 2 添加在最后一个位置</li><li>由于 2 比其父亲 6 要小, 所以将元素 2 上移, 交换 2 和 6 的位置</li><li>然后由于 2 比 5 小, 继续将 2 上移, 交换 2 和 5 的位置</li><li>此时 2 大于其父亲 (根节点) 1, 结束</li></ol></blockquote><p>上移的过程总结</p><blockquote><ol><li>先把需要新增的节点放到末尾的位置 </li><li>和其父级进行比较<blockquote><p>2.1 如果没有父节点了, 结束, 当前的位置就是新增节点的位置<br>2.1 如果比父级的值大, 结束, 这个位置就是新增的节点的所在位置<br>2.2 如果比父级的值小, 和父级交互值, 然后回到第二步, 继续进行比较</p></blockquote></li></ol></blockquote><p>代码实现: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 默认添加到尾部, 调用自身的 offer 方法</span>        <span class="token keyword">return</span> <span class="token function">offer</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 不支持 null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 修改次数 +1            </span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">// 当前数据的个数</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token comment">// 数据的个数大于当前数组的长度</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span>            <span class="token comment">// 扩容</span>            <span class="token function">grow</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 已存储数据个数 + 1            </span>        size <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 当前数组中的没有数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment">// 直接把数组的第一位设置为添加的数据</span>            queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// 添加数据到数组的 i 位置并进行上移操作</span>            <span class="token function">siftUp</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 元素上移</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">// 有比较器的使用比较器的上移方法</span>            <span class="token function">siftUpUsingComparator</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// 没有比较器使用, 没有比较器的的上移方法</span>            <span class="token function">siftUpComparable</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 使用用户自定义的比较器进行比较, 然后完成元素上移操作</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftUpUsingComparator</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 获取插入位置的父级节点的位置</span>            <span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">// 获取父级节点的值</span>            <span class="token class-name">Object</span> e <span class="token operator">=</span> queue<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 使用比较器进行比较当前的值和父级的值, </span>            <span class="token comment">// 当前的值 >= 父级的值, 不需要上移了, 此时的 k 位置就是数据存储的位置</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> e<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment">// 当前的位置设置为父级的值                </span>            queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token comment">// 将父级的位置赋给当前的 k, 标识下次计划插入的位置, 也就是上移操作</span>            k <span class="token operator">=</span> parent<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 数组当前的 k 位置等于需要插入的数据 x</span>        queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 使用元素的比较器进行比较, 然后完成元素上移操作</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftUpComparable</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 没有比较器, 需要当前的数据是 Comparable 的实现类, 即数据类型是可比较的</span>        <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> x<span class="token punctuation">;</span>        <span class="token comment">// 大体的流程和上面的一样</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token class-name">Object</span> e <span class="token operator">=</span> queue<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> e<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            k <span class="token operator">=</span> parent<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 数组扩容</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 当前数组的容量</span>        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// 当前数组的容量 &lt; 64, 则新的数组容量 = 旧数组容量 * 2 + 2, 否则等于新的数组容量 = 旧的容量 * 1.5</span>        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>oldCapacity <span class="token operator">&lt;</span> <span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 新的容量比最大值 (int 的最大值 - 8) 大</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> <span class="token constant">MAX_ARRAY_SIZE</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment">// 控制新的最大值不大于 int 的最大值</span>            newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 声明新的数组, 同时将旧的数组的数据迁移到新的数组</span>        queue <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 小于 0, 抛异常</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 入参的容量大于 int 的最大值 - 8 的话, 返回 int 的最大值, 否则返回 int 的最大值 - 8</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> <span class="token constant">MAX_ARRAY_SIZE</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">:</span> <span class="token constant">MAX_ARRAY_SIZE</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="4-2-删除数据"><a href="#4-2-删除数据" class="headerlink" title="4.2 删除数据"></a>4.2 删除数据</h3><p>对于 PriorityQueue 删除数据都是删除<strong>根元素</strong>, 也就是最小的元素。<br>删除了根元素, 就要找一个替代者移动到根位置, 相对于被删除的元素来说就是 “下移”, 如图:</p><p><img src="https://pic.imgdb.cn/item/656341d0c458853aef3addc7.png" alt="Alt &#39;BinaryHeapShiftDown&#39;"></p><blockquote><ol><li>将找出队尾的元素 8, 并将它在队尾位置上删除</li><li>此时队尾元素 8 比根元素 1 的最小孩子 3 要大, 所以将元素 1 下移, 交换 1 和 3 的位置</li><li>然后此时队尾元素 8 比元素 1 的最小孩子 4 要大, 继续将 1 下移, 交换 1 和 4 的位置</li><li>然后此时根元素 8 比元素 1 的最小孩子 9 要小, 不需要下移, 直接将根元素 8 赋值给此时元素 1 的位置, 1 被覆盖则相当于删除</li></ol></blockquote><p>下移的过程总结</p><blockquote><ol><li>获取末尾节点的值, 然后进行删除</li><li>找到需要删除位置的左右节点, 找到 2 个节点值比较小的节点<blockquote><p>2.1 如果没有左右节点, 把末尾节点的值放到这个位置, 下移过程结束<br>2.2 如果只有左节点, 较小值等于左节点的值</p></blockquote></li><li>用末尾的值和找到的较小值比较<blockquote><p>3.1 如果末尾的值比较小值小, 那么需要删除位置放入末尾节点的值, 下移结束<br>3.2 如果末尾的值比较小值大, 那么把较小值的放到需要删除的位置, 需要删除的位置替换为较小值所在的位置, 然后回到第二步, 继续进行比较</p></blockquote></li></ol></blockquote><p>如果删除的位置刚好是根节点, 上面的下移基本完成了。   </p><p>如果删除的位置是中间的位置, 那么还需要在进行一次是否上移的判断:<br>如果末尾的值直接就是放入第一次需要删除的位置, 没有任何的比较替换操作, 这是放入的位置的值可能比他的父级小, 所以还需要进行一次上移的判断,<br>如果不是直接放入到第一次需要删除的位置, 就不需要进行上移的判断</p><p>代码实现: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">E</span> x <span class="token operator">=</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// 为 null 抛出异常</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 存储的数据个数为 0, 返回 null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 新的元素个数 = 旧的元素个数 - 1    </span>        <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token operator">--</span>size<span class="token punctuation">;</span>        <span class="token comment">// 修改次数 + 1</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">// 获取根节点</span>        <span class="token class-name">E</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 获取最后一个节点</span>        <span class="token class-name">E</span> x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> queue<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 设置最后一个节点为 null</span>        queue<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 新的元素个数不等于 0, 进行下移</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 将元素 x 放入到 k 的位置, 然后进行下移</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token function">siftDownUsingComparator</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">siftDownComparable</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 使用用户自定义的比较器进行比较, 然后完成元素下移操作</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftDownUsingComparator</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 通过 size/2 找到第一个没有叶子节点的元素, 这个位置后面的节点都是没有叶子节点, 可以不用处理了</span>        <span class="token keyword">int</span> half <span class="token operator">=</span> size <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> half<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 获取指定位置的左节点</span>            <span class="token keyword">int</span> child <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">// c 存储的是左右节点中较小的值</span>            <span class="token class-name">Object</span> c <span class="token operator">=</span> queue<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 右节点的位置</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">// 不是数组的尾部, 左节点比右节点的值大, 那么较小值 c = 右节点的值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> c<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> queue<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token comment">// 需要替换的值为右节点的值</span>                c <span class="token operator">=</span> queue<span class="token punctuation">[</span>child <span class="token operator">=</span> right<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 需要替换的值比左右节点中的较小值还要小, 不需要继续处理了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> c<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment">// 将 x 理论存储的位置从 k 下移到左右节点中较小的节点的位置 child, 进入下层循环</span>            queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>            k <span class="token operator">=</span> child<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 将 x 值放到 k 位置</span>        queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 使用元素的的比较器进行比较, 然后完成元素上移操作</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftDownComparable</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 和上面的逻辑差不多</span>        <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>x<span class="token punctuation">;</span>        <span class="token keyword">int</span> half <span class="token operator">=</span> size <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>           <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> half<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> child <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>             <span class="token class-name">Object</span> c <span class="token operator">=</span> queue<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> queue<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                c <span class="token operator">=</span> queue<span class="token punctuation">[</span>child <span class="token operator">=</span> right<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> c<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>            k <span class="token operator">=</span> child<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>队列基本的操作只有入队和出队, 几乎没有查询的操作, 所以 PriorityQueue 的代码分析就到这里。</p><h2 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5 使用场景"></a>5 使用场景</h2><p>ProfityQueue 在一些调度和算法中使用比较多</p><blockquote><ol><li>带有优先级任务的调度, 比如什么加急审批</li><li>负载均衡, 可以根据流量等因素进行优先级的调度</li><li>一些搜索算法</li></ol></blockquote><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h2><p><a href="https://www.cnblogs.com/linghu-java/p/9467805.html">PriorityQueue源码分析</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发相关的一些概念</title>
      <link href="/article/2021/3682920581/"/>
      <url>/article/2021/3682920581/</url>
      
        <content type="html"><![CDATA[<p>平时在学习中遇到的一些并发相关的概念, 做个笔记整理一下。</p><h2 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1 相关概念"></a>1 相关概念</h2><h3 id="1-1-同步-VS-异步"><a href="#1-1-同步-VS-异步" class="headerlink" title="1.1 同步 VS 异步"></a>1.1 同步 VS 异步</h3><p>同步和异步关注的是 <code>消息通信机制</code>。 </p><p>同步: 调用方发起一个调用, 在没有得到结果之前, 这个调用就不返回, 即调用方主动等待调用的结果。<br>(A 调用了一个方法, A 必须等到这个方法返回结果了, 才能执行后续的代码)  </p><p>异步: 调用方发起一个调用后, 就不管了, 后续有结果, 可以让被调用方通知调用方 (A 调用了一个方法后, 就继续执行后面的代码, 不用等待方法的返回值)。<br>一般情况下, 被调用方处理完后, 会通过状态、通知、回调函数等来通知调用者。  </p><h3 id="1-2-阻塞-VS-非阻塞"><a href="#1-2-阻塞-VS-非阻塞" class="headerlink" title="1.2 阻塞 VS 非阻塞"></a>1.2 阻塞 VS 非阻塞</h3><p>阻塞和非阻塞关注的是 <code>程序在等待调用结果时的状态</code>。 </p><p>阻塞: 调用方发起一个调用, 在没有得到结果之前, 调用方会被挂起, 无法进行其他的操作, 等待执行结果。   </p><p>非阻塞: 调用方发起一个调用, 在没有得到结果之前, 调用方不会被挂起。</p><h3 id="1-3-并发-VS-并行"><a href="#1-3-并发-VS-并行" class="headerlink" title="1.3 并发 VS 并行"></a>1.3 并发 VS 并行</h3><p>并发: 多个任务交替执行, 也就是同一个时刻只有一个任务在执行。  </p><p>并行: 多个任务同时执行, 也就是同一个时刻有多个任务在执行。</p><h3 id="1-4-进程-VS-线程-VS-协程"><a href="#1-4-进程-VS-线程-VS-协程" class="headerlink" title="1.4 进程 VS 线程 VS 协程"></a>1.4 进程 VS 线程 VS 协程</h3><p>进程是程序向操作系统申请资源 (如内存空间和文件句柄) 的基本单位。也可以理解为是线程的一个容器。</p><p>线程也叫轻量级进程, 是程序执行的最小单位, 本身只拥有少部分执行必须的资源。是进程中可独立运行的最小单位。</p><p>协程也叫微线程, 用户可以自己控制协程切换的时机, 不再需要陷入系统的内核态。和线程的区别: 线程间的切换都是由系统进行的, 但是协程可以由代码显示进行调度。</p><h3 id="1-5-用户态-VS-内核态"><a href="#1-5-用户态-VS-内核态" class="headerlink" title="1.5 用户态 VS 内核态"></a>1.5 用户态 VS 内核态</h3><p>用户态和内核态是操作系统的两种运行级别, 两者最大的区别就是特权级不同。 运行在用户态的程序不能直接访问操作系统内核数据结构和程序, 而运行在内核态的程序则没有限制。</p><p>Linux 的架构中, 很重要的一个能力就是操纵系统资源的能力。但是系统资源是有限的, 无限制的使用, 将会导致浪费, 同时错误地使用会导致错误。<br>为了减少资源浪费, Linux 制定了一个等级制定, 即特权。Linux 将特权分成两个层次, 以 0 和 3 标识, 0 的特权级要高于 3。 0 特权级在操纵系统资源上是没有任何限制的, 可以执行任何操作, 而 3 特权则会受到极大的限制。<br>特权级 0 称之为内核态, 特权级 3 称之为用户态。</p><p>内核态和用户态之间的转换方式有 3 种</p><blockquote><ol><li>系统调用: 如调用 write(), read(), send() 等 IO 函数等操作, 进程需要会进入内核态使用内核代码去完成操作。系统调用本身就是中断, 软件中断, 和硬件中断不同</li><li>异常: 当前进程运行在用户态, 如果这个时候发生了异常事件, 就会触发切换</li><li>外设中断: 当外设完成用户的请求时, 会向 CPU 发送中断信号</li></ol></blockquote><h4 id="1-5-1-用户空间-VS-内核空间"><a href="#1-5-1-用户空间-VS-内核空间" class="headerlink" title="1.5.1 用户空间 VS 内核空间"></a>1.5.1 用户空间 VS 内核空间</h4><p>操作系统将虚拟内存划分为两部分:<br>一部分是用户空间, 供各个进程使用, 在这部分空间内各个进程之间相互独立。<br>另一部分是内核空间, 只提供给供内核使用, 每个进程可以通过系统调用进入内核, 所以内核空间由系统内的所有进程共享。</p><p>在 Linux 系统中, 用户空间和内核空间所占的虚拟内存比例是 3:1, 用户空间占了内存的低位, 内核空间占据内存的高位。</p><p>可以简单的理解为: 进程工作在用户空间就是用户态, 进程工作在内核空间就是内核态。</p><h4 id="1-5-2-零拷贝"><a href="#1-5-2-零拷贝" class="headerlink" title="1.5.2 零拷贝"></a>1.5.2 零拷贝</h4><p>传统的磁盘读取</p><blockquote><ol><li>应用程序发起系统调用, 进入内核态</li><li>从磁盘中读取数据到内核空间</li><li>将数据从内核空间拷贝到用户空间</li><li>应用程序恢复为用户态</li></ol></blockquote><p>零拷贝的实现</p><blockquote><ol><li>应用程序发起系统调用, 进入内核态</li><li>从磁盘读取数据到内核空间, 再将内核空间的数据<strong>映射</strong>到用户空间, 内核空间和用户空间不需要拷贝了</li><li>应用程序恢复为用户态</li></ol></blockquote><h2 id="2-独占锁和共享锁"><a href="#2-独占锁和共享锁" class="headerlink" title="2 独占锁和共享锁"></a>2 独占锁和共享锁</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>独占锁: 锁同一时刻只能被一个线程持有。<br>共享锁: 锁同时可以被多个线程持有。</p><h3 id="2-2-具体的实现"><a href="#2-2-具体的实现" class="headerlink" title="2.2 具体的实现"></a>2.2 具体的实现</h3><p>读锁是共享锁的具体实现, 而写锁是独占锁的具体实现。</p><p>读锁可以在没有写锁的时候被多个线程同时持有, 而写锁是独占的, 写锁的优先级要高于读锁。</p><h3 id="2-3-锁的附加属性"><a href="#2-3-锁的附加属性" class="headerlink" title="2.3 锁的附加属性"></a>2.3 锁的附加属性</h3><h4 id="2-3-1-公平性"><a href="#2-3-1-公平性" class="headerlink" title="2.3.1 公平性"></a>2.3.1 公平性</h4><p>锁的获取是否是公平的, 即锁的获取是否按照申请是顺序获取。  </p><p>如果像排队一样, 先来的先获取锁, 后来的后获取锁, 具备公平性, 这就是公平锁。<br>如果锁的获取是没有规则的, 可能后到的线程先获取锁, 这就是不公平锁。</p><h4 id="2-3-2-可重入性"><a href="#2-3-2-可重入性" class="headerlink" title="2.3.2 可重入性"></a>2.3.2 可重入性</h4><p>同一个线程在已经获取到一个锁了, 后续在未释放的情况下又一次申请同一个锁</p><blockquote><ol><li>申请成功, 锁具备可重入性</li><li>申请失败, 锁不具备可重入性</li></ol></blockquote><h3 id="2-4-锁引起的问题"><a href="#2-4-锁引起的问题" class="headerlink" title="2.4 锁引起的问题"></a>2.4 锁引起的问题</h3><h4 id="2-4-1-死锁"><a href="#2-4-1-死锁" class="headerlink" title="2.4.1 死锁"></a>2.4.1 死锁</h4><p>两个或者更多的线程相互占用对方的资源的锁, 而又相互等对方释放锁而被永远暂停 (线程的生命周期状态为 BLOCKED或者 WAITING)。</p><h4 id="2-4-2-活锁"><a href="#2-4-2-活锁" class="headerlink" title="2.4.2 活锁"></a>2.4.2 活锁</h4><p>线程拿到资源却又相互释放不执行, 相互谦让, 都主动将资源释放给别的线程使用, 这样这个资源在多个线程之间跳动而又得不到执行。</p><h4 id="2-4-3-线程饥饿"><a href="#2-4-3-线程饥饿" class="headerlink" title="2.4.3 线程饥饿"></a>2.4.3 线程饥饿</h4><p>线程一直无法获得其所需的资源而导致其任务一直无法进展 (优先级高的线程一直抢占优先级低线程的资源, 导致低优先级线程无法得到执行)。</p><h2 id="3-并发的优缺点"><a href="#3-并发的优缺点" class="headerlink" title="3 并发的优缺点"></a>3 并发的优缺点</h2><h3 id="3-1-优点"><a href="#3-1-优点" class="headerlink" title="3.1 优点"></a>3.1 优点</h3><blockquote><ol><li>充分利用多核 CPU 的运算能力, 使线程之间可以并行操作, 更快的处理能力</li><li>异步执行比同步执行更快, 使程序的处理能力得到提升</li><li>资源利用率提高, 如文件读取等情况</li></ol></blockquote><h3 id="3-2-缺点"><a href="#3-2-缺点" class="headerlink" title="3.2 缺点"></a>3.2 缺点</h3><p><strong>1. 频繁的上下文切换</strong><br>在操作系统内部, 多线程直接的实现是基于时间片实现的。 CPU 基于时间片不断的切换线程, 使得少量的 CPU 能够支撑起大量的线程。但是每次切换线程为了能够<br>在下次轮到这个线程的时间片到了能够继续执行下去, 需要把当前的状态保存起来, 下次好恢复。而这个过程是很耗时间的, 所以大量的线程存在, 会导致更高的上下<br>文切换, 反而会影响到系统的效率。</p><p><strong>2. 数据准确性问题</strong><br>多个线程共享数据时可能会产生于期望不相符的结果</p><p><strong>3. 线程活性问题</strong><br>死锁, 活锁, 线程饥饿等问题</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><a href="https://blog.csdn.net/zk3326312/article/details/79591358">浅谈用户态和内核态以及用户空间和内核空间</a><br><a href="https://zhuanlan.zhihu.com/p/248448896">并发编程基础概念</a><br><a href="https://zhuanlan.zhihu.com/p/258513662">原来 8 张图, 就可以搞懂「零拷贝」了</a><br><a href="https://blog.csdn.net/y277an/article/details/98000132">NIO效率高的原理之零拷贝与直接内存映射</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java LinkedHashMap</title>
      <link href="/article/2021/3661044544/"/>
      <url>/article/2021/3661044544/</url>
      
        <content type="html"><![CDATA[<p>LinkedHashMap 继承于 HashMap。在 HashMap 基础上, 维护了一条双向链表, 用来记录存入 Map 中的数据的顺序, 即存储到 Map 中的 key-value 是有序的。 解决了 HashMap 无法顺序访问的和保持插入顺序的问题。</p><h2 id="1-LinkedHashMap-的结构定义"><a href="#1-LinkedHashMap-的结构定义" class="headerlink" title="1 LinkedHashMap 的结构定义"></a>1 LinkedHashMap 的结构定义</h2><p>LinkedHashMap 是基于 HashMap 的实现的, 所以整体的结构是类似的, 唯一不同的是: 链表和红黑树的节点多维持了一个前驱节点指针和后驱节点指针。<br>简单的理解就是 HashMap + 双向链表。 </p><p>大体的结构如下:<br><img src="https://pic.imgdb.cn/item/6564bc84c458853aef62c82f.png" alt="Alt &#39;LinkedHashMap 数据结构&#39;"></p><h3 id="1-1-数组的定义"><a href="#1-1-数组的定义" class="headerlink" title="1.1  数组的定义"></a>1.1  数组的定义</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>因为继承了 HashMap, 直接复用父级 HashMap 的 table 属性, 存储的数据类型依旧是 Node</p><h3 id="1-2-链表的定义"><a href="#1-2-链表的定义" class="headerlink" title="1.2 链表的定义"></a>1.2 链表的定义</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 继承 HashMap Node 节点的基础上, 追加了一个前驱指针和后驱指针</span>        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> before<span class="token punctuation">,</span> after<span class="token punctuation">;</span>        <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="1-3-红黑树的定义-和-HashMap-的红黑树定义一样"><a href="#1-3-红黑树的定义-和-HashMap-的红黑树定义一样" class="headerlink" title="1.3 红黑树的定义 (和 HashMap 的红黑树定义一样)"></a>1.3 红黑树的定义 (和 HashMap 的红黑树定义一样)</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 继承了 LinkedHashMap.Entry, Entry 继承了 HashMap.Node  所以 TreeNode 具有 链表的特点</span>    <span class="token comment">/**      * 红黑树的定义     * LinkedHashMap.Entry 继承了 HashMap.Node 节点, 所以 TreeNode 是 Node 的子类, 也具备链表的特点     */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">/**         * 红黑树的根节点         */</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> parent<span class="token punctuation">;</span>                <span class="token comment">/**         * 当前节点的左节点         */</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> left<span class="token punctuation">;</span>        <span class="token comment">/**         * 当前节点的右节点         */</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> right<span class="token punctuation">;</span>        <span class="token comment">/**         * 删除后需要解决连接的节点         */</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> prev<span class="token punctuation">;</span>          <span class="token comment">/**         * 是否为红色节点         */</span>        <span class="token keyword">boolean</span> red<span class="token punctuation">;</span>        <span class="token comment">// ... 后面 省略 红黑树的操作</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="2-LinkedHashMap-中的几个重要属性"><a href="#2-LinkedHashMap-中的几个重要属性" class="headerlink" title="2 LinkedHashMap 中的几个重要属性"></a>2 LinkedHashMap 中的几个重要属性</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> head<span class="token punctuation">;</span>    <span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> tail<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-1-head-和-tail"><a href="#2-1-head-和-tail" class="headerlink" title="2.1 head 和 tail"></a>2.1 head 和 tail</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> head<span class="token punctuation">;</span><span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> tail<span class="token punctuation">;</span></code></pre><p>双向链表的头指针和尾指针</p><h3 id="2-2-accessOrder"><a href="#2-2-accessOrder" class="headerlink" title="2.2 accessOrder"></a>2.2 accessOrder</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span></code></pre><p>是否按照访问顺序调整节点的顺序, 声明 LinkedHashMap 的时候可以指定, 默认为 false, 既 LinkedHashMap 中的节点按照存入的顺序排列, 而 true 则是按照访问的顺序排列。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 设置容量, 负载因子, 和 accessOrder 为 true</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 一开始的</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 输出结果  one  two  three</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 获取 key 为 one</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 输出结果  two  three  one</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 获取 key 为 two</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 输出结果 three one two </span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看出来将 accessOrder 设置为 true 的话, LinkedHashMap 会在按照插入顺序的基础上, 将每次访问的节点移动到最后面</p><h2 id="3-LinkedHashMap-的构造方法"><a href="#3-LinkedHashMap-的构造方法" class="headerlink" title="3 LinkedHashMap 的构造方法"></a>3 LinkedHashMap 的构造方法</h2><h3 id="3-1-无参的构造函数"><a href="#3-1-无参的构造函数" class="headerlink" title="3.1 无参的构造函数"></a>3.1 无参的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用父级 HashMap 的无参构造函数</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 默认设置为 false</span>    accessOrder <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-2-指定容量的构造函数"><a href="#3-2-指定容量的构造函数" class="headerlink" title="3.2 指定容量的构造函数"></a>3.2 指定容量的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用父级 HashMap 指定容量的构造函数</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    accessOrder <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-3-指定容量和负载因子的构造函数"><a href="#3-3-指定容量和负载因子的构造函数" class="headerlink" title="3.3 指定容量和负载因子的构造函数"></a>3.3 指定容量和负载因子的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用父级 HashMap 指定容量和负载因子的构造函数</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>    accessOrder <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-4-指定容量-负载因子和顺序访问的构造函数"><a href="#3-4-指定容量-负载因子和顺序访问的构造函数" class="headerlink" title="3.4 指定容量, 负载因子和顺序访问的构造函数"></a>3.4 指定容量, 负载因子和顺序访问的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用父级指定容量和负载因子的构造函数</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将访问顺序参数设置为用户指定的值</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>accessOrder <span class="token operator">=</span> accessOrder<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-5-给定一个-Map-的构造函数"><a href="#3-5-给定一个-Map-的构造函数" class="headerlink" title="3.5 给定一个 Map 的构造函数"></a>3.5 给定一个 Map 的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用父级无参的构造函数</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    accessOrder <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">putMapEntries</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> m<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 存储数据的 table 数组为空, 当初始化</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 计算容量</span>            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>s <span class="token operator">/</span> loadFactor<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0F</span><span class="token punctuation">;</span>            <span class="token comment">// 控制容量 不大于 最大值</span>            <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 计算出来的容量大于预设的容量, 重新计算新的容量, 并赋值给 threshold</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">></span> threshold<span class="token punctuation">)</span>                threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token comment">// 存入的 Collection 的容量大于 当前的阈值, 调用 进行扩容</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 依次遍历需要导入的 Map, </span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">:</span> m<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">K</span> key <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">V</span> value <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 调用到父级的 putVal 方法, 这个方法涉及到添加数据的部分, 下面添加数据的部分讲解</span>            <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> evict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="4-LinkedHashMap-的操作方法"><a href="#4-LinkedHashMap-的操作方法" class="headerlink" title="4 LinkedHashMap 的操作方法"></a>4 LinkedHashMap 的操作方法</h2><h3 id="4-1-添加数据"><a href="#4-1-添加数据" class="headerlink" title="4.1 添加数据"></a>4.1 添加数据</h3><p>LinkedHashMap 本身没有提供出更多的添加数据的方法, 全部的添加数据的方法都是继承至 HashMap, 同时重写了添加数据中 HashMap 会调用的钩子方法, 达到自己添加数据后调整链表的效果<br>这里以 put(key, value) 为例</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 在 LinkedHashMap 中没有这个方法， 这个方法是父类 HashMap 的, 只是为了方法讲解, 添加到这里</span>    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 同样是计算 key 的 hashCode, 然后调用 putVal</span>        <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 在 LinkedHashMap 中没有这个方法， 这个方法是父类 HashMap 的, 只是为了方法讲解, 添加到这里</span>    <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>              <span class="token comment">// 将数组的 i 位置设置为 Node 节点</span>            <span class="token comment">// 在 HashMap 中 newNode 返回的是 Node 类型的数据</span>            <span class="token comment">// 但是 LinkedHashMap 则是 LinkedHashMap.Entry, 所以 LinkedHashMap 重写了这个方法</span>            <span class="token comment">// 这里会调用到自身的 newHode 方法</span>            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 在当前的数据中找到 key 相同的数据</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token comment">// HashMap 中这个方法是空方法, 但是 LinkedHashMap 有需要移动修改节点的需求</span>                <span class="token comment">// 所以 LinkedHashMap 也是重写了这个方法    </span>                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>           <span class="token operator">++</span>modCount<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token comment">// 扩容的逻辑没有变动</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 插入节点后的行为调用, HashMap 空方法, LinkedHashMap 重写了</span>        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token comment">// LinkedHashMap 自身的创建节点方法</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 创建节点</span>        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将新创建的节点设置到链表的尾部</span>        <span class="token function">linkNodeLast</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// LinkedHashMap 自身的方法, 将入参的节点设置到链表的尾部</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkNodeLast</span><span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 保存当前的尾结点</span>        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> last <span class="token operator">=</span> tail<span class="token punctuation">;</span>        <span class="token comment">// 设置当前的尾结点为创建的节点</span>        tail <span class="token operator">=</span> p<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">// 旧的尾结点为空, 没有数据</span>            <span class="token comment">// 设置头节点为新创建的节点</span>            head <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 旧的尾结点不为空, 有数据    </span>            <span class="token comment">// 设置新节点的前置节点为上次的尾结点</span>            p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>            <span class="token comment">// 设置上次的尾结点的后置节点为新创建的节点</span>            last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 新增节点时, 存在 key 已经有数据的情况, 这时除了替换旧的 value 外, 如果 accessOrder (按照访问顺序排序) 设置为 true, 还需要把这个节点放到最后面, 保持新增的顺序</span>    <span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> last<span class="token punctuation">;</span>                <span class="token comment">// accessOrder 为 true, 同时尾节点不等于入参的节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>last <span class="token operator">=</span> tail<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// p = 访问的节点 e, b = 访问的节点e 的前置节点  a = 访问的节点 e 的后置节点</span>            <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>            <span class="token comment">// 设置 p 的后置节点为 null</span>            p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        <span class="token comment">// p 的前置节点为 null,</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token comment">// 设置头节点为 p 的后置节点</span>                head <span class="token operator">=</span> a<span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token comment">// p 的前置节点存在</span>                <span class="token comment">// 设置 p 的前置节点的后置节点为 p 的后置节点</span>                b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>            <span class="token comment">// p 的后置节点不为 null,    </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token comment">// 设置 p 的后置节点的前置节点为 p 节点的前置节点</span>                a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token comment">// p 的后置节点 a 为 null, 说明p 就是尾结点了</span>                <span class="token comment">// 设置链表的尾节点为 p 的前置节点</span>                last <span class="token operator">=</span> b<span class="token punctuation">;</span>            <span class="token comment">// 原本的尾节点为空    </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token comment">// 设置头节点为 p 节点 </span>                head <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 原本的为节点不为空</span>                <span class="token comment">// 设置 p 的前置节点为原本的尾节点</span>                p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>                <span class="token comment">// 设置原本的尾节点的后置节点为 p </span>                last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 设置尾节点为需要移动的节点</span>            tail <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token comment">// 修改次数 + 1</span>            <span class="token operator">++</span>modCount<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// LinkedHashMap 自身的方法, 在插入新节点后, 调用, 判断是否需要删除最旧的节点 (第一个节点)，在 LinkedHashMap 中默认为不会删除</span>    <span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> first<span class="token punctuation">;</span>        <span class="token comment">// evict 在 putVal 方法调用中都是为 true, 构造方法中调用到这里一般都是 false</span>        <span class="token comment">// LinkedHashMap 的 removeEldestEntry 方法 一直都是返回 false, 但是子类可以重写这个方法, 让其返回 true, 就能走到下面的删除头节点的方法</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>evict <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 获取头节点的 key</span>            <span class="token class-name">K</span> key <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">;</span>            <span class="token comment">// 删除节点, 这个涉及到删除数据, 后面删除数据的部分分析</span>            <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>其他几个添加数据的方法类型, 就不展开了</p><h3 id="4-2-获取数据"><a href="#4-2-获取数据" class="headerlink" title="4.2 获取数据"></a>4.2 获取数据</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>        <span class="token comment">// 调用 HashMap 的 getNode 方法获取节点数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 设置了按照访问顺序排序的属性, 将当前节点设置到链表的尾部</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder<span class="token punctuation">)</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="4-3-删除数据"><a href="#4-3-删除数据" class="headerlink" title="4.3 删除数据"></a>4.3 删除数据</h3><p>通添加数据一样, LinkedHashMap 没有提供新的删除数据的方法, 都是继承父级 HashMap 的, 同时重写几个钩子函数</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// HashMap 的 remove 方法</span>    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span>  <span class="token keyword">null</span> <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// HashMap 的 删除节点</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> matchValue<span class="token punctuation">,</span> <span class="token keyword">boolean</span> movable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> node <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span> <span class="token class-name">V</span> v<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                node <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                                <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            node <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                        p <span class="token operator">=</span> e<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>matchValue <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> value <span class="token operator">||</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeTreeNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> movable<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> p<span class="token punctuation">)</span>                    tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">else</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token operator">++</span>modCount<span class="token punctuation">;</span>                <span class="token operator">--</span>size<span class="token punctuation">;</span>                <span class="token comment">// 此处调用到 LinkedHashMap 自身的 afterNodeRemoval 方法</span>                <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> node<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 调整删除节点后的左右节点的指针指向</span>    <span class="token keyword">void</span> <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// p = 删除的节点  b = 删除节点的前置节点, a = 删除节点的后置节点</span>        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>        <span class="token comment">// 设置删除节点 p 的前置节点和后置节点为 null, 便于垃圾回收</span>        p<span class="token punctuation">.</span>before <span class="token operator">=</span> p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 如果 p 的前置节点为 null, p 为头节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">// 设置头节点为 p 的后置节点</span>            head <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// p 的前置节点为 null, p 不是头节点</span>            <span class="token comment">// 设置 p 的前置节点的后置节点为 p 的后置节点</span>            b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token comment">// p 的后置节点为 null, p 为尾节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">// 设置尾节点为 p 的前置节点</span>            tail <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// p 的后置节点为 null, p 不是尾节点</span>            <span class="token comment">// 设置 p 的后置节点的前置节点为 p 的前置节点</span>            a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="4-4-修改数据"><a href="#4-4-修改数据" class="headerlink" title="4.4 修改数据"></a>4.4 修改数据</h3><p>LinkedHashMap 本身没提供修改数据的方法, 依旧是继承父级的</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token comment">// 调用到 LinkedHashMap 自身的 afterNodeAccess 方法, 尝试将这个节点设置到尾部</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="5-LinkedHashMap-的补充"><a href="#5-LinkedHashMap-的补充" class="headerlink" title="5 LinkedHashMap 的补充"></a>5 LinkedHashMap 的补充</h2><blockquote><ol><li>LinkedHashMap 继承于 HashMap, 所以具备了 HashMap 的所有特性, 同样的也就是一个线程不安全的集合类了,</li><li>LinkedHashMap 支持 fail-fast机制</li><li>LinkedHashMap 的序列化也是自定义的</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java HashSet</title>
      <link href="/article/2021/2891369044/"/>
      <url>/article/2021/2891369044/</url>
      
        <content type="html"><![CDATA[<p>HashSet 是一个基于 HashMap 实现的无序列表。<br>它不保证数据存储的顺序, 但是可以保证存储的数据是唯一不重复的, 同时支持存储 null。</p><p>如果再了解 HashMap 后, HashSet 是几个 Collection 实现中最容易理解的集合, 因为 HashSet 的所有操作都是借助于 HashMap 实现的。</p><p>HashSet 内部声明了一个 HashMap, 然后将数据存储在 HashMap 的 key 中, 所有的 value 直接设置为同一个 Object 对象, 借助 HashMap key 的唯一性间接的实现了 HashSet 的唯一性。</p><h2 id="1-HashSet-中的几个重要属性"><a href="#1-HashSet-中的几个重要属性" class="headerlink" title="1 HashSet 中的几个重要属性"></a>1 HashSet 中的几个重要属性</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 一个静态, 不可变的 Object 变量</span>    <span class="token comment">// 静态保证了唯一性, 整个应用就一个, 可以节省空间</span>    <span class="token comment">// 不可变, 进一步保正这个对象不会被任何线程修改</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token constant">PRESENT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// HashSet 中存储数据的地方</span>    <span class="token comment">// 就是借助 HashMap 存储的, 存入 HashSet 的数据, 统一放到这个 HashMap 的 key 中, 这个 key 对应的 value 则统一为上面定义的静态 Object</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> map<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="2-HashSet-的构造方法"><a href="#2-HashSet-的构造方法" class="headerlink" title="2 HashSet 的构造方法"></a>2 HashSet 的构造方法</h2><h3 id="2-1-无参的构造函数"><a href="#2-1-无参的构造函数" class="headerlink" title="2.1 无参的构造函数"></a>2.1 无参的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 为属性 map 赋值, 声明为 HashMap</span>    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>很简单, 创建一个 HashMap, 并赋值给自己存储数据的属性 <strong>HashMap&lt;E,Object&gt; map</strong></p><h3 id="2-2-指定容量的构造函数"><a href="#2-2-指定容量的构造函数" class="headerlink" title="2.2 指定容量的构造函数"></a>2.2 指定容量的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 指定容量 </span>    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>同样, 直接创建一个指定容量的 HashMap, 然后赋值给自己存储数据的属性 <strong>HashMap&lt;E,Object&gt; map</strong></p><h3 id="2-3-指定容量和负载因子的构造函数"><a href="#2-3-指定容量和负载因子的构造函数" class="headerlink" title="2.3 指定容量和负载因子的构造函数"></a>2.3 指定容量和负载因子的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 指定容量, 负载因子</span>    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>依旧是直接调用对应 HashMap 的方法, 创建出需要的 HashMap, 再赋值给自己的 <strong>HashMap&lt;E,Object&gt; map</strong> 属性</p><h3 id="2-4-给定一个-Collection-的构造函数"><a href="#2-4-给定一个-Collection-的构造函数" class="headerlink" title="2.4 给定一个 Collection 的构造函数"></a>2.4 给定一个 Collection 的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 创建一个 HashMap 赋值到自己的属性</span>    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">.75f</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 添加全部</span>    <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 将一个集合中的数据遍历添加到自己的 HashMap 中</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">boolean</span> modified <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">// 依次遍历每一个元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> c<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>            modified <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> modified<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 向自己的 HashMap 添加数据</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 很简单的调用 HashMap 的 put 方法, key 值为需要存入的数据, value 为 声明好的静态变量 PRESENT</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token constant">PRESENT</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-5-一个比较特殊的构造函数-没有提供出去的构造函数"><a href="#2-5-一个比较特殊的构造函数-没有提供出去的构造函数" class="headerlink" title="2.5 一个比较特殊的构造函数: 没有提供出去的构造函数"></a>2.5 一个比较特殊的构造函数: 没有提供出去的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">boolean</span> dummy<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// dump 参数没有作用, 只是为了重载</span>    <span class="token comment">// 通过这个构造函数, 可以将 HashSet 默认的 map 实现变为 LinkedHashMap, 主要是给子类 LinkedHashSet 起使用, 达到有序的效果</span>    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="3-HashSet-的操作方法"><a href="#3-HashSet-的操作方法" class="headerlink" title="3 HashSet 的操作方法"></a>3 HashSet 的操作方法</h2><h3 id="3-1-添加数据"><a href="#3-1-添加数据" class="headerlink" title="3.1 添加数据"></a>3.1 添加数据</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 单个添加元素</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 直接调用 map 的 put 方法</span>        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token constant">PRESENT</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-2-其他的添加方法"><a href="#3-2-其他的添加方法" class="headerlink" title="3.2 其他的添加方法"></a>3.2 其他的添加方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 直接添加一个集合</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">boolean</span> modified <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> c<span class="token punctuation">)</span>            <span class="token comment">// 遍历所有的元素, 调用自身的 add 方法</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>                modified <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> modified<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-3-删除数据"><a href="#3-3-删除数据" class="headerlink" title="3.3 删除数据"></a>3.3 删除数据</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 同样是调用 map 的 remove 方法</span>        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token operator">==</span><span class="token constant">PRESENT</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>同样的可以通过 removeAll 直接清空 HashSet 的数据</p><h3 id="3-4-查询数据"><a href="#3-4-查询数据" class="headerlink" title="3.4 查询数据"></a>3.4 查询数据</h3><p>Set 比较特殊, 没有提供直接获取值的方法 <code>get</code> 方法。<br>因为没必要, 如果你现在已经有一个数据 a, Set.get(a), 返回结果想要什么?<br>如果只是单纯的是想判断对象是否存在，可以通过 contain 方法进行判断。</p><h2 id="4-HashSet-的补充"><a href="#4-HashSet-的补充" class="headerlink" title="4 HashSet 的补充"></a>4 HashSet 的补充</h2><blockquote><ol><li>因为 HashSet 是通过 HashMap 实现的, HashMap 的 key 可以存 null, 但是只能存一个, 所以 HashSet 支持存 null, 同时只能存一个</li><li>因为 HashMap 是非线程安全的，所以 HashSet 也是线程非安全的。</li><li>HashSet 也是自定义了序列化方法</li><li>HashSet 内部没有提供自己的迭代器, 他内部是通过 HashMap 的 key 迭代器实现的</li><li>HashMap 支持 fail-fast 机制, 理所当然的 HashSet 也是。</li><li>HashSet 的数据是无序的, 如果需要使用有序的 Set, 可以使用 LinkedHashSet, 内部是借助 LinkedHashMap 实现</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Exchanger</title>
      <link href="/article/2021/2782634738/"/>
      <url>/article/2021/2782634738/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>Exchanger 是一个用于线程间协作的工具类, 用于两个线程间能够交换。它提供了一个交换的同步点, 在这个同步点两个线程能够交换数据。<br>具体交换数据是通过 exchange 方法来实现的, 如果一个线程先执行 exchange 方法, 那么它会阻塞等待另一个线程也执行 exchange 方法, 这个时候两个线程就都达到了同步点, 两个线程就可以交换数据。</p><h2 id="2-Exchanger-的方法"><a href="#2-Exchanger-的方法" class="headerlink" title="2 Exchanger 的方法"></a>2 Exchanger 的方法</h2><p>Exchanger 除了一个无参的构造方法外, 主要方法也很简单  </p><blockquote><ol><li>V exchange(V x) throws InterruptedException: 当一个线程执行该方法的时候, 会等待另一个线程也执行该方法, 因此两个线程就都达到了同步点,  将数据交换给另一个线程, 同时返回获取的数据</li><li>V exchange(V x,  long timeout,  TimeUnit unit) throws InterruptedException,  TimeoutException: 同上一个方法功能基本一样, 只不过这个方法同步等待的时候, 增加了超时时间。</li></ol></blockquote><p>Exchanger 理解起来很容易, 这里用一个简单的例子来看下它的具体使用。<br>我们来模拟这样一个情景, 在青春洋溢的中学时代, 下课期间, 男生经常会给走廊里为自己喜欢的女孩子送情书, 相信大家都做过这样的事情吧。<br>男孩会先到女孩教室门口, 然后等女孩出来, 教室那里就是一个同步点, 然后彼此交换信物, 也就是彼此交换了数据。现在, 就来模拟这个情景。 </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExchangerDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Exchanger</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> exchanger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Exchanger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//代表男生和女生</span>    <span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//男生对女生说的话</span>                <span class="token comment">// 这时候线程会被阻塞, 直到得到返回结果</span>            <span class="token class-name">String</span> girl <span class="token operator">=</span> exchanger<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token string">"我其实暗恋你很久了......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"女孩儿说："</span> <span class="token operator">+</span> girl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"女生慢慢的从教室里走出来......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//男生对女生说的话</span>            <span class="token class-name">String</span> boy <span class="token operator">=</span> exchanger<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token string">"我也很喜欢你......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"男孩儿说："</span> <span class="token operator">+</span> boy<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>输出结果：</p><pre class="language-log" data-language="log"><code class="language-log">女生慢慢的从教室里走出来<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>男孩儿说：我其实暗恋你很久了<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>女孩儿说：我也很喜欢你<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><h2 id="3-Exchanger-的源码实现"><a href="#3-Exchanger-的源码实现" class="headerlink" title="3 Exchanger 的源码实现"></a>3 Exchanger 的源码实现</h2><p>在 Exchanger 的源码实现中的实现, 会根据当前的并发情况, 分成 2 种实现<strong>单槽位</strong>和<strong>多槽位</strong>。</p><blockquote><ol><li>单槽位主要用于同一个时刻只有两个线程交换数据, 这样在竞争比较激烈的时候, 会影响到性能</li><li>多槽位主要用于同一个时刻有多个线程同时进行两个一组的数据交换, 彼此之间不受影响, 这样可以提高吞吐量</li></ol></blockquote><p>在 Exchanger 的源码中有 2 个属性</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arena<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> slot<span class="token punctuation">;</span></code></pre><p>这 2 个属性和单槽和多槽实现相关的属性</p><blockquote><ol><li>单槽的时候, 线程 A 打算交换内容, 会先通过 slot 判断是否已经有其他的线程在等待了, 有和这个 slot 的节点交换数据, 没有就把自己放到这个 slot 节点</li><li>如果在上面的第 1 步的单槽位操作中失败了, 就会进入到多槽操作, 从 arena 寻找可以交互的节点, 找不到就将自己存入到这个节点数组。</li></ol></blockquote><p>概况起来的话, 就如上面的情况, 具体的场景分析, 看后面的源码。</p><h3 id="3-1-Exchanger-的内部类"><a href="#3-1-Exchanger-的内部类" class="headerlink" title="3.1 Exchanger 的内部类"></a>3.1 Exchanger 的内部类</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Exchanger</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@sun.misc.Contended</span>     <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 多槽操作用到, 当前节点在 Exchanger 的多槽节点数组 Node[] arena 的数组位置, 默认为 0</span>        <span class="token keyword">int</span> index<span class="token punctuation">;</span>        <span class="token comment">// 多槽操作用到, 记录 上一次 Exchanger.bound 的值</span>        <span class="token keyword">int</span> bound<span class="token punctuation">;</span>        <span class="token comment">// 在同一个 bound 下 cas 失败的次数</span>        <span class="token keyword">int</span> collides<span class="token punctuation">;</span>        <span class="token comment">// 在当前线程等待另一个线程进行内容交换的过程中, 会通过 Exchanger 的一个常量值 SPINS 和当前线程的线程 id 等经过几次位运算得到一个 hash 值</span>        <span class="token comment">// 在线程交换内容后, 会将计算后的 hash 值存到这里</span>        <span class="token keyword">int</span> hash<span class="token punctuation">;</span>        <span class="token comment">// 当前线程调用 exchagne 方法打算传递给其他线程的内容</span>        <span class="token class-name">Object</span> item<span class="token punctuation">;</span>        <span class="token comment">// 从其他线程获取到的传递内容</span>        <span class="token keyword">volatile</span> <span class="token class-name">Object</span> match<span class="token punctuation">;</span>        <span class="token comment">// 当前节点中挂起的线程</span>        <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> parked<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Participant</span> <span class="token keyword">extends</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 每个线程 ThreadLocalMap 中存储的内容</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-3-Exchagner-的属性"><a href="#3-3-Exchagner-的属性" class="headerlink" title="3.3 Exchagner 的属性"></a>3.3 Exchagner 的属性</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Exchanger</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 槽位数组中任意两个使用槽之间的索引距离, 将它们隔开以避免伪共享</span>    <span class="token comment">// 将设某个节点的在数组的 index 号位, 那么和他进行内容交换的节点不是直接选择了 index + 1, 需要隔一段距离, 这样可以避免伪共享的影响</span>    <span class="token comment">// 那么隔的这段距离应该多大, 就是通过节点的 index 位置 + 这个属性搭配一起计算的, 计算方式在多槽操作中</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">ASHIFT</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment">// 等于 255, 二进制表示就是 00000000 00000000 00000000 11111111</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MMASK</span> <span class="token operator">=</span> <span class="token number">0xff</span><span class="token punctuation">;</span>    <span class="token comment">// 等于 256, 二进制表示就是 00000000 00000000 00000001 00000000</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SEQ</span> <span class="token operator">=</span> <span class="token constant">MMASK</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 当前机器中, Java 虚拟机的可用的处理器数量, 简单理解为可用核心数, 我的机器的值为 16 </span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">NCPU</span> <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// NCPU >=  510 (MMASK &lt;&lt; 1, 也就是乘以 2, 值为 510) ? 255 : NCPU/2;</span>    <span class="token comment">// FULL 的最大值是 255</span>    <span class="token comment">// 决定了 arean 的容量, arena 为一个 容量为 (Full + 2) * 32  的 Node 数组</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">FULL</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">NCPU</span> <span class="token operator">>=</span> <span class="token punctuation">(</span><span class="token constant">MMASK</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">MMASK</span> <span class="token operator">:</span> <span class="token constant">NCPU</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 等于 1024, 默认自旋的最大次数</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SPINS</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment">// 线程 A 调用 exchange 方法, 传递给其他线程的内容为 null 时, 会修改为一个默认值 NULL_ITEM</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token constant">NULL_ITEM</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 线程 A 调用带超时时间的 exchange 方法, 超时了还是没有得到其他线程给的值, 这时候默认会返回一个默认值 TIMED_OUT</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token constant">TIMED_OUT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 就是自定义的 ThreadLocal, 在构造方法中声明</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Participant</span> participant<span class="token punctuation">;</span>    <span class="token comment">// 存储多槽节点的数组</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arena<span class="token punctuation">;</span>    <span class="token comment">// 单槽操作的节点</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> slot<span class="token punctuation">;</span>    <span class="token comment">// 最大有效的竞技场位置的索引</span>    <span class="token comment">// 还有一个作用: 初始值为 0, 在单槽操作变为多槽操作中, 通过判断是否为 0, 来决定是否初始 arena 数组, 从而确保 arena 数组只会别初始一次</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> bound<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>引用 <a href="https://www.iteye.com/blog/brokendreams-2253956">大飞</a> 中对伪共享讲解:<br>假设一个类的两个相互独立的属性 a 和 b 在内存地址上是连续的  (比如 FIFO 队列的头尾指针), 那么它们通常会被加载到相同的 cpu cache line 里面。<br>并发情况下，如果一个线程修改了 a, 会导致整个 cache line 失效(包括 b ), 这时另一个线程来读 b, 就需要从内存里再次加载了。<br>这种多线程频繁修改 ab 的情况下, 虽然 a 和 b 看似独立, 但它们会互相干扰，非常影响性能。  </p><p>而数组的声明中, 是需要一段连续的内存的, 所以对 index 位置和 index + 1 的位置的节点频繁的操作, 会影响性能, 那么进行一段距离的隔离操作就行了。</p><h3 id="3-2-Exchanger-的单位槽的-exchange-方法"><a href="#3-2-Exchanger-的单位槽的-exchange-方法" class="headerlink" title="3.2 Exchanger 的单位槽的 exchange 方法"></a>3.2 Exchanger 的单位槽的 exchange 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Exchanger</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">exchange</span><span class="token punctuation">(</span><span class="token class-name">V</span> x<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> v<span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span>        <span class="token comment">// 需要交给另一个线程的信息为 null 的话，使用内部的一个 Object 作为替代</span>        <span class="token class-name">Object</span> item <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">NULL_ITEM</span> <span class="token operator">:</span> x<span class="token punctuation">;</span>        <span class="token comment">// 1. 多槽节点数组为 null, 单槽交换的返回值为 null, 线程中断标识为 true,</span>        <span class="token comment">// 2. 多槽节点数组为 null, 单槽交换的返回值为 null, 线程中断标识为 false, 多槽交换的返回值为 null</span>        <span class="token comment">// 3. 多槽节点数组不为 null, 线程中断标识为 true</span>        <span class="token comment">// 4. 多槽节点数组不为 null, 线程中断标识为 false, 多槽交换的返回值为 null</span>        <span class="token comment">// 上面 4 种情况, 都会抛出异常</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> arena<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> <span class="token function">slotExchange</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> <span class="token function">arenaExchange</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> <span class="token constant">NULL_ITEM</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token class-name">V</span><span class="token punctuation">)</span>v<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-3-Exchanger-的-slotExchange-方法"><a href="#3-3-Exchanger-的-slotExchange-方法" class="headerlink" title="3.3 Exchanger 的 slotExchange 方法"></a>3.3 Exchanger 的 slotExchange 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Exchanger</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token function">slotExchange</span><span class="token punctuation">(</span><span class="token class-name">Object</span> item<span class="token punctuation">,</span> <span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> ns<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取当前线程身上的 Node 节点</span>        <span class="token class-name">Node</span> p <span class="token operator">=</span> participant<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 线程的中断标识为 true, 返回 null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> q<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 槽位节点 solt 不为 null, 则说明已经有线程在这里等待交换数据了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>q <span class="token operator">=</span> slot<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token comment">// 通过 cas 将当前对象的 slot 的值从 q 更新为 null</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">SLOT</span><span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> q<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 更新成功</span>                    <span class="token comment">// 获取槽位节点的传递内容</span>                    <span class="token class-name">Object</span> v <span class="token operator">=</span> q<span class="token punctuation">.</span>item<span class="token punctuation">;</span>                    <span class="token comment">// 当前线程传递给其他线程的内容</span>                    q<span class="token punctuation">.</span>match <span class="token operator">=</span> item<span class="token punctuation">;</span>                    <span class="token comment">// 当前节点中挂起的线程</span>                    <span class="token class-name">Thread</span> w <span class="token operator">=</span> q<span class="token punctuation">.</span>parked<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                        <span class="token comment">// 唤醒挂起的线程</span>                        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 返回槽位节点的传递值    </span>                    <span class="token keyword">return</span> v<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// 这里就是从单槽操作切换到多槽操作的一个重点</span>                <span class="token comment">// 1. slot 不为 null, 当前线程尝试通过 cas 设置为 null, 失败了</span>                <span class="token comment">// 2. 同时当前应用可以的核心数 > 1 (有并发的可能性)</span>                <span class="token comment">// 3. 通过 cas 将当前 Exchanger 的 bound 属性从 0 设置为 255 成功</span>                <span class="token comment">// 三个条件公共导致当前  Exchanger 的 arena 数组声明</span>                <span class="token comment">// 这就满足了从单槽操作切换到多槽操作的一个重点: arena 数组不为空</span>                                <span class="token comment">// 声明完 arena 后, 会重新回到上面的循环, </span>                <span class="token comment">// slot 一旦为空了, 就直接返回 null, 进入到多槽操作</span>                <span class="token comment">// slot 不为空的话, 还是会继续通过 cas 尝试进行交换操作</span>                <span class="token comment">// 当前的核心数 > 1 并且  同时通过 cas 将 bound 从 0 设置为 256 </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NCPU</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> bound <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token constant">BOUND</span><span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">SEQ</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// 声明 arena 为一个 容量为 (Full + 2) * 32  的 Node 数组</span>                    <span class="token comment">// FULL 最大值为 255, 那么可以得出最终 arena 的容量在 8224 在</span>                    arena <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">FULL</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">ASHIFT</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arena <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token comment">// 多槽位不为空，需要执行多槽位交换, 直接返回 null</span>                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 多槽位为空, 同时槽位节点也为空</span>                <span class="token comment">// 从线程自身获取到的节点 p 的 item (当前线程打算传递给其他线程的内容) 为当前的 item 值</span>                p<span class="token punctuation">.</span>item <span class="token operator">=</span> item<span class="token punctuation">;</span>                <span class="token comment">// 通过 cas 将当前的槽位节点从 null 设置为当前线程身上的节点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">SLOT</span><span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// 设置成功了, 结束死循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment">// 设置失败, 先将线程自身获取到的节点 p 的 item 设置为 null, 重新跑一次循环    </span>                p<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 获取当前 p 节点身上的 hash 值, 默认值为 0</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>        <span class="token comment">// 是否设置了超时时候, 是的话, 过期时间 = 当前的纳秒 + 设置的超时时间的纳秒值, 否则超时时间为 0 </span>        <span class="token keyword">long</span> end <span class="token operator">=</span> timed <span class="token operator">?</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> ns <span class="token operator">:</span> <span class="token number">0L</span><span class="token punctuation">;</span>        <span class="token comment">// 计算最大的自旋次数 = 核心数 > 1 吗, 是的话, 最大自旋次数为 1024, 否则为 1 次</span>        <span class="token keyword">int</span> spins <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">NCPU</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">SPINS</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> v<span class="token punctuation">;</span>        <span class="token comment">// 只有从线程自身获取到的节点 p 里面的 从其他线程获取到的传递内容 为空, 就一直循环</span>        <span class="token comment">// 当前线程是 slot 了, 等待另一个线程和自身进行交换内容, 当当前的节点获取到另一个线程交换的内容就可以停止循环了, 即 p.match != null</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v <span class="token operator">=</span> p<span class="token punctuation">.</span>match<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 自旋次数大于 0</span>            <span class="token comment">// 当前线程为 slot 了, 但是还没有其他的线程和自身交换内容</span>            <span class="token comment">// 这是不会立即挂起当前线程, 而是通过自旋 spins 次, 这期间不到判断当前是否获取到了其他线程交换的内容</span>            <span class="token comment">// 自旋次数为 0 后, 还是没有获取到, 那么才尝试挂起当前的线程</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>spins <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 计算默认值, 第一次线程自身的 Node 节点的 h 为 0, 经过下面 3 步后还是为 0 </span>                h <span class="token operator">^=</span> h <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>                 h <span class="token operator">^=</span> h <span class="token operator">>>></span> <span class="token number">3</span><span class="token punctuation">;</span>                 h <span class="token operator">^=</span> h <span class="token operator">&lt;&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span>                <span class="token comment">// 计算后的 h 还是为 0</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token comment">// h = 1024 | 当前线程的 id</span>                    h <span class="token operator">=</span> <span class="token constant">SPINS</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>t<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">--</span>spins <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token constant">SPINS</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token comment">// (SPINS >>> 1) - 1 = (1024 / 2) - 1 = 511, 二进制 00000000 00000000 00000001 11111111</span>                    <span class="token comment">// 计算后的 h &lt; 0  并且 spins - 1 后 &amp; 511 等于 0,  </span>                    <span class="token comment">// 既每自旋 512 次, 同时 h &lt; 0, 线程执行让步, 那么多次的自旋还没有获取到交换内容, 先让出 cpu</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 槽位节点不等于线程自身的节点</span>            <span class="token comment">// 一开始 slot == p, 现在 slot != p</span>            <span class="token comment">// 可能的就是已经有另一个线程通过 cas 将 slot 置为 null, 后面会和当前节点的进行交换内容</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>slot <span class="token operator">!=</span> p<span class="token punctuation">)</span>                <span class="token comment">// 自旋次数重置为 1024</span>                spins <span class="token operator">=</span> <span class="token constant">SPINS</span><span class="token punctuation">;</span>                        <span class="token comment">// 1. 线程中断标识位 false</span>            <span class="token comment">// 2. 节点数组为 null</span>            <span class="token comment">// 3. 没有设置超时时间 或者 距离超时时间还 > 0   </span>            <span class="token comment">// 三个条件都满足  </span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> arena <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>timed <span class="token operator">||</span> <span class="token punctuation">(</span>ns <span class="token operator">=</span> end <span class="token operator">-</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 线程自身的节点的挂起线程等于当前线程</span>                p<span class="token punctuation">.</span>parked <span class="token operator">=</span> t<span class="token punctuation">;</span>                <span class="token comment">// 如果槽位节点 等于当前的线程节点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>slot <span class="token operator">==</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 超时时间 = 0</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>ns <span class="token operator">==</span> <span class="token number">0L</span><span class="token punctuation">)</span>                        <span class="token comment">// 挂起当前线程</span>                        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span>                        <span class="token comment">// 带超时时间的挂起线程</span>                        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> ns<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                p<span class="token punctuation">.</span>parked <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">SLOT</span><span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 能进入到这个的条件需要满足</span>                <span class="token comment">// 1. 自旋后, 还是没能获取到需要的交换的内容</span>                <span class="token comment">// 2. 当前 Exchanger 的 slot 还是等于当前线程的节点 p</span>                <span class="token comment">// 3. 当前 Exchagner 的 arena 不为 null</span>                <span class="token comment">// 4. 线程中断标识位 true</span>                <span class="token comment">// 5. 设置了超时时间, 同时已经超时了</span>                <span class="token comment">// 6. 当前的 Exchanger 的 slot 通过 cas 从 p 设置为 null 了</span>                <span class="token comment">// 然后根据当前是否超时了或者线程中断了, 判断是否要进入多槽操作</span>                                <span class="token comment">// v = 设置了超时时间 + 距离超时时间 &lt;= 0 + 线程中断标识为 false, </span>                <span class="token comment">// 都为是 返回默认值 TIMED_OUT, 结束流程了,  否则返回 null, 尝试到多槽操作</span>                v <span class="token operator">=</span> timed <span class="token operator">&amp;&amp;</span> ns <span class="token operator">&lt;=</span> <span class="token number">0L</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">TIMED_OUT</span> <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token comment">// 跳出循环</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 设置 p 节点的 match 属性为 null</span>        <span class="token constant">MATCH</span><span class="token punctuation">.</span><span class="token function">setRelease</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置 p 节点的 item 属性为 null</span>        p<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 设置 p 节点的 hash 值 = 最新的 hash</span>        p<span class="token punctuation">.</span>hash <span class="token operator">=</span> h<span class="token punctuation">;</span>        <span class="token comment">// 返回从其他线程获取到的传递内容</span>        <span class="token keyword">return</span> v<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-4-Exchanger-的-arenaExchange-方法"><a href="#3-4-Exchanger-的-arenaExchange-方法" class="headerlink" title="3.4 Exchanger 的 arenaExchange 方法"></a>3.4 Exchanger 的 arenaExchange 方法</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Exchanger</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token function">arenaExchange</span><span class="token punctuation">(</span><span class="token class-name">Object</span> item<span class="token punctuation">,</span> <span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> ns<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 槽位节点数组</span>        <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> arena<span class="token punctuation">;</span>        <span class="token comment">// 槽位数组的长度</span>        <span class="token keyword">int</span> alen <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// 获取当前线程身上维护的节点</span>        <span class="token class-name">Node</span> p <span class="token operator">=</span> participant<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 一个死循环, 下面的逻辑全部都在这个循环中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> p<span class="token punctuation">.</span>index<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                         <span class="token comment">// i 等于当前线程身上维护的节点的数组位置, 默认为 0</span>            <span class="token comment">// 这个 i 很重要, 后面会不断的修改 i 的值, 不断重试获取有值的位置</span>            <span class="token keyword">int</span> b<span class="token punctuation">,</span> m<span class="token punctuation">,</span> c<span class="token punctuation">;</span>            <span class="token comment">// 计算当前 index 对应的交换节点在槽位数组的位置</span>            <span class="token comment">// ASHIFT = 5, (1 &lt;&lt; ASHIFT) - 1 = 30</span>            <span class="token comment">// i &lt;&lt; ASHIFT = i &lt;&lt; 5 = i * 2^5 = i * 32</span>            <span class="token comment">// j = i * 32 + 30 , i 的取值在 [0, 255] 之间 (为什么, 后面源码中有)</span>            <span class="token comment">// arean 最大长度为 8224, j 计算出来后的结果最大为 8191</span>            <span class="token comment">// 这条计算方式几乎能把 255 内的数都能映射到对应的数组上</span>            <span class="token comment">// 每个节点之间相隔 62 个位置</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;&lt;</span> <span class="token constant">ASHIFT</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">ASHIFT</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 容错, 计算出来的结果 &lt; 0 或者 >= 数组的长度, 取数组的最后一个</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">>=</span> alen<span class="token punctuation">)</span>                j <span class="token operator">=</span> alen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">// 获取 arena 数组 j 位的节点信息    </span>            <span class="token class-name">Node</span> q <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">)</span><span class="token constant">AA</span><span class="token punctuation">.</span><span class="token function">getAcquire</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 下面的逻辑分为了 3 大块</span>            <span class="token comment">// 1. 当前节点应该在的位置在当前数组有效范围内, 同时对应的位置已经有节点了</span>            <span class="token comment">// 2. 当前节点应该在的位置在当前数组有效范围内, 但是对应的位置没有节点</span>            <span class="token comment">// 3. 当前节点应该在的位置不在当前数组有效范围内, 或者第一块的 cas 替换失败</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token constant">AA</span><span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">,</span> q<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 第一部分: 当前节点的应该在的位置在当前数组有效范围内, 同时对应的位置已经有节点了</span>                <span class="token comment">// 先通过 cas 将 arena 数组的 j 位置从 q 设置为 null </span>                <span class="token comment">// 2 个节点交换数据</span>                <span class="token class-name">Object</span> v <span class="token operator">=</span> q<span class="token punctuation">.</span>item<span class="token punctuation">;</span>                                     q<span class="token punctuation">.</span>match <span class="token operator">=</span> item<span class="token punctuation">;</span>                <span class="token class-name">Thread</span> w <span class="token operator">=</span> q<span class="token punctuation">.</span>parked<span class="token punctuation">;</span>                <span class="token comment">// 唤醒交换的节点里面的线程</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 返回获取的交换值    </span>                <span class="token keyword">return</span> v<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>m <span class="token operator">=</span> <span class="token punctuation">(</span>b <span class="token operator">=</span> bound<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token constant">MMASK</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> q <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 第二部分: 当前节点应该在的位置在当前数组有效范围内, 但是对应的位置没有节点</span>                <span class="token comment">// MMASK 等于 255, 二进制表示就是 00000000 00000000 00000000 11111111</span>                <span class="token comment">// 任何数 &amp; 上 MMASK, 最大值也只会是 255, 也就是 m 的取值范围为 [0, 255]</span>                <span class="token comment">// 线程上的节点的 index 不在 0 到 255 之间会被修正</span>                <span class="token comment">// bound 是数组最大的有效的位置，和 MMASK 相与，可以得到数组真正最大有效位的位置</span>                <span class="token comment">// Exchanger 的 bound 默认为 0</span>                <span class="token comment">// 线程的 Node 节点初始的 index 的默认值也为 0</span>                <span class="token comment">// 更新当前节点交换的内容为最新的 item, 可以去除 p.item == null 的情况</span>                p<span class="token punctuation">.</span>item <span class="token operator">=</span> item<span class="token punctuation">;</span>                                             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">AA</span><span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 将当前的节点设置到当前数组的 j 的位置 (即本身打算交换的位置)</span>                    <span class="token comment">// 计算超时时间, 设置了超时同时当前的 同时 数组真正最大有效位的位置 为 0, 计算超时的时间, 否则超时时间就是 0,不超时</span>                    <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> ns <span class="token operator">:</span> <span class="token number">0L</span><span class="token punctuation">;</span>                    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                        <span class="token comment">// 自旋操作</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> h <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> spins <span class="token operator">=</span> <span class="token constant">SPINS</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 先通过自旋, 获取当前节点中其他线程交换的数据, 不为空, 即交换成功, 做一下处理后, 就能返回</span>                        <span class="token class-name">Object</span> v <span class="token operator">=</span> p<span class="token punctuation">.</span>match<span class="token punctuation">;</span>                        <span class="token comment">// 当前节点中有其他线程交换的数据了</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token comment">// 将当前节点的 match 属性设置为 null</span>                            <span class="token constant">MATCH</span><span class="token punctuation">.</span><span class="token function">setRelease</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// item 属性设置为 null</span>                            p<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                                     <span class="token comment">// 更新 hash 为最新的 hash    </span>                            p<span class="token punctuation">.</span>hash <span class="token operator">=</span> h<span class="token punctuation">;</span>                            <span class="token comment">// 返回获取到的数据</span>                            <span class="token keyword">return</span> v<span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>spins <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token comment">// 进到这里, 自旋次数还是大于 0, 同时当前节点中还没有其他线程的交换的内容</span>                            <span class="token comment">// 这里和 slotExchanger 一样的</span>                            <span class="token comment">// 计算一个新的 hash 值</span>                            h <span class="token operator">^=</span> h <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>                             h <span class="token operator">^=</span> h <span class="token operator">>>></span> <span class="token number">3</span><span class="token punctuation">;</span>                             h <span class="token operator">^=</span> h <span class="token operator">&lt;&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span>                                                         <span class="token comment">// 计算出来的 hash 值为 0, 修改为 1024 | 当前的线程 Id</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                                                h <span class="token operator">=</span> <span class="token constant">SPINS</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>t<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">--</span>spins <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token constant">SPINS</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                                <span class="token comment">// 计算出来的 hash 值小于 0, spins 先自减 1, 然后 &amp; 上 511 == 0</span>                                <span class="token comment">// 尝试让出线程执行权, 等待下次 cpu 重新调度</span>                                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token punctuation">&#125;</span>                        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">AA</span><span class="token punctuation">.</span><span class="token function">getAcquire</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">!=</span> p<span class="token punctuation">)</span>                            <span class="token comment">// arena 数组 j 位置不等于 p</span>                            <span class="token comment">// 可能的就是已经有另一个线程通过 cas 将 j 位置设为 null, 后面会和当前节点的进行交换内容</span>                            spins <span class="token operator">=</span> <span class="token constant">SPINS</span><span class="token punctuation">;</span>                          <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> m <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>timed <span class="token operator">||</span> <span class="token punctuation">(</span>ns <span class="token operator">=</span> end <span class="token operator">-</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token comment">// 1. 线程中断标识位 false</span>                            <span class="token comment">// 2. 计算出来的数组最大有效位的位置 = 0, 已经达到当前数组的最小有效位了, 没法再减了, 进行阻塞</span>                            <span class="token comment">// 3. 没有设置超时时间 或者 距离超时时间还大于 0   </span>                            <span class="token comment">// 三个条件都满足  </span>                            <span class="token comment">// 尝试挂起当前的线程</span>                            p<span class="token punctuation">.</span>parked <span class="token operator">=</span> t<span class="token punctuation">;</span>                            <span class="token comment">// arena 数组 j 位置的节点仍然是当前线程的节点</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">AA</span><span class="token punctuation">.</span><span class="token function">getAcquire</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">==</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token comment">// 挂起当前的线程</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>ns <span class="token operator">==</span> <span class="token number">0L</span><span class="token punctuation">)</span>                                    <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> ns<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                            p<span class="token punctuation">.</span>parked <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">AA</span><span class="token punctuation">.</span><span class="token function">getAcquire</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">==</span> p <span class="token operator">&amp;&amp;</span> <span class="token constant">AA</span><span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">,</span> p<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                                        <span class="token comment">// 当前这个槽位一直没有线程来交换数据，切换到另一个槽位</span>                            <span class="token comment">// arena 数组 j 位置的节点仍然是当前线程的节点 同时通过 cas 将 arena 数组的 j 位置从 p 设置为 null</span>                                                        <span class="token comment">// 计算出来的数组最大有效位的索引 != 0, 也就是 bound 低 8 位存在 1</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>                                                <span class="token comment">// 将 Exchanger 的 bound 属性增加 256 - 1, 也就是 bound + 00000001 00000000 - 00000001</span>                                <span class="token comment">// bound 低 8 位存在 1, 那么经过下面的 cas 操作, bound 值增大了, 但是 bound 低 8 位的值减小了</span>                                <span class="token comment">// m 只会取 bound 的低 8 位, 也就是变相的使下次的 m 取值 - 1 了。</span>                                <span class="token constant">BOUND</span><span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> b <span class="token operator">+</span> <span class="token constant">SEQ</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// p 的打算和其他线程交换的内容设置为 null    </span>                            p<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                            <span class="token comment">// hash 设置为新的 hash</span>                            p<span class="token punctuation">.</span>hash <span class="token operator">=</span> h<span class="token punctuation">;</span>                            <span class="token comment">// 设置 i = 线程当前的节点的位置 / 2;</span>                            <span class="token comment">// 通过这个新的索引值, 重新计算得到新的交换位置</span>                            i <span class="token operator">=</span> p<span class="token punctuation">.</span>index <span class="token operator">>>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>                                                         <span class="token comment">// 线程中断标识为 true, 返回 null</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                            <span class="token comment">// 设置了超时时间, 超时时间为 0, 同时计算后的数组有效位的最大索引最大值为 0</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> m <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ns <span class="token operator">&lt;=</span> <span class="token number">0L</span><span class="token punctuation">)</span>                                <span class="token keyword">return</span> <span class="token constant">TIMED_OUT</span><span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                         <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span>                    <span class="token comment">// cas 失败了, 设置线程自身的节点 p 的打算用来交换的内容 item 为 null, 然后重新循环</span>                    p<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                                 <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 第三部分: 当前节点应该在的位置不在当前数组有效范围内, 或者第一块的 cas 替换失败</span>                <span class="token comment">// 尝试重新设置线程节点的 index</span>                <span class="token comment">// 线程自身的节点 p 的 bound 不等于 Exchanger 当前的 bound</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>bound <span class="token operator">!=</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                        <span class="token comment">// 更新线程自身的节点 p 的 bound 等于当前 Exchanger 的 bound</span>                    p<span class="token punctuation">.</span>bound <span class="token operator">=</span> b<span class="token punctuation">;</span>                    <span class="token comment">// 线程自身的节点 p 的 collides 为重置为 0 </span>                    p<span class="token punctuation">.</span>collides <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token comment">// 线程自身的节点 p 的 bound 不等于当前 Exchanger 的 bound,</span>                    <span class="token comment">// 将 p 重置为当前的的 bound, i 下次操作的位置, 还是从本轮计算出来的 m 值开始</span>                                        <span class="token comment">// m 为 arean 数组有效位的位置的最大值</span>                    <span class="token comment">// i == m 并且 m != 0, 那么 i 下次的位置为 m - 1， 上面验证过 i 位置节点的位置不正确, 这里 i == m, 那么从 m - 1 开始吧</span>                    <span class="token comment">// 其他情况依旧还是从 m 开始</span>                    i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> m <span class="token operator">||</span> m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> m <span class="token operator">:</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">=</span> p<span class="token punctuation">.</span>collides<span class="token punctuation">)</span> <span class="token operator">&lt;</span> m <span class="token operator">||</span> m <span class="token operator">==</span> <span class="token constant">FULL</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token constant">BOUND</span><span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> b <span class="token operator">+</span> <span class="token constant">SEQ</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 在当前的 bound 下, cas 失败的次数 &lt; 数组有效位的位置的最大值, 还能继续试</span>                    <span class="token comment">// m 等于最大容量值了达到了最大值了</span>                    <span class="token comment">// 通过 cas 给 bound 增大失败</span>                    <span class="token comment">// 通过 cas 设置 bound = bound + 256 + 1 = bound + 00000001 00000000 + 00000001 </span>                    <span class="token comment">// bound 只看低 8 位的话，结果就是 + 1 了, 后面 bound &amp; MMASK = m 也就是 新的 m = 旧的 m + 1</span>                    <span class="token comment">// 线程自身的节点 p 的的 collides + 1, 又进行了一次 cas 操作</span>                    p<span class="token punctuation">.</span>collides <span class="token operator">=</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token comment">// i 等于 0 时, i 重新赋值为计算后的数组有效位的最大索引最大值, 否则 i 减 1</span>                    <span class="token comment">// i 已经到 0 了, 那么 i 重新从最大值开始, 否则从 i - 1 继续开始</span>                    i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> m <span class="token operator">:</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                          <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span>                    <span class="token comment">// i 等于 计算后的数组有效位的最大索引最大值 + 1</span>                    i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                                         <span class="token comment">// 线程自身的节点 p 的索引值等于 i, 继续从 i 位置开始处理</span>                p<span class="token punctuation">.</span>index <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>多槽交换方法 arenaExchange 的整体流程和 slotExchange 类似，主要区别在于它会根据当前线程的数据携带结点 Node 中的 index 字段计算出命中的槽位。 </p><blockquote><ol><li>为了解决缓存行的问题, Exchanger 中存节点的数组不会连续存储的, 而是存一个, 下一个会隔一段距离后才存储</li><li>基于这个可以想象成 2 个数组, 一个连续的逻辑数组, 节点之间没有间隔, 一个就是实际存储的数组, 节点直接由间隔的, 得到逻辑数组的位置 i, 可以通过公式推导出他在实际数组的位置 j</li><li>Exchagner 中的数组是一开始就声明好的, 但是为了性能, 整个数组一开始不会就全部都使用, 而是设置了一个最高有效位, 也就是上面的 bound 属性, 数组可用的部分为 [0, bound] 部分</li><li>在使用中, 节点到了, 先通过节点的逻辑数组位置 index, 计算出实际的位置, 判断实际的位置有没有节点在等待, 有, 交换数据返回</li><li>对应的位置没有数据, 同时这个逻辑位置 index 还在当前数组的有效最高位内 (bound 可以通过公式逆推逻辑位置), 那么就和单槽操作的一样, 把当前节点放到对应的位置</li><li>在第 5 步中, 会通过自旋, 自旋次数达到上限, 通过换一个槽位 (等于当前的位置 index &#x2F; 2), 继续自旋, 直到当前逻辑数组的第一位, 在没有超时的限制下, 挂起当前线程, 等待其他线程交换</li><li>在上面的 4,5 中, 当前节点的逻辑数组位置 index 对应的节点没有节点等待, 而且这个 index 又不符合有效最高位的情况下, </li><li>当前节点的 bound 值和当前 Exchanger 的不一致, 先重置为一样的, 那么设置当前的当前节点为 m 或者 m - 1 (流程走下来, 确定 m 对应的位置没有节点) 的位置重新循环处理, 从第 4 步开始</li><li>当前节点的逻辑数组位置 index 对应的节点没有节点等待, 而且这个 index 又不符合有效最高为的情况下, bound 还一样, 那么从有效最高为的 当前节点的上一个节点 或者 有效最高位节点开始处理</li><li>最后这一步了, 没办法设置从 有效最高位 + 1 的位置开始处理 (这时候位置为 null, 会将当前节点放到这个位置)</li></ol></blockquote><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><a href="https://github.com/CL0610/Java-concurrency/blob/master/26.%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%AF%B4java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-Semaphore%EF%BC%8CExchanger/%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%AF%B4java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-Semaphore%EF%BC%8CExchanger.md">大白话说Java并发工具类-Semaphore, Exchanger</a><br><a href="https://blog.csdn.net/u014634338/article/details/78385521">Java 并发 — Exchanger源码分析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java HashMap</title>
      <link href="/article/2021/3656336691/"/>
      <url>/article/2021/3656336691/</url>
      
        <content type="html"><![CDATA[<p>HashMap 是 Map 接口中基于哈希表的非同步实现, 自身也可以自动扩容。使用时可以通过 key 快速定位到对应的 value。key 和 value 同时可以都为 null。</p><h2 id="1-HashMap-的结构定义"><a href="#1-HashMap-的结构定义" class="headerlink" title="1 HashMap 的结构定义"></a>1 HashMap 的结构定义</h2><p>JDK1.8 对 HashMap 进行了比较大的优化, 底层实现由之前的 “数组 + 链表” 改为 “数组 + 链表 + 红黑树”。<br>在链表的长度大于等于 8 并且数组的长度大于等于 64 时, 将对应的链表转为红黑树 (本文不涉及红黑树部分的分析, 涉及到时, 只会提一下, 然后跳过)。</p><p>首先数组是整个数据的存储真正实体, 数组中的存储的数据是链表或者红黑树, 当链表的长度达到了条件, 就变成了红黑树, 大体的情况如下:<br><img src="https://pic.imgdb.cn/item/6564b817c458853aef501a3e.png" alt="Alt &#39;HashMap 数据结构&#39;"></p><h3 id="1-1-数组的定义"><a href="#1-1-数组的定义" class="headerlink" title="1.1  数组的定义"></a>1.1  数组的定义</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>从上面的代码就是 HashMap 中数据存储的地方: 数组。 数组存储的数据类型为 Node, 这个 Node 是链表的定义。<br>而 红黑树的定义是继承了 Node, 所以通过向上转型的方式, 就能通过一个 Node 的类型表示链表和红黑树。</p><h3 id="1-2-链表的定义"><a href="#1-2-链表的定义" class="headerlink" title="1.2 链表的定义"></a>1.2 链表的定义</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** * 链表定义     * Map.Entry 行为接口, 定义了一堆操作方法, 比如 getValue, setValue 等 */</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 当前节点的 hash 值</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>        <span class="token comment">// 当前节点的 key</span>        <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>        <span class="token comment">// 当前节点的 value</span>        <span class="token class-name">V</span> value<span class="token punctuation">;</span>        <span class="token comment">// 下一个节点, 这个属性决定了 Node 为链表</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/**         * 计算当前节点 hashCode         */</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Objects.hashCode 本质就是调用对象的 o.hashCode()</span>        <span class="token comment">// 当前节点的 hashCode 值 等于 key 的 hashCode  异或 value 的 hashCode 值</span>            <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/**         * 节点比较         */</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token comment">// 都是 Map.Entry 节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>                <span class="token comment">// Objects.equals 会先比较一下 2 者的内存地址, 一样直接返回 true</span>                <span class="token comment">// 不一样, 调用 key.equals(e.getKey) 进行比较</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="1-3-红黑树的定义"><a href="#1-3-红黑树的定义" class="headerlink" title="1.3 红黑树的定义"></a>1.3 红黑树的定义</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 继承了 LinkedHashMap.Entry, Entry 继承了 HashMap.Node  所以 TreeNode 具有 链表的特点</span>    <span class="token comment">/**      * 红黑树的定义     * LinkedHashMap.Entry 继承了 HashMap.Node 节点, 所以 TreeNode 是 Node 的子类, 也具备链表的特点     */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">/**         * 红黑树的根节点         */</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> parent<span class="token punctuation">;</span>                <span class="token comment">/**         * 当前节点的左节点         */</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> left<span class="token punctuation">;</span>        <span class="token comment">/**         * 当前节点的右节点         */</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> right<span class="token punctuation">;</span>        <span class="token comment">/**         * 删除后需要解决连接的节点         */</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> prev<span class="token punctuation">;</span>          <span class="token comment">/**         * 是否为红色节点         */</span>        <span class="token keyword">boolean</span> red<span class="token punctuation">;</span>        <span class="token comment">// ... 后面 省略 红黑树的操作</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="2-HashMap-中的几个重要属性"><a href="#2-HashMap-中的几个重要属性" class="headerlink" title="2 HashMap 中的几个重要属性"></a>2 HashMap 中的几个重要属性</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">UNTREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MIN_TREEIFY_CAPACITY</span> <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-1-table"><a href="#2-1-table" class="headerlink" title="2.1 table"></a>2.1 table</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span></code></pre><p>HashMap 中存储数据的数组</p><h3 id="2-2-size"><a href="#2-2-size" class="headerlink" title="2.2 size"></a>2.2 size</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span></code></pre><p>HashMap 中已经存储的数据个数</p><h3 id="2-3-modCount"><a href="#2-3-modCount" class="headerlink" title="2.3 modCount"></a>2.3 modCount</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span></code></pre><p>HashMap 已经被修改了多少次, 用于支撑 fail-fast 机制</p><h3 id="2-4-loadFactor"><a href="#2-4-loadFactor" class="headerlink" title="2.4 loadFactor"></a>2.4 loadFactor</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span></code></pre><p>负载因子: 默认等于  DEFAULT_LOAD_FACTOR &#x3D; 0.75f;<br>作用: 一般情况都是在容器满了才会进行扩容, 但是在 HashMap 中, 数据量达到了<strong>数组的长度 * 负载因子</strong>的值, 就会进行扩容了。<br>原因: HashMap 在数组中插入一个数据, 是先通过一个 hash 方法转换为一个 hash 值, 通过这个 hash 值计算得到存储在数组的位置, 通过 hash 计算, 就可能存在 hash 冲突。<br>数据越密集, 冲突的可能性越大, 所以 HashMap 中的数组是不会完成存满的, 通过空留一部分, 减少冲突等。  </p><p>负载因子默认值为 0.75 的原因: 太大冲突可能性变大, 太小浪费了空间, 同时会导致数组扩容等耗时操作。<br>所以 0.75 应该是一个经验值的估算, 或者是因为 HashMap的数组长度为 2^n, 乘以 0.75, 能获得一个整数。</p><h3 id="2-5-threshold"><a href="#2-5-threshold" class="headerlink" title="2.5 threshold"></a>2.5 threshold</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span></code></pre><p>当前数组的阈值, 即数组实际应该放多少数据</p><h3 id="2-6-几个常量"><a href="#2-6-几个常量" class="headerlink" title="2.6 几个常量"></a>2.6 几个常量</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 1 左移多少位, 就是相当于 2 的 多少次方, 这里就是 2^4 = 16</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span></code></pre><p>声明 HashMap, 不指定容量时, 默认为 16。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 2^30</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span></code></pre><p>HashMap 最大容量, 容量必须是 2 的 n 次方, 涉及到通过 key 的 hash 值定位到数组的位置中的一个配合。<br>HashMap 中数组的容量设定为 2 的 n 次方具体有 2 个作用:  </p><p>第一, 得到了 key 对应的 hash 后, 如何通过 hash 定位到数组中的哪一个位置呢?</p><p>最简单的方式就是取模了吧, 通过 hash 值模于当前数组的长度, 得到的就是当前 hash 对应的数组位置。<br>但是取模的效率不太好, 那么有什么好的优化方式吗?   </p><p>在数学上, a, b 都是正整数的情况下, a % b, 在 b 是 2 的 n 次方下, **a % b &#x3D; a &amp; (b - 1)**。<br>位运算比正常的算术运算快, 那么将 HashMap 的容量设置为 2 的 n 次方, 就可以通过与运算达到取模的效果。<br>所以 HashMap 中的数组容量必须为 2 的 n 次方。</p><p>第二个作用在后面会分析。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span></code></pre><p>HashMap 中链表变为红黑树的长度配置, 链表长度达到了 8 满足了链表变为红黑树的条件之一。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">UNTREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span></code></pre><p>HashMap 中红黑树重新变为链表的长度配置, 红黑树的节点个数达到了 6, 满足了红黑树变为链表的条件之一。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MIN_TREEIFY_CAPACITY</span> <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span></code></pre><p>HashMap 中链表变为红黑树的的另外一个条件, 当前数组的长度达到了 64。</p><h2 id="3-HashMap-的构造方法"><a href="#3-HashMap-的构造方法" class="headerlink" title="3 HashMap 的构造方法"></a>3 HashMap 的构造方法</h2><h3 id="3-1-无参的构造函数"><a href="#3-1-无参的构造函数" class="headerlink" title="3.1 无参的构造函数"></a>3.1 无参的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 设置负载因子为 0.75</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre><h3 id="3-2-指定初始容量-和负载因子-的构造函数"><a href="#3-2-指定初始容量-和负载因子-的构造函数" class="headerlink" title="3.2 指定初始容量 (和负载因子) 的构造函数"></a>3.2 指定初始容量 (和负载因子) 的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用到自身的指定容量 和负载因子的构造函数, 传入的负载因子为默认值 0.75</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/**  * 指定 初始容量 和 负载因子   */</span><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 指定的容量小于 0, 格式不正确</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 指定的容量超过了最大容量, 设置为支持的最大容量值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span>        initialCapacity <span class="token operator">=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">;</span>    <span class="token comment">// 格式不正确 NaN: Not-a-Number,  isNaN(arg) => arg 不是数字, 返回true</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 负载因子直接等于输入的值</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>    <span class="token comment">// tableSizeFor 这个方法会对输入的值, 转换为第一个大于或等于输入值的 2 的 n 次方的数, 比如: 输入 3 得到 4, 输入 4 得到 4, 输入 5 得到 8</span>    <span class="token comment">// 因为 HashMap 的容量需要是 2 的 n 次方, 通过 tableSizeFor 将用户输入的不是 2 的 n 次方的数, 进行修正</span>        <span class="token comment">// threshold 这个属性上面说过是用来存储 HashMap 的实际容量 (声明的数组容量 * 负载因子), 但是这里直接赋值的是 2 的 n 次方, 错了吗?</span>    <span class="token comment">// 实际上没错的, threshold 就是用来存储实际的容量的, 这里只是把计算出来的容量临时存在这个变量, 在第一次进行存放数据时, 进行修正为实际容量的</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token comment">/** * 计算数组容量 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 此次减 1 的原因: 让后面的处理结果变为 n 是第一个大于等于 cap 的 2 的 n 次方的数</span>    <span class="token comment">// 如果这里不减 1 的话, 刚好传进来的数是 2 的 n 次方, 经过下面几步的处理会变成 2 的 n+1 次方的数</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token comment">// 做一个容错 如果 cap 是一个小于等于 0 的数, 经过上面的处理, n 将会变成一个负数</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-3-给定一个-Map-的构造函数"><a href="#3-3-给定一个-Map-的构造函数" class="headerlink" title="3.3 给定一个 Map 的构造函数"></a>3.3 给定一个 Map 的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 负载因子 = 0.75</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">;</span>    <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 放入数据 * @param m 数据 * @param evict 这个参数主用是在插入节点后, 做调整用的, 在 HashMap 中不具备任何作用, 构造参数中直接使用 false, 其他的情况使用 true 即可, 基于 HashMap 实现的 LinkedHashMap 才需要使用到这个参数 */</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">putMapEntries</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> m<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取需要传入的 Map 的数据个数</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 大于 0 的话, 才出来</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 当前存放数据的 table 为空, 表示为初始化</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 计算出来需要的容量 =  长度 / 赋值因子 + 1</span>            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>s <span class="token operator">/</span> loadFactor<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0F</span><span class="token punctuation">;</span>            <span class="token comment">// 限制最大的容量 为  2^ 30</span>            <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 计算出来的当前需要的容量 > 实际的容量, 进行新容量的计算</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">></span> threshold<span class="token punctuation">)</span>                <span class="token comment">// 计算存储数据的数组的容量</span>                threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token comment">// 当前存入的数据量直接大于当前阈值, 进行重新扩容</span>            <span class="token comment">// 扩容方法在下面的添加数据讲解</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 遍历 Map, 将里面的数据逐个迁移到当前的 Map 中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">:</span> m<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">K</span> key <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">V</span> value <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 添加数据的在下面的添加数据讲解</span>            <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> evict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="4-HashMap-的操作方法"><a href="#4-HashMap-的操作方法" class="headerlink" title="4 HashMap 的操作方法"></a>4 HashMap 的操作方法</h2><h3 id="4-1-添加数据"><a href="#4-1-添加数据" class="headerlink" title="4.1 添加数据"></a>4.1 添加数据</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 计算 key 的 hash 值</span>        <span class="token comment">// 2. 调用 putVal 进行数据的新增</span>        <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * key 计算出 hash 值     */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> h<span class="token punctuation">;</span>        <span class="token comment">// 对象的 hashCode ^ 对象的 hashCode >>> 16</span>        <span class="token comment">// 将 hashCode 的高 16 位与 hashCode 进行异或运算, 主要是为了在 table 的 length 较小的时候, 让高位也参与运算, 减少 hash 冲突, 并且不会有太大的开销</span>        <span class="token comment">// 这里做了一个容错, 如果 key 为 0, 那么计算出来的 hash 值为 0, 也就是 HashMap 直接 key 为 0 的情况, 但是只能存一个 key 为 null 的数据, </span>        <span class="token comment">// 后面的 key 为 null, 计算出来的 hash 都是 0, 会把旧值覆盖(默认情况)</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 存值     * @ hash 存的 key 的hash值     * @ key  对象的 key     * @ value 存的值     * @ onlyIfAbsent 存入的数据已在 HashMap 中存在, 是否有新的 value 替代旧的 value, false 进行修改, true 不修改     * @ evict 这个值用于 LinkedHashMap, 在HashMap 中没有作用     */</span>    <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>        <span class="token comment">// 数组为空 或者 数组的长度为 0, 进行扩容</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>                <span class="token comment">// HashMap 对象的位置是通过 (数组的长度 - 1) &amp; hash, 也就是 hash % (2 ^ n - 1) 的形式</span>        <span class="token comment">// 存储的位置为空, 直接将 hash, key, value 封装为新的 Node 节点, 放到指定的位置</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 存储的位置已经有数据了</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>            <span class="token comment">// 需要放入的位置的第一个节点 的 hash 和 key 一样, 取到这个节点</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>e <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            <span class="token comment">// 调用红黑树 进行处理</span>                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 对应的位置不是红黑树, 那么就是链表了,  从链表的第一个节点开始遍历到尾部</span>                    <span class="token comment">// 下一个节点为空, 直接将当前的节点放到尾部</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 当前的容量已经达到了 8个, 转为红黑树, binCount 从 0 开始遍历的</span><span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>                            <span class="token comment">// 这个方法后面</span>                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token comment">// 链表中有一个节点的 hash 和 key 和要插入的一样, 取到这个节点, 停止遍历链表</span><span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                         <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token comment">// p = p 的下一个节点, 判断下一个节点</span>                    p <span class="token operator">=</span> e                                        <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// e 不为空, 表示在数组当前的位置的链表或红黑树中存在一个 key 值和 hash 值和当前要存入的数据一样。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 获取旧值</span>                <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token comment">//  旧值为 null 或者入参的 onlyIfAbsent 为 false, 新值替换旧值</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token comment">// 在 HashMap 中这个是空方法                    </span>                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 修改次数 + 1, 用于支持 fast-fail 机制</span>            <span class="token operator">++</span>modCount<span class="token punctuation">;</span>            <span class="token comment">// 当前存储的数据个数达到了阈值, 进行扩容</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>     <span class="token comment">// HashMap 的这个方法没有实现</span>     <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 重新扩容     */</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取当前数组的引用</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token comment">// 当前的容量</span>        <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// 当前的阈值</span>        <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>        <span class="token comment">// 新的容量, 新的阈值</span>        <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 当前的容量不为0, 也就是有数据存在了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 当前的容量已经达到最大了, 直接不进行操作</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 直接将阈值设为 int 的最大值</span>            <span class="token comment">// 实际的数组长度依旧为 2^30, 一般情况阈值 threshold = 实际数组的长度 * 负载因子, 负载因子一般都是小于 1 大于 0 的数, 所以 threshold &lt; 数组的实际长度</span>                <span class="token comment">// 决定数组是否扩容的则是由 threshold 是否小于当前的数据个数 size, 所以数组的容量还未完全用完了, 就扩容了,</span>                <span class="token comment">// 现在的情况是, 旧的数组的容量已经达到了设定的最大容量了, 无法继续扩了, 所以将 threshold 直接设置为 int 的最大值 > 数组的长度, 这样可以继续利用原本因负载因子而无法使用到的空间</span>                threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>                        <span class="token comment">// 新容量的值 = 旧数组的容量 * 2</span>            <span class="token comment">// 新的容量 &lt; 最大容量 &amp;&amp; 旧的容量 >= 初始默认的容量(16),  这种情况下设置新的负载 = 旧的 * 2</span>            <span class="token comment">// 那么就存在旧的容量为 2, 4, 8 三种情况, 没有走到下面的 newThr = old &lt;&lt; 1, 那么新的阈值为 0 </span>            <span class="token comment">// oldCap >= DEFAULT_INITIAL_CAPACITY, 新的阈值什么不是无条件的等于旧的阈值的 2 倍</span>            <span class="token comment">// 而是只有在 oldCap >= DEFAULT_INITIAL_CAPACITY, 新的阈值才会是旧阈值的 2 倍</span>            <span class="token comment">// 而如果 oldCap 为 2, 4, 8, 则新的阈值为 0, 需要到下面的新的阈值 = 0 的判断进行处理, 具体的分析看下面的备注 1</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span> oldCap <span class="token operator">>=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span>                newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment">// 当旧的阈值大于 0, 设置新的容量 = 阈值</span>            <span class="token comment">// 能够走到这一步的情况有: </span>            <span class="token comment">// 1. 我们初始时, 只指定了容量, 然后第一次往里面加数据</span>            <span class="token comment">// 2. 初始时, 只传递了一个 Map, 然后第一次把 Map 里面的数据放到当前 HashMap 时</span>            <span class="token comment">// 新的容量 = 当前的阈值 = threshold, 因为在声明 HashMap 时, 会临时将容量存储到 threshold, 直接赋值过来就是需要的容量了</span>            newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>             <span class="token comment">// 当我们创建时, 没有指定容量时, 在第一次放数据, 会走这一步</span>            <span class="token comment">// 这里将需要的容量的设置为默认值 16, 新的阈值为 16 * 0.75</span>            newCap <span class="token operator">=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">;</span>            newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">*</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 新的阈值为 0 </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 一般情况下阈值 = 新容量 * 0.75, 如果数组的容量达到了最大容量, 则直接设置为 int 的最大值</span>            <span class="token comment">// 这里新的阈值为 0, 能够走到这一步的情况有:</span>            <span class="token comment">// 1. 我们初始时, 只指定了容量, 然后第一次往里面加数据</span>            <span class="token comment">// 2. 初始时, 只传递了一个 Map, 然后第一次把 Map 里面的数据放到当前 HashMap 时</span>            <span class="token comment">// 3. 扩容时, 旧的容量为 2/4/8 中的一个, 那么 newThr 也是 0, 需要结合上面的扩容的 oldCap >= DEFAULT_INITIAL_CAPACITY 进行分析</span>            <span class="token comment">// 计算理论的阈值 = 新的容量 * 负载因子</span>            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>            <span class="token comment">// 新的容量 &lt; 最大值 &amp;&amp; 理论的阈值 &lt; 最大值 ? 新的阈值 = 计算出来的阈值 : 新的阈值 = int 的最大值</span>            <span class="token comment">// 这里个人感觉有点问题, 具体看下面的 备注 2</span>            newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 设置新的阈值</span>        threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>        <span class="token comment">// 声明新的数组, 用于存储数据</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// HashMap 中的数组引用修改为新声明的数组</span>        table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>        <span class="token comment">// 数组 重新赋值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 遍历旧数组的每一项</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>                <span class="token comment">// 获取到当前数组的第 j 个元素</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    第 j 个元素不为 <span class="token keyword">null</span><span class="token punctuation">,</span> 表示有数据<span class="token punctuation">,</span> 需要进行迁移                    <span class="token comment">// 旧数组的 j 位置的值设置为空, 方便垃圾回收</span>                    oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                        <span class="token comment">// 如果 e.next 为空, 则代表旧数组的该位置只有 1 个节点, 那么把这个节点直接放到新数组里面, 就行了</span>                        <span class="token comment">// 通过 (节点 的 hash 值 &amp; 新容量 -1 ) 取到新的位置</span>                        newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                        <span class="token comment">// 原本的这个节点为树节点, 调用 TreeNode 的 split 进行处理</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                                <span class="token comment">// 到了这一步, 说明当前位置存储的是一个 链表, 同时链表的数据存在 2 个以上</span>                        <span class="token comment">// 声明了2 个链表, lo 链表, hi 链表, 这 4 个指针, 分别指向了 2 个链表的头和尾 </span>                        <span class="token comment">// 其中的 lo 可以理解为 low, 地位链表, hi 为 hight, 高维链表, </span>                        <span class="token comment">// 新的数组的容量是是原来的2倍, 那么 原来的一倍 可以理解为 low, 扩充出来的为 hight</span>                        <span class="token comment">// 原本在同一个链表上的节点, 转移到扩容后的数组式, 只可能会被分配到 2 个位置,  和原来一样的位置 或者原来的位置 + oldCap 的位置, 看下面的备注 3 </span>                        <span class="token comment">// lo 链表存放的是节点位置不需要修改的节点, hi 就是存储位置变为 原来位置 + oldCap 的节点</span>                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>                        <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>                            <span class="token comment">// 遍历 j 位置上的链表</span>                            <span class="token comment">// 临时保存下一个节点</span>                            next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                            <span class="token comment">// 当前节点的 hash 值 与上旧的容量值等于 0, 那么可以确定这个节点在新数组的位置和原来的一样</span>                            <span class="token comment">// 先将其放到低维的链表, 后面在把低维的链表放到新数组的对应位置</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                                                <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                                    <span class="token comment">// 如果loTail为空, 代表该节点为第一个节点</span>                                    loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    <span class="token comment">// 否则将节点添加在链表的尾部</span>                                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                                    <span class="token comment">// 重新设置尾结点</span>                                loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                 <span class="token comment">// 不等于 0, 表示这个节点需要存放到新的位置, 先放到高维链表</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                                <span class="token comment">// 作用同上面</span>                                    hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                                hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 设置数组的 j 位置为 lo 链表</span>                            loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                            newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 设置数组的 j + oldCap 为 hi链表</span>                            hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                            newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 返回新数组</span>        <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 将指定的位置转为树     * 在 putVal 时, 如果发现链表的长度大于 8 了, 就会调用这个方法, 将链表变为链表     */</span>    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>        <span class="token comment">// 注意这里: 数组为空, 或者长度还不够 64, 进行扩容, 不进行转换操作</span>        <span class="token comment">// 所以链表转为红黑树的还有一个大前提: 当前 HashMap 中存储数据的数组的长度要大于 64, 而不是链表的长度大于 8 就树化</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MIN_TREEIFY_CAPACITY</span><span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 需要处理的位置的链表不为 null</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> hd <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> tl <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 因为 TreeNode 继承了 Node, 所以 TreeNode 也可以当做链表使用</span>            <span class="token comment">// 将 Node 转为 TreeNode</span>            <span class="token comment">// 然后将下面拼接成一个以 TreeNode 为类型的链表</span>                <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> <span class="token function">replacementTreeNode</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token comment">// 树的根节点</span>                    hd <span class="token operator">=</span> p<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 按照链表的格式, 改变节点的指向, </span>                    p<span class="token punctuation">.</span>prev <span class="token operator">=</span> tl<span class="token punctuation">;</span>                    tl<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                tl <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 重新将当前节点头结点设置为树的根节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> hd<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">// 转为树</span>                hd<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="4-1-1-备注-1"><a href="#4-1-1-备注-1" class="headerlink" title="4.1.1 备注 1"></a>4.1.1 备注 1</h4><p>在 resize 方法中, 旧数组已有数据了, 但是在进行扩容时, 容量默认是 2 倍扩展, 但是阈值只有在 <code>oldCap &gt;= DEFAULT_INITIAL_CAPACITY</code> 时才会进行 2 倍扩展, 否则是为<strong>新的容量 * 负载因子</strong>。<br>原因: 为了在容量少的情况下, 尽可能的利用数组的空间, 不造成浪费。</p><p>假设我们在初始时, 指定了容量为 2, 那么在初始后容量值为 2, 阈值为  2 * 0.75 &#x3D; 1。 </p><p>第一次扩容: </p><table><thead><tr><th align="center"></th><th align="center">旧的容量</th><th align="center">新的容量</th><th align="center">旧的阈值</th><th align="center">经过运算新的阈值</th></tr></thead><tbody><tr><td align="center">旧阈值 &lt;&lt; 1</td><td align="center">2</td><td align="center">4</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">新容量 × 0.75</td><td align="center">2</td><td align="center">4</td><td align="center">1</td><td align="center">3</td></tr></tbody></table><p>第一次扩容: </p><table><thead><tr><th align="center"></th><th align="center">旧的容量</th><th align="center">新的容量</th><th align="center">旧的阈值</th><th align="center">经过运算新的阈值</th></tr></thead><tbody><tr><td align="center">旧阈值 &lt;&lt; 1</td><td align="center">4</td><td align="center">8</td><td align="center">2</td><td align="center">4</td></tr><tr><td align="center">新容量 × 0.75</td><td align="center">4</td><td align="center">8</td><td align="center">3</td><td align="center">6</td></tr></tbody></table><p>第三次扩容</p><table><thead><tr><th align="center"></th><th align="center">旧的容量</th><th align="center">新的容量</th><th align="center">旧的阈值</th><th align="center">经过运算新的阈值</th></tr></thead><tbody><tr><td align="center">旧阈值 &lt;&lt; 1</td><td align="center">8</td><td align="center">16</td><td align="center">4</td><td align="center">8</td></tr><tr><td align="center">新容量 × 0.75</td><td align="center">8</td><td align="center">16</td><td align="center">6</td><td align="center">12</td></tr></tbody></table><p>第四次扩容</p><table><thead><tr><th align="center"></th><th align="center">旧的容量</th><th align="center">新的容量</th><th align="center">旧的阈值</th><th align="center">经过运算新的阈值</th></tr></thead><tbody><tr><td align="center">旧阈值 &lt;&lt; 1</td><td align="center">16</td><td align="center">32</td><td align="center">8</td><td align="center">16</td></tr><tr><td align="center">新容量 × 0.75</td><td align="center">16</td><td align="center">32</td><td align="center">12</td><td align="center">24</td></tr></tbody></table><p>通过上面可以发现: 在旧容量 &lt; 16 之间变化时, 通过新容量 × 负载因子, 阈值会大一些, 可以更充分的利用数组的空间, 在第四次扩容时, 新容量为 32 时, 旧的阈值为 12, 这时 12 &lt;&lt; 1 等于 32 * 0.75, 所以 2 者后续的计算是一样的, 通过位运算比较快。</p><p>可以简单理解为: 阈值一直都是等于当前的容量 * 负载因子,<br>在旧容量为 2, 4, 8 按照上面的方式计算。<br>到了就容量 &gt;&#x3D; 16 时, 可以通过位运算达到同样的计算效果, 使用位运算更快</p><h4 id="4-1-2-备注-2"><a href="#4-1-2-备注-2" class="headerlink" title="4.1.2 备注 2"></a>4.1.2 备注 2</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token comment">// 步骤 1    </span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span> oldCap <span class="token operator">>=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment">// 省略</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>         <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 步骤 2</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>        <span class="token comment">// 步骤 3</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 设置新的阈值</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上面的阈值的计算一般情况下是没问题的, 但是在容量从 2^29 到最大值 2^30 扩容时, 按照上面的步骤</p><blockquote><ol><li>走到步骤 1 时, 容量变为原来的 2 倍, newCap &#x3D; MAXIMUM_CAPACITY, 这时  newCap &lt; MAXIMUM_CAPACITY, 不满足条件, 所以 newThr 还是 0</li><li>到了步骤 2 时, 计算出来的 ft &#x3D; newCap * loadFactor, loadFactory 一般都是大于 0, 小于 1 的数, 所以 ft &lt; newCap &#x3D; MAXIMUM_CAPACITY, 既 ft &lt; MAXIMUM_CAPACITY</li><li>到了步骤 3 时, new &#x3D; MAXIMUM_CAPACITY &lt; MAXIMUM_CAPACITY 为 false,  false &amp;&amp; true &#x3D; false</li><li>经过步骤 3 后, newThr 直接变为 int.max_value, 正常应该是 newCap * loadFactor, 下次扩容时, 到达上面的旧容量 &gt;&#x3D; MAXIMUM_CAPACITY, 再把阈值修改为 int.max_value</li></ol></blockquote><p>上面的分析都是基于负载因子大于 0, 小于 1 的情况的分析, 如果用户将负载因子设置为大于 1 的情况, 可能导致步骤 2 计算出来的 ft 为 负数。<br>所以可以将上面的步骤 1 修改为 &lt;&#x3D; MAXIMUM_CAPACITY 或者步骤 3 修改为 &lt;&#x3D; MAXIMUM_CAPACITY</p><h4 id="4-1-3-备注-3"><a href="#4-1-3-备注-3" class="headerlink" title="4.1.3 备注 3"></a>4.1.3 备注 3</h4><p>(e.hash &amp; oldCap) &#x3D;&#x3D; 0 可以判断节点在新数组的位置和旧数组的是否一样, 很巧妙的利用了数组的长度为 2 的 n 次方这个特性。 也就是 HashMap 中数组的容量是 2 的 n 次方的第二个作用。</p><p>能达到这样的效果的必须知道: </p><blockquote><ol><li>oldCap 是 2 ^ n, newCap 是 在 oldCap 的基础 * 2, 也就是 newCap 是 2 ^ (n + 1)</li><li>2 ^ n 在二进制的表示为  1 + n 个 0 ,  2 ^ (n + 1) 二进制表示  1 + ( n + 1 ) 个 0</li><li>2 ^ n - 1 在二进制的表示为  n 个 1, 那么  2 ^ (n + 1) 就是 n + 1 个 1</li><li>(2 ^ n - 1) &amp; hash,  我们只需要取 hash 的从右到左的 1 到 n 位就行了, 因为 2 ^ n - 1 前面都是 0, &amp; 上都是 0</li></ol></blockquote><p>我们假设有个节点 A, 其 现在在数组中的 index 位置, 现在 oldCap 是 16, 既 2^4, 16 - 1 &#x3D; 15, 二进制表示为 <strong>00000000 00000000 00000000 00001111</strong></p><p>这时候 index &#x3D; hash &amp; (16 - 1), index 的值自然就是只和 hash 值的低 4 位有关, 我们假设它为 abcd</p><p>oldCap 扩大了一倍, 当前节点的的位置 index 的计算公式 &#x3D; (32-1) &amp; hash, 和 hash 值的低 5 位有关,  hash 的低 5 位的值无外乎下面两种情况:  <code>0abcd</code> 或者 <code>1abcd</code></p><p>0abcd &#x3D; index, 而 1abcd &#x3D; 0abcd + 10000 &#x3D; 0abcd + oldCap &#x3D; index + oldCap, 从这里可以知道容量扩大了一倍, 那么新的 index 是有规律的, 要么不变, 要么就是 index + oldCap</p><p>新旧 index 是否一致就体现在 hash 值的第 5 位, 那么第 5 位怎么知道呢？ 32 的 2^n 的二进制形式 <code>1 + 5 个 0</code>, 那么 hash &amp; oldCap 就能知道 hash 的第 5 位是 0 或者 1 了, 既 hash &amp; oldCap &#x3D; 0, hash 的第 5 位为 0,<br>hash &amp; oldCap 不等于 0, hash 的第 5 位为 1。</p><p>最终可以通过 hash &amp; oldCap 得到</p><blockquote><ol><li>hash &amp; oldCap &#x3D; 0 &#x3D;&gt; 当前节点在数组的位置不用变</li><li>hash &amp; oldCap !&#x3D; 0 &#x3D;&gt; 当前节点在新数组的 index + oldCap 的位置</li></ol></blockquote><h3 id="4-2-其他添加数据的方式"><a href="#4-2-其他添加数据的方式" class="headerlink" title="4.2 其他添加数据的方式"></a>4.2 其他添加数据的方式</h3><blockquote><ol><li>直接添加一个 Map 的 putAll(Map&lt;K, V&gt; map);</li><li>添加一个元素, 如果对应的位置已经有数据了, 则不添加 putIfAbsent(K key, V value)</li></ol></blockquote><h3 id="4-3-获取数据"><a href="#4-3-获取数据" class="headerlink" title="4.3 获取数据"></a>4.3 获取数据</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**      * 通过 key 获取 value, 如果节点为 null, 返回 nulL     */</span>    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 通过 key 的 hash 值和 key 值获取 value 值     */</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>        <span class="token comment">// 数组不为空, 长度大于 0, 链表的第一个节点 不为 null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 第一个节点的 hash 值和传入的 hash 值一样, key 值也一样,  第一个节点符合条件了, 直接返回</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> first<span class="token punctuation">;</span>            <span class="token comment">// 链表有下一个节点    </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 树节点, 转换为树节点进行处理</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 遍历 链表的其他节点,</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token keyword">return</span> e<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="4-4-删除数据"><a href="#4-4-删除数据" class="headerlink" title="4.4 删除数据"></a>4.4 删除数据</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** * 直接通过 key删除 */</span><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 删除节点     * matchValue : 为 true, 找到了节点, 还会比较他们的值, 值相同才会删除     * movable : 针对红黑树起作用, 为 false, 节点删除了, 不改变其他节点的位置     */</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> matchValue<span class="token punctuation">,</span> <span class="token keyword">boolean</span> movable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 数组不为 null, 长度大于 0, 同时定位到的位置不为 null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> node <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span> <span class="token class-name">V</span> v<span class="token punctuation">;</span>            <span class="token comment">// 链表的第一个节点符合了条件</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                node <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token comment">// 链表的下一个节点不为null</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 节点为 树节点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                     <span class="token comment">// 遍历链表</span>                    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 寻找找到符合条件</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            node <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                        p <span class="token operator">=</span> e<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token comment">// 找到了需要删除的节点, 如果设置了需要检查值, 后面会对其值的内存地址和 equals 进行比较 </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>matchValue <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> value <span class="token operator">||</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token comment">// 调用红黑树的删除节点的方法</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeTreeNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> movable<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> p<span class="token punctuation">)</span>                <span class="token comment">// 把链表的头部直接指向了下一个节点</span>                    tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">else</span>                <span class="token comment">// p 在上面的链表的遍历中, 变成需要删除的节点的前一个节点了</span>                    <span class="token comment">// p 的下一个节点指向需要删除节点的下一个节点</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token operator">++</span>modCount<span class="token punctuation">;</span>                <span class="token operator">--</span>size<span class="token punctuation">;</span>                <span class="token comment">// 空方法</span>                <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> node<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>上面只是通过 key 进行删除数据的, 同样还有一个通过 key 和 value 值都相同的情况进行删除的方法。</p><h3 id="4-5-修改数据"><a href="#4-5-修改数据" class="headerlink" title="4.5 修改数据"></a>4.5 修改数据</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> oldValue<span class="token punctuation">,</span> <span class="token class-name">V</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span> <span class="token class-name">V</span> v<span class="token punctuation">;</span>        <span class="token comment">// 通过 getNode 获取到对应的节点, 节点的值等于入参的 oldValue</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> oldValue <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>oldValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 替换节点的 value 值等于入参的新 value</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="5-HashMap-的补充"><a href="#5-HashMap-的补充" class="headerlink" title="5 HashMap 的补充"></a>5 HashMap 的补充</h2><blockquote><ol><li>HashMap 同样是线程不安全的, 如果需要线程安全, 同样可以通过 Collections.synchronizedMap() 获取到一个线程安全的实现类。</li><li>HashMap 支持 fail-fast 机制</li><li>HashMap 的序列化也是自定义的</li><li>HashMap 内部提供了许多迭代器: KeyIterator, ValueIterator, EntryIterator, 方便各种遍历需求</li><li>HashMap 的线程不安全, 猜测时, 同时有 2 个线程判断到需要扩容了, 然后同时进行扩容, 期间就可能造成闭合的链路。</li></ol></blockquote><h2 id="6-红黑树相关的内容"><a href="#6-红黑树相关的内容" class="headerlink" title="6 红黑树相关的内容"></a>6 红黑树相关的内容</h2><blockquote><ol><li><a href="https://www.cnblogs.com/tiancai/p/9072813.html">清晰理解红黑树的演变—红黑的含义</a> 红黑树的前身</li><li><a href="https://blog.csdn.net/v_JULY_v/article/details/6105630">教你初步了解红黑树</a> 红黑树的节点插入</li><li><a href="https://www.cnblogs.com/qingergege/p/7351659.html">红黑树之删除节点</a>  红黑树的节点删除</li><li><a href="https://my.oschina.net/u/3272058/blog/1914452">红黑树原理以及插入、删除算法 附图例说明</a> 里面的增删图片不错</li></ol></blockquote><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h2><p><a href="https://blog.csdn.net/v123411739/article/details/78996181">Java集合: HashMap详解 (JDK 1.8) </a><br><a href="https://segmentfault.com/a/1190000015812438?utm_source=tag-newest">深入理解HashMap(四): 关键源码逐行分析之resize扩容</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java CopyOnWriteArrayList</title>
      <link href="/article/2021/367535606/"/>
      <url>/article/2021/367535606/</url>
      
        <content type="html"><![CDATA[<p>在 Java 的集合中, List 是一个很高频使用的集合中, 但是平时使用的 ArrayList, LinkedList 都是线程不安全的。 线程可见性不支持, 内部的 fast-fail 机制等都是表明他们不适合高频发的场景使用。如果我们需要一个线程安全的列表集合</p><blockquote><ol><li>使用古老的集合类 Vector</li><li>通过 Collections.synchronizedList(List&lt;T&gt; list) 得到一个线程安全的列表</li></ol></blockquote><p>虽然他们的确可以处理高并发的场景, 但是性能却不太行 (内部几乎所有的操作都是通过加同步锁实现的), 那么是否有更好的选择吗 ?</p><p>如果你现在的业务场景是一种<strong>读多写少</strong>, 同时支持<strong>短时间的数据延迟</strong>的情况, 那么可以考虑使用一下 <strong>CopyOnWriteArrayList</strong>, 它是一个设计简单, 采用了写时复制 (Copy-On-Write) 的机制, 以确保在读取和写入操作之间的最终一致性的 List。</p><h2 id="1-Copy-On-Write"><a href="#1-Copy-On-Write" class="headerlink" title="1 Copy-On-Write"></a>1 Copy-On-Write</h2><p>Copy-On-Write 的特点概括起来就 2 个</p><blockquote><ol><li>读写分离</li><li>最终一致性</li></ol></blockquote><p>大体的实现如下:</p><blockquote><ol><li>在集合的内部统一维护着一个数组(链表) 的数据结构, 存储着用户的数据</li><li>用户读取数据时, 直接就从这个数据结构中获取数据即可</li><li>而在用户对内部的数据进行修改时, 则会对修改办法进行加锁, 串行地处理<blockquote><p>3.1 获取到锁的线程, 会直接从内部维护的数据结构直接拷贝一份相同的数据<br>3.2 对拷贝的数据进行修改<br>3.3 将修改后的数据设置到集合内部统一维护的数据结构</p></blockquote></li></ol></blockquote><p>这个过程中</p><blockquote><ol><li>变更的操作不会影响到读取的操作</li><li>变更后的数据, 也同样不会被立即读取到这就会造成一定时间的数据不一致</li><li>将变更后的数据, 重新设置到集合内部的统一的数据结构后, 最终都能读取到最新的数据, 也就是最终达到数据一致的效果</li></ol></blockquote><h2 id="2-CopyOnWriteArrayList-的实现原理"><a href="#2-CopyOnWriteArrayList-的实现原理" class="headerlink" title="2 CopyOnWriteArrayList 的实现原理"></a>2 CopyOnWriteArrayList 的实现原理</h2><p>经过上面的一大篇铺垫, 可能认为 CopyOnWriteArrayList 是一个很复杂的集合类, 实际就是一个简单的数组引用的修改。</p><p>下面通过分析源码的进行深入了解一下</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** 真正存储数据的数组 */</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到 CopyOnWriteArrayList 本质就是一个数组, 只是这个数组被 <strong>volatile</strong> 修饰了(volatile 只能保证对象的引用变更了, 能被所有线程感知到, 但是对引用里面的内容进行变更, 线程是无法感知到的)。</p><h3 id="2-1-读取操作"><a href="#2-1-读取操作" class="headerlink" title="2.1 读取操作"></a>2.1 读取操作</h3><p>我们先简单看一下 CopyOnWriteArrayList 的读操作</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 获取列表中第 index 位的内容     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">elementAt</span><span class="token punctuation">(</span><span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 获取存储数据的数组     */</span>    <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 直接返回当前的数组变量 array</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 获取指定数组对应位置的数据      */</span>    <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token class-name">E</span> <span class="token function">elementAt</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 通过索引读取到入参的数组的指定位置的数据</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看出来整个 get 方法很简单, 没有任何针对并发场景的处理 (CAS, 加锁等)。<br>因为这个读的操作不涉及都任何的数据变更, 简单实现获取数据的逻辑即可。</p><h3 id="2-2-新增数据"><a href="#2-2-新增数据" class="headerlink" title="2.2 新增数据"></a>2.2 新增数据</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        <span class="token comment">// 1. 通过一个可重入锁 lock, 保证写线程在同一时刻只有一个, 变为串行的执行</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 2. 获取到原本存数据的数组的引用</span>            <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 3. 获取到原本数组的长度</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            <span class="token comment">// 4. 创建新的数组, 并将旧数组的数据复制到新数组中</span>            <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 5. 往新数组最后一位添加新的数据</span>            newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token comment">// 截至到这一步, 虽然看起来我们已经对集合里面的数据做了修改,</span>            <span class="token comment">// 但是在这之前所有的线程读操作, 还是读取旧数组的数据</span>            <span class="token comment">// 6. 将旧数组引用指向新的数组, 上面的数组变量通过 volatile 修饰了, 将新的数组设置过去, 其他线程都会感知到这个变量变了</span>            <span class="token comment">// 所以变更后的数据, 这时其他线程可以读取到了</span>            <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 锁释放</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 更新集合里面的数组     */</span>    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setArray</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 直接将入参的数组赋值给当前的 array 属性</span>        array <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>整个 add 方法的逻辑整理如下</p><blockquote><ol><li>竞争锁, 获取锁成功的线程才能继续执行下面的逻辑</li><li>从旧的数组里面拷贝一个新的数组</li><li>追加新的数据到新数组的最后面</li><li>将新的数组替换集合里面的旧数组</li><li>释放锁</li></ol></blockquote><p>这里面涉及到 2 个并发相关的知识</p><blockquote><ol><li>可重入锁 ReentrantLock, 让整个写的操作变为串行</li><li>修饰 CopyOnWriteArrayList 数组变量的 array, 在数据替换后, 能构让其他线程感知到, 去读取最新的值</li></ol></blockquote><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><h3 id="3-1-Copy-On-Write-vs-读写锁"><a href="#3-1-Copy-On-Write-vs-读写锁" class="headerlink" title="3.1 Copy-On-Write vs 读写锁"></a>3.1 Copy-On-Write vs 读写锁</h3><p>Copy-On-Write 机制和读写锁都是通过读写分离的思想实现的, 但两者还是有些不同。</p><blockquote><ol><li>Copy-On-Write 对写操作做了锁控制, 确保写操作的数据正常, 而对读取操作不做任何的限制, 确保了读取的性能, 但是带来了一定时间 “脏数据” 的问题</li><li>读写锁: 对整个读写操作都加锁, 在有线程在读取数据, 写线程必须等待, 在写线程变更数据的过程, 读操作也必须等待写操作完成, 通过这种等待, 牺牲了一定的性能, 但是确保了数据的一致</li></ol></blockquote><h3 id="3-2-Copy-On-Write-的缺点"><a href="#3-2-Copy-On-Write-的缺点" class="headerlink" title="3.2 Copy-On-Write 的缺点"></a>3.2 Copy-On-Write 的缺点</h3><blockquote><ol><li>内存占用问题: 因为 Copy-On-Write 的写时复制机制, 所以在进行写操作的时候, 内存里会同时存在新旧两个对象, 这个会导致的内存差不多两倍的消耗, 如果这些对象占用的内存比较大, 可能会造成内存问题</li><li>数据一致性问题: Copy-On-Write 机制只能保证数据的最终一致性, 不能保证数据的实时一致性</li></ol></blockquote><h3 id="3-3-CopyOnWriteArrayList-适用的场景"><a href="#3-3-CopyOnWriteArrayList-适用的场景" class="headerlink" title="3.3 CopyOnWriteArrayList 适用的场景"></a>3.3 CopyOnWriteArrayList 适用的场景</h3><p>下面列举了几个读多写少的业务场景</p><blockquote><ol><li>系统配置管理: </li><li>系统黑白名单管理</li><li>应用内部缓存<br>…</li></ol></blockquote><p>列举的这几个基本都是一些变更不频繁, 但是读取高频的场景, 同时短时间的数据延迟同步影响不大, 所以还是挺适合 CopyOnWriteArrayList</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><a href="https://github.com/CL0610/Java-concurrency/blob/master/16.%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BCopyOnWriteArrayList/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BCopyOnWriteArrayList.md">并发容器之CopyOnWriteArrayList</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java LinkedList</title>
      <link href="/article/2021/2368526883/"/>
      <url>/article/2021/2368526883/</url>
      
        <content type="html"><![CDATA[<p>LinkedList 一个双向链表。<br>本身是基于链表进行封装的列表, 所以具备了链表的特性: 变更简单, 容量是无限的, 不必像数组提前声明容量等。<br>同时 LinkedList 支持存储包括 null 在内的所有数据类型。</p><h2 id="1-链表"><a href="#1-链表" class="headerlink" title="1 链表"></a>1 链表</h2><p>了解 LinkedList 之前, 我们需要先了解一下双向链的特点</p><blockquote><ol><li>单链表, 双链表, 循环链表的定义, 可以看一下<a href="https://www.jianshu.com/p/6ebedde370b0">这个</a></li><li>链表内存是散乱的, 每一个元素存储本身内存地址的同时还存储下一个元素的地址</li><li>链表具备了增删快, 查找慢的特点</li><li>LinkedList 是基于双向链表设计的, 所以具备了链表的特点</li></ol></blockquote><h2 id="2-LinkedList-中每个节点的定义"><a href="#2-LinkedList-中每个节点的定义" class="headerlink" title="2 LinkedList 中每个节点的定义"></a>2 LinkedList 中每个节点的定义</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>  <span class="token comment">/** 当前节点的内容 */</span>    <span class="token class-name">E</span> item<span class="token punctuation">;</span>    <span class="token comment">/** 下一个节点 */</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>    <span class="token comment">/** 上一个节点 */</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> prev<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> prev<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 当前节点的数据 = element</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token comment">// 当前节点的后置节点 = next</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token comment">// 当前节点的前置节点 = prev</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>Node 节点中除了指向下一个节点的 next, 还包含指向上一个节点的 prev, 所以 LinkedList 是一个双向的链表。</p><h2 id="3-LinkedList-中的几个属性"><a href="#3-LinkedList-中的几个属性" class="headerlink" title="3 LinkedList 中的几个属性"></a>3 LinkedList 中的几个属性</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> first<span class="token punctuation">;</span>    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> last<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-1-size"><a href="#3-1-size" class="headerlink" title="3.1 size"></a>3.1 size</h3><p>表示当前链表中的节点个数。</p><h3 id="3-2-first"><a href="#3-2-first" class="headerlink" title="3.2 first"></a>3.2 first</h3><p>整个双向链表的头节点</p><h3 id="3-3-last"><a href="#3-3-last" class="headerlink" title="3.3 last"></a>3.3 last</h3><p>整个双向链表的尾节点</p><p><strong>重要的就这个几个属性了</strong></p><h2 id="4-LinkedList-的构造方法"><a href="#4-LinkedList-的构造方法" class="headerlink" title="4 LinkedList 的构造方法"></a>4 LinkedList 的构造方法</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 构造函数 1: 无参构造函数</span>    <span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 构造函数 2: 给定一个 Collection 的构造</span>    <span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="4-1-无参的构造函数"><a href="#4-1-无参的构造函数" class="headerlink" title="4.1 无参的构造函数"></a>4.1 无参的构造函数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></code></pre><p>就是单纯的声明 LinkedList 的实例, 没有其他的逻辑了</p><h3 id="4-2-给定一个-Collection-的构造"><a href="#4-2-给定一个-Collection-的构造" class="headerlink" title="4.2 给定一个 Collection 的构造"></a>4.2 给定一个 Collection 的构造</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用自身无参的构造函数</span>    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将集合 c 添加到当前的链表中</span>    <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 将集合对象全部添加到当前链表中 */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用 addAll 重写方法在 size 的位置添加数据</span>    <span class="token keyword">return</span> <span class="token function">addAll</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 指定位置的批量插入 */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 判断 0 &lt;= index &lt;= size, 不满足抛出异常</span>    <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 集合转为数组</span>    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numNew <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// 需要插入的集合没有数据, 直接结束</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numNew <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">// pred: 新增的元素的将要插入的位置的前一个节点  </span>    <span class="token comment">// succ: 新增的元素的将要插入的位置的节点</span>    <span class="token comment">// 如果新增的元素的节点位置为 a, 那么 pred 就是 a 的前一位的节点, succ 就是 a 节点</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> pred<span class="token punctuation">,</span> succ<span class="token punctuation">;</span>        <span class="token comment">// 需要添加的元素刚好追加在已有的后面的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        succ <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        pred <span class="token operator">=</span> last<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取指定位置的节点</span>        succ <span class="token operator">=</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        pred <span class="token operator">=</span> succ<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> o <span class="token operator">:</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">E</span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 第一次创建时, 那么第一个节点就是 first节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// 将 pred 的下一个节点指向新创建的节点</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>                    <span class="token comment">// 将 pred 改为当前节点, 方便下一个元素操作</span>        pred <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>       <span class="token comment">// succ 是为空的, 表示直接在已有的数据后面追加元素的话, 所以将最后节点设置为新增元素的最后一个元素的节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>succ <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        last <span class="token operator">=</span> pred<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 原有数据后半部分拼接到现在链表的后半部分</span>        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> succ<span class="token punctuation">;</span>        succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// 当前的长度</span>    size <span class="token operator">+=</span> numNew<span class="token punctuation">;</span>    <span class="token comment">// 修改次数加1 </span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 校验 index 的值满足:  0 &lt;= index &lt;= size */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* * 判断 index 是否大于等于 0 并且小于等于 size */</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isPositionIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> index <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;=</span> size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 获取指定位置的节点 */</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 此次做了一个小优化: 当要查找的位置小于现有数据的一半, 从前往后找, 大于的话, 从后面开始找</span>    <span class="token comment">// size >> 1 相当于 size / 2</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 从前向后找</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 从后向前找</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>            x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>从代码可知  </p><blockquote><ol><li>LinkedList 是基于双向链表实现了</li><li>LinkedList 的数据是通过 first(节点) 和 last(节点) 和 size 三个共同维护的</li><li>LinkedList 内部的数据通过泛型, 保持了自己的类型, 没有转为 Object。</li></ol></blockquote><h2 id="5-LinkedList-几个常用的方法"><a href="#5-LinkedList-几个常用的方法" class="headerlink" title="5 LinkedList 几个常用的方法"></a>5 LinkedList 几个常用的方法</h2><h3 id="5-1-1-添加数据"><a href="#5-1-1-添加数据" class="headerlink" title="5.1.1  添加数据"></a>5.1.1  添加数据</h3><p><strong>直接在链表末尾添加元素</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 直接添加一个元素</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 默认新增到链表的末尾</span>    <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 将入参的元素添加到链表的末尾 */</span><span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取链表的尾结点</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>    <span class="token comment">// 将数据封装为 Node 节点</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 链表的尾结点等于新的节点</span>    last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token comment">// 如果链表一开始的尾结点为空, 表示链表一开始没有数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token comment">// 链表的头节点也等于当前的新节点</span>        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment">// 一开始的为节点有值, 将原来的尾结点的下一个节点设置为当前新的节点</span>        l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>            <span class="token comment">// 链表个数 + 1</span>    size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 修改次数 + 1</span>    modCount<span class="token operator">++</span>    <span class="token punctuation">&#125;</span></code></pre><p><strong>指定位置的插入</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 判断 0 &lt;= index &lt;= size, 不满足抛出异常</span>    <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// index == size 要插入的位置刚好在末尾</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span>        <span class="token function">linkLast</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         <span class="token comment">// 插入到某个节点的前面</span>        <span class="token function">linkBefore</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">/** * 将元素插入到某个节点的前面 */</span><span class="token keyword">void</span> <span class="token function">linkBefore</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> succ<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取某个节点的前置节点</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> pred <span class="token operator">=</span> succ<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> succ<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置插入位置的节点的前置节点为需要插入的新节点</span>    succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token comment">// 插入位置的节点的前置节点为空, 表示没有头节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token comment">// 需要插入的位置的前置节点的下一个节点为新节点</span>        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token comment">// 个数加 1</span>    size<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">// 修改次数 + 1</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span></code></pre><p><strong>在头部插入</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">linkFirst</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 在链表的头节点前新增元素 */</span> <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取头节点</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 头节点等于新节点</span>    first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token comment">// 原本的头节点为空, 表示没有数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token comment">// 设置尾节点为新节点</span>        last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment">// 设置原本的头节点的前置节点为当前的节点</span>        f<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span></code></pre><p>还有前面看到的</p><blockquote><ol><li>插入一个 Collection 的 <strong>addAll(Collection c)</strong></li><li>指定位置的插入一个 Collection 的 <strong>addAll(int index, Collection c)</strong></li></ol></blockquote><h3 id="5-1-2-删除数据"><a href="#5-1-2-删除数据" class="headerlink" title="5.1.2 删除数据"></a>5.1.2 删除数据</h3><p><strong>直接删除 (默认删除第一个元素)</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 删除链表第一个元素 */</span><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>    <span class="token comment">// 头节点为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">unlinkFirst</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 删除指定的节点 */</span><span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">unlinkFirst</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取删除节点的数据</span>    <span class="token keyword">final</span> <span class="token class-name">E</span> element <span class="token operator">=</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token comment">// 找到删除元素的下一个元素</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> next <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment">// 清空删除元素的信息</span>    f<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    f<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">// 将头节点重新设置为删除元素的下一个元素</span>    first <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token comment">// 如果原本删除元素就是没有后续元素时, 将最后的元素设置为 null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        last <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token comment">// 将新的第一个元素的前置节点设置为 null</span>        next<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token comment">// 元素个数 - 1    </span>    size<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token comment">// 修改次数 + 1</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 返回数据</span>    <span class="token keyword">return</span> element<span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span></code></pre><p><strong>指定位置的删除</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 检测删除的位置是否正确</span>    <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">checkElementIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果不满足  0 &lt;= index &lt; size, 就抛出异常</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isElementIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> index <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">E</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">E</span> element <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token comment">// 得到将要移除的元素的后置节点</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> next <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment">// 得到将要移除的元素的前置节点</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> prev <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token comment">// 如果前置节点为空, 说明移除的为头节点, 重新设置头节点为删除节点的后置节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        first <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 将前置节点的下一个节点设置为后置节点</span>        prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token comment">// 设置删除节点前置节点为 null</span>        x<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 如果后置节点为空, 说明移除的为尾节点, 重新设置尾节点为删除节点的前置节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        last <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 将后置节点的前置节点设置为前置节点</span>        next<span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token comment">// 设置删除节点后置节点为 null</span>        x<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 将删除节点的数据设置为 null</span>    x<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    size<span class="token operator">--</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> element<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>指定删除元素</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 需要删除的节点为 null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 找到第一个为 null 的元素, 进行删除</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 找到节点的数据等于要删除的节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>除了上面几个还有</p><blockquote><ol><li>删除第一个 removeFirst()</li><li>删除最后一个 removeLast()</li><li>删除第一个符合的元素 removeFirstOccurrence(Object o)</li><li>删除最后一个符合的元素 removeLastOccurrence(Object o)</li></ol></blockquote><h3 id="5-1-3-获取数据"><a href="#5-1-3-获取数据" class="headerlink" title="5.1.3 获取数据"></a>5.1.3 获取数据</h3><p><strong>获取指定位置的数据</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 确保 0 &lt;= index &lt; size</span>    <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 定位到对应位置的节点的数据</span>    <span class="token keyword">return</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>获取第一个的数据</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>获取最一个的数据</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> l<span class="token punctuation">.</span>item<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="5-1-4-更新数据"><a href="#5-1-4-更新数据" class="headerlink" title="5.1.4 更新数据"></a>5.1.4 更新数据</h3><p><strong>更新指定位置节点的属性值</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 确保 0 &lt;= index &lt; size</span>    <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取指定位置的节点数据</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x <span class="token operator">=</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取指定节点是旧数据</span>    <span class="token class-name">E</span> oldVal <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token comment">// 更新指定节点的数据</span>    x<span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>    <span class="token comment">// 返回旧数据</span>    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="6-LinkedList-补充"><a href="#6-LinkedList-补充" class="headerlink" title="6 LinkedList 补充"></a>6 LinkedList 补充</h2><p><strong>1. LinkedList 实现了 Serializable 接口, 但是他的属性都是设置为 transient ?</strong></p><p>LinkedList 重写了序列化方法 <code>writeObject</code> 和反序列化方法 <code>readObject</code>。 在序列化中, 重新通过遍历所有节点, 把所有节点数据写入到 ObjectOutputStream。</p><p><strong>2. LinkedList 支持 fail-fast 机制 ?</strong></p><p>通过继承关系可以指定 LinkedList 也是实现了 AbstractList,  具备了 <code>modCount</code>, 在修改中也会增加 <code>modCount</code> 的值, 所以 LinkedList 也支持 fail-fast 机制。</p><p><strong>3. LinkedList不是一个线程安全的集合 ?</strong></p><p>LinkedList 是线程不安全的, 如果需要保证线程的安全性, 可以考虑使用 Collections.synchronizedList(Lise l) 函数返回一个线程安全的 LinkedList 类。</p><p><strong>4. 不要用 for 遍历 LinkedList ?</strong></p><p>遍历的代码</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span> item <span class="token operator">=</span> list2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>源码中涉及的代码: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedList</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>如上: 我们通过 for 遍历 LinkedList, </p><blockquote><ol><li>第一次 get(0), node(0), 就是 first 节点</li><li>第二次 get(1), node(1), 就是 first -&gt; node1</li><li>第三次 get(2), node(2), 就是 first -&gt; node1 -&gt; node2</li></ol></blockquote><p>每次通过 get() 就是需要从第一个节点一直找到对应的位置, 才能找到需要的节点。<br>所以遍历 LinkedList 可以使用 foreach (foreach 循环的原理就是迭代器) 或者迭代器。</p><p><strong>5. LinkedList 还有其他的作用吗</strong></p><p>LinkedList 实现了 Deque 接口,  所以 LinkedList 可以作为双端队列, 同时 LinkedList 的双向链表的特点, 还可以作为 Stack 使用, 但是 LinkedList 的这 2 个功能,<br>如果没有什么特殊的要求的话, 都可以使用 ArrayDeque 替代, 后者的性能更好。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 锁信息</title>
      <link href="/article/2021/364637211/"/>
      <url>/article/2021/364637211/</url>
      
        <content type="html"><![CDATA[<h2 id="1-MySQL-锁定义"><a href="#1-MySQL-锁定义" class="headerlink" title="1 MySQL 锁定义"></a>1 MySQL 锁定义</h2><p>MySQL 锁 (Lock) 是数据库管理系统用于管理并发访问的一种机制。<br>在多用户同时访问数据库的环境下，可能会出现多个事务同时对相同的数据进行读取或写入操作，为了保证数据的一致性和完整性，需要使用锁来控制对数据的访问。</p><p>在并发环境下，当多个事务试图同时访问相同的数据时，锁可以确保只有一个事务能够成功地获取对数据的访问权限，其他事务需要等待或被阻塞，直到获得相应的锁为止。<br>锁的主要作用是防止多个事务同时对同一数据进行不一致的修改，从而避免数据的丢失、错误或混乱。</p><p>总的来说，MySQL 锁是用于管理并发访问的机制，通过控制对数据的访问权限，确保多个事务之间不会发生冲突，从而维护数据的一致性和完整性。</p><h2 id="2-锁的一些概念"><a href="#2-锁的一些概念" class="headerlink" title="2 锁的一些概念"></a>2 锁的一些概念</h2><h3 id="2-1-行级锁和表级锁"><a href="#2-1-行级锁和表级锁" class="headerlink" title="2.1 行级锁和表级锁"></a>2.1 行级锁和表级锁</h3><p>一般情况下, 数据库都会支持 2 种不同的<strong>锁方式</strong></p><blockquote><ol><li>表锁, 直接锁住整张表数据</li><li>行锁, 锁住表里面的特定行数据</li></ol></blockquote><p>区别</p><blockquote><ol><li>从锁定粒度上看, 表锁肯定是大于行锁的</li><li>从加锁效率上看, 表锁快于行锁。表锁只需要直接锁住这张表就行了, 而行锁, 还需要在表里面去检索这一行数据</li><li>从冲突的概率上看, 表锁大于行锁。在表锁上, 其他任何一个事务都不能操作这张表, 但是行锁, 其他的事务还可以来操作表里面其他行的数据</li></ol></blockquote><p>注: MyISAM 只支持表级锁。</p><h3 id="2-2-共享锁和排他锁"><a href="#2-2-共享锁和排他锁" class="headerlink" title="2.2 共享锁和排他锁"></a>2.2 共享锁和排他锁</h3><p>共享锁, 也可以叫做读锁。它允许多个事务同时对相同的资源 (通常是数据库中的某个数据) 进行读取操作，而不允许任何事务在同一时间内对该资源进行写入操作。<br>共享锁通常用于实现读取的并发性，多个事务可以同时读取同一份数据而不会相互干扰。</p><p>排他锁, 也可以叫做写锁。它用于确保在某一时刻只有一个事务能够对资源进行写入操作。<br>当一个事务获得了排他锁，其他事务无法同时获得相同资源的共享锁或排他锁，从而阻止了其他事务对该资源的读取或写入操作。</p><p><strong>行级锁和表级锁 + 共享锁和排他锁</strong>之间两两配合, 基本就构成了整个 MySQL 所有锁的形式</p><blockquote><ol><li>共享行锁</li><li>排他行锁</li><li>共享表锁</li><li>排他表锁</li></ol></blockquote><h2 id="3-MySQL-InnoDB-锁的基本类型"><a href="#3-MySQL-InnoDB-锁的基本类型" class="headerlink" title="3 MySQL InnoDB 锁的基本类型"></a>3 MySQL InnoDB 锁的基本类型</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html">官网</a>把 InnoDB 的锁分成了 8 大类</p><blockquote><ol><li>Shared and Exclusive Locks</li><li>Intention Locks</li><li>Record Locks</li><li>Gap Locks</li><li>Next-Key Locks</li><li>Insert Intention Locks</li><li>AUTO-INC Locks</li><li>Predicate Locks for Spatial Indexes</li></ol></blockquote><p>备注: 下面锁的分析场景都需要关闭自动提交, 否则每一条语句执行完就自动提交, 事务就结束了, 达不到验证的效果,<br>可以在同一个 session 中执行 <strong>set autocommit &#x3D; 0;</strong>, 临时关闭自动提交。</p><h3 id="3-1-Shared-and-Exclusive-Locks"><a href="#3-1-Shared-and-Exclusive-Locks" class="headerlink" title="3.1 Shared and Exclusive Locks"></a>3.1 Shared and Exclusive Locks</h3><p>共享和排他锁。</p><p>Shared Locks (共享锁, 简称 S 锁), 可以细分为 <strong>共享行锁 + 共享表锁</strong>, 主要用于支持多个事务同时读取相同的数据, <strong>并发读取</strong>, 但阻止对同一数据的写入操作。<br>注意不要在加上了读锁以后去写数据, 不然的话可能会出现死锁的情况。<br>共享锁可以用 <code>select …… lock in share mode</code> 的方式手动加共享锁, 只要事务结束, 锁就会自动释放。  </p><p>Exclusive Locks (排他锁, 简称 X 锁), 同样可以细分为 <strong>排他行锁 + 排他表锁</strong>, 主要用于确保在某一时刻只有一个事务能够对数据进行写入操作，<strong>独占写入</strong>, 阻止其他事务对同一数据进行读取或写入。  </p><p>排他锁的加锁方式有三种</p><blockquote><ol><li>自动加排他锁, 在操作数据的时候, 包括增删改, 都会默认加上一个排他锁</li><li>手工加排他锁, 可以用一个 <code>select …… for update</code> 给一行数据 (表) 加上一个排他锁, 其他事务操作相同资源时, <strong>进行阻塞</strong></li><li>手工加排他锁, 可以用一个 <code>select …… for update nowait</code> 给一行数据 (表), 加上一个排他锁, 其他事务操作相同资源时, <strong>直接拒绝</strong></li></ol></blockquote><h3 id="3-2-行锁的原理"><a href="#3-2-行锁的原理" class="headerlink" title="3.2 行锁的原理"></a>3.2 行锁的原理</h3><p>假设当前有一张表 t1, 有 2 个字段: </p><table><thead><tr><th align="center">字段名</th><th align="center">字段类型</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td></tr><tr><td align="center">name</td><td align="center">varchar</td><td align="center"></td></tr></tbody></table><p>同时, 表中已经有 2 条数据:  </p><table><thead><tr><th align="center">id</th><th align="center">name</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">one</td></tr><tr><td align="center">2</td><td align="center">two</td></tr></tbody></table><p><strong>场景一</strong>  </p><p>假设当前表 t1 2 个字段的设置如下:  </p><table><thead><tr><th align="center">字段</th><th align="center">类型</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center">没有任何的索引</td></tr><tr><td align="center">name</td><td align="center">varchar</td><td align="center">没有任何的索引</td></tr></tbody></table><blockquote><ol><li>事务 A : <code>select * from t1 where id = 1 for update;</code>, 看起来是锁住 id &#x3D; 1 的行</li><li>事务 B : <code>select * from t1 where id = 2 for update;</code>, 这时候加锁失败, 阻塞住了</li><li>事务 C : <code>insert into t1 values(3, &#39;three&#39;)</code>, 这时候插入失败, 同样阻塞住了</li></ol></blockquote><p>通过上面的情景可以得到:   </p><p>分析</p><blockquote><ol><li>表中的所有字段都没有索引</li><li>这时事务 A 对 id &#x3D; 1 的记录加了锁</li><li>事务 B 尝试对 id &#x3D; 2 的记录加锁失败</li><li>事务 C 尝试向表新增一条记录, 也失败</li></ol></blockquote><p>做个猜想: <strong>InnoDB 的行锁的依赖索引实现的</strong></p><p><strong>场景二</strong> </p><p>假设当前表 t1 2 个字段的设置如下:  </p><table><thead><tr><th align="center">字段</th><th align="center">类型</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center">主键索引</td></tr><tr><td align="center">name</td><td align="center">varchar</td><td align="center">没有任何的索引</td></tr></tbody></table><p>现在表中已经有 2 条数据。</p><blockquote><ol><li>事务 A : <code>select * from t1 where id = 1 for update;</code>, 锁住 id &#x3D; 1 的行</li><li>事务 B : <code>select * from t1 where id = 1 for update;</code>, 尝试锁住 id &#x3D; 1 的行失败, 阻塞住</li><li>事务 C : <code>select * from t1 where id = 2 for update;</code>, 尝试锁住 id &#x3D; 2 的行, 成功</li><li>事务 D : <code>insert into t1 values(3, &#39;three&#39;)</code>, 新增记录成功</li></ol></blockquote><p>分析</p><blockquote><ol><li>表中的 id 为主键</li><li>这时事务 A 对 id &#x3D; 1 的记录加了锁</li><li>事务 B 尝试对 id &#x3D; 1 的记录加锁失败</li><li>事务 C 尝试对 id &#x3D; 2 的记录加锁成功</li><li>事务 D 尝试向表新增一条记录, 也失败</li></ol></blockquote><p>场景一和场景二表的区别就是 id 是否为主键<br>做个推测: <strong>InnoDB 的行锁的实现是通过主键索引实现的</strong></p><p><strong>场景三</strong>  </p><p>假设当前表 t1 2 个字段的设置如下: </p><table><thead><tr><th align="center">字段</th><th align="center">类型</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center">主键索引</td></tr><tr><td align="center">name</td><td align="center">varchar</td><td align="center">唯一索引</td></tr></tbody></table><blockquote><ol><li>事务 A : <code>select * from t1 where name = &#39;one&#39; for update;</code>, 锁住 name &#x3D; one 的行</li><li>事务 B : <code>select * from t1 where name = &#39;one&#39; for update;</code>, 尝试锁住 name &#x3D; one 的行失败, 阻塞住</li><li>事务 C : <code>select * from t1 where id = 1 for update;</code>, 尝试锁住 id &#x3D; 1 的行失败, 阻塞住</li><li>事务 D : <code>select * from t1 where id = 2 for update;</code>, 尝试锁住 id &#x3D; 2 的行, 成功</li></ol></blockquote><p>可以得出一个推测: InnoDB 的行锁, 既不是锁行记录, 也不是锁字段, 而是就是通过<strong>锁住索引</strong>来实现的。</p><p>备注: 上面整个过程实际是从结论推导过程, 所以不必太过深究, 只是为了验证 InnoDB 的行锁是通过锁索引实现的。</p><p>下面做个总结: </p><p><strong>在表中没有索引的时候, InnoDB 是如何加锁的</strong></p><p>索引的定义</p><blockquote><ol><li>如果我们定义了主键 (PRIMARY KEY), 那么 InnoDB 会选择主键作为聚集索引</li><li>如果没有显式定义主键, 则 InnoDB 会选择第一个不包含有 NULL 值的唯一索引作为主键索引</li><li>如果也没有这样的唯一索引, 则 InnoDB 会选择内置 6 字节长的 ROWID 作为隐藏的聚集索引, 它会随着行记录的写入而主键递增</li></ol></blockquote><p>所以 InnoDB 在没有任何索引时, 会通过内置的 ROWID 作为索引, 然后借助锁住这个索引达到加锁效果</p><p><strong>在表中没有索引的时候, 查询一行记录, 为什么也会导致锁全表</strong></p><p>上面知道, 没有任何索引时, InnoDB 通过锁住内置的 ROWID 索引达到加锁效果。<br>但是在查询时, 查询条件的字段和 ROWID 之间如何对应呢?<br>比如条件 id &#x3D; 1, 那么他对应的 ROWID 是多少呢? InnoDB 无法确定, 所以最保险的做法就是整张表锁住。  </p><p>所以查询没有使用索引, 会进行全表扫描, 然后把每一个隐藏的聚集索引都锁住了。</p><p><strong>为什么通过唯一索引给数据行加锁, 主键索引也会被锁住</strong></p><p>通过辅助索引进行查询数据时, 先在辅助索引里面找到对应的主键的值, 然后再在主键索引里面查询数据。<br>所以我们通过辅助索引锁定一行数据的时候, 它跟我们检索数据的步骤是一样的, 会通过主键值找到主键索引, 然后锁定。</p><p><strong>表锁什么时候使用</strong><br>当一张表加锁时, 无法通过行锁锁住, 那么就会晋升为表锁, 也就是行锁无法锁住资源, 就直接通过表锁实现。</p><h3 id="3-3-意向锁"><a href="#3-3-意向锁" class="headerlink" title="3.3 意向锁"></a>3.3 意向锁</h3><h4 id="3-3-1-介绍"><a href="#3-3-1-介绍" class="headerlink" title="3.3.1 介绍"></a>3.3.1 介绍</h4><p>意向锁, 重点其实是<strong>意向</strong>, 有趋势但是还未做。<br>所以意向锁实际上是没有<strong>真正</strong>给表或者表中的行进行加锁操作, 而更像是给表打了一个标识, 表示有锁的意思。</p><p>意向锁是由数据库自己维护的 (非存储引擎维护), 同时 2 个意向锁都是<strong>表级别的锁</strong></p><blockquote><ol><li>给一行数据加上<strong>共享锁</strong>之前, 数据库会自动在这张表上面加一个<strong>意向共享锁</strong> (Intention Sharded Lock, 简称 IS 锁)</li><li>给一行数据加上<strong>排他锁</strong>之前, 数据库会自动在这张表上面加一个<strong>意向排他锁</strong> (Intention Exclusive Lock, 简称 IX 锁)</li></ol></blockquote><p>也就是说:  </p><blockquote><ol><li>如果一张表上面至少有一个<strong>意向共享锁</strong>, 说明有其他的事务给表中的某些数据行加上了<strong>共享锁</strong>  </li><li>如果一张表上面至少有一个<strong>意向排他锁</strong>, 说明有其他的事务给表中的某些数据行加上了<strong>排他锁</strong></li></ol></blockquote><h4 id="3-3-2-特点"><a href="#3-3-2-特点" class="headerlink" title="3.3.2 特点"></a>3.3.2 特点</h4><p>意向锁的特点:  </p><blockquote><ol><li>2 个意向锁之间不像共享和排他锁是互斥的, 他们之间是互相兼容的</li><li>2 个意向锁都是表级别锁, 所以只会影响到表级别的共享锁和排他锁, 对行级别的共享锁和排他锁无影响</li></ol></blockquote><p>举个例子吧<br>假设现在有一张表 t1, 数据如下</p><table><thead><tr><th align="center">id</th><th align="center">name</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">one</td></tr><tr><td align="center">2</td><td align="center">two</td></tr><tr><td align="center">3</td><td align="center">three</td></tr></tbody></table><p>情况一, id 是主键</p><blockquote><ol><li>事务 A : <code>select * from t1 where id = 1 for update;</code>, 这时表 t1 在行 id &#x3D; 1 上有一个行级别排他锁, 同时表上有一个意向排他锁</li><li>事务 B : <code>select * from t1 where id = 2 lock in share mode;</code>, 尝试给 id &#x3D; 2 加上行级别共享锁, 虽然表上已经有意向排他锁, 但是意向锁不互斥, 同时意向锁不影响行锁, 所以 2 个锁都加成功</li><li>事务 C : <code>select * from t1 where id = 3 for update;</code>, 尝试给 id &#x3D; 3 加上行级别排他锁, 意向锁不互斥和意向锁不影响行锁, 所以还是加锁成功</li></ol></blockquote><p>可以发现</p><blockquote><ol><li>意向锁都是表级别的锁, 不会影响到行级别的锁</li><li>意向锁互不影响</li></ol></blockquote><p>情况二, id 是主键, name 没有任何索引</p><blockquote><ol><li>事务 A : <code>select * from t1 where id = 1 for update;</code>, 这时表 t1 在行 id &#x3D; 1 上有一个行级别排他锁, 同时表上有一个意向排他锁</li><li>事务 B : <code>select * from t1 where name = &#39;one&#39; for update;</code>, 没有使用索引, 需要加表级别排他锁, 但是发现上面已经有一个意向排他锁, 加锁失败, 阻塞</li><li>事务 C : <code>select * from t1 where name = &#39;one&#39; lock in share mode;</code>, 没有使用索引, 需要加表级别共享锁, 但是发现上面已经有一个意向排他锁, 加锁失败, 阻塞</li></ol></blockquote><p>可以发现</p><blockquote><ol><li>事务 A 只是给表中的某一行加了一个行级别的排他锁, 同时给表加了一个意向排他锁</li><li>事务 B 试图给表加上表排他锁, 需要先确定表中没有其他锁, 在没有意向锁时, 需要遍历所有行确定这个结论, 但是现在有意向锁, 直接知道表中某些行有锁, 可以确定不能加了</li><li>事务 C 同理</li></ol></blockquote><p>各个锁之间的兼容关系如下</p><p>|     | 共享锁 (S ) | 排他锁 (X) | 共享意向锁 (IS) | 排他意向锁 (IX) |<br>| :-: |:-: |:-: |:-: |<br>| 共享锁 (S ) | 兼容 | 排斥 | 兼容 | 排斥 |<br>| 排他锁 (X)  | 排斥 | 排斥 | 排斥 | 排斥 |<br>| 共享意向锁 (IS) | 兼容 | 排斥 | 兼容 | 兼容 |<br>| 排他意向锁 (IX) | 排斥 | 排斥 | 兼容 | 兼容 |</p><h4 id="3-3-3-意义"><a href="#3-3-3-意义" class="headerlink" title="3.3.3 意义"></a>3.3.3 意义</h4><p>两个意向锁存在的意义</p><blockquote><ol><li>有了 2 个意向锁, 在 InnoDB 里面就可以支持更多粒度的锁, 特定场景下, 行级锁可以与表级锁共存 (共享锁和共享意向锁基本都是兼容的, 已经存在共享表锁时, 可以支持共享行锁)</li><li>可以把它理解成一个标志, 是用来提高加表锁的效率的。 比如要给一张表加表锁, 那么就需要判断是否有行锁, 先要判断有没其他的事务锁定了其中了某些行, 有了意向锁这个标志, 就可以不去遍历行</li></ol></blockquote><h3 id="3-4-锁算法"><a href="#3-4-锁算法" class="headerlink" title="3.4 锁算法"></a>3.4 锁算法</h3><p>Record Locks、Gap Locks、Next-Key Locks 虽然官方将他们分为锁的类型, 但是更形象的说法是<strong>锁的算法</strong>, 也就是在什么情况下锁定什么范围。</p><p>假设当前有一张表 t, 有 2 个字段: </p><blockquote><ol><li>int 类型的 id, 是主键索引</li><li>varchar 类型的 name</li></ol></blockquote><p>表中当前有 4 条数据, id 分别为 1, 4, 7, 10。</p><table><thead><tr><th align="center">id</th><th align="center">name</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">4</td><td align="center">4</td></tr><tr><td align="center">7</td><td align="center">7</td></tr><tr><td align="center">10</td><td align="center">10</td></tr></tbody></table><h4 id="3-4-1-几个名词的定义"><a href="#3-4-1-几个名词的定义" class="headerlink" title="3.4.1 几个名词的定义"></a>3.4.1 几个名词的定义</h4><p><img src="https://pic.imgdb.cn/item/65f2e40c9f345e8d030d7874.png" alt="Alt &#39;记录&#39;"></p><p>表里面存在的数据的行, 就叫做 Record (记录), 当前 t 表有 4 个 Record。</p><p><img src="https://pic.imgdb.cn/item/65f2e40f9f345e8d030d89e2.png" alt="Alt &#39;间隙&#39;"></p><p>在表中, Record 和 Record 之间可能存在一段数据不存在的区间, 叫做 Gap (间隙), 它是一个左开右开的区间, 当前 t 表这里有 5 个 Gap。</p><p><img src="https://pic.imgdb.cn/item/65f2e4119f345e8d030d9605.png" alt="Alt &#39;临键&#39;"></p><p>间隙 (Gap) 连同右边的记录 (Record), 公共组成的区间, 叫做 Next-Key (临键), 它是一个左开右闭的区间, 当前 t 表这里有 4 个 Next-Key。</p><h4 id="3-4-2-Record-Lock-记录锁"><a href="#3-4-2-Record-Lock-记录锁" class="headerlink" title="3.4.2 Record Lock - 记录锁"></a>3.4.2 Record Lock - 记录锁</h4><p>只对表中的某行记录加锁, 就是记录锁。</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">4</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">and</span> id <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span></code></pre><p>上面 2 个 SQL 都可以查询唯一一条记录: id &#x3D; 4 的记录。<br>像这种通过<strong>唯一索引 (主键也属于唯一索引)</strong> 进行查询的语句, 同时查询结果明确<strong>只有 1 条记录</strong>的情况, 就是使用到了记录锁。<br>记录锁主要用于唯一性的索引 (包括唯一索引和主键索引), 非唯一性索引的只会出现间隙锁或临键锁。  </p><p>记录锁是一个排他锁, 会<strong>阻塞</strong>其他事务对对应记录的<strong>所有相关</strong>操作。</p><h4 id="3-4-3-Gap-Lock-间隙锁"><a href="#3-4-3-Gap-Lock-间隙锁" class="headerlink" title="3.4.3 Gap Lock - 间隙锁"></a>3.4.3 Gap Lock - 间隙锁</h4><p>在记录和记录之间存在着某些间隙, 对这些间隙进行加锁, 就是间隙锁。</p><p><strong>特别说明:</strong></p><blockquote><ol><li>间隙锁主要是阻塞插入 insert, 对于删改查都不会有影响, 查很容易理解, 删改, InnoDB 的 MVCC 机制可以保证数据在事务中的正常</li><li>相同的间隙锁之间不冲突, 2 个间隙锁的区间可以是包含关系, 也可以是部分重叠</li><li>间隙锁只在 RR 的隔离级别出现, 所以将隔离级别修改成别的, 可以关闭间隙锁功能</li><li>另一种关闭间隙锁的方式, 将 <code>innodb_locks_unsafe_for_binlog</code> 设置为 0, 这时候除了外键约束和唯一性检查会加间隙锁, 其他情况都不会用间隙锁</li></ol></blockquote><p>例子:</p><blockquote><ol><li>事务 A: <code>select * from t where id = 6 for update;</code>, 找不到, 导致 4 - 7 之间出现间隙锁</li><li>事务 B: <code>insert into t (&#39;id&#39;, &#39;name&#39;) values(5, &#39;5&#39;);</code> 在 4 - 7 之间有间隙锁, 插入失败</li><li>事务 C: <code>select * from t where id = 6 for update;</code>, 查询结果为空, 没有被阻塞</li></ol></blockquote><h4 id="3-4-4-Next-Key-Lock-临键锁"><a href="#3-4-4-Next-Key-Lock-临键锁" class="headerlink" title="3.4.4 Next-Key Lock - 临键锁"></a>3.4.4 Next-Key Lock - 临键锁</h4><p>将记录和记录之间的间隙一起加锁, 就是临键锁。</p><p><strong>特别说明:</strong></p><blockquote><ol><li>临键锁就是 MySQL 里面默认的行锁算法, 等于<strong>间隙锁 + 记录锁</strong></li><li>临键锁等于<strong>间隙锁 + 记录锁</strong>, 所以其锁住的范围和间隙锁是相同的, 只是间隙中命中的记录会变成记录锁, 比如查询条件为 7, 那么间隙锁的范围为 (4, 10), 命中记录 7, 最终变为 (4, 7] 和 (7, 10)</li><li>临键锁会进行退化: 通过等值查询匹配到一条记录, 退化为记录锁</li><li>临键锁会进行退化: 使用唯一性索引, 没有匹配到任何记录的时候, 退化成间隙锁</li></ol></blockquote><p>使用唯一性索引, 临键锁锁住的是<strong>条件范围内, 小于等于查询范围最小值的最后一个索引 (可以是索引本身) + 大于等于查询范围最大值的第一个索引 (不包含索引本身) 间所有的索引记录 + 索引记录前边的间隙</strong>  </p><p>例子: </p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id <span class="token operator">></span> <span class="token number">5</span> <span class="token operator">and</span> id <span class="token operator">&lt;</span> <span class="token number">9</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span></code></pre><p>查询范围为 (5, 9),<br>小于等于查询范围最小值 (这里就是 5) 的最后一个索引 (这里是 4)<br>大于等于查询范围最大值 (这里就是 9) 的第一个索引 (这里是 10)<br>所以这条 SQL 锁住的范围为 (4, 7] 和 (7, 10)</p><p>同理</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t2 <span class="token keyword">where</span> id <span class="token operator">></span> <span class="token number">5</span> <span class="token operator">and</span> id <span class="token operator">&lt;=</span> <span class="token number">7</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span></code></pre><p>这时候锁住的范围为 (4, 7] 和 (7, 10]</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t2 <span class="token keyword">where</span> id <span class="token operator">></span> <span class="token number">8</span> <span class="token operator">and</span> id <span class="token operator">&lt;=</span> <span class="token number">10</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span></code></pre><p>这时候锁住的范围为 (7, 10] 和 (10, +∞] </p><h4 id="3-4-5-非唯一性索引的锁算法"><a href="#3-4-5-非唯一性索引的锁算法" class="headerlink" title="3.4.5 非唯一性索引的锁算法"></a>3.4.5 非唯一性索引的锁算法</h4><p>上面讨论的锁算法讨论的都是唯一索引下的情况, 那么如果查询条件是非唯一索引 (值是可以重复的) 呢?</p><p>假设现在有一张表, id 的主键, num 是普通的索引, 表中有数据</p><table><thead><tr><th align="center">id (主键)</th><th align="center">num (普通索引)</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">6</td></tr><tr><td align="center">3</td><td align="center">2</td></tr><tr><td align="center">4</td><td align="center">2</td></tr><tr><td align="center">5</td><td align="center">3</td></tr><tr><td align="center">6</td><td align="center">5</td></tr><tr><td align="center">8</td><td align="center">5</td></tr><tr><td align="center">9</td><td align="center">5</td></tr><tr><td align="center">10</td><td align="center">3</td></tr></tbody></table><p>使用非唯一索引时, InnoDB 在使用锁的时候, <strong>会先按照非唯一索引进行排序, 非唯一索引排序后, 非唯一索引有相同值时, 会再按照主键排序</strong>, 所以排序后的变为</p><table><thead><tr><th align="center">id (主键)</th><th align="center">num (普通索引)</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">3</td><td align="center">2</td></tr><tr><td align="center">4</td><td align="center">2</td></tr><tr><td align="center">5</td><td align="center">3</td></tr><tr><td align="center">10</td><td align="center">3</td></tr><tr><td align="center">6</td><td align="center">5</td></tr><tr><td align="center">8</td><td align="center">5</td></tr><tr><td align="center">9</td><td align="center">5</td></tr><tr><td align="center">2</td><td align="center">6</td></tr></tbody></table><p>对于间隙锁的范围, 等值查询的一般情况下, 锁住的是 <strong>左区间是以当前条件向左找到第一条记录, 右区间是向右找到的第一条记录</strong><br>如果现在条件为 <code>where num = 4</code>,  num 4 向左找到的第一条记录为 (10, 3), 向右找到的第一条记录为 (6, 5), 所以这个条件锁住的间隙为 (3, 5), 在具体的是 (10, 3) 到 (6, 5)。<br>如果这时候想里面插入 (7, 5) 是能插入成功的, 因为不在上面说的范围内。</p><p>我们知道, <strong>当查询条件没有索引时, 会导致锁表</strong>, 所以下面讨论的是在有索引的情况:<br>影响锁的范围的影响因素</p><blockquote><ol><li>条件是否为唯一索引</li><li>查询的方式, 等值查询, 范围查询</li></ol></blockquote><p><strong>情况一: 唯一索引 + 等值查询</strong></p><blockquote><ol><li>命中了记录, 直接就是记录锁</li><li>未命中记录, 间隙锁, 锁住的就是包住这个条件的 2 个记录的区间, (注意上面间隙锁范围的说明)</li></ol></blockquote><p><strong>情况二: 唯一索引 + 范围查询</strong></p><p>使用范围查询的话, 基本锁住的范围就是条件限制的范围, 这个范围内的记录加上的都是记录锁。</p><p>需要说明的是, 如果 where <code>主键 &gt; 条件</code>, 这个条件不是记录, 那么会向左找到第一条记录, 以这条记录开始,<br>同理如果 where <code>主键 &lt; 条件</code>, 这个条件不是记录, 会向右找到第一条记录</p><p><strong>情况三: 非唯一索引 + 等值查询</strong></p><p>以这个条件, 向左找到第一条记录, 向右找到的第一条记录, 组成一个区间, 中间的记录为记录锁, 同时会锁住这条记录对应的主键索引。</p><p><strong>情况四: 非唯一索引 + 范围查询</strong></p><p>和唯一索引不同的, 非唯一索引, 还会增加 2 侧的间隙</p><blockquote><ol><li>where <code>非唯一索引 &gt; 条件</code>, 无论条件是否为记录, 都会向左找到第一条记录, 从这里开始加上条件的范围组成区间, 中间出现的记录都会加上记录锁, 同理 <code>where 非唯一索引 &lt; 条件</code> 会向右找到第一条记录, 加上条件的范围。</li></ol></blockquote><h3 id="3-5-其他几个锁"><a href="#3-5-其他几个锁" class="headerlink" title="3.5 其他几个锁"></a>3.5 其他几个锁</h3><h4 id="3-5-1-插入意向锁"><a href="#3-5-1-插入意向锁" class="headerlink" title="3.5.1 插入意向锁"></a>3.5.1 插入意向锁</h4><p>插入意向锁是一种特殊的间隙锁, 但不同于间隙锁的是, 该锁只用于并发插入操作: 如果多个事务插入到相同的索引间隙中, 如果它们不在间隙中的相同位置插入, 则无需等待其他事务。<br>比如说有索引记录 4 和 7, 有两个事务想要分别插入 5, 6, 在获取插入行上的排它锁之前, 每个事务都使用插入意图锁锁定 4 和 7 之间的间隙, 但是不会互相阻塞, 因为行是不冲突的。<br>简单来说: 插入意向锁锁定了索引之间的间隙, 但是事务之间只要不插入同一个位置, 彼此之间是不会阻塞的。</p><h4 id="3-5-2-自增锁"><a href="#3-5-2-自增锁" class="headerlink" title="3.5.2 自增锁"></a>3.5.2 自增锁</h4><p>自增锁是一种比较特殊的表级锁, 主要用于在事务中插入自增字段。<br>通过 <code>innodb_autoinc_lock_mode</code> 配置控制自动增量锁定的算法, 允许用户在<code>可预测的自动增量值序列</code>和<code>插入操作的最大并发之间</code>进行权衡选择。</p><p>为了便于介绍 innodb_autoinc_lock_mode 参数, 先将需要用到自增锁的 Insert 语句进行分类</p><blockquote><ol><li>INSERT-like: 所有可以向表中增加行的语句, 包含 insert, insert … select, replace, replace … select, load data, insert … on duplicate key update 6 个语句</li><li>Simple inserts: 可以预先确定要插入的行数的语句, 直接的 insert 和 replace</li><li>Bulk inserts: 事先不知道要插入的行数的语句, insert … select, replace … select, load data</li><li>Mixed-mode inserts: 在 Simple inserts 语句的基础上, 部分行手动指定了自增列的值, 比如, insert into t1(id, name) values(1, ‘one’), (Null, ‘two’), (Null, ‘three’) 和 insert … on duplicate key update 语句</li></ol></blockquote><p>innodb_autoinc_lock_mode 三种取值的含义</p><p><strong>traditional (取值: 0)</strong></p><p>在此锁定模式下, 所有 “INSERT-like” 语句获得一个特殊的表级 AUTO-INC 锁, 用于插入具有 AUTO_INCREMENT 列的表。<br>此锁定通常保持到 insert 语句结束 (不是事务结束) , 以确保为给定的INSERT语句序列以可预测和可重复的顺序分配自动递增值, 并确保自动递增由任何给定语句分配的值是连续的。</p><p>在<strong>基于语句复制 (statement-based replication</strong>) 的情况下, 这意味着当在从服务器上复制 SQL 语句时, 自动增量列使用与主服务器上相同的值。多个 INSERT 语句的执行结果是确定性的, 从服务器再现与主服务器相同的数据</p><p><strong>consecutive (取值: 1)</strong></p><p>在此锁定模式下, “Simple inserts” (要插入的行数事先已知) , 不使用表级 AUTO-INC 锁, 而是通过在 mutex (轻量锁) 的控制下获得所需数量的自动递增值来避免表级 AUTO-INC 锁, 它只在分配过程的持续时间内保持, 而不是直到语句完成。<br>当然: 如果另一个事务保持 AUTO-INC 锁, 则 “Simple inserts” 则需要等待 AUTO-INC 锁, 然后按照 “Bulk inserts” 处理。</p><p>此锁定模式确保, 当有行数不预先知道的 INSERT 存在时, 任何 “INSERT-like” 语句分配的所有自动递增值是连续的, 并且对于基于语句的复制 (statement-based replication) 操作是安全的。<br>此模式大体是和 traditional 一致的。但有个特殊场景需要注意: 混合模式的插入, 可能会有部分多余自增值丢失。<br>InnoDB 分配比要插入的行数更多的自动增量值。但是, 所有自动分配的值都是连续生成的 (因此高于) 由最近执行的前一条语句生成的自动增量值, “多余” 的数字丢失。</p><p><strong>interleaved (取值: 2)</strong></p><p>在此锁定模式下, 所有 “INSERT-like” 语句不使用 AUTO-INC 锁, 可以同时执行多个语句, 这是最快和最可扩展的锁定模式。</p><p>但是当使用基于语句的复制或恢复方案时, 从二进制日志重播SQL语句时, 这是不安全的</p><p>在此锁定模式下, 自动递增值保证在所有并发执行的 “INSERT-like” 语句中是唯一且单调递增的。但是, 由于多个语句可以同时生成数字 (即, 跨语句交叉编号) , 为任何给定语句插入的行生成的值可能不是连续的。<br>如果执行的语句是 “simple inserts”, 其中要插入的行数已提前知道, 则除了 “Mixed-mode inserts” 之外, 为单个语句生成的数字不会有间隙。然而, 当执行 “Bulk inserts”时, 在由任何给定语句分配的自动递增值中可能存在间隙。</p><p>如果不使用二进制日志作为恢复或复制的一部分来重放 SQL 语句, 则可以使用 interleaved 模式来消除所有使用表级 AUTO-INC 锁, 以实现更大的并发性和性能, 其代价是由于并发的语句交错执行, 同一语句生成的 AUTO-INCREMENT 值可能会产生间隙。</p><p>Binlog 一般用于 MySQL 的数据复制, 通俗一点就是用于主从同步。在 MySQL 中 Binlog 的格式有 3 种, 分别是:</p><blockquote><ol><li>Statement: 基于语句, 只记录对数据做修改的 SQL 语句, 能够有效的减少 binlog 的数据量, 提高读取, 基于 Binlog 重放的性能</li><li>Row: 只记录被修改的行, 所以 Row 记录的 binlog 日志量一般来说会比 Statement 格式要多</li><li>Mixed: Statement 和 Row 的结合, 怎么个结合法呢。表结构变更使用 statement 模式来记录, 如果 SQL 语句是 update 或者 delete 语句, 那么使用 row 模式</li></ol></blockquote><p>如果 MySQL 采用的格式为 Statement, 那么 MySQL 的主从同步实际上同步的就是一条一条的 SQL 语句。如果此时采用了交叉模式, 那么并发情况下 INSERT 语句的执行顺序就无法得到保障。<br>INSERT 同时交叉执行, 并且 AUTO_INCREMENT 交叉分配将会直接导致主从之间同行的数据主键 ID 不同。</p><p>和自增锁相关的三个参数</p><blockquote><ol><li>auto_increment_offset: 表示起始数字</li><li>auto_increment_increment: 表示自增的步长 (即每次增加 n 个数字, 2 就代表每次 +2)</li><li>innodb_autoinc_lock_mode: 加锁的模式, 可以设定 3 个值, 0, 1, 2, 默认为 1</li></ol></blockquote><h4 id="3-5-3-空间索引的谓词锁"><a href="#3-5-3-空间索引的谓词锁" class="headerlink" title="3.5.3 空间索引的谓词锁"></a>3.5.3 空间索引的谓词锁</h4><p>InnoDB 支持对包含空间的列建立 SPATIAL 索引。</p><p>要处理涉及 SPATIAL 索引的操作的锁定, next-key 锁定不能很好地支持 REPEATABLE READ 或 SERIALIZABLE 事务隔离级别, 因为在多维数据中没有绝对排序概念, 因此不清楚哪个是邻键。<br>为了支持具有 SPATIAL 索引的表的隔离级别, InnoDB 使用谓词锁。SPATIAL 索引包含最小边界矩形 (MBR) 值, 因此 InnoDB 通过设置用于查询的 MBR 值的谓词锁来强制对索引进行一致读取。<br>此时, 其他事务不能插入或修改与查询条件匹配的行。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><a href="https://www.cnblogs.com/better-farther-world2099/articles/14955475.html">彻底搞懂 MySQL 中的锁机制</a><br><a href="https://nicky-chin.cn/2022/03/17/mysql-lock-struct/">mysql之innodb锁系统源码分析</a>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 事务</title>
      <link href="/article/2021/4103934888/"/>
      <url>/article/2021/4103934888/</url>
      
        <content type="html"><![CDATA[<h2 id="1-事务定义"><a href="#1-事务定义" class="headerlink" title="1 事务定义"></a>1 事务定义</h2><p>事务是数据库管理系统 (DBMS) 执行过程中的一个逻辑单位, 由一个有限的数据库操作序列构成, 这些操作要么都做, 要么都不做, 是一个不可分割的工作单位。</p><p>事务是数据库最小的工作单元, 是不可以再分的, 可能包含了一个或者一系列的 DML 语句。</p><h2 id="2-事务的作用"><a href="#2-事务的作用" class="headerlink" title="2 事务的作用"></a>2 事务的作用</h2><p>下面列举几个比较常见的作用: </p><p><strong>1. 确保数据完整性</strong><br>事务可以确保一系列操作作为一个整体被执行，要么全部成功，要么全部失败。这对于需要多步操作的复杂业务来说非常重要，如银行转账、订单处理等。</p><p><strong>2. 提供错误恢复机制</strong><br>如果在执行事务的过程中发生错误（例如，系统崩溃或其他问题），数据库可以利用事务日志回滚到事务开始前的状态，避免数据损坏或丢失。</p><p><strong>3. 支持并发控制</strong><br>在多用户环境中，事务提供了一种机制，使得每个用户可以独立地工作，同时防止他们的操作相互干扰。这是通过事务的隔离级别来实现的，例如，读已提交、可重复读、串行化等。</p><p><strong>4. 保持业务逻辑的一致性</strong><br>通过将相关的一系列数据库操作组合成一个事务，可以确保业务逻辑的一致性。如果不使用事务，那么在一系列操作中的某个点发生故障，可能会导致数据状态不一致。</p><h2 id="3-事务的四大特性"><a href="#3-事务的四大特性" class="headerlink" title="3 事务的四大特性"></a>3 事务的四大特性</h2><p>事务的四大特性: ACID</p><p><strong>Atomicity (原子性)</strong><br>对数据库的一系列的操作, 要么都是成功, 要么都是失败, 不可能出现部分成功或者部分失败的情况。</p><p>以转账的场景为例, 一个账户的余额减少, 对应一个账户的增加, 这两个一定是同时成功或者同时失败的。</p><p>在 InnoDB 里面是通过 undo log 来实现的, 它记录了数据修改之前的值 (逻辑日志) , 一旦发生异常, 就可以用 undo log 来实现回滚操作</p><p><strong>consistent (一致性)</strong><br>数据库的完整性约束没有被破坏, 事务执行的前后都是合法的数据状态。</p><p>比如说转账的这个场景, A 账户余额减少 1000, B 账户余额只增加了 500, 这个时候因为两个操作都成功了, 按照我们对原子性的定义, 它是满足原子性的, 但是它没有满足一致性, 因为它导致了会计科目的不平衡。</p><p><strong>Isolation (隔离性)</strong><br>多个事务, 对表或者行的并发操作, 是透明的, 互相不干扰的, 一个未完成事务不会影响另外一个未完成事务。</p><p><strong>Durable (持久性)</strong><br>一旦一个事务被提交, 它应该持久保存, 不会因为与其他操作冲突而取消这个事务。</p><p>持久性是通过 redo log 和 double write 双写缓冲来实现的。<br>我们操作数据的时候, 会先写到内存的 buffer pool 里面, 同时记录 redo log, 如果在刷盘之前出现异常, 在重启后就可以读取 redo log 的内容, 写入到磁盘, 保证数据的持久性。<br>恢复成功的前提是数据页本身没有被破坏, 是完整的, 这个通过双写缓冲 (double write) 保证。</p><h2 id="4-数据库什么时候会出现事务"><a href="#4-数据库什么时候会出现事务" class="headerlink" title="4 数据库什么时候会出现事务"></a>4 数据库什么时候会出现事务</h2><p><strong>1. 自动开启和自动提交</strong></p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">update</span> 表名 <span class="token keyword">set</span> 字段 <span class="token operator">=</span> 值 <span class="token keyword">where</span> 条件<span class="token punctuation">;</span></code></pre><p>上面的 SQL 会自动开启了一个事务, 并且自动提交了, 所以最终写入了磁盘。</p><p>这种行为是通过 InnoDB 里面有一个 autocommit 的参数 (<code>show variables like &#39;autocommit&#39;;</code>) 控制的, 它的默认值是 on&#x2F;true,<br>表示在操作数据的时候, 会自动开启一个事务, 和自动提交事务。</p><p><strong>2. 手动开启和手动提交</strong></p><p>把 autocommit 设置成 false&#x2F;off, 那么数据库的事务就需要我们手动开启和手动结束。</p><p>手动开启事务的方法</p><blockquote><ol><li>begin</li><li>start transcation</li></ol></blockquote><p>手动提交事务&#x2F;手动撤销事务</p><blockquote><ol><li>commit</li><li>rollback</li><li>客户端的连接断开的时候, 事务也会结束</li></ol></blockquote><h2 id="5-事务并发会带来的问题"><a href="#5-事务并发会带来的问题" class="headerlink" title="5 事务并发会带来的问题"></a>5 事务并发会带来的问题</h2><h3 id="5-1-脏读"><a href="#5-1-脏读" class="headerlink" title="5.1 脏读"></a>5.1 脏读</h3><p>如图:</p><p><img src="https://pic.imgdb.cn/item/65f3b46f9f345e8d0325e2ad.png" alt="Alt &#39;脏读&#39;"></p><blockquote><ol><li>Transcation A 查询 id &#x3D; 1 的记录的 age &#x3D; 16</li><li>Transcation B 更新 id &#x3D; 1 的记录的 age &#x3D; 18, 但是还未提交事务</li><li>Transcation A 再次查询 id &#x3D; 1 的记录的 age &#x3D; 18</li></ol></blockquote><p>在一个事务里面, 由于其他的事务修改了数据并且没有提交, 而导致了前后两次读取数据不一致的情况, 这种事务并发的问题叫做 <strong>脏读</strong></p><h3 id="5-2-不可重复读"><a href="#5-2-不可重复读" class="headerlink" title="5.2 不可重复读"></a>5.2 不可重复读</h3><p>如图:</p><p><img src="https://pic.imgdb.cn/item/65f3b4739f345e8d0325edd6.png" alt="Alt &#39;不可重复读&#39;"></p><blockquote><ol><li>Transcation A 查询 id &#x3D; 1 的记录的 age &#x3D; 16</li><li>Transcation B 更新 id &#x3D; 1 的记录的 age &#x3D; 18, 并且提交了事务</li><li>Transcation A 再次查询 id &#x3D; 1 的记录的 age &#x3D; 18</li></ol></blockquote><p>一个事务里面, 读取到了其他事务已提交的数据导致前后两次读取数据不一致的情况, 这种事务并发的问题叫做 <strong>不可重复读</strong></p><h4 id="4-2-幻读"><a href="#4-2-幻读" class="headerlink" title="4.2 幻读"></a>4.2 幻读</h4><p>如图:</p><p><img src="https://pic.imgdb.cn/item/65f3b4769f345e8d0325f798.png" alt="Alt &#39;幻读&#39;"></p><blockquote><ol><li>Transcation A 查询 age &gt; 15 的记录总条数的 count &#x3D; 1</li><li>Transcation B 插入了一条 age &#x3D; 18 的记录, 并且提交了事务</li><li>Transcation A 再次查询 age &gt; 15 的记录总条数的 count &#x3D; 2</li></ol></blockquote><p>一个事务里面, 由于其他事务插入或者删除数据导致前后两次读取数据数据不一致, 这种事务并发的问题叫做 <strong>幻读</strong></p><p>幻读和不可重复读的区别:</p><blockquote><ol><li>不可重复读强调的是记录的修改</li><li>幻读强调的集合的增减</li></ol></blockquote><p>事务并发带来的三大问题, 无论是脏读, 还是不可重复读, 还是幻读, 它们都是数据库的<strong>读一致性</strong>的问题, 都是在一个事务里面前后两次读取出现了不一致的情况。<br>读一致性的问题, 必须要由数据库提供一定的事务隔离机制来解决。</p><h2 id="6-SQL92-标准"><a href="#6-SQL92-标准" class="headerlink" title="6 SQL92 标准"></a>6 SQL92 标准</h2><p>数据库厂商都按照这个标准, 提供一定的事务隔离级别, 来解决事务并发的问题。</p><p>SQL92 里面定义了四个隔离级别</p><blockquote><ol><li>Read Uncommitted (未提交读) :, 一个事务可以读取到其他事务未提交的数据, 会出现脏读, 它没有解决任何的问题</li><li>Read Committed (已提交读) : 一个事务只能读取到其他事务已提交的数据, 不能读取到其他事务未提交的数据, 它解决了脏读的问题, 但是会出现不可重复读的问题</li><li>Repeatable Read (可重复读): 在同一个事务里面多次读取同样的数据结果是一样的, 它解决了不可重复读的问题, 但是会出现幻读的问题</li><li>Serializable (串行化) : 在这个隔离级别里面, 所有的事务都是串行执行的, 也就是对数据的操作需要排队, 已经不存在事务的并发操作了, 所以它解决了所有的问题</li></ol></blockquote><p>这个是 SQL92 的标准, 但是不同的数据库厂商或者存储引擎的实现有一定的差异, 比如 Oracle 里面就只有两种 RC (已提交读) 和 Serializable (串行化) </p><h3 id="6-1-MySQL-InnoDB-对隔离级别的支持"><a href="#6-1-MySQL-InnoDB-对隔离级别的支持" class="headerlink" title="6.1 MySQL InnoDB 对隔离级别的支持"></a>6.1 MySQL InnoDB 对隔离级别的支持</h3><p>在 MySQL InnoDB 里面, 不需要使用串行化的隔离级别去解决所有问题。</p><table><thead><tr><th align="center">事务隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">未提交读 (Read Uncommitted)</td><td align="center">可能</td><td align="center">可能</td><td align="center">可能</td></tr><tr><td align="center">已提交读 (Read Committed)</td><td align="center">不可能</td><td align="center">可能</td><td align="center">可能</td></tr><tr><td align="center">可重复读 (Repeatable Read)</td><td align="center">不可能</td><td align="center">不可能</td><td align="center">对 InnoDB 不可能</td></tr><tr><td align="center">串行化 (Serializable)</td><td align="center">不可能</td><td align="center">不可能</td><td align="center">不可能</td></tr></tbody></table><p>InnoDB 支持的四个隔离级别和 SQL92 定义的基本一致, 隔离级别越高, 事务的并发度就越低。<br>唯一的区别就在于, InnoDB 在 RR 的级别就解决了幻读的问题。<br>这个也是 InnoDB 默认使用 RR 作为事务隔离级别的原因, 既保证了数据的一致性, 又支持较高的并发度。</p><h2 id="7-事务隔离级别的实现"><a href="#7-事务隔离级别的实现" class="headerlink" title="7 事务隔离级别的实现"></a>7 事务隔离级别的实现</h2><p>要解决读一致性的问题, 保证一个事务中前后两次读取数据结果一致, 实现事务隔离, 应该怎么做?</p><h3 id="7-1-LBCC"><a href="#7-1-LBCC" class="headerlink" title="7.1 LBCC"></a>7.1 LBCC</h3><p>要保证前后两次读取数据一致, 那么读取数据的时候, 锁定要操作的数据, 不允许其他的事务修改就行了。这种方案叫做基于锁的并发控制 Lock Based Concurrency Control (LBCC) 。<br>如果仅仅是基于锁来实现事务隔离, 一个事务读取的时候不允许其他时候修改, 那就意味着不支持并发的读写操作, 而我们的大多数应用都是读多写少的, 这样会极大地影响操作数据的效率。</p><h4 id="7-2-MVCC"><a href="#7-2-MVCC" class="headerlink" title="7.2 MVCC"></a>7.2 MVCC</h4><p>要让一个事务前后两次读取的数据保持一致, 那么可以在修改数据的时候给它建立一个备份或者叫快照, 后面再来读取这个快照就行了。<br>这种方案叫做多版本的并发控制 Multi Version Concurrency Control (MVCC) 。</p><p>MVCC 的核心思想是: 可以查到在这个事务开始之前已经存在的数据, 即使它在后面被修改或者删除了。在这个事务之后新增的数据, 是查不到的。</p><p><strong>MVCC 的实现</strong></p><p>InnoDB 为每行记录都实现了三个隐藏字段</p><blockquote><ol><li>DB_ROW_ID: 6 个字节, 行标识</li><li>DB_TRX_ID: 6 个字节, 插入或更新行的最后一个事务的事务 ID, 事务编号是自动递增的 (我们把它理解为创建版本号, 在数据新增或者修改为新数据的时候, 记录当前事务 ID)</li><li>DB_ROLL_PTR: 7 个字节, 回滚指针 (我们把它理解为删除版本号, 数据被删除的时候, 记录删除的事务 ID)</li></ol></blockquote><p>如图:<br><img src="https://pic.imgdb.cn/item/65f3b47c9f345e8d03260a43.png" alt="Alt &#39;MVVC 简单示意图&#39;"></p><p>如上面的演示, 通过版本号的控制, 无论其他事务是插入 &#x2F; 修改 &#x2F; 删除, 第一个事务查询到的数据都没有变化。</p><p>在 InnoDB 中, MVCC 是通过 Undo log 实现的, MVCC 和锁是协同使用的。<br>Oracle, Postgres 等等其他数据库都有 MVCC 的实现。  </p><h2 id="8-支持事务的存储引擎"><a href="#8-支持事务的存储引擎" class="headerlink" title="8 支持事务的存储引擎"></a>8 支持事务的存储引擎</h2><blockquote><ol><li>InnoDB</li><li>NDB</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL InooDB 索引实现</title>
      <link href="/article/2021/322214130/"/>
      <url>/article/2021/322214130/</url>
      
        <content type="html"><![CDATA[<h2 id="1-索引定义"><a href="#1-索引定义" class="headerlink" title="1 索引定义"></a>1 索引定义</h2><p>维基百科对数据库索引的定义:<br>数据库索引是数据库管理系统（DBMS）中的一个排序数据结构, 以协助快速查询和更新数据库表中的数据。</p><p>MongoDB对索引的定义:<br>索引是一种特殊的数据结构, 以有序和便于遍历的形式存储数据集合中特定字段或一组字段的值。<br>索引条目的排序支持有效的相等匹配和基于范围的查询操作。</p><p>理解:<br>数据库表中的数据以文件的形式存放在磁盘上, 每一行数据都有其磁盘地址。 如果没有索引, 要从表中检索一条数据, 只能依次遍历整张表的数据, 直到找到这条数据。<br>而索引是一种特殊的专门用于快速检索的数据结构。有了索引后, 只需在索引中检索这条数据, 找到数据存放在磁盘的地址后, 就可以找到数据了。</p><h2 id="2-索引的实现原理"><a href="#2-索引的实现原理" class="headerlink" title="2 索引的实现原理"></a>2 索引的实现原理</h2><p>假设现在有 1 到 9 总共 9 个数字, 在不做任何处理的情况下, 需要从中找到数字 9, 有什么好的方式呢？</p><p><img src="https://pic.imgdb.cn/item/657ac817c458853aef66a5d6.png" alt="Alt &#39;随机数字获取例子&#39;"></p><p>这时能做的也就只能一个个遍历了, 但是我们知道逐个遍历的随机性比较大, 同时性能会随着数据量的增加逐渐下降。</p><p>那么有没有好的方式呢？有。</p><blockquote><ol><li>我们可以将所有的数字先按照从小到大的顺序进行排序</li><li>每次查找时都从已有的数据的中间开始, 用中间的数字和要查找的数字进行比较。如果要查找的数字比中间大, 把左侧的数据都放弃; 如果要查找的数字比中间小, 把右侧的数据放弃。</li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/657ac965c458853aef6b2692.png" alt="Alt &#39;二分查找获取数字例子&#39;"></p><p>像上面的查找方式实际上就是利用了<strong>二分查找</strong>的思想。<br>在一个已经排过序的数据中, 进行二分查找是一个很快的过程, 因为每次查找都能过滤掉一半的数据。</p><p>而数据库的索引就是借助二分查找思想实现的。</p><h2 id="3-索引实现的数据结构"><a href="#3-索引实现的数据结构" class="headerlink" title="3 索引实现的数据结构"></a>3 索引实现的数据结构</h2><p>索引就是通过二分查找的思想设计的, 那么落实到具体的实现就是需要确定一个比较适合二分查找思想的<strong>数据结构</strong>。  </p><p>不同的数据结构有不同的特性, 比如: </p><blockquote><ol><li>数组的查找效率是非常快, 但是在数组中间的新增删除会很慢, 会涉及到后面数据的移动</li><li>链表的变更很快, 但是查询很慢, 每次查询都需要从头往后逐个遍历</li></ol></blockquote><p>所以选择一个合适的数据结构, 对索引的性能很重要。<br>那么有什么数据结构符合: </p><blockquote><ol><li>支持变更 (二分查找要求数据有序, 所以会涉及到数据的调整)</li><li>查询效率不错</li><li>适合二分查找的思想</li></ol></blockquote><h3 id="3-1-二叉查找树-BST-Binary-Search-Tree"><a href="#3-1-二叉查找树-BST-Binary-Search-Tree" class="headerlink" title="3.1 二叉查找树 (BST, Binary Search Tree)"></a>3.1 二叉查找树 (BST, Binary Search Tree)</h3><p>通过二分查找这个条件基本可以过滤掉很多条件, 而在常用的数据结构中, 最索引符合条件的数据结构能想到的就是<strong>树</strong>了。</p><p><img src="https://pic.imgdb.cn/item/657acafac458853aef6ff451.png" alt="Alt &#39;树数据结构&#39;"></p><p>因为索引的数据是有序的, 所以还是需要有序的树, 也就是**二叉查找树 (BST, Binary Search Tree)**。</p><p>二叉查找树 (二叉搜索树, 二叉排序树) 的特点</p><blockquote><ol><li>若任意节点的左子树不空, 则左子树上所有结点的值均小于它的根结点的值</li><li>若任意节点的右子树不空, 则右子树上所有结点的值均大于它的根结点的值</li><li>任意节点的左、右子树也分别为二叉查找</li><li>……</li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/657acb96c458853aef724c1f.png" alt="Alt &#39;二叉查找树例子&#39;"></p><p>二叉查找数可以实现快速查找, 又能实现快速插入。<br>但是二叉树有一个问题: 它的查找耗时和这棵树的深度有关, 在最坏的情况下, 时间复杂度会退化为 O(n)。</p><p>假设现在向二叉查找树中插入 2, 3, 4, 5, 6。<br>这个时候将会得到如下的一棵二叉查找树:<br><img src="https://pic.imgdb.cn/item/657acca4c458853aef764638.png" alt="Alt &#39;二叉查找树斜树例子&#39;"></p><p>它会变成变成链表 (也叫做 “斜树”), 这种情况下不能达到加快查询速度的目的, 和顺序查找效率差不多。<br>造成树倾斜的原因: 左右子树深度差太大, 导致不平衡。</p><h3 id="3-2-平衡二叉树-AVL-Balanced-Binary-Search-Tree"><a href="#3-2-平衡二叉树-AVL-Balanced-Binary-Search-Tree" class="headerlink" title="3.2 平衡二叉树 (AVL, Balanced Binary Search Tree)"></a>3.2 平衡二叉树 (AVL, Balanced Binary Search Tree)</h3><p>既然二叉树会 “失衡”, 那么能让他 “不失衡” 吗?<br>有, 这时就是平衡二叉树了, 平衡二叉树要求左右子树深度差绝对值不能超过 1, 向树中插入数据时, 一旦树出现不平衡, 需要通过左旋或右旋进行调整。  </p><p>平衡的解决了树失衡的情况, 那么平衡二叉树作为索引实现是最合适吗?</p><p><strong>首先作为索引应该存储什么内容</strong></p><blockquote><ol><li>索引的键值。比如在表中的 id 上面创建了一个索引, 在用 where id &#x3D; 1 的条件查询的时候, 需要能在索引里面找到 id 对应的键值, 也就是 1</li><li>索引对应的数据, 因为索引的作用就是去查找数据, 找到了索引, 也就是找到了数据 (这里也可以是存放的是数据的磁盘地址, 通过这个地址, 再到磁盘读取)</li><li>必须持有左子节点和右子节点的引用, 这样才能找到下一个节点。比如大于 26 的时候, 走右边, 到下一个树的节点, 继续判断</li></ol></blockquote><p><strong>索引本身就是数据, 所以也是需要持久化的</strong><br>当数据库宕机等原因, 需要重启后, 我们为表建立的索引是必须要可以继续使用的, 为了达到这个效果, 那么我们就需要将数据存放到磁盘中。  </p><p>基于上面 2 点的考虑, 现在我们有 1 棵平衡二叉树如下  </p><p><img src="https://pic.imgdb.cn/item/657ace33c458853aef7c1ef0.png" alt="Alt &#39;平衡二叉树数据查询例子&#39;"></p><p>需要查询索引 &#x3D; 5 的表记录的磁盘位置, 需要经历如下操作</p><blockquote><ol><li>从磁盘中读取根节点 4</li><li>5 比根节点的 4 大, 从磁盘中读取右节点 6</li><li>5 比节点 6 小, 从磁盘中读取左节点 5</li><li>5 等于节点 5, 从当前节点获取磁盘地址, 获取到数据</li></ol></blockquote><p>从上面的过程中, 每一次节点都需要和磁盘进行一次 IO 操作。 而在系统操作中, 磁盘 IO 是一个很耗时的行为。<br>所以 InnoDB 在进行磁盘 IO 操作时, 不是按需读取, 而是按照页的维度 (一页默认等于 16k) 进行读取, 也就是每次从磁盘读取数据都是 16k 的数据, 通过这种多读取的方式, 减少 IO 次数。  </p><p>而平衡二叉树的节点的存储的内容为: <strong>索引值 + 索引对应的数据(数据的磁盘地址) + 引用</strong>, 例如整形的索引的, 可能只用了十几个或者几十个字节, 即使加上数据, 它也很少能达到 16K 的容量,<br>所以访问一个树节点, 进行一次 IO 的时候, 浪费了大量的空间。  </p><p>也许你会想, 一次 IO, 可以读取 16k 数据, 那么我一次性读取 16k 的树节点不就行了吗?<br>能实现这个的前提是 16k 的节点在磁盘中都是连续的, 但是树的节点间是通过引用, 也就是指针关联的, 内存不一定的连续的, 所以每次 16k 数据的读取, 不一定都是有用的数据。</p><p>解决方案: 让树上每个节点存储更多的数据。<br>通过让节点的关键字 (索引值) 的数量增加, 那么节点的数据就增加了。</p><p>关键字 (索引值) 增加, 会引起节点内指针数量的怎几个, 也就是产生了更多的分叉 (也叫做 “路数”)。<br>分叉数越多, 数的深度会减少, 这个时候树不再是二叉, 而是多叉, 或者叫做多路。</p><h3 id="3-3-多路平衡树-B-Tree-Balanced-Tree"><a href="#3-3-多路平衡树-B-Tree-Balanced-Tree" class="headerlink" title="3.3 多路平衡树 (B Tree, Balanced Tree)"></a>3.3 多路平衡树 (B Tree, Balanced Tree)</h3><p>二叉树就是树中每个节点最多就有 2 个子节点。<br>而 B 树是多路树, 多路就是多叉, 也就是树中的每个节点都是多个字节点。</p><p><img src="https://pic.imgdb.cn/item/657ad055c458853aef836ba1.png" alt="Alt &#39;B 树例子&#39;"></p><p>如图, 上面 B 树的根节点就下面有 3 个子节点, 而 2 节点的下面有 2 个节点。<br>所以 B 树的节点最多可以有多少个节点呢？  </p><p>这个涉及到 B 树的一个概念: 度 (Degree), 最大多少度就是表示了 B 树中的节点最多可以为多少路, 也就是多少分叉。<br>假设一棵树的最大路数 (Max Degree) 是 3, 依次插入 1, 2, 3。 在插入 3 的时候, 第一个磁盘块出现了 3 个关键字, 有 4 个指针, 即变成了 4 路。<br>这个时候就需要进行分裂, 把中间的数据 2 提上去, 把 1, 3 变成 2 的子节点 (同样的进行了删除节点, 可能需要进行合并操作)。</p><p>跟 AVL 树一样, B 树的节点存储<strong>索引值 + 索引对应的数据(数据的磁盘地址) + 节点引用</strong>。<br><img src="https://pic.imgdb.cn/item/657ad180c458853aef87809c.png" alt="Alt &#39;B 树节点结构&#39;"></p><p>同时 B 树的分叉数 (路数) 永远比索引值多 1, 比如有节点中有 2 个索引值, 那么会有 3 个指向下游的节点的指针, 大体的结构如下:<br><img src="https://pic.imgdb.cn/item/657ad129c458853aef8650e8.png" alt="Alt &#39;B 树例子&#39;"></p><p>这样, 设定 B 树每个节点的大小为 16k (充分利用每次 IO 16k 的特性, 这样每次 IO 就是一个节点的数据), 利用 B 树多路的特点, 将表中多个行数据组织在同一个节点中,<br>这样既可以利用索引的特性, 又可以减少 IO 次数, 提高查询效率。  </p><p>一个节点为 16k, 每行记录和索引的大小都是在建表时确定的, 而指针的大小跟操作系统的位数有关, 64 位系统, 一个指针占 8 个字节, 32 位系统, 一个指针占 4 个字节。<br>这样一个节点可以存储的数据 &#x3D; 16k - 1 个节点引用 (B 树的路数比索引值多 1) &#x2F; (索引值 + 索引对应的数据 + 节点引用) 个索引值。</p><p>但是实际上, InnoDB 还是没有选中 B Tree 作为索引。使用 B Tree 作为索引的实现时:   </p><blockquote><ol><li>非叶子节点存储的是<strong>索引值 + 数据</strong>, 搜索有可能在非叶子节点结束, 也有可能要到叶子节点才结束, 越靠近根节点查询效率越快, 而离根节点越远, 效率越慢, 查询时间很不稳定</li><li>每个节点的大小固定为一页 (默认 16k) 的大小, 有限的容量既要存索引值, 还有存储数据。如果数据很多, 那么 1 个节点能存储的索引数会少很多, 那么可能会导致这个树很高, 导致 I&#x2F;O 的次数提高</li></ol></blockquote><h3 id="3-4-加强版多路平衡查找树-B-Tree"><a href="#3-4-加强版多路平衡查找树-B-Tree" class="headerlink" title="3.4 加强版多路平衡查找树 (B+ Tree)"></a>3.4 加强版多路平衡查找树 (B+ Tree)</h3><p>InnoDB 实现的 B+ Tree 和 B Tree 区别不大, 只是做了以下 2 个调整</p><blockquote><ol><li>它的索引值的数量和路数相等, 节点间的索引取值是一个左闭右开的区间 <strong>[x, y)</strong></li><li>B+ Tree 的根节点和非叶子节点中都不会存储数据, 只有叶子节点才存储数据。搜索到索引值不会直接返回, 而是继续走到最后一层的叶子节点, 这里才会找到真正的行数据, 所以每条记录查询的时间基本都是一样的</li><li>B+ Tree 的每个叶子节点增加了一个指向相邻叶子节点的指针, 它的最后一个数据指向下一个叶子节点的第一个数据, 形成了一个有序的链表</li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/657ad295c458853aef8bc26a.png" alt="Alt &#39;B+ 树例子&#39;"></p><p><strong>B+ Tree 比 B Tree 更适合作为索引的实现</strong></p><blockquote><ol><li>B+ Tree 是 B Tree 的变种, B Tree 能解决的问题, 它也能解决</li><li>扫库, 扫表能力更强 (如果要对表进行全表扫描, 只需要遍历叶子节点就可以, 不需要遍历整棵 B+ Tree, 因为叶子节点有指向下一个叶子节点的指针, 所有数据都是串联起来的)</li><li>B+ Tree 的索引过滤能力相对于 B Tree 更强, 非叶子节点不保存数据区, 所以一个节点保存更多的索引值, 一次磁盘加载的索引值更多</li><li>排序能力更强, 因为叶子节点有下一个数据区的指针, 数据形成了链表</li><li>效率更加稳定, B+ Tree 永远都是在叶子节点拿到数据, 所以 IO 次数稳定</li></ol></blockquote><h3 id="3-5-为什么不使用红黑树来实现索引"><a href="#3-5-为什么不使用红黑树来实现索引" class="headerlink" title="3.5 为什么不使用红黑树来实现索引"></a>3.5 为什么不使用红黑树来实现索引</h3><p>红黑树也是二叉查找树, 但是不是严格平衡的, 其本身有 5 个约束</p><blockquote><ol><li>根节点必须是黑色的</li><li>节点分为红色或者黑色</li><li>叶子节点都是黑色的 NULL 节点</li><li>红色节点的两个子节点都是黑色 (不允许两个相邻的红色节点)</li><li>从任意节点出发, 到其每个叶子节点的路径中包含相同数量的黑色节点</li></ol></blockquote><p>基于上面的约束, 可以推导出: 从根节点到叶子节点的最长路径 (红黑相间的路径) 不大于最短路径(全部是黑色节点) 的 2 倍。</p><p><strong>不使用红黑树的原因</strong></p><blockquote><ol><li>只有两路</li><li>不够平衡</li></ol></blockquote><h3 id="3-6-InnoDB-索引的另一种实现"><a href="#3-6-InnoDB-索引的另一种实现" class="headerlink" title="3.6 InnoDB 索引的另一种实现"></a>3.6 InnoDB 索引的另一种实现</h3><p>在 InnoDB 中还有一种 Hash 实现索引的方式。<br>Hash 以 KV 的形式检索数据, 会根据索引字段生成哈希码和指针, 指针指向数据。</p><p>Hash 索引的特点</p><blockquote><ol><li>它的时间复杂度是 O(1), 查询速度比较快。因为哈希索引里面的数据不是按顺序存储的, 所以不能用于排序</li><li>在查询数据的时候要根据键值计算哈希码, 所以它只能支持等值查询 (&#x3D; IN) , 不支持范围查询 (&gt; &lt; &gt;&#x3D; &lt;&#x3D; between and)</li><li>如果字段重复值很多的时候, 会出现大量的哈希冲突 (采用拉链法解决), 效率会降低</li></ol></blockquote><p>InnoDB 只支持显式创建 B+Tree 索引, 对于一些热点数据页, InnoDB 会自动建立自适应 Hash 索引, 也就是在 B+Tree 索引基础上建立 Hash 索引, 这个过程对于客户端是不可控制的, 隐式的。<br>这个隐式的建立过程就是 Adaptive Hash Index 自适应哈希索引。这个行为也是通过一个开关控制的 **show variables like ‘innodb_adaptive_hash_index’;**。  </p><h2 id="4-B-Tree-的落地实现"><a href="#4-B-Tree-的落地实现" class="headerlink" title="4 B+ Tree 的落地实现"></a>4 B+ Tree 的落地实现</h2><p>MySQL 的数据都是以文件的形式存放在磁盘中的, 在 MySQL 中有这么一个参数 <strong>show VARIABLES LIKE ‘datadir’;</strong>, 可以找到这个数据目录的地址。<br>在这个目录下, 每个数据库都有自己的文件夹, 数据库下的表同样的在对应的数据库文件夹下有自己的文件</p><blockquote><ol><li>InnoDB 的表有 2 个文件, 表名.frm 和 表名.ibd</li><li>MyISAM 的表有 3 个文件, 表名.frm, 表名.MYD 和 表名.MYI</li></ol></blockquote><p>其中 .frm 是 MySQL 里面表结构定义的文件, 每个表都会生成的。</p><h3 id="4-1-MyISAM"><a href="#4-1-MyISAM" class="headerlink" title="4.1 MyISAM"></a>4.1 MyISAM</h3><p>在 MyISAM 中</p><blockquote><ol><li>.MYD 文件, D 代表了 Data, 是 MyISAM 的数据文件, 存放数据记录, 也就是表中的所有数据</li><li>.MYI 文件, I 代表了 Index, 是 MyISAM 的索引文件, 存放的是表中的索引数据。</li></ol></blockquote><p>MyISAM 的 B+ Tree 里面, 叶子节点存放的是数据文件对应的磁盘地址。索引从索引文件 .MYI 中找到键值后, 会再到数据文件 .MYD 中获取相应的数据记录。<br><img src="https://pic.imgdb.cn/item/657b1184c458853aefb66928.png" alt="Alt &#39;MyISAM 数据查找过程&#39;"></p><p>这里分析的是主键索引, 如果是非主键索引, 有什么不一样的吗?</p><p>在 MyISAM 里面, 非主键索引也在 .MYI 文件里面。<br>非主键索引跟主键索引存储和检索数据的方式没有任何区别, 一样是在索引文件里面找到磁盘地址, 然后到数据文件里面获取数据。</p><h3 id="4-2-InnoDB"><a href="#4-2-InnoDB" class="headerlink" title="4.2 InnoDB"></a>4.2 InnoDB</h3><p>在 InnoDB 中只有一个 .ibd 文件。在 InnoDB 中以主键为索引组织数据的存储, 索引文件和数据文件都在同一个 .ibd 文件中。<br>在 InnoDB 的主键索引的叶子节点上, 直接存储了表中的数据  </p><p><img src="https://pic.imgdb.cn/item/657b121dc458853aefb99859.png" alt="Alt &#39;InnoDB 数据查找过程&#39;"></p><p>在 InnoDB 中, 这种组织数据的方式叫做 (聚集) 索引组织表 (clustered index organize table), 即索引和数据组织在一起, 也叫做聚集索引。<br>同理, MyISAM 那种将索引和数据分开的方式叫做非聚集索引。    </p><p>在 InnoDB 中, 主键索引是聚集索引, 非主键索引都是非聚集索引。</p><p>非主键索引叶子节点存储的是非主键索引索引和<strong>对应记录的主键值</strong>。<br>如果使用非主键索引查询, 会先在非主键索引树中找到主键值, 再根据主键值在主键索引树中查询, 最终获取到数据。  </p><p><img src="https://pic.imgdb.cn/item/657b152fc458853aefc9e63a.png" alt="Alt &#39;InnoDB 非主键索引查询过程&#39;"></p><h3 id="4-3-问题的思考"><a href="#4-3-问题的思考" class="headerlink" title="4.3 问题的思考"></a>4.3 问题的思考</h3><p><strong>InnoDB 为什么不直接在非主键索引里面存储主键的磁盘地址</strong></p><p>B+ Tree 为了维持平衡, 节点的数据会进行调整, 从而有概率引起节点分裂和合并的操作, 这些操作会改变数据的地址。<br>索引在非主键索引如果存储的是地址, 在调整完主键索引树后, 还需要修改所有的非主键索引的地址, 但是如果存放的是主键的 id, 则不需要关心辅助索引的变化。</p><p><strong>一张表没有主键时怎么办</strong><br>如果显示地定义了主键 (primary key), 那么 InnoDB 会选择这个主键作为聚集索引。<br>如果没有显示定义主键, 则 InnoDB 会选择第一个不包含有 Null 值的唯一索引作为主键索引<br>如果没有这样的唯一索引, 则 InnoDB 会选择内置 6 字节的 ROWID 作为隐藏的聚集索引, 它会随着行记录的写入而主键递增。</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">select _rowId name from 表名;</code></pre><p><strong>为什么主键索引的选择都是建议选择自增的列</strong><br>在上面分析中, 索引有一个特点就是有序, 如果选择自增的列作为主键索引, 那么每次新增的数据都是在原有数据后面的追加</p><blockquote><ol><li>插入性能优化, 因为每次插入都是在原有数据后面追加, 不会造成数据的移动, 所以插入性能很好</li><li>顺序读取优化, 索引的数据最终都是需要持久化到磁盘的, 如果索引递增, 那么就可以保证索引的数据都是顺序写入磁盘的, 这样就可以大大提高顺序读取的性能</li><li>减少索引碎片, 当使用非递增主键时, 删除或新增操作可能导致数据页的移动或分裂, 从而引起索引碎片。递增主键的插入和删除通常只会在索引的末尾进行, 减少了这种碎片化的可能性</li></ol></blockquote><h2 id="5-InnoDb-中使用索引的一些特性"><a href="#5-InnoDb-中使用索引的一些特性" class="headerlink" title="5 InnoDb 中使用索引的一些特性"></a>5 InnoDb 中使用索引的一些特性</h2><h3 id="5-1-离散度"><a href="#5-1-离散度" class="headerlink" title="5.1 离散度"></a>5.1 离散度</h3><p>建立索引, 不是越多越好, 也不是随便哪一列都适合建立索引。</p><p>一般选择作为索引的列, 可以从<strong>查询频率</strong>和<strong>离散度(数据的重复率)</strong>, 两个角度来考虑。</p><p>列的离散度的计算公式:<br>count(distinct(列名)) &#x2F; count(1), 列的去重数据和所有数据行的比例。数据行数相同的情况下, 分子越大, 列的离散度就越高。</p><p>简单来说: 列的重复值越多, 离散度就越低, 重复值越少, 离散度就越高。<br>一个简单的例子: 在用户表里面, 给性别列加索引和给姓名加索引, 2 者的收益不同, 前者的离散度较低, 后者较高。</p><p>注: 可以通过 <strong>show indexes from 表名;</strong>, 查看表的索引情况。<br>查询结果中的 <strong>Cardinality</strong>, 代表基数, 代表了预估的不重复的值的数量。索引的基数和表总行数越接近, 列的离散度就越高。</p><p>散列度的判断也不一定是完全考量的, 一些特殊的场景, 也可以考虑建立索引。  </p><p>举个例子:<br>假设有一种信息发送表, 表里面每天都会增加大量数据, 表中有 1 列表示当前消息的状态, 已发送, 待发送 2 个状态, 如果直接考虑离散度, 那么这个列的离散度就很低, 不适合建立索引。    </p><p>业务场景, 定时器定时的从表中查询出待发送的消息, 进行发送, 每次发送成功后, 就将记录的状态更新为已发送。<br>那么这时候给状态加上索引, 因为表中大部分的情况都是已发送的, 未发送的只占里面总量的很少很少, 通过这个索引可以筛选掉一大部分的以发送数据。</p><h3 id="5-2-联合索引最左原则"><a href="#5-2-联合索引最左原则" class="headerlink" title="5.2 联合索引最左原则"></a>5.2 联合索引最左原则</h3><p>联合索引是指在多个列上建立索引。</p><p>联合索引在 B+ Tree 中是复合的数据结构, 他按照从左到右的顺序来建立索引树。<br>比如: 当前有 name 和 phone 的复合索引, 在树中, name 是有序的, phone 是无序的。只有当 name 相等的情况下, phone 才有序。  </p><p>当查询的时候使用的条件为 <code>where name= &#39;A&#39; and phoe = &#39;123&#39;;</code>, B+ Tree 会优先比较 name 来确定下一步应该搜索的方向, 往左还是往右。<br>如果 name 相同的情况, 再比较 phone。 如果查询条件没有 name, 就不知道第一步应该查哪个节点, 因为建立搜索树的时候 name 是第一个比较因子, 所以用不到索引。</p><h3 id="5-3-覆盖索引"><a href="#5-3-覆盖索引" class="headerlink" title="5.3 覆盖索引"></a>5.3 覆盖索引</h3><p>通过索引查询数据时, 不管是单例索引还是复合索引, 如果 select 的数据列值用从索引中就能取得, 不必从数据区中读取, 这时候使用的索引就叫做覆盖索引, 这样就避免了回表。</p><p>比如现在我有 1 张表 t1, 表中有 id, name, phone, sex 三个字段, 有一个组合索引 name + phone + sex,</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> sex <span class="token keyword">from</span> t1 <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'A'</span> <span class="token operator">and</span> phone <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span></code></pre><p>这时查询的条件和结果都可以在索引树中找到, 不需要回表, 这时候就是覆盖索引。</p><p><strong>回表的过程</strong>  </p><blockquote><ol><li>非主键索引, 先通过索引找到主键索引的键值 (主键索引跳过此步骤)</li><li>通过主键值到主键索引中找到对应的行</li><li>从行中找到查询列中其他不在索引里面的字段的值 (也就是重新回到表数据中)</li></ol></blockquote><p>需要回到数据区, 也就是表中的情况, 就是回表</p><h3 id="5-4-索引条件下退-ICP"><a href="#5-4-索引条件下退-ICP" class="headerlink" title="5.4 索引条件下退 (ICP)"></a>5.4 索引条件下退 (ICP)</h3><p>ICP 功能默认是开启的, 我们先尝试关闭 ICP 功能:</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 关闭 ICP</span><span class="token keyword">set</span> optimizer_switch<span class="token operator">=</span><span class="token string">'index_condition_pushdown=off'</span><span class="token punctuation">;</span><span class="token comment">-- 查看参数</span><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'opimizer_switch'</span><span class="token punctuation">;</span></code></pre><p>现在有一张雇员表 employees, 里面有 2 个非空的 varchar 的字段 first_name 和 last_name, 在表上建立了一个复合索引 (last_name, first_name)。<br>现在要查询出所有姓是 wang (last_name) 和名字中最后一个字为 zi 的员工</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees <span class="token keyword">where</span> last_name <span class="token operator">=</span> <span class="token string">'wang'</span> <span class="token operator">and</span> first_name <span class="token operator">like</span> <span class="token string">'%zi'</span><span class="token punctuation">;</span></code></pre><p>这条 SQL 有两种执行方式:</p><p>(1) 根据联合索引查出所有姓 wang 的二级索引数据, 然后回表, 到主键索引上查询全部符合条件的数据 (假设现在有 3 条数据) 。然后返回给 MySQL Server 层, 在 Server 层过滤出名字以 zi 结尾的员工。<br>(2) 根据联合索引查出所有姓 wang 的二级索引数据, 然后从二级索引中筛选出 first_name 以 zi 结果的索引, 然后在回表, 到主键索引上查询全部符合条件的数据 (假设现在有 1 条数据), 返回给 Server 层。</p><p>注: <strong>在 MySQL 的设计中, 索引的比较是在存储引擎进行的, 数据记录的比较, 是在 Server 层进行的</strong>。</p><p>很明显, 第二种方式到主键索引上查询的数据更少。而且当 first_name 的条件不能用于索引过滤时, Server 层不会把 first_name 的条件传递给存储引擎, 所以不会读取到两条没有必要的记录。</p><p>如果这时候满足 last_name &#x3D; ‘wang’ 的记录有 10000 条, 就有 9999 条是没必要读取的记录。</p><p>通过 explain 分析上面的 SQL, 可以看到结果里面的 <code>Extra</code> 列里面的结果为 <code>Using where</code>。<br>Using where 代表从存储引擎取回的数据不全部满足条件, 需要在 Server 层过滤。<br>先用 last_name 条件进行索引范围扫描, 读取数据表记录, 然后进行比较, 检查是否符合 first_name like ‘%zi’ 的条件, 此时 3 条中只有 1 条符合条件。</p><p>开启 ICP 功能</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> optimizer_switch<span class="token operator">=</span><span class="token string">'index_condition_pushdown=on'</span><span class="token punctuation">;</span></code></pre><p>此时再通过 explain 分析上面的 SQL, 可以看到结果里面的 <code>Extra</code> 列里面的结果为 <code>Using index condition</code>。<br>把 first_name like ‘%zi’ 下推给存储引擎后, 只会从数据库表读取所需的 1 条记录。</p><p>索引条件下推 (Index Condition Pushdown), 5.6 以后完善的功能。只适用于二级索引。<br>ICP 的目标是减少访问表的完整行的读数量从而减少 I&#x2F;O 操作。</p><h2 id="6-索引带来的问题"><a href="#6-索引带来的问题" class="headerlink" title="6 索引带来的问题"></a>6 索引带来的问题</h2><p>使用索引可以带来查询效率的提升, 但是其本身也会引入其他的问题。</p><p><strong>性能开销</strong><br>在往表中新增&#x2F;删除记录时, InnoDB 除了需要保证数据的正确落库, 还需要同时还需要维护对应的索引树, 这个过程有可能会导致索引树的调整, 页合并, 页分裂等情况, 都是对数据库性能的开销</p><p><strong>占用存储空间</strong><br>索引最终是需要持久到磁盘中的, 而这一份都是需要磁盘空间的, 而且这部分空间是非数据的开销, 只是单纯是辅助查询的空间消耗</p><p><strong>过多或不正确的索引, 可能查询性能下降</strong><br>过多的索引, 离散度不高的索引等, 可能会导致数据库选择不合适的索引, 做出错误的查询执行计划, 进而影响到查询的效率</p><h2 id="7-索引的使用上的建议"><a href="#7-索引的使用上的建议" class="headerlink" title="7 索引的使用上的建议"></a>7 索引的使用上的建议</h2><p><strong>索引的使用</strong>  </p><blockquote><ol><li>常用在 where 条件 &#x2F; order  排序 &#x2F; join 的 on 字段上建索引</li><li>索引的数量不要太多 –&gt; 浪费空间, 更新变慢</li><li>区分度低的字段, 例如性别, 不用要建索引 –&gt; 离散度太低, 导致扫描行数过多</li><li>频繁更新的值, 不要作为主键或者索引 –&gt; 可能会导致页分裂</li><li>组合索引把散列度高的 (区分度高) 的值放在前面</li><li>创建复合索引, 而不是修改单列索引</li><li>无序的值 (例如身份证, UUID) 尽量不要作为索引</li><li>当字段值比较长的时候, 可以考虑前缀索引, 截取字段的前面一部分内容建立索引, 至于截取多少, 可以通过散列值判断</li></ol></blockquote><p><strong>索引失效</strong></p><blockquote><ol><li>在索引列上使用函数, 表达式, 计算</li><li>字符串不加引号, 出现隐式转换, varchar 和 char 字段等于查询等场景</li><li>like 条件中前面带 %</li><li>不等于查询, not like, not in, !&#x3D;</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM 方法调用</title>
      <link href="/article/2021/4076239504/"/>
      <url>/article/2021/4076239504/</url>
      
        <content type="html"><![CDATA[<p>方法调用并不等同于方法中的代码被执行, 方法调用阶段唯一的任务就是确定被调用方法的版本 (即调用哪一个方法), 暂时还未涉及方法内部的具体运行过程。</p><p>Class 文件的编译过程中不包含传统程序语言编译的连接步骤, 一切方法调用在 Class 文件里面存储的都只是符号引用, 而不是方法在实际运行时内存布局中<br>的入口地址 (也就是之前说的直接引用), 这个特性给 Java 带来了更强大的动态扩展能力, 但也使得 Java 方法调用过程变得相对复杂, 某些调用需要在类加<br>载期间, 甚至到运行期间才能确定目标方法的直接引用。</p><h2 id="1-解析"><a href="#1-解析" class="headerlink" title="1 解析"></a>1 解析</h2><p>所有方法调用的目标方法在 Class 文件里面都是一个常量池中的符号引用, 在类加载的解析阶段, 会将其中的一部分符号引用转化为直接引用, 这种解析能够<br>成立的前提是: 方法在程序真正运行之前就有一个可确定的调用版本, 并且这个方法的调用版本在运行期是不可改变的。调用目标在程序代码写好, 编译器进行编译那一刻就已经确定下来。<br>这类方法的调用被称为解析 (Resolution)。</p><p>在 Java 语言中符合 “编译期可知, 运行期不可变” 这个要求的方法, 主要有静态方法和私有方法两大类。前者与类型直接关联, 后者在外部不可被访问, 这<br>两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本, 因此它们都适合在类加载阶段进行解析。</p><p>调用不同类型的方法, 字节码指令集里设计了不同的指令。在 Java 虚拟机支持以下 5 条方法调用字节码指令, 分别是</p><blockquote><ol><li>invokestatic: 用于调用静态方法</li><li>invokespecial: 用于调用实例构造器 <init>() 方法, 私有方法和父类中的方法</li><li>invokevirtual: 用于调用所有的虚方法</li><li>invokeinterface: 用于调用接口方法, 会在运行时在确定一个实现该接口的对象</li><li>invokedynamic: 先在运行时动态解析出调用点限定符所引用的方法, 然后再执行该方法</li></ol></blockquote><p>前面 4 条调用指令, 分派逻辑都固化在 Java 虚拟机内部, 而 invokedynamic 指令的分派逻辑是由用户设定的引导方法来决定的。</p><p>只要能被 invokestatic 和 invokespecial 指令调用的方法, 都可以在解析阶段中确定唯一的调用版本, Java 语言里符合这个条件的方法共有静态方法,<br>私有方法, 实例构造器, 父类方法 4 种, 再加上被 final 修饰的方法 (final 方法是通过 invokevirtual 指令调用的)。</p><p>这 5 种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为 “非虚方法” (No-Virtual Method), 与之相反, 其他方法<br>就被称为 “虚方法” (Virtual Method)。</p><p>解析调用一定是个静态的过程, 在编译期间就完全确定, 在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用, 不必延迟到运行期再去完成。<br>而另一种主要的方法调用形式: 分派 (Dispatch) 调用则要复杂许多, 它可能是静态的也可能是动态的。按照分派依据的宗量数可分为单分派和多分派。<br>这两类分派方式两两组合就构成了静态单分派, 静态多分派, 动态单分派, 动态多分派 4 种分派组合情况。</p><h2 id="2-分派"><a href="#2-分派" class="headerlink" title="2 分派"></a>2 分派</h2><h3 id="2-1-静态分派"><a href="#2-1-静态分派" class="headerlink" title="2.1 静态分派"></a>2.1 静态分派</h3><p>先看一下一段代码</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticDispatch</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">static</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Human</span> guy<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello,guy!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Man</span> guy<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello,gentleman!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Woman</span> guy<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello,lady!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                 <span class="token class-name">Human</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">Human</span> woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">StaticDispatch</span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticDispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 此处输出结果: hello,guy!</span>        sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>man<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 此处输出结果: hello,guy!</span>        sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>woman<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>再确定为什么输出结果是这样之前, 先理解一点概念性的东西。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Human</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上面的代码中,<br>“Human” 称为变量的 “静态类型 (Static Type)” 或者 “外观类型 (Apparent Type)”,<br>“Man” 称为变量的 “实际类型 (Actual Type)” 或者 “运行时类型 (Runtime Type)”。</p><p>静态类型和实际类型在程序中都可能发生变化, 区别是静态类型的编号仅仅在使用时发生, 变量本身的静态类型不会被改变, 并且最终的静态类型咋编译期就可知。<br>实际类型变化的结果在运行期才可确定, 编译器在编译期并不知道一个对象的实际类型是什么。</p><p>例子:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 实际类型变化 </span><span class="token class-name">Human</span> human <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 静态类型变化 </span>sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Man</span><span class="token punctuation">)</span> human<span class="token punctuation">)</span><span class="token punctuation">;</span>sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Woman</span><span class="token punctuation">)</span> human<span class="token punctuation">)</span></code></pre><p>对象 human 的实际类型是可变的, 必须等到程序运行到这行的时候才能确定。<br>而 human 的静态类型是 Human, 使用时临时改变这个类型 (例如: 通过强转), 但这个改变在编译期是可知的。</p><p>理解了这 2 个概念后, 分析一下上面的代码了。</p><p>在方法接收者已经确定是对象 “sr” 的前提下, 使用哪个重载版本, 就完全取决于<strong>传入参数的数量</strong>和<strong>数据类型</strong>。<br>虚拟机 (或者准确地说是编译器) 在重载时是通过参数的静态类型而不是实际类型作为判定依据的。由于静态类型在编译期可知, 所以在编译阶段, Javac 编<br>译器就根据参数的静态类型决定了会使用哪个重载版本, 因此选择了 sayHello(Human) 作为调用目标, 并把这个方法的符号引用写到 main() 方法里的两条<br>invokevirtual 指令的参数中。</p><p>所有依赖静态类型来决定方法执行版本的分派动作, 都称为静态分派。<br>静态分派的最典型应用表现就是方法重载。静态分派发生在编译阶段, 因此确定静态分派的动作实际上不是由虚拟机来执行的。</p><p>Javac 编译器虽然能确定出方法的重载版本, 但在很多情况下这个重载版本并不是 “唯一” 的, 往往只能确定一个 “相对更合适的” 版本。<br>产生这种模糊结论的主要原因是字面量天生的模糊性, 它不需要定义, 所以字面量就没有显式的静态类型, 它的静态类型只能通过语言, 语法的规则去理解和推断。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Overload</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Object</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello Object"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello int"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">long</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello long"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Character</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello Character"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">char</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello char"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello char ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Serializable</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello Serializable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>上面的代码输出的结果为: “hello char”。<br>因为 ‘a’ 是一个 char 类型的数据。</p><p>但是注释掉 <strong>sayHello(char arg)</strong> 方法后, 会输出 “hello, int”。<br>这时候发生了一次自动类型转换, ‘a’ 可以代表一个字符, 还可以代表数字 97 (字符 ‘a’ 的 Unicode 数值为十进制数字 97)。  </p><p>再一次注释掉 <strong>sayHello(int arg)</strong>, 输出结果为 “hello long”, int 可以转换为 long。<br>一般 char 依次可以转换为 char &gt; int &gt; long &gt; float &gt; double 的顺序进行转换。</p><p>注释 <strong>sayHello(long arg)</strong> 输出: “hello Character”。  </p><p>注释 <strong>sayHello(Character arg)</strong> 输出 “hello Serializable” (Character 实现了 Serializable)。<br>这时候如果代码里面还有一个 Comparable<Character> 的参数的话, 这时会出现编译失败, Character 同时实现了 Serializable 和 Comparable<Character>,<br>2 个重载方法的优先级是一样的。</p><p>注释 <strong>sayHello(Serializable arg)</strong> 输出: “hello Object”。  </p><p>注释 <strong>sayHello(Object arg)</strong> 输出: “hello char …”。<br>可见变长参数的重载优先级是最低的。</p><h3 id="2-2-动态分派"><a href="#2-2-动态分派" class="headerlink" title="2.2 动态分派"></a>2.2 动态分派</h3><p>动态分派主要与 Java 语言多态性的<strong>重写</strong>有关。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicDispatch</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>         <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"man say hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"woman say hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Human</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">Human</span> woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// man say hello</span>        man<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// woman say hello</span>        woman<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// woman say hello</span>        man<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>选择调用的方法版本是不可能再根据静态类型来决定的, 因为静态类型同样都是 Human 的两个变量 man 和 woman 在调用 sayHello() 方法时产生了不同<br>的行为, 甚至变量 man 在两次调用中还执行了两个不同的方法。</p><p>通过 <strong>javac 和 javap</strong> 获取到字节码文件</p><pre class="language-none"><code class="language-none">public static void main(java.lang.String[]);    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1         0: new           #2                  &#x2F;&#x2F; class DynamicDispatch$Man         3: dup         4: invokespecial #3                  &#x2F;&#x2F; Method DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V         7: astore_1         8: new           #4                  &#x2F;&#x2F; class DynamicDispatch$Woman        11: dup        12: invokespecial #5                  &#x2F;&#x2F; Method DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V        15: astore_2        16: aload_1        17: invokevirtual #6                  &#x2F;&#x2F; Method DynamicDispatch$Human.sayHello:()V        20: aload_2        21: invokevirtual #6                  &#x2F;&#x2F; Method DynamicDispatch$Human.sayHello:()V        24: new           #4                  &#x2F;&#x2F; class DynamicDispatch$Woman        27: dup        28: invokespecial #5                  &#x2F;&#x2F; Method DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V        31: astore_1        32: aload_1        33: invokevirtual #6                  &#x2F;&#x2F; Method DynamicDispatch$Human.sayHello:()V        36: return</code></pre><p>0 ～ 15 行的字节码是准备动作, 作用是建立 man 和 woman 的内存空间, 调用 Man 和 Woman 类型的实例构造器, 将这两个实例的引用存放在第 1, 2 个<br>局部变量表的变量槽中, 对应的代码就是</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Human</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">Human</span> woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>16 ~ 21 行的字节码我们很容易对应的就是代码的</p><pre class="language-java" data-language="java"><code class="language-java">man<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>woman<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>但是在字节码的 17 和 21 行都是 “invokevirtual #6 &#x2F;&#x2F; Method DynamicDispatch$Human.sayHello:()V”, 无论是指令, 还是指令的参数都是一样的,<br>但是他们最终执行的目标方法并不相同。问题主要是 “invokevirtual” 指令。</p><p>根据《Java虚拟机规范》, invokevirtual 指令的运行时解析过程大致分为以下几步</p><blockquote><ol><li>找到操作数栈顶的第一个元素所指向的对象的实际类型, 记作 C。</li><li>如果在类型 C 中找到与常量中的描述符和简单名称都相符的方法, 则进行访问权限校验, 如果通过则返回这个方法的直接引用, 查找过程结束; 不通过则<br>  返回 java.lang.IllegalAccessError 异常</li><li>否则, 按照继承关系从下往上依次对 C 的各个父类进行第二步的搜索和验证过程</li><li>如果始终没有找到合适的方法, 则抛出 java.lang.AbstractMethodError 异常</li></ol></blockquote><p>正是因为 invokevirtual 指令执行的第一步就是在运行期确定接收者的实际类型, 所以两次调用中的 invokevirtual 指令并不是把常量池中方法的符号引<br>用解析到直接引用上就结束了, 还会根据方法接收者的实际类型来选择方法版本, 这个过程就是 Java 语言中方法重写的本质。我们把这种在运行期根据实际类<br>型确定方法执行版本的分派过程称为<strong>动态分派</strong>。</p><p>注: Java 中字段是不参与多态的, 调用某个类的某个字段, 这个字段需要在这个类中能看到, 当子类和父类存在同名字段, 子类的内存中 2 个字段都存在,<br>但是子类的字段会遮蔽父类的同名字段, 既子类的字段优先。</p><h3 id="2-3-单分派和多分派"><a href="#2-3-单分派和多分派" class="headerlink" title="2.3 单分派和多分派"></a>2.3 单分派和多分派</h3><p>方法的接收者 (可以理解为具体的类) 与方法的参数统称为方法的宗量。<br>根据分派基于多少种宗量, 可以将分派划分为单分派和多分派两种。<br>单分派是根据一个宗量对目标方法进行选择, 多分派则是根据多于一个宗量对目标方法进行选择。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dispatch</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">QQ</span><span class="token punctuation">&#123;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">WeChat</span><span class="token punctuation">&#123;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hardChoice</span><span class="token punctuation">(</span><span class="token class-name">QQ</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>               <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Father choose QQ"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>          <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hardChoice</span><span class="token punctuation">(</span><span class="token class-name">WeChat</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>               <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Father choose WeChat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">&#123;</span>          <span class="token annotation punctuation">@Override</span>          <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hardChoice</span><span class="token punctuation">(</span><span class="token class-name">QQ</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>               <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Son choose QQ"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>          <span class="token annotation punctuation">@Override</span>          <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hardChoice</span><span class="token punctuation">(</span><span class="token class-name">WeChat</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>               <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Son choose WeChat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token class-name">Father</span> father <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token class-name">Father</span> son <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// Father choose WeChat</span>          father<span class="token punctuation">.</span><span class="token function">hardChoice</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WeChat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// Son choose QQ</span>          son<span class="token punctuation">.</span><span class="token function">hardChoice</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">QQ</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>对应的字节码</p><pre class="language-none"><code class="language-none">0: new           #2                  &#x2F;&#x2F; class Dispatch$Father3: dup4: invokespecial #3                  &#x2F;&#x2F; Method Dispatch$Father.&quot;&lt;init&gt;&quot;:()V7: astore_18: new           #4                  &#x2F;&#x2F; class Dispatch$Son11: dup12: invokespecial #5                  &#x2F;&#x2F; Method Dispatch$Son.&quot;&lt;init&gt;&quot;:()V15: astore_216: aload_117: new           #6                  &#x2F;&#x2F; class Dispatch$WeChat20: dup21: invokespecial #7                  &#x2F;&#x2F; Method Dispatch$WeChat.&quot;&lt;init&gt;&quot;:()V24: invokevirtual #8                  &#x2F;&#x2F; Method Dispatch$Father.hardChoice:(LDispatch$WeChat;)V27: aload_228: new           #9                  &#x2F;&#x2F; class Dispatch$QQ31: dup32: invokespecial #10                 &#x2F;&#x2F; Method Dispatch$QQ.&quot;&lt;init&gt;&quot;:()V35: invokevirtual #11                 &#x2F;&#x2F; Method Dispatch$Father.hardChoice:(LDispatch$QQ;)V38: return</code></pre><p>首先分析编译阶段, 也就是静态分派阶段:<br>静态分派阶段 2 个 hardChoice() 方法的版本, 选择依据有: 一是静态类型是 Father, 还是 Son, 二就是方法参数是 QQ, 还是 WeChat。这一次选择最终产生<br>了两条 invokevirtual 指令, 两条指令分别是上面的 21 和 35, 也就是 Father::hardChoice(WeChat) 和 Father::hardChoice(QQ)。<br>静态分派根据 2 个总量进行选择, 所以静态分派是属于多分派类型</p><p>再分析运行阶段, 也就是动态分派阶段<br>在执行 2 个 invokevirtual 指令时, 由于编译期已经决定了目标方法的参数是 QQ, 还是 WeChat, 虚拟机可以不关心入参, 此时影响虚拟机选择的因素只有该<br>方法的接收者的实际类型是 Father, 还是 Son。因为只有一个宗量作为选择依据, 所以动态分派属于单分派类型。</p><p>所以, 如今 Java 语言是一门静态多分派, 动态单分派语言。</p><h3 id="2-4-动态分派的实现"><a href="#2-4-动态分派的实现" class="headerlink" title="2.4 动态分派的实现"></a>2.4 动态分派的实现</h3><p>动态分派是执行非常频繁的动作, 而且动态分派的方法版本选择过程需要运行时在接收者类型的方法元数据中搜索合适的目标方法, 因此, Java 虚拟机实现基<br>于执行性能的考虑, 真正运行时一般不会如此频繁地去反复搜索类型元数据。</p><p>面对这种情况, 一种基础而且常见的优化手段是为类型在方法区中建立一个虚方法表 (Virtual Method Table, 也成为 vtable。<br>与此对应的, 在 invokeinterface 执行时也会用到接口方法表 – Interface Method Table, 简称 itable)。</p><p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写, 那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的, 都指向父<br>类的实现入口, 如果子类中重写了这个方法, 子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</p><p>虚方法表一般在类加载的连接阶段进行初始化, 准备了类的变量初始值后, 虚拟机会把该类的虚方法也一同初始化。<br>虚拟机除了使用虚方法表之外, 为了进一步提高性能, 还使用类型继承关系分析 (Class Hierarchy Analysis, CHA), 守护内联 (Guarded Inlining),<br>内联缓存 (Inline Cache) 等多种非稳定的激进优化来争取更多的性能空间。</p><h2 id="3-Java-与动态类型"><a href="#3-Java-与动态类型" class="headerlink" title="3 Java 与动态类型"></a>3 Java 与动态类型</h2><p>动态类型语言与动态语言, 弱类型语言并不是一个概念, 动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的, 所以 Java 本身<br>是一门静态类型语言。</p><h3 id="3-1-java-lang-invoke-包"><a href="#3-1-java-lang-invoke-包" class="headerlink" title="3.1 java.lang.invoke 包"></a>3.1 java.lang.invoke 包</h3><p>JDK7 时新加入的 java.lang.invoke 包, 用于在单纯依靠符号引用来确定调用目标方法之外, 提供一种新的动态确定目标方法的方式, 称为 “方法句柄 (Method Handler)”。</p><p>举个例子, 在 Java 中要给一个集合排序的话, 需要怎么做的? 普遍的做法是设计一个带有 compare() 方法的 Comparator 接口, 以实现这个接口的对象作为参数。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">List</span> list<span class="token punctuation">,</span> <span class="token class-name">Comparator</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>但是在 C&#x2F;C++ 中常用做法是, 实现一个带谓词 (也就是动词, 一个排序时比较大小的动作) 的排序函数, 然后把函数指针传递到排序方法, 像这样</p><pre class="language-C" data-language="C"><code class="language-C">void sort(int list[], int size, int (*compare) (int, int))</code></pre><p>句柄的作用就是在 Java 语言上实现类似于函数指针或者委托的方法别名这样的工具。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodHandleTest</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ClassA</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>         <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">ClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 无论 obj 最终是哪个实现类, 下面这句都能正确调用到 println 方法。</span>        <span class="token function">getPrintlnMH</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invokeExact</span><span class="token punctuation">(</span><span class="token string">"string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>     <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">MethodHandle</span> <span class="token function">getPrintlnMH</span><span class="token punctuation">(</span><span class="token class-name">Object</span> receiver<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// MethodType: 代表 "方法类型", 包含了方法的返回值 (methodType() 的第一个参数) 和具体参数 (methodType() 第二个及以后的参数)</span>          <span class="token class-name">MethodType</span> mt <span class="token operator">=</span> <span class="token class-name">MethodType</span><span class="token punctuation">.</span><span class="token function">methodType</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 这句的作用是在指定类中查找符合给定的方法 名称、方法类型, 并且符合调用权限的方法句柄</span>          <span class="token comment">// 因为这里调用的是一个虚方法, 按照 Java 语言的规则, 方法第一个参数是隐式的, 代表该方法的接收者, 也即 this 指向的对象, 这个参</span>          <span class="token comment">// 数以前是放在参数列表中进行传递, 现在提供了 bindTo() 方法来完成这件事情</span>          <span class="token keyword">return</span> <span class="token class-name">MethodHandles</span><span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findVirtual</span><span class="token punctuation">(</span>receiver<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"println"</span><span class="token punctuation">,</span> mt<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bindTo</span><span class="token punctuation">(</span>receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>方法 getPrintlnMH() 中实际上是模拟了 invokevirtual 指令的执行过程, 只不过它的分派逻辑并非固化在 Class 文件的字节码上, 而是通过一个由用<br>户设计的 Java 方法来实现。而这个方法本身的返回值 (MethodHandler 对象), 可以视为对最终调用方法的一个 “引用”。</p><p>有了 MethodHandle 就可以写出类似于 C&#x2F;C++ 那样的函数声明了</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">List</span> list<span class="token punctuation">,</span> <span class="token class-name">MethodHandle</span> compare<span class="token punctuation">)</span></code></pre><ul><li>MethodHandler 和 Reflection 的 区别</li></ul><ol><li><p>Reflection 和 MethodHandle 机制本质上都是在模拟方法调用, 但是 Reflection 是在模拟 Java 代码层次的方法调用, 而 MethodHandle 是在模拟<br>字节码层次的方法调用。 在 MethodHandles.Lookup 上的 3 个方法 findStatic(), findVirtual(), findSpecial() 对应 invokestatic, invokevirtual<br>(以及 invokeinterface) 和 invokespecial 这几条字节码指令的执行权限校验行为。</p></li><li><p>Reflection 中的 java.lang.reflect.Method 对象远比 MethodHandle机 制中的 java.lang.invoke.MethodHandle 对象所包含的信息来得多。<br>前者是方法在 Java 端的全面映像, 包含了方法的签名, 描述符以及方法属性表中各种属性的 Java 端表示方式, 还包含执行权限等的运行期信息。而后者<br>仅包含执行该方法的相关信息。用开发人员通俗的话来讲, Reflection 是重量级, 而 MethodHandle 是轻量级</p></li><li><p>由于 MethodHandle 是对字节码的方法指令调用的模拟, 那理论上虚拟机在这方面做的各种优化 (如方法内联), 在 MethodHandle 上也应当可以采用类<br>似思路去支持 (但目前实现还在继续完善中), 而通过反射去调用方法则几乎不可能直接去实施各类调用点优化措施</p></li><li><p>Reflection API 的设计目标是只为 Java 语言服务的, 而 MethodHandle 则设计为可服务于所有 Java 虚拟机之上的语言</p></li></ol><h3 id="3-2-invokedynamic-指令"><a href="#3-2-invokedynamic-指令" class="headerlink" title="3.2 invokedynamic 指令"></a>3.2 invokedynamic 指令</h3><p>invokedynamic 指令与 MethodHandle 机制的作用是一样的, 都是为了解决原有 4 条 “invoke*” 指令方法分派规则完全固化在虚拟机之中的问题, 把如<br>何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中, 让用户 (广义的用户, 包含其他程序语言的设计者) 有更高的自由度。而且, 它们两者的思路也是<br>可类比的, 都是为了达成同一个目的, 只是一个用上层代码和 API 来实现, 另一个用字节码和 Class 中其他属性, 常量来完成。</p><p>每一处含有 invokedynamic 指令的位置都被称作 “动态调用点 (Dynamically-Computed Call Site)”, 这条指令的第一个参数不再是代表方法符号引用<br>的 CONSTANT_Methodref_info 常量, 而是变为 JDK7 时新加入的 CONSTANT_InvokeDynamic_info 常量。</p><p>从这个新常量中可以得到 3 项信息: 引导方法 (Bootstrap Method, 该方法存放在新增的 BootstrapMethods 属性中), 方法类型 (MethodType)<br>和名称。引导方法是有固定的参数, 并且返回值规定是 java.lang.invoke.CallSite 对象, 这个对象代表了真正要执行的目标方法调用。 根据 CONSTANT_InvokeDynamic_info<br>常量中提供的信息, 虚拟机可以找到并且执行引导方法, 从而获得一个 CallSite 对象, 最终调用到要执行的目标方法上。</p><p>由于 invokedynamic 指令面向的主要服务对象并非 Java 语言, 而是其他 Java 虚拟机之上的其他动态类型语言, 因此, 光靠 Java 语言的编译器 Javac<br>的话, 在 JDK7 时甚至还完全没有办法生成带有 invokedynamic 指令的字节码。</p><p>一般情况的字节码是这样的</p><pre class="language-none"><code class="language-none">Constant pool:     #121 &#x3D; NameAndType #33:#30 &#x2F;&#x2F; testMethod:(Ljava&#x2F;lang&#x2F;String;)V      #123 &#x3D; InvokeDynamic #0:#121 &#x2F;&#x2F; #0:testMethod:(Ljava&#x2F;lang&#x2F;String;)V     public static void main(java.lang.String[]) throws java.lang.Throwable;     Code:          stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1               0: ldc #23 &#x2F;&#x2F; String abc                2: invokedynamic #123, 0 &#x2F;&#x2F; InvokeDynamic #0:testMethod: (Ljava&#x2F;lang&#x2F;String;)V                7: nop                8: return</code></pre><p>在 main 方法中, invokedynamic 它的参数为第 123 项常量池 (第二个值为 0, 虚拟机中不会直接使用, 只是其占位作用, 是为了给常量池缓存留出足够<br>的空间)</p><p>从常量池中可见, 第 123 项常量显示 “#123&#x3D;InvokeDynamic#0：#121” 说明它是一项 CONSTANT_InvokeDynamic_info 类型常量, 常量值中前面 “#0”<br>代表引导方法取 Bootstrap Methods 属性表的第 0 项。而后面的 “#121”, 代表引用第 121 项类型为 CONSTANT_NameAndType_info 的常量, 从这个<br>常量中可以获取到方法名称和描述符, 即后面输出的 “testMethod： (Ljava&#x2F;lang&#x2F;String;)V”</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p>《深入理解Java虚拟机》- 周志明  </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM 编译和优化</title>
      <link href="/article/2021/4024797796/"/>
      <url>/article/2021/4024797796/</url>
      
        <content type="html"><![CDATA[<p>在构建高性能的 Java 应用程序时, 理解 Java 编译和优化的工作原理是至关重要的。<br>Java 虚拟机（JVM）通过即时编译（Just-In-Time Compilation）将源代码转化为机器可执行代码, 并通过一系列优化技术提升应用程序性能。<br>本文将简单地研究 Java 编译的各个阶段, 探讨不同优化技术的实际效果, 并为开发者提供实用的指导, 以确保他们能够最大限度地发挥 Java 在性能方面的优势。</p><h2 id="1-前端编译"><a href="#1-前端编译" class="headerlink" title="1 前端编译"></a>1 前端编译</h2><p>在 Java 技术下, “编译期” 是一个比较含糊的表述, 因为它可能指的是</p><blockquote><ol><li>前端编译器 (“编译器的前端” 更准确一些) 把 *.java 文件转变成 *.class 文件的过程</li><li>Java 虚拟机的即时编译器 (常称 JIT 编译器, Just In Time Compiler) 运行期把字节码转变成本地机器码的过程</li><li>使用静态的提前编译器 (常称 AOT 编译器, Ahead Of Time Compiler) 直接把程序编译成与目标机器指令集相关的二进制代码的过程</li></ol></blockquote><p>这三者的代表性编译器产品</p><blockquote><ol><li>前端编译器: JDK 的 Javac, Eclipse JDT 中的增量式编译器 (ECJ)</li><li>即时编译器: HotSpot 虚拟机的 C1, C2 编译器, Graal 编译器</li><li>提前编译器: JKD 的 Jaotc, GNU Compiler for the Java (GCJ), Excelsior JET</li></ol></blockquote><p>这 3 类过程中最符合普通程序员对 Java 程序编译认知的应该是第一类。下面讨论的基本都限制在第一种情况。</p><h3 id="1-1-Javac-源码"><a href="#1-1-Javac-源码" class="headerlink" title="1.1 Javac 源码"></a>1.1 Javac 源码</h3><p>在 JDK8 中, Javac 的源码主要存放在 $JAVA_HOME&#x2F;lib&#x2F;tools.jar, 拷贝一份到一个地方, 解压后, 依次进入 com&#x2F;sun&#x2F;tools&#x2F;javac, 这里就是源<br>码的地方。当然最简单的方式就是打开一包编译器, 顺便建立一个 Java 项目, 搜索 com.sun.tools.javac.Main 就可以了。</p><p>从 Javac 代码的总体结构来看, 编译过程大致可以分为 1 个准备过程和 3 个处理过程, 它们分别如下所示</p><blockquote><ol><li>准备过程: 初始化插入式注解处理器</li><li>解析与填充符号表过程, 包括<blockquote><p>2.1 词法, 语法分析。将源代码的字符流转变为标记集合, 构造出抽象语法树<br>2.2 填充符号表。产生符号地址和符号信息</p></blockquote></li><li>插入式注解处理器的注解处理过程: 插入式注解处理器的执行阶段</li><li>分析与字节码生成过程, 包括<blockquote><p>4.1 标注检查。对语法的静态信息进行检查<br>4.2 数据流及控制流分析。对程序动态运行过程进行检查<br>4.3 解语法糖。将简化代码编写的语法糖还原为原有的形式<br>4.4 字节码生成。将前面各个步骤所生成的信息转化成字节码</p></blockquote></li></ol></blockquote><p>上述 3 个处理过程里, 执行插入式注解时又可能会产生新的符号, 如果有新的符号产生, 就必须转回到之前的解析, 填充符号表的过程中重新处理这些新符号。<br>大体的流程如下:<br><img src="https://pic.imgdb.cn/item/6585979ec458853aefd9b3b7.png" alt="Alt &#39;Java 处理器处理过程&#39;"></p><p>代码的入口: com.sun.tools.javac.main.JavaCompiler, 后面整个详细的流程省略。</p><p>流程:</p><ol><li><p>词法分析, 源代码的字符流转变为标记 (Token) 集合, 主要由 com.sun.tools.javac.parser.Scanner 实现  </p></li><li><p>语法分析, 根据标记序列构造抽象语法树, 主要由 com.sun.tools.javac.parser.Parser, 产生的抽象树为 com.sun.tools.javac.tree.JCTree  </p></li><li><p>填充符号表, 对符号表进行填充, 主要由 com.sun.tools.javac.parser.Enter  </p></li><li><p>注解处理器, 通过注解处理器, 可以对抽象语法树中的元素进行读取, 修改, 添加, 在处理注解期间对语法树进行过修改, 编译器将回到解析及填充符号表<br>的过程重新处理, 直到所有插入式注解处理器都没有再对语法树进行修改为止。插入式注解处理器的初始主要为 com.sun.tools.javac.main.JavaCompiler.initPorcessAnnotations,<br>而执行过程则为 com.sun.tools.javac.main.JavaCompiler.processAnnotions</p></li><li><p>语义分析, 是对结构上正确的源程序进行上下文相关性质的检查, 大体可以分为 2 个流程 标注检查 (JavaCompiler.attribute) 和控制流分析 (JavaCompiler.flow)。<br>标注检查中, 会对源代码中做一个 “常量折叠 (Constant Folding)” 的优化 (int a &#x3D; 1 + 4; &#x3D;&#x3D;&gt; int a &#x3D; 5) </p></li><li><p>解语法糖, 把语法糖还原回原始的基础语法结构, 由 com.sun.tools.javac.comp.TransTypes 和  com.sun.tools.javac.comp.Lower 完成</p></li><li><p>字节码生成, 由 com.sun.tools.javac.jvm.Gen 完成, 把前面各个步骤生成的信息 (语法树, 符号表) 转为字节码, 还会进行少了代码的添加和转换,<br>类似于 <init> 和 <clinit>, 将字符串的 + , 替换为 StringBuffer 或者 StringBuilder 的 append 操作</p></li><li><p>最终由 com.sun.tools.javac.jvm.ClassWriter 输出字节码, 生成 Class 文件。</p></li></ol><h2 id="2-后端编译"><a href="#2-后端编译" class="headerlink" title="2 后端编译"></a>2 后端编译</h2><p>编译器无论在何时, 在何种状态下把 Class 文件转换成与本地基础设施 (硬件指令集, 操作系统) 相关的二进制机器码, 它都可以视为整个编译过程的后端。</p><h3 id="2-1-即时编译器"><a href="#2-1-即时编译器" class="headerlink" title="2.1 即时编译器"></a>2.1 即时编译器</h3><p>目前主流的两款商用 Java 虚拟机 (HotSpot, OpenJ9) 里, Java 程序最初都是通过解释器 (Interpreter) 进行解释执行的, 当虚拟机发现某个方法或<br>代码块的运行特别频繁, 就会把这些代码认定为 “热点代码 (Hot Spot Code)”, 为了提高热点代码的执行效率, 在运行时, 虚拟机将会把这些代码编译成本<br>地机器码, 并以各种手段尽可能地进行代码优化, 运行时完成这个任务的后端编译器被称为即时编译器。</p><p>现在主流的 Java 虚拟机内部都同时包含解释器和编译器, 2 者各有好处。<br>当程序需要迅速启动和执行的时候, 解释器可以首先发挥作用, 省去编译的时间, 立即运行。当程序启动后, 随着时间的推移, 编译器逐渐发挥作用, 把越来<br>越多的代码编译成本地代码, 这样可以减少解释器的中间损耗, 获得更高的执行效率。<br>当运行环境的内存资源限制较大时, 使用解释执行可以节约内存, 反之, 可以使用编译执行提高效率。<br>解释器可以作为编译器激进优化 (不能保证所有情况都正确, 但大多数时候都能提升运行速度的优化) 的后备”逃生门”, 通过逆优化退回到解释状态执行。</p><p>HotSpot 虚拟机中内置了两个 (或三个) 即时编译器: 客户端编译器 (Client Compiler, 简称 C1), 服务端编译器 (Service Compiler, 简称 C2),<br>还有 JDK10 出现的长期目标是替代 C2 的 Graal 编译器。</p><p>热点代码</p><ul><li>被多次调用的方法  </li><li>被多次执行的循环体</li></ul><p>对于这两种情况, 编译的目标对象都是整个方法体, 而不会是单独的循环体。</p><p>HotSpot 采用基于计数器的热点探测 (Counter Based Hot Spot Code Detection) 的方式确定方法是否为 “热点代码”。 虚拟机会为每个方法 (甚至是代码块)<br>建立计数器, 统计方法的执行次数, 如果执行次数超过一定的阈值就认为它是 “热点方法”。</p><p>为了实现热点计数, HotSpot 为每个方法准备了两类计数器: 方法调用计数器 (Invocation Counter) 和回边计数器 (Back Edge Counter, “回边” 的<br>意思就是指在循环边界往回跳转)。调用计数器 + 回边计数器之和超过了阈值 (客户端模式, 默认为 1500 次, 服务端模式: 10000 次), 就会向即时编译器<br>提交一个该方法的代码编译请求。</p><h3 id="2-2-提前编译器"><a href="#2-2-提前编译器" class="headerlink" title="2.2 提前编译器"></a>2.2 提前编译器</h3><p>2 种作法:<br>一条分支是做与传统 C, C++ 编译器类似的, 在程序运行之前把程序代码编译成机器码的静态翻译工作;<br>另外一条分支是把原本即时编译器在运行时要做的编译工作提前做好并保存下来, 下次运行到这些代码 (譬如公共库代码在被同一台机器其他 Java 进程使用)<br>时直接把它加载进来使用</p><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h2><p>《深入理解Java虚拟机》- 周志明</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM 栈帧</title>
      <link href="/article/2021/3794460514/"/>
      <url>/article/2021/3794460514/</url>
      
        <content type="html"><![CDATA[<p>执行引擎是 Java 虚拟机核心的组成部分之一。 在《Java虚拟机规范》中制定了 Java 虚拟机字节码执行引擎的概念模型,<br>这个概念模型成为各大发行商的 Java 虚拟机执行引擎的统一外观 (Facade)。 </p><p>不同的虚拟机的实现中, 通常会有</p><blockquote><ol><li>解释执行 (通过解释器执行) </li><li>编译执行 (通过即时编译器产生本地代码执行)<br>两种选择, 也可能两者兼备, 还可能会有同时包含几个不同级别的即时编译器一起工作的执行引擎。<br>但是从外观上看, 所有的 Java 虚拟机的执行引擎都是: 输入的是<strong>字节码二进制流</strong>, 输出的是<strong>执行结果</strong>。</li></ol></blockquote><p>而这一个的过程, 落实到 HotSpot 的实现就是<strong>运行时栈帧</strong>。<br>下面会对<strong>运行时栈帧</strong>做一个简单的介绍。</p><h2 id="1-运行时栈帧"><a href="#1-运行时栈帧" class="headerlink" title="1 运行时栈帧"></a>1 运行时栈帧</h2><p>Java 虚拟机以方法作为最基本的执行单元, “栈帧” (Stack Frame) 则是用于支持虚拟机进行方法调用和方法执行背后的数据结构, 它也是虚拟机运行时数<br>据区中的虚拟机栈 (Virtual Machine Stack) 的栈元素。  </p><p>栈帧存储了方法的<strong>局部变量表</strong> + <strong>操作数栈</strong> + <strong>动态连接</strong> + <strong>方法返回地址</strong>等信息。<br>每一个方法从调用开始至执行结束的过程, 都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p><p>在编译 Java 程序源码的时候, 栈帧中需要多大的局部变量表, 需要多深的操作数栈就已经被分析计算出来, 并且写入到方法表的 Code 属性之中。<br>一个栈帧需要分配多少内存, 并不会受到程序运行期变量数据的影响, 而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。</p><p>一个线程中的方法调用链可能会很长, 以 Java 程序的角度来看, 同一时刻, 同一条线程里面, 在调用堆栈的所有方法都同时处于执行状态。而对于执行引擎<br>来讲, 在活动线程中, 只有位于栈顶的方法才是在运行的, 只有位于栈顶的栈帧才是生效的, 其被称为 “当前栈帧” (Current Stack Frame), 与这个栈帧<br>所关联的方法被称为 “当前方法” (Current Method)。</p><p>综上, 栈帧的结构如下:<br><img src="https://pic.imgdb.cn/item/65a3cf24871b83018a13c595.png" alt="Alt &#39;栈帧结构&#39;"></p><h2 id="2-局部变量表-Local-Variables-Table"><a href="#2-局部变量表-Local-Variables-Table" class="headerlink" title="2 局部变量表 - Local Variables Table"></a>2 局部变量表 - Local Variables Table</h2><p>局部变量表是一组变量值的存储空间, 用于存放方法参数和方法内部定义的局部变量。在 Java 程序被编译为 Class 文件时, 就在方法的 Code 属性的<br>max_locals 数据项中确定了该方法所需分配的局部变量表的最大容量。</p><p>局部变量表的容量以变量槽 (Variable Slot) 为最小单位。1 个槽的具体大小, 《Java虚拟机规范》中并没有明确指出, 但是引导性地说明了 </p><blockquote><ol><li>boolean </li><li>byte</li><li>char</li><li>short</li><li>int</li><li>float</li><li>reference</li><li>returnAddress 类型的数据<br>这 8 种数据类型, 都可以使用 32 位或更小的物理内存来存储。</li></ol></blockquote><p>reference 类型表示对一个对象实例的引用, 《Java虚拟机规范》既没有说明它的长度, 也没有明确指出这种引用应有怎样的结构。<br>但是需要能通过这个引用做到两件事情</p><blockquote><ol><li>从根据引用直接或间接地查找到对象在 Java 堆中的数据存放的起始地址或索引</li><li>根据引用直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息</li></ol></blockquote><p>returnAddress 类型模板很少见了, 它是为字节码指令 jsr, jsr_w 和 ret 服务的, 指向了一条字节码指令的地址, 某些很古老的 Java 虚拟机曾<br>经使用这几条指令来实现异常处理时的跳转, 但现在也已经全部改为采用异常表来代替了。</p><p>对于 64 位的数据类型, Java 虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间。Java 语言中明确的 64 位的数据类型只有 long 和 double 两种。  </p><p>Java 虚拟机通过索引定位的方式使用局部变量表, 索引值的范围是从 0 开始至局部变量表最大的变量槽数量。如果访问的是 32 位数据类型的变量, 索引 N<br>就代表了使用第 N 个变量槽, 如果访问的是 64 位数据类型的变量, 则说明会同时使用第 N 和 N + 1 两个变量槽。 对于两个相邻的共同存放一个 64 位数<br>据的两个变量槽, 虚拟机不允许采用任何方式单独访问其中的某一个。</p><p>当一个方法被调用时, Java 虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程, 即实参到形参的传递。 如果执行的是实例方法 (没有被 static<br>修饰的方法), 那局部变量表中第 0 位索引的变量槽默认是用于传递方法所属对象实例的引用, 在方法中可以通过关键字 “this” 来访问到这个隐含的参数。<br>其余参数则按照参数表顺序排列, 占用从 1 开始的局部变量槽, 参数表分配完毕后, 再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</p><p>为了尽可能节省栈帧耗用的内存空间, 局部变量表中的变量槽是可以重用的, 方法体中定义的变量, 其作用域并不一定会覆盖整个方法体, 如果当前字节码 PC<br>计数器的值已经超出了某个变量的作用域, 那这个变量对应的变量槽就可以交给其他变量来重用。 不过, 这样的设计除了节省栈帧空间以外, 还会伴随有少量<br>额外的副作用, 例如在某些情况下变量槽的复用会直接影响到系统的垃圾收集行为</p><p>注: 在虚拟机运行参数中加上 “-verbose:gc” 来看看垃圾收集的过程。 </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> placeholder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre><p>输出结果:</p><pre class="language-log" data-language="log"><code class="language-log"><span class="token punctuation">[</span>GC <span class="token operator">(</span>System<span class="token punctuation">.</span>gc<span class="token operator">(</span><span class="token operator">)</span><span class="token operator">)</span>  <span class="token number">76402K</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">67232K</span><span class="token operator">(</span><span class="token number">188416K</span><span class="token operator">)</span><span class="token punctuation">,</span> <span class="token number">0.0062015</span> secs<span class="token punctuation">]</span><span class="token punctuation">[</span>Full GC <span class="token operator">(</span>System<span class="token punctuation">.</span>gc<span class="token operator">(</span><span class="token operator">)</span><span class="token operator">)</span>  <span class="token number">67232K</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">67164K</span><span class="token operator">(</span><span class="token number">188416K</span><span class="token operator">)</span><span class="token punctuation">,</span> <span class="token number">0.0253018</span> secs<span class="token punctuation">]</span></code></pre><p>发现在 System.gc() 运行后并没有回收掉这 64MB 的内存, 因为在执行 System.gc() 时, 变量 placeholder 还处于作用域之内, 虚拟机自然不敢回收掉 placeholder 的内存。</p><p>修改一下代码</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> placeholder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre><p>输出结果:</p><pre class="language-log" data-language="log"><code class="language-log"><span class="token punctuation">[</span>GC <span class="token operator">(</span>System<span class="token punctuation">.</span>gc<span class="token operator">(</span><span class="token operator">)</span><span class="token operator">)</span>  <span class="token number">76402K</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">67232K</span><span class="token operator">(</span><span class="token number">188416K</span><span class="token operator">)</span><span class="token punctuation">,</span> <span class="token number">0.0062015</span> secs<span class="token punctuation">]</span><span class="token punctuation">[</span>Full GC <span class="token operator">(</span>System<span class="token punctuation">.</span>gc<span class="token operator">(</span><span class="token operator">)</span><span class="token operator">)</span>  <span class="token number">67232K</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">67164K</span><span class="token operator">(</span><span class="token number">188416K</span><span class="token operator">)</span><span class="token punctuation">,</span> <span class="token number">0.0253018</span> secs<span class="token punctuation">]</span></code></pre><p>在 if 判断结束后, placeholder 的作用域被限制在花括号以内, 从代码逻辑上讲, 在执行 System.gc() 的时候, placeholder 已经不可能再被访问了, 但执行这段程序 gc 后, 64MB 的内存还是没释放。</p><p>再做一下修改</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> placeholder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>这次的输出结果:</p><pre class="language-log" data-language="log"><code class="language-log"><span class="token punctuation">[</span>GC <span class="token operator">(</span>System<span class="token punctuation">.</span>gc<span class="token operator">(</span><span class="token operator">)</span><span class="token operator">)</span>  <span class="token number">76402K</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">67232K</span><span class="token operator">(</span><span class="token number">188416K</span><span class="token operator">)</span><span class="token punctuation">,</span> <span class="token number">0.0038170</span> secs<span class="token punctuation">]</span><span class="token punctuation">[</span>Full GC <span class="token operator">(</span>System<span class="token punctuation">.</span>gc<span class="token operator">(</span><span class="token operator">)</span><span class="token operator">)</span>  <span class="token number">67232K</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1629K</span><span class="token operator">(</span><span class="token number">188416K</span><span class="token operator">)</span><span class="token punctuation">,</span> <span class="token number">0.0189803</span> secs<span class="token punctuation">]</span></code></pre><p>placeholder 能否被回收的根本原因就是: 局部变量表中的变量槽是否还存有关于 placeholder 数组对象的引用。 第一次修改中, 代码虽然已经离开了 placeholder 的作用域, 但在此之后, 再没有发生过任何对局部变量表的读写操作, placeholder 原本所占用的变量槽还没有被其他变量所复用。 所以作为 GC Roots 一部分的局部变量表仍然保持着对它的关联。 这种关联没有被及时打断,  绝大部分情况下影响都很轻微。 但如果遇到一个方法, 其后面的代码有一些耗时很长的操作, 而前面又定义了占用了大量内存但实际上已经不会再使用的变量, 手动将其设置为 null 值 (用来代替那句 int<br>a&#x3D;12, 把变量对应的局部变量槽清空) 便不见得是一个绝对无意义的操作, 这种操作可以作为一种在极特殊情形 (对象占用内存大, 此方法的栈帧长时间不能被回收, 方法调用次数达不到即时编译器的编译条件) 下的 “奇技” 来使用。</p><p>我们知道在类的加载阶段, 对于类的属性值, 会存在 2 次赋值, 第一次在准备阶段, 基于了字段的默认值, 第二次基于字段真正的数值。 但是在局部变量中, 如果只声明了, 但是没有赋值, 这个字段是没法使用的, 因为其不存在默认值。</p><h2 id="3-操作数栈-Operand-Stack"><a href="#3-操作数栈-Operand-Stack" class="headerlink" title="3 操作数栈 - Operand Stack"></a>3 操作数栈 - Operand Stack</h2><p>操作数栈也常被称为操作栈, 是一个后入先出 (Last In First Out, LIFO) 的栈。<br>操作数栈的最大深度也在编译的时候被写入到 Code 属性的 max_stacks 数据项之中。 操作数栈的每一个元素都可以是包括 long 和 double 在内的任意 Java 数据类型。 32 位数据类型所占的栈容量为 1, 64 位数据类型所占的栈容量为 2。 当一个方法刚刚开始执行的时候, 这个方法的操作数栈是空的, 在方法的执行过程中, 会有各种<strong>字节码指令</strong>往操作数栈中写入和提取内容, 也就是出栈和入栈操作。 例如: 整数加法的字节码指令 iadd, 会从操作数栈的顶部出去 2 个数, 相加后, 在存入栈顶。</p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配。 每个字节码都有其操作的数据类型限制。 这个限制编译程序代码的时候, 编译器会进行保证, 在类校验阶段的数据流分析中还会再次验证这一点。</p><p>在概念模型中, 两个不同栈帧作为不同方法的虚拟机栈的元素, 是完全相互独立的。 但是在大多虚拟机的实现里都会进行一些优化处理, 令两个栈帧出现一部分重叠。 让下面栈帧的部分操作数 栈与上面栈帧的部分局部变量表重叠在一起, 这样做不仅节约了一些空间, 更重要的是在进行方法调 用时就可以直接共用一部分数据, 无须进行额外的参数复制传递了。</p><p><img src="https://pic.imgdb.cn/item/65a3cf22871b83018a13bdaf.png" alt="Alt &#39;栈帧真实实现&#39;"></p><ul><li>操作数栈 + 局部变量表配合的流程</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> add <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        num1 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>先通过 <code>javac Application.java</code><br>得到字节码文件, 再通过 <code>javap -c -l -p -v Application.class &gt;&gt; class.txt</code></p><p>打开 class.txt 就能得到我们的字节码文件了, 内容如下</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Compiled</span> from <span class="token string">"Application.java"</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token class-name">Application</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Code</span><span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> aload_0       <span class="token number">1</span><span class="token operator">:</span> invokespecial #<span class="token number">1</span>                  <span class="token comment">// Method java/lang/Object."&lt;init>":()V</span>       <span class="token number">4</span><span class="token operator">:</span> <span class="token keyword">return</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>InterruptedException</span><span class="token punctuation">;</span>    <span class="token class-name">Code</span><span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> iconst_1       <span class="token number">1</span><span class="token operator">:</span> iconst_2       <span class="token number">2</span><span class="token operator">:</span> invokestatic  #<span class="token number">2</span>                  <span class="token comment">// Method add:(II)I</span>       <span class="token number">5</span><span class="token operator">:</span> istore_1       <span class="token number">6</span><span class="token operator">:</span> getstatic     #<span class="token number">3</span>                  <span class="token comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>       <span class="token number">9</span><span class="token operator">:</span> iload_1      <span class="token number">10</span><span class="token operator">:</span> invokevirtual #<span class="token number">4</span>                  <span class="token comment">// Method java/io/PrintStream.println:(I)V</span>      <span class="token number">13</span><span class="token operator">:</span> <span class="token keyword">return</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Code</span><span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> iconst_3       <span class="token number">1</span><span class="token operator">:</span> istore_0       <span class="token number">2</span><span class="token operator">:</span> iload_0       <span class="token number">3</span><span class="token operator">:</span> iload_1       <span class="token number">4</span><span class="token operator">:</span> iadd       <span class="token number">5</span><span class="token operator">:</span> istore_2       <span class="token number">6</span><span class="token operator">:</span> iload_2       <span class="token number">7</span><span class="token operator">:</span> ireturn<span class="token punctuation">&#125;</span></code></pre><p>整理成图的话, 调用 add 方法前是这样的</p><p><img src="https://pic.imgdb.cn/item/65a3cf20871b83018a13b66d.png" alt="Alt &#39;栈帧处理过程-步骤1&#39;"></p><ul><li>先看一下 add 方法的局部变量</li></ul><p>首先我们看到 add 方法的局部变量表有三个属性, 分别是入参的 num1, num2, 还有方法内部声明的 result 变量。</p><p>补充说明: 因为这里的 add 方法是静态的, 所以入参有几个变量, 那么局部变量表就有几个。<br>在实际中, 如果方法是非静态的话, 局部变量变的第一个会多 1 个 this 的变量, 后面才是入参。</p><ul><li>add 方法的操作数栈的变化</li></ul><p>各个指令的作用可以通过查看官网得知: <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">地址</a></p><p>add 方法  </p><ol><li>第一个指令 iconst_3, 把一个 int 的数字放入到操作栈, 这里的 iconst_3, 代表的是把 3 放入到操作栈 (注意这里的 iconst_? 只能表示到 5,<br>超过 5 后的指令会变成 bipush 数字)</li></ol><p>这时候的操作数栈是这样的<br><img src="https://pic.imgdb.cn/item/65a3cf1e871b83018a13abcc.png" alt="Alt &#39;栈帧处理过程-步骤2&#39;"></p><ol start="2"><li>第二个指令 istore_0, 把操作数栈, 最上面的数字 (必须是 int) 出栈, 并覆盖局部变量表第 0 的位置</li></ol><p>这时候的操作数栈是这样的<br><img src="https://pic.imgdb.cn/item/65a3cf1c871b83018a13a1dd.png" alt="Alt &#39;栈帧处理过程-步骤3&#39;"></p><p>通过查看局部变量表的变化, 我们可以知道 <code>num1 = 3</code> 在程序中是分成了 2 个指令完成的</p><ol start="3"><li>第三个指令 iload_0, 把第 0 个局部变量的值放入栈帧(这个值必须是 int 类型)<br>第四个命令为 iload_1, 那么就是把第 1 个局部变量放入到栈帧</li></ol><p>经过第三, 四个指令后, 这时候的操作数栈是这样的<br><img src="https://pic.imgdb.cn/item/65a3cf19871b83018a13967d.png" alt="Alt &#39;栈帧处理过程-步骤4&#39;"></p><ol start="4"><li>第五个指令 iadd, 把栈帧中的头 2 个 int 操作数弹出来, 进行相加, 然后再把结果入栈。</li></ol><p>经过第五个指令后, 这时候的操作数栈是这样的<br><img src="https://pic.imgdb.cn/item/65a3cf17871b83018a138c42.png" alt="Alt &#39;栈帧处理过程-步骤5&#39;"></p><p>后面的六, 七 就省略了</p><p>ireturn 从纸面上就能里面了吧, 把操作数栈中的栈顶(一个 int 的数字)返回出去。</p><p>从上面的内容, 可以知道, 操作数栈用于方法执行过程的流转, 局部变量表则用于存储临时的变量数据。</p><h2 id="4-动态连接-Dynamic-Linking"><a href="#4-动态连接-Dynamic-Linking" class="headerlink" title="4 动态连接 - Dynamic Linking"></a>4 动态连接 - Dynamic Linking</h2><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用, 持有这个引用是为了支持方法调用过程中的动态连接。<br>Class 文件的常量池中存有大量的符号引用, 字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数 (invokevirtual #4 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(I)V)<br>这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用, 这种转化被称为静态解析。 另外一部分将在每一次运行期间都转化为直接引用,<br>这部分就称为动态连接。</p><h2 id="5-方法返回地址-return-address"><a href="#5-方法返回地址-return-address" class="headerlink" title="5 方法返回地址 - return address"></a>5 方法返回地址 - return address</h2><p>当一个方法开始执行后, 只有两种方式退出这个方法。  </p><p>第一种方式是执行引擎遇到任意一个方法返回的字节码指令, 这时候可能会有返回值传递给上层的方法调用者 (调用当前方法的方法称为调用者或者主调方法),<br>方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定, 这种退出方法的方式称为 “正常调用完成” (Normal Method Invocation Completion)</p><p>第二种退出方式是在方法执行的过程中遇到了异常, 并且这个异常没有在方法体内得到妥善处理。无论是 Java 虚拟机内部产生的异常, 还是代码中使用 athrow<br>字节码指令产生的异常。只要在本方法的异常表中没有搜索到匹配的异常处理器, 就会导致方法退出, 这种退出方法的方式称为 “异常调用完成 (Abrupt Method Invocation Completion)”。<br>一个方法使用异常完成出口的方式退出, 是不会给它的上层调用者提供任何返回值的。</p><p>无论采用何种退出方式, 在方法退出之后, 都必须返回到最初方法被调用时的位置, 程序才能继续执行。<br>方法返回时可能需要在<strong>栈帧</strong>中保存一些信息, 用来帮助恢复它的上层主调方法的执行状态。<br>一般来说, 方法正常退出时, 主调方法的 PC 计数器的值就可以作为返回地址, 栈帧中很可能会保存这个计数器值。而方法异常退出时, 返回地址是要通过异常<br>处理器表来确定的, 栈帧中就一般不会保存这部分信息。</p><p>方法退出的过程实际上等同于把当前栈帧出栈, 因此退出时可能执行的操作有: 恢复上层方法的局部变量表和操作数栈, 把返回值 (如果有的话) 压入调用者栈<br>帧的操作数栈中, 调整 PC 计数器的值以指向方法调用指令后面的一条指令等。</p><h2 id="6-附加信息-overhead-information"><a href="#6-附加信息-overhead-information" class="headerlink" title="6 附加信息 - overhead information"></a>6 附加信息 - overhead information</h2><p>《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中, 例如与调试, 性能收集相关的信息, 这部分信息完全取决于具体的虚拟机实现, 这里不再详述。</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h2><p>《深入理解Java虚拟机》- 周志明</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM Class 文件的加载</title>
      <link href="/article/2021/1618578639/"/>
      <url>/article/2021/1618578639/</url>
      
        <content type="html"><![CDATA[<p>Java 虚拟机把描述类的数据从 Class 文件加载到内存, 并对数据进行校验, 转换解析和初始化, 最终形成可以被虚拟机直接使用的 Java 类型,<br>这个过程被称作虚拟机的<strong>类加载机制</strong>。  </p><p>与那些在编译时需要进行连接的语言不同, 在 Java 语言里面, 类的加载, 连接和初始化过程都是在程序运行期间完成的, 这种策略让 Java 语言进行提前编译会面临额外的困难,<br>也会让类加载时稍微增加一些性能开销, 但是却为 Java 应用提供了极高的扩展性和灵活性, Java 天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p><p>比如, 要加载一个接口的实现了, 除了可以从当前的 jar 里面或外部的依赖 jar 包加载外, 还可以自定义自己的类加载器或 Java 预置,<br>通过网络请求一个二进制流文件作为程序运行的实现类等。</p><p>从上面的例子中, 我们可以知道, JVM 的类加载机制的数据来源, 除了是一个真真正正的 Class 文件外, 还是可以通过网络加载回来的二进制流,<br>乃至可以是从数据库中读取的数据, 所以对于 Class 文件的定义范围可以适当扩大到二进制流的范畴, 还有每个 Class 文件都有代表着 Java 语言中的一个类或接口的可能性。</p><h2 id="1-类加载的时机"><a href="#1-类加载的时机" class="headerlink" title="1 类加载的时机"></a>1 类加载的时机</h2><p><img src="https://pic.imgdb.cn/item/65e825409f345e8d033d0dfe.png" alt="Alt &#39;Class 的生命周期&#39;"></p><p>如图, 一个类型从被加载到虚拟机内存中开始, 到卸载出内存为止, 它的整个生命周期将会经历</p><blockquote><p>加载 (Loading)<br>验证 (Verification)<br>准备 (Preparation)<br>解析 (Resolution)<br>初始化 (Initialization)<br>使用 (Using)<br>卸载 (Unloading)  </p></blockquote><p>七个阶段, 其中验证 + 准备 + 解析三个部分统称为连接 (Linking)。</p><p>加载, 验证, 准备, 初始化和卸载这五个阶段的顺序是确定的, Class 的加载过程必须按照这种顺序按部就班地开始,<br>而解析阶段则不一定: 它在某些情况下可以在初始化阶段之后再开始, 这是为了支持 Java 语言的运行时绑定特性, 也称为动态绑定或晚期绑定。</p><p>对于一个类什么时候加载, 《Java虚拟机规范》没有强制要求, 但是对于类的初始化阶段, 则严格规定了有且只有六种情况必须立即对类进行 “初始化” (而加载, 验证, 准备自然需要在此之前开始):</p><ol><li>遇到 new &#x2F; getstatic &#x2F; putstatic &#x2F; invokestatic 这四条字节码指令时, 如果类型没有进行过初始化, 则需要先触发其初始化阶段。</li></ol><p>能够生成这四条指令的典型 Java 代码场景有</p><blockquote><p>1.1 使用 new 关键字实例化对象的时候<br>1.2 读取或设置一个类型的静态字段 (被 final 修饰, 已在编译期把结果放入常量池的静态字段除外) 的时候<br>1.3 调用一个类型的静态方法的时候</p></blockquote><ol start="2"><li>使用 java.lang.reflect 包的方法对类型进行反射调用的时候, 如果类型没有进行过初始化, 则需要先触发其初始化</li><li>当初始化类的时候, 如果发现其父类还没有进行过初始化, 则需要先触发其父类的初始化</li><li>当虚拟机启动时, 用户需要指定一个要执行的主类 (包含 main() 方法的那个类), 虚拟机会先初始化这个主类</li><li>当使用 JDK7 新加入的动态语言支持时, 如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic &#x2F; REF_putStatic &#x2F; REF_invokeStatic &#x2F; REF_newInvokeSpecial<br>四种类型的方法句柄, 并且这个方法句柄对应的类没有进行过初始化, 则需要先触发其初始化</li><li>当一个接口中定义了 JDK8 新加入的默认方法 (被 default 关键字修饰的接口方法) 时, 如果有这个接口的实现类发生了初始化, 那该接口要在其之前被初始化</li></ol><p>这六种场景中的行为称为对一个类型进行<strong>主动引用</strong>。除此之外, 还有一些引用类型不会触发初始化, 称为<strong>被动引用</strong>。</p><p>被动引用的例子:</p><ol><li>通过子类引用父类的静态字段, 不会导致子类初始化</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 通过子类调用父类的静态属性</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">SubClass</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>对于静态字段, 只有直接定义这个字段的类才会被初始化, 因此通过其子类来引用父类中定义的静态字段, 只会触发父类的初始化而不会触发子类的初始化</p><ol start="2"><li>通过数组定义来引用类, 不会触发此类的初始化</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 通过数组定义来引用类</span>        <span class="token class-name">SuperClass</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperClass</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>这段代码不会触发 SuperClass 的加载, 但是这段代码里面触发了另一个名为 “[Lxxx.xxx.SuperClass” 的类的初始化阶段, 这并不是一个合法的类型名称,<br>它是一个由虚拟机自动生成的, 直接继承于 java.lang.Object 的子类, 创建动作由字节码指令 newarray 触发。</p><p>这个类代表了一个元素类型为 xxx.xxx.SuperClass 的一维数组, 数组中应有的属性和方法 (用户可直接使用的只有被修饰为 public 的 length 属性和 clone() 方法) 都实现在这个类里。</p><ol start="3"><li>常量在编译阶段会存入调用类的常量池中, 本质上没有直接引用到定义常量的类, 因此不会触发定义常量的类的初始化</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConstClass</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">HELLO_WORLD</span> <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">// 通过类引用其常量</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ConstClass</span><span class="token punctuation">.</span><span class="token constant">HELLO_WORLD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>在编译阶段通过常量传播优化, 已经将此常量的值 “hello world” 直接存储在 TestClass 类的常量池中, 以后 TestClass 对常量 ConstClass.HELLO_WORLD 的引用, 实际都被转化为 TestClass 类对自身常量池的引用了。</p><p>另外:<br>接口的加载过程与类加载过程稍有不同, 接口也有初始化过程, 接口与类真正有所区别的是前面讲述的六种初始化场景中的第三种:<br><strong>当一个类在初始化时, 要求其父类全部都已经初始化过了</strong>, 但是接口没有这个限制, 只有在真正使用到父接口的时候 (如引用接口中定义的常量) 才会初始化。</p><h2 id="2-类的加载过程"><a href="#2-类的加载过程" class="headerlink" title="2 类的加载过程"></a>2 类的加载过程</h2><h3 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h3><p>在加载阶段, Java 虚拟机需要完成以下三件事情</p><blockquote><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象, 作为方法区这个类的各种数据的访问入口</li></ol></blockquote><p>在上面的说明中可以知道, 只要是一个可以转为 Class 对象的二进制字节流, 就可以作为输入源。<br>那么可操作的空间就很大了, 从网络请求, 运行时动态代理, 由其他文件生成 (JSP 页面等), 从加密文件中获取等, 用户完全可以使用自定义的<br>类加载器 (重写一个类加载器的 findClass() 或 loadClass() 方法), 实现根据自己的想法来赋予应用程序获取运行代码的动态性。</p><p>对于数组类而言, 情况就有所不同, 数组类本身不通过类加载器创建, 它是由 Java 虚拟机直接在内存中动态构造出来的。<br>但是数组类的元素类型 (Element Type, 指的是数组去掉所有维度的类型) 最终还是要靠类加载器来完成加载,<br>一个数组类 (下面简称为 C) 创建过程遵循以下规则:</p><blockquote><ol><li>如果数组的组件类型 (Component Type, 指的是数组去掉一个维度的类型, 注意和前面的元素类型区分开来) 是引用类型, 那就递归采用上面定义的加<br>  载过程去加载这个组件类型, 数组 C 将被标识在加载该组件类型的类加载器的类名称空间上</li><li>如果数组的组件类型不是引用类型 (例如 int[] 数组的组件类型为 int), Java 虚拟机将会把数组 C 标记为与引导类加载器关联 (引导类加载器 Boostrap ClassLoader)</li><li>数组类的可访问性与它的组件类型的可访问性一致, 如果组件类型不是引用类型, 它的数组类的可访问性将默认为 public, 可被所有的类和接口访问到</li></ol></blockquote><p>类名称空间的知识可以看<a href="https://blog.csdn.net/qq_37362891/article/details/106981909">这里</a></p><p>加载阶段与连接阶段的部分动作 (如一部分字节码文件格式验证动作) 是交叉进行的, 加载阶段尚未完成, 连接阶段可能已经开始, 但这些夹在加载阶段之中进<br>行的动作, 仍然属于连接阶段的一部分, 这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h3 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 验证</h3><p>验证是连接阶段的第一步, 这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求, 保证这些信息被当作代码运<br>行后不会危害虚拟机自身的安全。</p><p>验证阶段<strong>大致上</strong>会完成下面四个阶段的检验动作</p><ol><li>文件格式验证</li></ol><p>第一阶段要验证字节流是否符合 Class 文件格式的规范, 并且能被当前版本的虚拟机处理。 这一阶段可能包括下面这些验证点</p><ul><li>是否以魔数 0xCAFEBABE 开头</li><li>主, 次版本号是否在当前 Java 虚拟机接受范围之内</li><li>常量池的常量中是否有不被支持的常量类型 (检查常量 tag 标志)</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li><li>CONSTANT_Utf8_info 型的常量中是否有不符合 UTF-8 编码的数据</li><li>Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息</li><li>……</li></ul><p>实际上第一阶段的验证点还远不止这些, 上面所列的只是从 HotSpot 虚拟机验证的一小部分内容。<br>该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内, 格式上符合描述一个 Java 类型信息的要求。<br>通过了这个阶段, 原本的字节流才被允许存放在 Java 虚拟机的方法区中, 因为后面的三个阶段都是基于方法区的存储结构上进行的。</p><ol start="2"><li>元数据验证</li></ol><p>第二阶段是对字节码描述的信息进行语义分析, 以保证其描述的信息符合《Java语言规范》的要求, 这个阶段可能包括的验证点如下</p><ul><li>这个类是否有父类 (除了 java.lang.Object 之外, 所有的类都应当有父类)</li><li>这个类的父类是否继承了不允许被继承的类 (被 final 修饰的类)</li><li>如果这个类不是抽象类, 是否实现了其父类或接口之中要求实现的所有方法</li><li>类中的 字段&#x2F;方法 是否与父类产生矛盾 (例如覆盖了父类的 final 字段, 或者出现不符合规则的方法重载, 例如方法参数都一致, 但返回值类型却不同等)</li><li>……</li></ul><ol start="3"><li>字节码验证</li></ol><p>第三阶段通过数据流分析和控制流分析, 确定程序语义是合法的, 符合逻辑的。这阶段对类的方法体 (Class 文件中的 Code 属性) 进行校验分析, 保证被校<br>验类的方法在运行时不会做出危害虚拟机安全的行为, 这个阶段可能包括的验证点如下    </p><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作, 例如不会出现类似于 “在操作栈放置了一个 int 类型的数据, 使用时却按 long 类型来加<br>载入本地变量表中” 这样的情况</li><li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上</li><li>保证方法体中的类型转换总是有效的, 例如可以把一个子类对象赋值给父类数据类型, 这是安全的, 但是把父类对象赋值给子类数据类型, 甚至把对象赋值给<br>与它毫无继承关系, 完全不相干的一个数据类型, 则是危险和不合法的 </li><li>……</li></ul><p>如果一个方法体通过了字节码验证, 也仍然不能保证它一定就是安全的。</p><p>由于数据流分析和控制流分析的高度复杂性, 为了避免过多的执行时间消耗在字节码验证阶段中, 在 JDK6 之后的 Javac 编译器和 Java 虚拟机里进行了一<br>项联合优化, 把尽可能多的校验辅助措施挪到 Javac 编译器里进行。具体的做法:</p><ul><li>给方法体 Code 属性的属性表中新增加了一项名为 “StackMapTable” 的新属性, 这项属性描述了方法体所有的基本块 (Basic Block, 指按照控制流拆分<br>的代码块) 开始时本地变量表和操作栈应有的状态</li><li>在字节码验证期间, Java 虚拟机就不需要根据程序推导这些状态的合法性, 只需要检查 StackMapTable 属性中的记录是否合法即可, 从原来的将字节码<br>验证的类型推导转变为类型检查, 从而节省了大量校验时间。</li></ul><p>理论上 StackMapTable 属性也存在错误或被篡改的可能, 所以是否有可能在恶意篡改了 Code 属性的同时, 也生成相应的 StackMapTable 属性来骗过虚<br>拟机的类型校验, 则是虚拟机设计者们需要仔细思考的问题。</p><p>HotSpot 虚拟机对于主版本号大于 50 (对应 JDK6) 的 Class 文件, 使用<strong>类型检查</strong>来完成数据流分析校验则是唯一的选择</p><ol start="4"><li>符号引用验证</li></ol><p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候, 这个转化动作将在<strong>连接的第三阶段 – 解析阶段</strong>中发生。符号引用验证可以看作<br>是对类自身以外 (常量池中的各种符号引用) 的各类信息进行匹配性校验, 通俗来说就是, 该类是否缺少或者被禁止访问它依赖的某些外部类, 方法, 字段等资源,<br>这个阶段可能包括的验证点如下</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li><li>符号引用中的类, 字段, 方法的可访问性 (private &#x2F; protected &#x2F; public &#x2F; <package>) 是否可被当前类访问</li><li>……</li></ul><p>符号引用验证的主要目的是确保解析行为能正常执行, 如果无法通过符号引用验证, Java 虚拟机将会抛出一个 java.lang.IncompatibleClassChangeError<br>的子类异常, 例如: java.lang.IllegalAccessError, java.lang.NoSuchFieldError, java.lang.NoSuchMethodError 等。</p><p>验证阶段对于虚拟机的类加载机制来说, 是一个非常重要的, 但却不是必须要执行的阶段, 在生产环境的实施阶段就可以考虑使用 -Xverify：none 参数来关<br>闭大部分的类验证措施, 以缩短虚拟机类加载的时间。当然前提的是确保程序运行的所有代码 (第三方包, 外部加载等) 都是安全的。</p><h3 id="2-3-准备"><a href="#2-3-准备" class="headerlink" title="2.3 准备"></a>2.3 准备</h3><p>准备阶段是正式为类中定义的变量 (即静态变量, 被 static 修饰的变量) 分配内存并设置类变量初始值的阶段。<br>这些变量所使用的内存都应当在方法区中进行分配, 方法区本身是一个逻辑上的区域。<br>在 JDK7 及之前, HotSpot 使用永久代来实现方法区时, 在 JDK8 及之后, 类变量则会随着 Class 对象一起存放在 Java 堆中。</p><p>准备阶段 2 个混淆点</p><blockquote><ol><li>这时候进行内存分配的仅包括类变量, 而不包括实例变量, 实例变量将会在对象实例化时随着对象一起分配在 Java 堆中</li><li>这时候进行初始值的赋值, 一般赋予的是数据类型的零值, 而不是用户设置的数值</li></ol></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 在准备阶段, 这时 value = 0;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></code></pre><p>变量 value 在准备阶段过后的初始值为 0 而不是 123, 因为这时尚未开始执行任何 Java 方法, 而把 value 赋值为 123 的 putstatic 指令是程序被<br>编译后, 存放于类构造器 <clinit>() 方法之中, 所以把 value 赋值为 123 的动作要到类的初始化阶段才会被执行。</p><p>数据类型的零值</p><table><thead><tr><th align="center">数据类型</th><th align="center">零值</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">0</td></tr><tr><td align="center">long</td><td align="center">0L</td></tr><tr><td align="center">short</td><td align="center">(short)0</td></tr><tr><td align="center">char</td><td align="center">‘\u0000’</td></tr><tr><td align="center">byte</td><td align="center">(byte)0</td></tr><tr><td align="center">boolean</td><td align="center">false</td></tr><tr><td align="center">float</td><td align="center">0.0f</td></tr><tr><td align="center">double</td><td align="center">0.0d</td></tr><tr><td align="center">reference</td><td align="center">null</td></tr></tbody></table><p>赋值为零值的特殊情况:<br>如果类字段的字段属性表中存在 ConstantValue 属性, 那在准备阶段变量值就会被初始化为 ConstantValue 属性所指定的初始值, 假设上面类变量 value<br>的定义修改为:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></code></pre><p>编译时 Javac 将会为 value 生成 ConstantValue 属性, 在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。</p><h3 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4 解析"></a>2.4 解析</h3><p>解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。</p><ul><li>符号引用 (Symbolic References)</li></ul><p>符号引用以一组符号来描述所引用的目标, 符号可以是任何形式的字面量, 只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关, 引<br>用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同, 但是它们能接受的符号引用必须都是一致的, 因为符号引用<br>的字面量形式明确定义在 《Java虚拟机规范》 的 Class 文件格式中。</p><ul><li>直接引用 (Direct References)</li></ul><p>直接引用是可以直接指向目标的指针 &#x2F; 相对偏移量 &#x2F; 一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的, 同一个符号引用在不同<br>虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用, 那引用的目标必定已经在虚拟机的内存中存在。</p><p>《Java虚拟机规范》 之中并未规定解析阶段发生的具体时间, 只要求在执行</p><blockquote><p>anewarray<br>checkcast<br>getfield<br>getstatic<br>instanceof<br>invokedynamic<br>invokeinterface<br>invokespecial<br>invokestatic<br>invokevirtual<br>ldc<br>ldc_w<br>ldc2_w<br>multianewarray<br>new<br>putfield<br>putstatic </p></blockquote><p>这 17 用于操作符号引用的字节码指令之前, 对它们所使用的符号引用进行解析即可。<br>所以虚拟机实现可以根据需要来自行判断, 到底是在<strong>类被加载器加载时</strong>就对常量池中的符号引用进行解析, 还是等到<strong>一个符号引用将要被使用前</strong>才去解析它。</p><p>对方法或者字段的访问, 也会在解析阶段中对它们的可访问性 (public, protected, private, <pacakge>) 进行检查。</p><p>存在对同一个符号引用进行多次解析请求的情况, 除 invokedynamic 指令以外, 虚拟机实现可以对第一次解析的结果进行缓存, 譬如在运行时直接引用常量池<br>中的记录, 并把常量标识为已解析状态, 从而避免解析动作重复进行。无论是否真正执行了多次解析动作, Java 虚拟机都需要保证的是在同一个实体中, 如果<br>一个符号引用之前已经被成功解析过, 那么后续的引用解析请求就应当一直能够成功。同样地, 如果第一次解析失败了, 其他指令对这个符号的解析请求也应该<br>收到相同的异常, 哪怕这个请求的符号在后来已成功加载进 Java 虚拟机内存之中。</p><p>不过对于 invokedynamic 指令, 上面的规则就不成立了。当碰到某个前面已经由 invokedynamic 指令触发过解析的符号引用时, 并不意味着这个解析结果<br>对于其他 invokedynamic 指令也同样生效。因为 invokedynamic 指令的目的本来就是用于动态语言支持。它对应的引用称为 “动态调用点限定符<br>(Dynamically-Computed Call Site Specifier)”, 这里 “动态” 的含义是指必须等到程序实际运行到这条指令时, 解析动作才能进行。</p><p>解析动作主要针对类或接口, 字段, 类方法, 接口方法, 方法类型, 方法句柄和调用点限定符这 7 类符号引用进行, 分别对应常量池的 8 种常量类型 </p><blockquote><p>CONSTANT_Class_info<br>CONSTANT_Fieldref_info<br>CONSTANT_Methodref_info<br>CONSTANT_InterfaceMethodref_info<br>CONSTANT_MethodType_info<br>CONSTANT_MethodHandle_info<br>CONSTANT_Dynamic_info<br>CONSTANT_InvokeDynamic_info</p></blockquote><p>对于后 4 种, 它们都和动态语言支持密切相关, 也就是 invokedynamic 指令有关。</p><h4 id="2-4-1-类或接口的解析"><a href="#2-4-1-类或接口的解析" class="headerlink" title="2.4.1 类或接口的解析"></a>2.4.1 类或接口的解析</h4><p>假设当前代码所处的类为 D, 如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的直接引用, 那虚拟机完成整个解析的过程需要包括以下 3 个步骤</p><blockquote><ol><li>如果 C 不是一个数组类型, 那虚拟机将会把代表 N 的全限定名传递给 D 的类加载器去加载这个类 C。在加载过程中, 由于元数据验证 &#x2F; 字节码验证<br>  的需要, 又可能触发其他相关类的加载动作, 例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常, 解析过程就将宣告失败</li><li>如果 C 是一个数组类型, 并且数组的元素类型为对象, 也就是 N 的描述符会是类似 “[Ljava&#x2F;lang&#x2F;Integer” 的形式, 那将会按照第一点的规则先加<br>  载数组的元素类型。既需要加载的元素类型就是 “java.lang.Integer”, 接着由虚拟机生成一个代表该数组维度和元素的数组对象</li><li>如果上面两步没有出现任何异常, 那么 C 在虚拟机中实际上已经成为一个有效的类或接口了, 但在解析完成前还要进行符号引用验证, 确认 D 是否具备<br>  对 C 的访问权限。如果发现不具备访问权限, 将抛出 java.lang.IllegalAccessError 异常</li></ol></blockquote><p>针对上面第 3 点访问权限验证, 在 JDK9 引入了模块化以后, 一个 public 类型也不再意味着程序任何位置都有它的访问权限, 我们还必须检查模块间的访<br>问权限。</p><p>如果我们说一个 D 拥有 C 的访问权限, 那就意味着以下 3 条规则中至少有其中一条成立</p><ul><li>被访问类 C 是 public 的, 并且与访问类 D 处于同一个模块</li><li>被访问类 C 是 public 的, 不与访问类 D 处于同一个模块, 但是被访问类 C 的模块允许被访问类 D 的模块进行访问</li><li>被访问类 C 不是 public 的, 但是它与访问类 D 处于同一个包中</li></ul><h4 id="2-4-2-字段解析"><a href="#2-4-2-字段解析" class="headerlink" title="2.4.2 字段解析"></a>2.4.2 字段解析</h4><p>要解析一个未被解析过的字段符号引用, 首先将会对字段表内 class_index 项中索引的 CONSTANT_Class_info 符号引用进行解析, 也就是字段所属的类<br>或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常, 都会导致字段符号引用解析的失败, 如果解析成功完成, 那把这个字段所属的<br>类或接口用 C 表示,《Java虚拟机规范》 要求按照如下步骤对 C 进行后续字段的搜索  </p><ul><li>如果 C 本身就包含了简单名称和字段描述符都与目标相匹配的字段, 则返回这个字段的直接引用, 查找结束</li><li>否则, 如果在 C 中实现了接口, 将会按照继承关系从下往上递归搜索各个接口和它的父接口, 如果接口中包含了简单名称和字段描述符都与目标相匹配的字段,<br>则返回这个字段的直接引用, 查找结束</li><li>否则, 如果 C 不是 java.lang.Object 的话, 将会按照继承关系从下往上递归搜索其父类, 如果在父类中包含了简单名称和字段描述符都与目标相匹配的<br>字段, 则返回这个字段的直接引用, 查找结束</li><li>否则, 查找失败, 抛出 java.lang.NoSuchFieldError 异常</li></ul><p>如果查找过程成功返回了引用, 将会对这个字段进行权限验证, 如果发现不具备对字段的访问权限, 将抛出 java.lang.IllegalAccessError 异常</p><p>但在实际情况中, Javac 编译器往往会采取比上述规范更加严格一些的约束, 譬如有一个同名字段同时出现在某个类的接口和父类当中, 或者同时在自己或父类<br>的多个接口中出现, 按照解析规则仍是可以确定唯一的访问字段, 但 Javac 编译器就可能直接拒绝其编译为 Class 文件。</p><h4 id="2-4-3-方法解析"><a href="#2-4-3-方法解析" class="headerlink" title="2.4.3 方法解析"></a>2.4.3 方法解析</h4><p>方法解析的第一个步骤与字段解析一样, 也是需要先解析出方法表的 class_index 项中索引的方法所属的类或接口的符号引用, 如果解析成功, 那么我们依<br>然用 C 表示这个类, 接下来虚拟机将会按照如下步骤进行后续的方法搜索  </p><ul><li>由于 Class 文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的, 如果在类的方法表中发现 class_index 中索引的 C 是个接口的话, 那<br>就直接抛出 java.lang.IncompatibleClassChangeError 异常</li><li>如果通过了第一步, 在类 C 中查找是否有简单名称和描述符都与目标相匹配的方法, 如果有则返回这个方法的直接引用, 查找结束</li><li>否则, 在类 C 的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法, 如果有则返回这个方法的直接引用, 查找结束</li><li>否则, 在类 C 实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法, 如果存在匹配的方法, 说明类 C 是一个抽象类,<br>这时候查找结束, 抛出 java.lang.AbstractMethodError 异常</li><li>否则, 宣告方法查找失败, 抛出 java.lang.NoSuchMethodError</li></ul><p>最后, 如果查找过程成功返回了直接引用, 将会对这个方法进行权限验证, 如果发现不具备对此方法的访问权限, 将抛出 java.lang.IllegalAccessError 异常</p><h4 id="2-4-4-接口方法解析"><a href="#2-4-4-接口方法解析" class="headerlink" title="2.4.4 接口方法解析"></a>2.4.4 接口方法解析</h4><p>接口方法也是需要先解析出接口方法表的 class_index 项中索引的方法所属的类或接口的符号引用, 如果解析成功, 依然用 C 表示这个接口, 接下来虚拟机<br>将会按照如下步骤进行后续的接口方法搜索</p><ul><li>与类的方法解析相反, 如果在接口方法表中发现 class_index 中的索引 C 是个类而不是接口, 那么就直接抛出 java.lang.IncompatibleClassChangeError<br>异常</li><li>否则, 在接口 C 中查找是否有简单名称和描述符都与目标相匹配的方法, 如果有则返回这个方法的直接引用, 查找结束</li><li>否则, 在接口 C 的父接口中递归查找, 直到 java.lang.Object 类 (接口方法的查找范围也会包括 Object 类中的方法) 为止, 看是否有简单名称和描<br>述符都与目标相匹配的方法, 如果有则返回这个方法的直接引用, 查找结束</li><li>对于规则 3, 由于 Java 的接口允许多重继承, 如果 C 的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法, 那将会从这多个方法中返回其中<br>一个并结束查找, 《Java虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法。 不同发行商实现的Javac编<br>译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。</li><li>否则, 宣告方法查找失败, 抛出 java.lang.NoSuchMethodError 异常</li></ul><p>在 JDK9 之前, Java 接口中的所有方法都默认是 public 的, 也没有模块化的访问约束, 所以不存在访问权限的问题, 接口方法的符号解析就不可能抛出<br>java.lang.IllegalAccessError 异常。 但在 JDK9 中增加了接口的静态私有方法, 也有了模块化的访问约束, 所以从 JDK9 起,<br>接口方法的访问也完全有可能因访问权限控制而出现 java.lang.IllegalAccessError 异常</p><h3 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5 初始化"></a>2.5 初始化</h3><p>进行准备阶段时, 变量已经赋过一次系统要求的初始零值, 而在初始化阶段, 则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源, 初始化<br>阶段就是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程, 由 Javac 编译器的自动生成物。</p><p><code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中的所有类中的静态变量的赋值动作和静态语句块 (static{} 块) 中的语句<strong>合并</strong>产生的, 编译器收集的顺序是由语句在<br>源文件中出现的顺序决定的, 静态语句块中只能访问到定义在静态语句块之前的变量, 定义在它之后的变量, <strong>在前面的静态语句块可以赋值, 但是不能访问</strong></p><p><code>&lt;clinit&gt;()</code> 方法与类的构造函数 (即在虚拟机视角中的实例构造器 <code>&lt;init&gt;()</code> 方法) 不同, 它不需要显式地调用父类构造器, Java 虚拟机会保证在子类的<br><code>&lt;clinit&gt;()</code> 方法执行前, 父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</p><p><code>&lt;clinit&gt;()</code> 方法对于类或接口来说并不是必需的, 如果一个类中没有静态语句块, 也没有对静态变量的赋值操作, 那么编译器可以不为这个类生成 <code>&lt;clinit&gt;()</code> 方法</p><p>接口中不能使用静态语句块, 但仍然有变量初始化的赋值操作, 因此接口与类一样都会生成 <code>&lt;clinit&gt;()</code> 方法, 但接口与类不同的是, 执行接口的 <code>&lt;clinit&gt;()</code><br>方法不需要先执行父接口的 <code>&lt;clinit&gt;()</code> 方法, 因为只有当父接口中定义的变量被使用时, 父接口才会被初始化。 同样的, 接口的实现类在初始化时也一样不<br>会执行接口的 <code>&lt;clinit&gt;()</code> 方法</p><p>Java 虚拟机必须保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确地加锁同步, 如果多个线程同时去初始化一个类, 那么只会有其中一个线程去执行这个<br>类的 <code>&lt;clinit&gt;()</code> 方法, 其他线程都需要阻塞等待, 直到活动线程执行完毕 <code>&lt;clinit&gt;()</code> 方法。如果在一个类的 <code>&lt;clinit&gt;()</code> 方法中有耗时很长的操作,<br>那就可能造成多个进程阻塞, 如果执行 <code>&lt;clinit&gt;()</code> 方法的那条线程退出  <code>&lt;clinit&gt;()</code> 方法后, 其他线程唤醒后则不会再次进入 <code>&lt;clinit&gt;()</code> 方法</p><h2 id="3-类的加载器"><a href="#3-类的加载器" class="headerlink" title="3 类的加载器"></a>3 类的加载器</h2><p>类加载阶段中的 “通过一个类的全限定名来获取描述该类的二进制字节流” 这个动作是放到 Java 虚拟机外部去实现, 以便让应用程序自己决定如何去获取所需的<br>类, 实现这个动作的代码被称为 “类加载器 (Class Loader)”。</p><p>对于任意一个类, 都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性, 每一个类加载器, 都拥有一个独立的类名称空间。<br>也就是两个类是否 “相等”, 只有在这两个类是由同一个类加载器加载的前提下才有意义, 否则, 即使这两个类来源于同一个 Class 文件, 被同一个 Java 虚<br>拟机加载, 只要加载它们的类加载器不同, 那这两个类就必定不相等。</p><p>这里所指的 “相等”, 包括代表类的 Class 对象的</p><blockquote><p>equals()<br>isAssignableFrom()<br>isInstance()</p></blockquote><p>方法的返回结果, 也包括了使用 instanceof 关键字做对象所属关系判定等各种情况。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoaderTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ClassLoader</span> myLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">String</span> fileName <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">".class"</span><span class="token punctuation">;</span>                     <span class="token class-name">InputStream</span> is <span class="token operator">=</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token keyword">if</span> <span class="token punctuation">(</span>is <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                         <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token punctuation">&#125;</span>                    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>is<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                     is<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token class-name">Object</span> obj <span class="token operator">=</span> myLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"xxxx.ClassLoaderTest"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// xxxx.ClassLoaderTest</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 结果 false</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token namespace">xxxx<span class="token punctuation">.</span></span>ClassLoaderTest</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>ClassLoaderTest 先是由 AppClassLoader 进行了加载, 执行内部的 main 方法, main 里面的 ClassLoaderTest 则是有自定义的 ClassLoader<br>加载的, 所以 2 个的 ClassLoaderTest 的 ClassLoader 不一样, 所以程序判断的结果为 false</p><h3 id="3-1-双亲委派模型"><a href="#3-1-双亲委派模型" class="headerlink" title="3.1 双亲委派模型"></a>3.1 双亲委派模型</h3><p>在 JVM 中, 只存在两种不同的类加载器: 一种是启动类加载器 (Bootstrap ClassLoader), 这个类加载器使用 C++ 语言实现, 是虚拟机自身的一部分;<br>另外一种就是其他所有的类加载器, 这些类加载器都由 Java 语言实现, 独立存在于虚拟机外部, 并且全都继承自抽象类 java.lang.ClassLoader</p><p>自 JDK1.2 以来, Java 一直保持着三层类加载器, 双亲委派的类加载架构。绝大多数 Java 程序都会使用到以下 3 个系统提供的类加载器来进行加载</p><ul><li>启动类加载器 (Boostrap Class Loader)<br>这个类加载器负责加载存放在 <strong><JAVA_HOME>\lib</strong> 目录, 或者被 <strong>-Xbootclasspath</strong> 参数所指定的路径中存放的, 而且是 Java 虚拟机能够识别的 (按照<br>文件名识别, 如 rt.jar, tools.jar, 名字不符合的类库即使放在 lib 目录中也不会被加载) 类库加载到虚拟机的内存中, 启动类加载器无法被 Java 程序<br>直接引用, 用户在编写自定义类加载器时, 如果需要把加载请求委派给引导类加载器去处理, 那直接使用 null 代替即可</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Returns the class loader for the class. Some implementations may use null to represent the bootstrap cla */</span><span class="token keyword">public</span> <span class="token class-name">ClassLoader</span> <span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ClassLoader</span> cl <span class="token operator">=</span> <span class="token function">getClassLoader0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>cl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token class-name">SecurityManager</span> sm <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>sm <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token class-name">ClassLoader</span> ccl <span class="token operator">=</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getCallerClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>ccl <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> ccl <span class="token operator">!=</span> cl <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>cl<span class="token punctuation">.</span><span class="token function">isAncestor</span><span class="token punctuation">(</span>ccl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             sm<span class="token punctuation">.</span><span class="token function">checkPermission</span><span class="token punctuation">(</span><span class="token class-name">SecurityConstants</span><span class="token punctuation">.</span><span class="token constant">GET_CLASSLOADER_PERMISSION</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> cl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><p>扩展类加载器 (Extension Class Loader)<br>这个类加载器是在类 sun.misc.Launcher$ExtClassLoader 中以 Java 代码的形式实现的。它负责加载 <strong><JAVA_HOME>\lib\ext</strong> 目录中, 或者被<br><strong>java.ext.dirs</strong> 系统变量所指定的路径中所有的类库。根据这个加载器的名称, 可以推断出这是一种 Java 系统类库的扩展机制, 允许用户将具有通用性的类<br>库放置在 ext 目录里以扩展 Java SE 的功能, 在 JDK9 之后, 这种扩展机制被模块化带来的天然的扩展能力所取代</p></li><li><p>应用程序类加载器 (Application Class Loader)<br>这个类加载器由 <strong>sun.misc.Launcher$AppClassLoader</strong> 来实现。由于应用程序类加载器是 ClassLoader 类中的 getSystemClassLoader() 方法的返<br>回值, 所以有些场合中也称它为 “系统类加载器”。它负责加载用户类路径 (ClassPath) 上所有的类库, 开发者同样可以直接在代码中使用这个类加载器。如<br>果应用程序中没有自定义过自己的类加载器, 一般情况下这个就是程序中默认的类加载器</p></li></ul><p><img src="https://pic.imgdb.cn/item/65e825439f345e8d033d1abc.png" alt="Alt &#39;类加载器类型&#39;"></p><p>JDK 9 之前的 Java 应用都是由这三种类加载器互相配合来完成加载的, 如果用户认为有必要, 还可以加入自定义的类加载器来进行拓展, 典型的如增加除了<br>磁盘位置之外的 Class 文件来源, 或者通过类加载器实现类的隔离 &#x2F; 重载等功能。</p><p>图中展示的各种类加载器之间的层次关系被称为类加载器的 “双亲委派模型 (Parents Delegation Model)”。双亲委派模型要求除了顶层的启动类加载器外,<br>其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承 (Inheritance) 的关系来实现的, 而是通常使用组合 (Composition)<br>关系来复用父加载器的代码。</p><p>双亲委派模型的工作过程是: 如果一个类加载器收到了类加载的请求, 它首先不会自己去尝试加载这个类, 而是把这个请求委派给父类加载器去完成, 每一个层<br>次的类加载器都是如此, 因此所有的加载请求最终都应该传送到最顶层的启动类加载器中, 只有当父加载器反馈自己无法完成这个加载请求 (它的搜索范围中没<br>有找到所需的类) 时, 子加载器才会尝试自己去完成加载。</p><p>使用双亲委派模型来组织类加载器之间的关系, 一个显而易见的好处就是 Java 中的类随着它的类加载器一起具备了一种带有优先级的层次关系。<br>例如类 java.lang.Object, 它存放在 rt.jar 之中, 无论哪一个类加载器要加载这个类, 最终都是委派给处于模型最顶端的启动类加载器进行加载, 因此<br>Object 类在程序的各种类加载器环境中都能够保证是同一个类。反之, 如果没有使用双亲委派模型, 都由各个类加载器自行去加载的话, 如果用户自己也编写<br>了一个名为 java.lang.Object 的类, 并放在程序的 ClassPath 中, 那系统中就会出现多个不同的 Object 类, Java 类型体系中最基础的行为也就无<br>从保证, 应用程序将会变得一片混乱</p><p>双亲委派模型的实现</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 先检查类是否加载过</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">long</span> t0 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 有父级的话, 让父级进行加载</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 没有父级, 自己进行加载</span>                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 依旧为空的, 自己尝试进行查找</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">long</span> t1 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// this is the defining class loader; record the stats</span>                <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-2-破坏双亲委派模型"><a href="#3-2-破坏双亲委派模型" class="headerlink" title="3.2 破坏双亲委派模型"></a>3.2 破坏双亲委派模型</h3><ul><li>线程上下文类加载器 (ThreadContextClassLoader)</li></ul><p>JNDI 现在已经是 Java 的标准服务, 它的代码由启动类加载器来完成加载 (在 JDK1.3 时加入到 rt.jar 的), 属于 Java 中很基础的类型, 但 JNDI 存<br>在的目的就是对资源进行查找和集中管理, 它需要调用由其他厂商实现并部署在应用程序的 ClassPath 下的 JNDI 服务提供者接口 (Service Provider<br>Interface, SPI) 的代码, 现在问题来了, 启动类加载器是绝不可能认识, 加载这些代码的。</p><p>为了解决这个困境, Java 的设计团队只好引入了一个不太优雅的设计: 线程上下文类加载器 (Thread Context ClassLoader)。这个类加载器可以通过<br>java.lang.Thread 类的 setContextClassLoader() 方法进行设置, 如果创建线程时还未设置, 它将会从父线程中继承一个, 如果在应用程序的全局范<br>围内都没有设置过的话, 那这个类加载器默认就是应用程序类加载器。<br>JNDI 服务使用这个线程上下文类加载器去加载所需的 SPI 服务代码, 这是一种父类加载器去请求子类加载器完成类加载的行为, 这种行为实际上是打破了双亲<br>委派模型的层次结构来逆向使用类加载器, 已经违背了双亲委派模型的一般性原则</p><ul><li><p>还有以 IBM 公司主导的 JSR-291 (即 OSGi R4.2) 提案, 通过自定义的类加载器机制的实现动态特性。</p></li><li><p>JDK9 的模块化实现也对类加载架构做了跳转</p></li><li><p>要破坏的化, 可以通过自定义类加载器, 继承 ClassLoader, 重写 loadClass 方法</p></li></ul><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p>《深入理解Java虚拟机》- 周志明  </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM Class 文件</title>
      <link href="/article/2021/2891775576/"/>
      <url>/article/2021/2891775576/</url>
      
        <content type="html"><![CDATA[<p>Java 的口号 “一次编写, 到处运行 (Write Once, Run Anywhere)” 的基础: JVM 和 所有平台都统一支持的程序存储格式 – 字节码 (Byte Code)。<br>只要在对应的平台安装对应的 JVM, 将我们编写的源码编译为 Class 文件, 就能达到了一次编写, 导出运行的目标, 中间的所有细节由不同平台的 JVM 进行处理即可。</p><p>这个过程中最重要的产物就是 Class 文件, 本文将简单地介绍一下 Class 文件的结构和内容。</p><h2 id="1-Java-文件到-Class-文件"><a href="#1-Java-文件到-Class-文件" class="headerlink" title="1 Java 文件到 Class 文件"></a>1 Java 文件到 Class 文件</h2><p>我们编写的 Java 源代码需要借助 Javac 编译器, 才能编译成 JVM 能识别的字节码文件, 流程如图所示</p><p><img src="https://pic.imgdb.cn/item/65e7e0829f345e8d036b092e.jpg" alt="Alt &#39;Java 源代码到 Class 文件&#39;"></p><p>Javac 是一种编译器, 能<strong>将一种语言规范转化成另外一种语言规范, 通常编译器都是将便于人理解的语言规范转化成机器容易理解的语言规范</strong>,<br>如 C&#x2F;C++ 或者汇编语言都是将源代码直接编译成目标机器码, 这个目标机器代码是 CPU 直接执行的指令集合, 这些指令集合也就是底层的一种语言规范。</p><p>Javac 的编译器也是将 Java 这种对人非常友好的编程语言编译成对所有机器都非常友好的一种语言, 这种语言不是针对某种机器或某个平台。<br><strong>怎么消除不同种类, 不同平台之间的差异这个任务就由 JVM 来完成</strong>, 而 Javac 的任务就是将 Java 源代码语言转化为 JVM 能够识别的一种语言,<br>然后由 JVM 再转化成当前这个机器能够识别的机器语言。</p><p>回归到 Java, Javac 的任务就是将 Java 源代码编译成 Java 字节码, 也就是JVM能够识别的二进制代码, 从表面看是将 .java 文件转化为 .class 文件。<br>而实际上是将 Java 源代码转化成一连串二进制数字, 这些二进制数字是有格式的, 只有 JVM 能够真确的识别他们到底代表什么意思。</p><p>编译器把一种语言规范转化为另一种语言规范的这个过程需要哪些步骤？ 回答这个问题需要参照《编译原理》, 总结过程如下:</p><ol><li>词法分析：读取源代码, 一个字节一个字节的读进来, 找出这些词法中我们定义的语言关键词如：if、else、while 等, 识别哪些 if<br>是合法的哪些是不合法的。这个步骤就是词法分析过程。</li></ol><p>词法分析的结果：就是从源代码中找出了一些规范化的 token 流, 就像人类语言中, 给你一句话你要分辨出哪些是一个词语, 哪些是标点符号, 哪些是动词, 哪些是名词。</p><ol start="2"><li>语法分析：就是对词法分析中得到的 token 流进行语法分析, 这一步就是检查这些关键词组合在一起是不是符合 Java 语言规范。如 if<br>的后面是不是紧跟着一个布尔型判断表达式。</li></ol><p>语法分析的结果：就是形成一个符合 Java 语言规定的抽象语法树, 抽象语法树是一个结构化的语法表达形式, 它的作用是把语言的主要词法用一个结构化的形式组织在一起。<br>这棵语法树可以被后面按照新的规则再重新组织。</p><ol start="3"><li>语义分析：语法分析完成之后也就不存在语法问题了, 语义分析的主要工作就是把一些难懂的, 复杂的语法转化成更简单的语法。就如难懂的文言文转化为大家都懂的百话文,<br>或者是注释一下一些不懂的成语。</li></ol><p>语义分析结果：就是将复杂的语法转化为简单的语法, 对应到 Java 就是将 foreach 转化为 for<br>循环, 还有一些注释等。最后生成一棵抽象的语法树, 这棵语法树也就更接近目标语言的语法规则。</p><ol start="4"><li>字节码生成：将会根据经过注释的抽象语法树生成字节码, 也就是将一个数据结构转化为另外一个数据结构。就像将所有的中文词语翻译成英文单词后按照英文语法组装成英文语句。<br>代码生成器的结果就是生成符合 Java 虚拟机规范的字节码。</li></ol><p>这个过程中的需要的组件如下图所示</p><p><img src="https://pic.imgdb.cn/item/65e7e0889f345e8d036b188a.png" alt="Alt &#39;编译器编译需要的组件&#39;"></p><p>从上面的描述中我们知道编译就是将一种语言通过分析分解, 再按照一定的方式先形成一个简单的框架 (将 Java 源文件的字节流转化为对应的 token 流),<br>然后在通过详细的分析按照一定的规定在这个框架里添加东西使这个 token 流形成更加结构化的语法树 (就是将前面生成的token流中的一个个单词组装成一句话),<br>但是这棵树离我们的目标 – Java 字节码还有点差距。</p><p>所以再进行语义分析使那棵粗糙的树更加完整完善 (给类添加默认的构造函数, 检查变量在使用前有没有初始化, 检查操作变量类型是否匹配),<br>然后 Javac 编译器调用 com.sun.tools.javac.jvm.Gen 类遍历这棵语法树将 Java 方法中的代码块转换成符合 JVM 语法的命令形式的二进制数据。<br>按照 JVM 的文件组织格式将字节码输出到以 class 为扩展名的文件中, 也就是生成最终的 Java 字节码。</p><p>词法分析: 将关键词组织成 token 流即检查源码中的的关键词是否正确并组织成 token 流。<br>语法分析: 检查源码是否符合 Java 语法规范并将词组成语句。<br>语义分析: 简化复杂的语法, 检查变量类型是否合法。<br>代码生成器: 遍历这棵树生成符合 JVM 规范的代码。</p><h2 id="2-Class-文件的结构"><a href="#2-Class-文件的结构" class="headerlink" title="2 Class 文件的结构"></a>2 Class 文件的结构</h2><h3 id="2-1-Class-文件的特点"><a href="#2-1-Class-文件的特点" class="headerlink" title="2.1 Class 文件的特点"></a>2.1 Class 文件的特点</h3><p>任何一个 Class 文件都对应着唯一的一个类或接口的定义信息 (在 JDK9 以后, Java 开始模块化, 出现了 package-info.java, moudle-info.java 这些属于反例, 完全属于描述性的),<br>但是类或接口并不一定都得定义在文件里 (比如类或接口可以动态生成, 直接送入类加载器中)。</p><p>Class 文件是一组以 8 个字节为基础单位的二进制流, 各个数据项目严格按照顺序紧凑地排列在文件之中, 中间没有添加任何分隔符, 也就是整个文件都是必须的内容。<br>当遇到需要占用 8 个字节以上空间的数据项时, 则会按照高位在前的方式分割成若干个 8 个字节进行存储。</p><p>在计算机系统中, 我们是以字节为单位的, 每个地址单元都对应着一个字节, 一个字节为 8 bit。 存储 8 个字节的内容, 没有问题。<br>但是需要存储超过 8 个字节的时候, 比如 16 字节, 32 字节 时, 怎么办呢?</p><p>这时理所当然的在用几个 8 字节进行凑就可以了, 比如 16 个字节用 2 个 8 字节凑, 就满足了。 但是将这 16 个字节分成 2 个 8 字节进行存储时, 出现了 2 种方式的存放方式。<br>big-endian (数据的低位保存在内存的高地址中, 而数据的高位保存在内存的低地址中) 和 little-endian (数据的低位保存在内存的低地址中, 而数据的高位保存在内存的高地址中)。</p><p>比如我们现在有一个 16 Bit 的数据 0x1234, 需要 2 个 8 字节的位置进行, 完全按照内容顺序存储,<br>12 存储在内存的前面, 也就是高位, 34 存储在后面, 也就是低位, 内存中存储的顺序为 1234, 这个是 little-endion。<br>但是反着过来, 将 34 存储在内存的前面, 即高位, 12 反而存在内存的后面, 即低位, 存储存储顺序变为 3412, 这个就是 big-endian。</p><p>根据 《Java虚拟机规范》 的规定, Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据, 这种伪结构中只有两种数据类型: “无符号数” 和 “表”。</p><p>无符号数属于基本的数据类型, 以 u1&#x2F;u2&#x2F;u4&#x2F;u8 来分别代表 1 个字节 &#x2F; 2 个字节 &#x2F; 4 个字节 &#x2F; 8 个字节的无符号数, 无符号数可以用来描述数字,<br>索引引用, 数量值或者按照 UTF-8 编码构成字符串值。</p><p>表由多个无符号数或者其他表作为数据项构成的复合数据类型, 为了便于区分, 所有表的命名都习惯性地以 “<strong>_info</strong>“ 结尾。<br>表用于描述有层次关系的复合结构的数据, 整个 Class 文件本质上也可以视作是一张表, 这种表的内容大致如下:</p><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">magic</td><td align="center">u4</td><td align="center">1</td></tr><tr><td align="center">minor_version</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">major_version</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">constant_pool_count</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">constant_pool</td><td align="center">cp_info</td><td align="center">constant_pool_count - 1</td></tr><tr><td align="center">access_flags</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">this_class</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">super_class</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">interfaces_count</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">interfaces</td><td align="center">u2</td><td align="center">interfaces_count</td></tr><tr><td align="center">fields_count</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">fields</td><td align="center">filed_info</td><td align="center">fields_count</td></tr><tr><td align="center">methods_count</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">methods</td><td align="center">method_info</td><td align="center">methods_count</td></tr><tr><td align="center">attributes_count</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">attributes</td><td align="center">attribute_info</td><td align="center">attributes_count</td></tr></tbody></table><p>下面逐个看一下它们都是什么含义吧。</p><h4 id="2-1-1-magic-minor-version-major-version"><a href="#2-1-1-magic-minor-version-major-version" class="headerlink" title="2.1.1 magic&#x2F;minor_version&#x2F;major_version"></a>2.1.1 magic&#x2F;minor_version&#x2F;major_version</h4><p>每个 Class 文件的头 4 个字节被称为魔数 (magic_version), 它的唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件。<br>Class 文件的魔数为 “0xCAFEBABE”。</p><p>接着下面的 4 个字节 (minor_version + major_version), 第 5, 6 位表示次版本号, 7, 8 表示主版本号。</p><p>用 JDK8 和 JDK14 编译同一个 Java 文件, 他们的版本号字节分别为 <strong>0000 0034</strong> 和 <strong>0000 003a</strong>。 这个版本号会影响到 JVM 能否执行这个文件。<br>每个 JDK 都有自己支持支持的版本号范围, 在这个范围的前提下, 能够向下兼容低版本的, 但是一定不能执行超过自己支持的高版本号的文件。</p><h4 id="2-1-2-常量池"><a href="#2-1-2-常量池" class="headerlink" title="2.1.2 常量池"></a>2.1.2 常量池</h4><p>和常量池相关的 <strong>constant_pool_count</strong> 和 <strong>constant_pool</strong>。<br>constant_pool_count 这个容量计数是从 1 开始, 而不是 0, 如果常量池数量的值为 22, 这就是代表常量池中有 21 项。</p><p>常量池中主要存放两大类常量: 字面量 (Literal) 和符号引用 (Symbolic References)。</p><p>字面量比较接近于 Java 语言层面的常量概念, 如文本字符串, 被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念,<br>主要包括下面几类常量</p><blockquote><ol><li>被模块导出或者开放的包 (Package)</li><li>类和接口的全限定名 (Fully Qualified Name)</li><li>字段的名称和描述符 (Descriptor)</li><li>方法的名称和描述符</li><li>方法句柄和方法类型 (Method Handle, Method Type, Invoke Dynamic)</li><li>动态调用点和动态常量 (Dynamically-Computed Call Site, Dynamically-Computed Constant)</li></ol></blockquote><p>Java 代码在进行 Javac 编译的时候, 在 Class 文件中不会保存各个方法, 字段最终在内存中的布局信息。<br>这些字段, 方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址, 也就无法直接被虚拟机使用的。<br>当虚拟机做类加载时, 将会从常量池获得对应的符号引用, 再在类创建时或运行时解析, 翻译到具体的内存地址之中。</p><p>常量池中每一项常量都是一个表, 截至 JDK13, 常量表中分别有 17 种不同类型的常量。<br>这 17 类表起始的第一位是 u1 类型的标志位 (一般叫做 tag), 代表着当前常量属于什么类型的常量类型。</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th><th align="center">标志</th></tr></thead><tbody><tr><td align="center">CONSTANT_Utf8_info</td><td align="center">UTF-8 编码的字符串</td><td align="center">1</td></tr><tr><td align="center">CONSTANT_Integer_info</td><td align="center">整形字面量</td><td align="center">3</td></tr><tr><td align="center">CONSTANT_Float_info</td><td align="center">浮点型字面量</td><td align="center">4</td></tr><tr><td align="center">CONSTANT_Long_info</td><td align="center">长整型字面量</td><td align="center">5</td></tr><tr><td align="center">CONSTANT_Double_info</td><td align="center">双精度浮点型整形</td><td align="center">6</td></tr><tr><td align="center">CONSTANT_Class_info</td><td align="center">类或接口的符号引用</td><td align="center">7</td></tr><tr><td align="center">CONSTANT_String_info</td><td align="center">字符串类型字面量</td><td align="center">8</td></tr><tr><td align="center">CONSTANT_Fieldref_info</td><td align="center">字段的符号引用</td><td align="center">9</td></tr><tr><td align="center">CONSTANT_Methodref_info</td><td align="center">类中方法的符号引用</td><td align="center">10</td></tr><tr><td align="center">CONSTANT_InterfaceMethodref_info</td><td align="center">接口中方法的符号引用</td><td align="center">11</td></tr><tr><td align="center">CONSTANT_NameAndType_info</td><td align="center">字段或方法的部分符号引用</td><td align="center">12</td></tr><tr><td align="center">CONSTANT_MethodHandle_info</td><td align="center">方法句柄</td><td align="center">15</td></tr><tr><td align="center">CONSTANT_MethodType_info</td><td align="center">方法类型</td><td align="center">16</td></tr><tr><td align="center">CONSTANT_Dynamic_info</td><td align="center">一个动态计算常量</td><td align="center">17</td></tr><tr><td align="center">CONSTANT_InvokeDynamic_info</td><td align="center">一个动态方法调用点</td><td align="center">18</td></tr><tr><td align="center">CONSTANT_Module_info</td><td align="center">一个模块</td><td align="center">19</td></tr><tr><td align="center">CONSTANT_Package_info</td><td align="center">一个模块中开放或导出的包</td><td align="center">20</td></tr></tbody></table><p>字符串表 CONSTANT_Utf8_info 的内容如下</p><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">tag</td><td align="center">u1</td><td align="center">1</td></tr><tr><td align="center">length</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">bytes</td><td align="center">u1</td><td align="center">length</td></tr></tbody></table><p>在 Class 文件, 经过了魔数, 版本, 常量池的数量, 紧接着的就是具体的常量项。<br>接着往后找,</p><blockquote><p>假设找到第一个字节, 值为 1, 这表示第一个常量为字符串,<br>接着往下找第 2, 3 个字节 (字符串常量的长度用的是 16 个字节表示), 得到这个字符串常量的长度占了多少个字节,<br>再往后找对应的字节数, 这个就是字符串的内容了</p></blockquote><p>这样就能得到第一个常量的内容。</p><p><strong>一个小知识: u2 类型能表达的最大值 65535, 也就是 64 KB, 如果我们定义了一个字符串常量&#x2F;方法名等超过了这个临界值, 会编译失败</strong>。</p><p>类或接口的符号引用表 CONSTANT_Class_info 的内容如下</p><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">tag</td><td align="center">u1</td><td align="center">1</td></tr><tr><td align="center">name_index</td><td align="center">u2</td><td align="center">1</td></tr></tbody></table><p>tag 同上, 而 name_index 是常量池的索引值, 它指向常量池中一个 CONSTANT_Utf8_info 类型常量, 此常量代表了这个类 (或者接口) 的全限定名。<br>其他类型的常量表差不多, 就不列举了, 在实际中, 我们可以通过各种工具, 对 Class 文件进行分析, 不需要通过如此计算每个字节,<br>各种转换, 最接近的工具就是 JDK 自带的 <strong>javac</strong>。</p><h4 id="2-1-3-访问符标志"><a href="#2-1-3-访问符标志" class="headerlink" title="2.1.3 访问符标志"></a>2.1.3 访问符标志</h4><p>经过常量池后, 紧接着的是 u2 表示的访问符标识 (access_flags), 这个标志用于识别一些类或者接口层次的访问信息,<br>包括: 这个 Class 是类还是接口 &#x2F; 是否定义为 public 类型 &#x2F; 是否定义为 abstract 类型 &#x2F; 如果是类的话, 是否被声明为 final 等</p><table><thead><tr><th align="center">标志名称</th><th align="center">标志值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">ACC_PUBLIC</td><td align="center">0x0001</td><td align="center">是否为 public 类型</td></tr><tr><td align="center">ACC_FINAL</td><td align="center">0x0010</td><td align="center">是否被声明为 final, 只有类可设置</td></tr><tr><td align="center">ACC_SUPER</td><td align="center">0x0020</td><td align="center">是否允许使用 invokespecial 字节码指令的新语义, invokespecial 指令在 JDK1.0.2 发生了改变, 所以为了不混淆, JDK1.0.2 以后这个必须为 true</td></tr><tr><td align="center">ACC_INTERFACE</td><td align="center">0x0200</td><td align="center">标识这是一个接口</td></tr><tr><td align="center">ACC_ABSTRACT</td><td align="center">0x0400</td><td align="center">标识这是一个 abstract 的类型, 抽象类或接口这个为 true, 其他为 false</td></tr><tr><td align="center">ACC_SYNTHETIC</td><td align="center">0x1000</td><td align="center">标识这个类是否由用户代码生成</td></tr><tr><td align="center">ACC_ANNOTATION</td><td align="center">0x2000</td><td align="center">标识这是一个注解</td></tr><tr><td align="center">ACC_ENUM</td><td align="center">0x4000</td><td align="center">标识这是一个枚举</td></tr><tr><td align="center">ACC_MODULE</td><td align="center">0x8000</td><td align="center">标识这是一个模板</td></tr></tbody></table><p>access_flags 中一共有 16 个标志位可以使用, 当前只定义了其中 9 个, 其他没用到的都为 0 (2 个字节, 16 位, 所以上限为 16 个标识)。</p><h4 id="2-1-4-类索引、父类索引与接口索引集合"><a href="#2-1-4-类索引、父类索引与接口索引集合" class="headerlink" title="2.1.4 类索引、父类索引与接口索引集合"></a>2.1.4 类索引、父类索引与接口索引集合</h4><p>一个 Java 类的继承 &#x2F; 实现关系的确定是由下面 4 个参数决定的 <strong>this_class</strong>, <strong>super_class</strong>, <strong>interface_count</strong>, *<br><em>interfaces</em>*</p><p>this_class: 类索引, 用于确定这个类的全限定名<br>super_class: 父类索引, 用于确定这个类的父类的全限定名, 除了 java.lang.Object 外, 所有 Java 类的父类索引都不为空<br>interface_count: 接口个数, 用于确定这个类的接口个数<br>interfaces: 接口索引集合, 用来描述这个类实现了哪些接口, 按照 implements 关键字从左到右排列 (当然如果当前是一个接口类, 那么就是 extends 关键字的后面)</p><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">this_class</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">super_class</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">interfaces_count</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">interfaces</td><td align="center">u2</td><td align="center">interfaces_count</td></tr></tbody></table><h4 id="2-1-5-字段表集合"><a href="#2-1-5-字段表集合" class="headerlink" title="2.1.5 字段表集合"></a>2.1.5 字段表集合</h4><p>字段表 (field_info) 用于描述接口或者类中声明的变量。</p><p>在 Java 中一个字段定义, 会涉及下面几个方面</p><blockquote><p>作用域 (public, private, protected)<br>实例变量还是类变量 (static)<br>可变性 (final)<br>并发可见性 (volatile)<br>可否被序列化 (transient)<br>字段数据类型 (基本类型, 对象, 数组)<br>字段名称</p></blockquote><p>字段表的结构</p><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">acc_flags</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">name_index</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">descriptor_index</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">attributes_count</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">attributes</td><td align="center">attributes_info</td><td align="center">attributes_count</td></tr></tbody></table><p>字段修饰符放在 access_flags 项目中, 它与类中的 access_flags 项目是非常类似的, 都是一个 u2 的数据类型, 其中可以设置的标志位和含义。</p><table><thead><tr><th align="center">标志名称</th><th align="center">标志值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">ACC_PUBLIC</td><td align="center">0x0001</td><td align="center">字段是否为 public 类型</td></tr><tr><td align="center">ACC_PRIVATE</td><td align="center">0x0002</td><td align="center">字段是否为 private 类型</td></tr><tr><td align="center">ACC_PROTECTED</td><td align="center">0x0004</td><td align="center">字段是否为 protected 类型</td></tr><tr><td align="center">ACC_STATIC</td><td align="center">0x0008</td><td align="center">字段是否为 static</td></tr><tr><td align="center">ACC_FINAL</td><td align="center">0x0010</td><td align="center">字段是否为 final</td></tr><tr><td align="center">ACC_VOLATILE</td><td align="center">0x0040</td><td align="center">字段是否为 volatile</td></tr><tr><td align="center">ACC_TRANSIENT</td><td align="center">0x0080</td><td align="center">字段是否 transient</td></tr><tr><td align="center">ACC_SYNTHETIC</td><td align="center">0x1000</td><td align="center">字段是否由编译器自动产生</td></tr><tr><td align="center">ACC_ENUM</td><td align="center">0x4000</td><td align="center">字段是否为 enum</td></tr></tbody></table><p>很明显, 由于语法规则的约束, ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED 三个标志最多只能选择其一, ACC_FINAL, ACC_VOLATILE 不能同时选择。<br>接口之中的字段必须有 ACC_PUBLIC, ACC_STATIC, ACC_FINAL 标志, 这些都是由 Java 本身的语言规则所导致的。</p><p>在 access_flags 标志的是两项索引值</p><blockquote><p>name_index<br>descriptor_index</p></blockquote><p>它们都是对常量池项的引用, 分别代表着字段的简单名称以及字段和方法的描述符。</p><p>全限定名: 就是包名 + 类名的字符串, 将里面的 <strong>.</strong> 替换为 <strong>&#x2F;</strong>, 同时在末尾加上 <strong>;</strong> 表示结束的<br>简单名称: 就是没有任何类型和参数修饰的方法或字段<br>描述符: 用来描述字段的数据类型, 方法的参数列表 (包括数量, 类型以及顺序) 和返回值</p><p>描述符标识字符含义</p><table><thead><tr><th align="center">标识字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">B</td><td align="center">基础数据类型 byte</td></tr><tr><td align="center">C</td><td align="center">基础数据类型 char</td></tr><tr><td align="center">D</td><td align="center">基础数据类型 double</td></tr><tr><td align="center">F</td><td align="center">基础数据类型 float</td></tr><tr><td align="center">I</td><td align="center">基础数据类型 int</td></tr><tr><td align="center">L</td><td align="center">基础数据类型 long</td></tr><tr><td align="center">S</td><td align="center">基础数据类型 short</td></tr><tr><td align="center">Z</td><td align="center">基础数据类型 boolean</td></tr><tr><td align="center">V</td><td align="center">特殊类型 void</td></tr><tr><td align="center">L</td><td align="center">对象类型 如 Ljava&#x2F;lang&#x2F;Object</td></tr></tbody></table><p>对于数组类型, 每一维度将使用一个前置的 “[“ 字符来描述,<br>如一个定义为 “java.lang.String[][]” 类型的二维数组将被记录成 “[[Ljava&#x2F;lang&#x2F;String;”, 一个整型数组”int[]” 将被记录成 “[I”。</p><p>用描述符来描述方法时, 按照先参数列表, 后返回值的顺序描述, 参数列表按照参数的严格顺序放在一组小括号 “()” 之内,<br>比如方法 “int indexOf(char[]source, int sourceOffset, int sourceCount, char[]target,  int targetOffset, int targetCount, int fromIndex)” 的描述符为 “([CII[CIII])I”,<br>再如 “String toString(String str)” 的描述符为 “(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;”</p><p>在描述符后面的就是属性表集合了, 用于存储一些额外的信息。<br>字段表可以在属性表中附加描述零至多项的额外信息, 比如默认值之类的, 具体内容后面的属性表在聊。</p><p>字段表集合中不会列出从父类或者父接口中继承而来的字段, 但有可能出现原本 Java 代码之中不存在的字段,<br>譬如在内部类中为了保持对外部类的访问性, 编译器就会自动添加指向外部类实例的字段。</p><h4 id="2-1-6-方法表集合"><a href="#2-1-6-方法表集合" class="headerlink" title="2.1.6 方法表集合"></a>2.1.6 方法表集合</h4><p>Class 文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式, 方法表的结构如同字段表一样,<br>依次包括访问标志 (access_flags), 名称索引 (name_index), 描述符索引 (descriptor_index), 属性表集合 (attributes) 几项</p><p>方法表的结构</p><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">acc_flags</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">name_index</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">descriptor_index</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">attributes_count</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">attributes</td><td align="center">attributes_info</td><td align="center">attributes_count</td></tr></tbody></table><p>因为 volatile 关键字和 transient 关键字不能修饰方法, 所以方法表的访问标志中没有了 ACC_VOLATILE 标志和 ACC_TRANSIENT 标志。<br>与之相对, synchronized, native, strictfp 和 abstract 关键字可以修饰方法, 方法表的访问标志中也相应地增加了<br>ACC_SYNCHRONIZED, ACC_NATIVE、ACC_STRICTFP 和 ACC_ABSTRACT 标志</p><table><thead><tr><th align="center">标志名称</th><th align="center">标志值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">ACC_PUBLIC</td><td align="center">0x0001</td><td align="center">是否为 public 方法</td></tr><tr><td align="center">ACC_PRIVATE</td><td align="center">0x0002</td><td align="center">是否为 private 方法</td></tr><tr><td align="center">ACC_PROTECTED</td><td align="center">0x0004</td><td align="center">是否为 protected 方法</td></tr><tr><td align="center">ACC_STATIC</td><td align="center">0x0008</td><td align="center">是否为 static 方法</td></tr><tr><td align="center">ACC_FINAL</td><td align="center">0x0010</td><td align="center">是否为 final 方法</td></tr><tr><td align="center">ACC_SYNCHRONIZED</td><td align="center">0x0020</td><td align="center">是否为 synchronized 方法</td></tr><tr><td align="center">ACC_BRIDGE</td><td align="center">0x0040</td><td align="center">是否为编译器生成的桥接方法</td></tr><tr><td align="center">ACC_VARARGS</td><td align="center">0x0080</td><td align="center">方法是否接受不定参数</td></tr><tr><td align="center">ACC_NATIVE</td><td align="center">0x0100</td><td align="center">是否为 native 方法</td></tr><tr><td align="center">ACC_ABSTRACT</td><td align="center">0x0400</td><td align="center">是否为 abstract 方法</td></tr><tr><td align="center">ACC_STRICT</td><td align="center">0x0800</td><td align="center">是否为 strictfp 方法</td></tr><tr><td align="center">ACC_SYNTHETIC</td><td align="center">0x1000</td><td align="center">方法是否为编译器自动产生</td></tr></tbody></table><h4 id="2-1-7-属性表集合"><a href="#2-1-7-属性表集合" class="headerlink" title="2.1.7  属性表集合"></a>2.1.7  属性表集合</h4><p>属性表 (attribute_info) 与 Class 文件中其他的数据项目要求严格的顺序, 长度和内容不同, 不再要求各个属性表具有严格顺序。</p><p>属性表的结构</p><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">attribute_name_index</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">attribute_length</td><td align="center">u1</td><td align="center">1</td></tr><tr><td align="center">info</td><td align="center">u1</td><td align="center">attribute_length</td></tr></tbody></table><p>虚拟机规范预定义的属性</p><table><thead><tr><th align="center">属性名称</th><th align="center">使用位置</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Code</td><td align="center">方法表</td><td align="center">Java 代码编译成的字节码指令</td></tr><tr><td align="center">ConstantValue</td><td align="center">字段表</td><td align="center">由 final 关键字定义的常量值</td></tr><tr><td align="center">Deprecated</td><td align="center">类, 方法表, 字段表</td><td align="center">被声明为 deprecated 的类, 方法, 字段</td></tr><tr><td align="center">Exceptions</td><td align="center">方法表</td><td align="center">方法抛出的异常列表</td></tr><tr><td align="center">EnclosingMethod</td><td align="center">类文件</td><td align="center">仅当一个类为局部类或匿名类时才能拥有这个属性, 这个属性用于标志这个类所在的外围方法</td></tr><tr><td align="center">InnerClass</td><td align="center">类文件</td><td align="center">内部类列表</td></tr><tr><td align="center">LineNumberTable</td><td align="center">Code 属性</td><td align="center">Java 源码的行号和字节码指令的对应关系</td></tr><tr><td align="center">LocalVariableTable</td><td align="center">Code 属性</td><td align="center">方法的局部变量描述</td></tr><tr><td align="center">StackMapTable</td><td align="center">Code 属性</td><td align="center">供新的类型检查验证器 (Type Checker) 检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配</td></tr><tr><td align="center">Signature</td><td align="center">类, 方法表, 字段表</td><td align="center">用于支持泛型下的方法签名</td></tr><tr><td align="center">SourceFile</td><td align="center">类文件</td><td align="center">记录源文件名称</td></tr><tr><td align="center">SourceDebugExtension</td><td align="center">类文件</td><td align="center">用于存储额外的调试信息</td></tr><tr><td align="center">Synthetic</td><td align="center">类, 方法表, 字段表</td><td align="center">标识方法或字段是编译器自动生成的</td></tr><tr><td align="center">LocalVariableTypeTable</td><td align="center">类</td><td align="center">使用特征签名替代描述符, 是为了引入泛型语法后能描述泛型参数化类型</td></tr><tr><td align="center">RuntimeVisibleAnnotations</td><td align="center">类, 方法表, 字段表</td><td align="center">为动态注解提供支持, 用于指明哪些注解是运行时可见的</td></tr><tr><td align="center">RuntimeInVisibleAnnotations</td><td align="center">类, 方法表, 字段表</td><td align="center">为动态注解提供支持, 用于指明哪些注解是运行时不可见的</td></tr><tr><td align="center">RuntimeVisibleParameterAnnotations</td><td align="center">方法表</td><td align="center">作用和 RuntimeVisibleAnnotations 相似, 只不过这个只能用于方法参数</td></tr><tr><td align="center">RuntimeInVisibleParameterAnnotations</td><td align="center">方法表</td><td align="center">作用和 RuntimeInVisibleAnnotations 相似, 只不过这个只能用于方法参数</td></tr><tr><td align="center">AnnotationDefault</td><td align="center">方法表</td><td align="center">用于记录注解类元素的默认值</td></tr><tr><td align="center">BoostrapMethods</td><td align="center">类文件</td><td align="center">用于保存 invokedynamic 指令引用的引导方法限定符</td></tr><tr><td align="center">RuntimeVisibleTypeAnnotations</td><td align="center">类, 方法表, 字段表, Code 属性</td><td align="center">为实现 JSR 308 中新增的类型注解提供的支持, 用于指明哪些注解是运行时可见的</td></tr><tr><td align="center">RuntimeInVisibleTypeAnnotations</td><td align="center">类, 方法表, 字段表, Code 属性</td><td align="center">为实现 JSR 308 中新增的类型注解提供的支持, 用于指明哪些注解是运行时不可见的</td></tr><tr><td align="center">MethodParameters</td><td align="center">方法表</td><td align="center">用于支持 (编译时加入 -parameters 参数) 将方法名称编译进 Class 文件, 并可运行时获取</td></tr><tr><td align="center">Module</td><td align="center">类</td><td align="center">用于记录一个 Module 的名称和相关的信息 (requires, exports, opens, uses, provides)</td></tr><tr><td align="center">ModulePackages</td><td align="center">类</td><td align="center">用于记录一个模块中所有被 exports 或 opens 的包</td></tr><tr><td align="center">ModuleMainClass</td><td align="center">类</td><td align="center">用于指定一个模块的主类</td></tr><tr><td align="center">NestHost</td><td align="center">类</td><td align="center">用于支持嵌套类的反射和访问控制 API, 一个内部类通过该属性得知自己的宿主类</td></tr><tr><td align="center">NestMembers</td><td align="center">类</td><td align="center">用于支持嵌套类的反射和访问控制 API, 一个内部类通过该属性得知自己有哪些内部类</td></tr></tbody></table><ul><li>Code 属性</li></ul><p>Code 属性表的结构</p><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">attribute_name_index</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">attribute_length</td><td align="center">u4</td><td align="center">1</td></tr><tr><td align="center">max_stack</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">max_locals</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">code_length</td><td align="center">u4</td><td align="center">1</td></tr><tr><td align="center">code</td><td align="center">u1</td><td align="center">cide_length</td></tr><tr><td align="center">exception_table</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">attributes_count</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">attributes</td><td align="center">attributes_info</td><td align="center">attributes_count</td></tr></tbody></table><p>attribute_name_index 是一项指向 CONSTANT_Utf8_info 型常量的索引, 此常量值固定为 “Code”, 它代表了该属性的属性名称,<br>attribute_length 指示了属性值的长度。</p><p>max_stack 代表了操作数栈 (Operand Stack) 深度的最大值。 在方法执行的任意时刻, 操作数栈都不会超过这个深度。<br>虚拟机运行的时候需要根据这个值来分配栈帧 (Stack Frame) 中的操作栈深度</p><p>max_locals 代表了局部变量表所需的存储空间。 在这里, max_locals 的单位是变量槽 (Slot), 变量槽是虚拟机为局部变量分配内存所使用的最小单位。<br>对于 byte, char, float, int, short, boolean 和 returnAddress 等长度不超过 32 位的数据类型, 每个局部变量占用一个变量槽, 而<br>double 和 long 这两种 64 位的数据类型则需要两个变量槽来存放。 方法参数 (包括实例方法中隐藏参数 “this”),<br>显式异常处理程序的参数 (Exception Handler Parameter, 就是 try-catch 语句中 catch 块中所定义的异常),<br>方法体中定义的局部变量都需要依赖局部变量表来存放。 并不是在方法中用了多少个局部变量, 就把这些局部变量所占变量槽数量之和作为<br>max_locals 的值, 在代码实际运行中, 槽有时可以重用。</p><p>code_length 和 code 用来存储 Java 源程序编译后生成的字节码指令。 code_length 代表字节码长度, code<br>是用于存储字节码指令的一系列字节流。<br>注: 虽然 code_length 的类型为 u4, 理论上最大值可以达到 2 的 32 次幂, 但是 《Java虚拟机规范》 中明确限制了一个方法不允许超过<br>65535 条字节码指令, 即它实际只使用了 u2 的长度。  </p><p>code 属性是 Class 文件中最重要的一个属性, 用于描述代码。</p><p>exception_table 异常表 (此处的异常表不是上面的 Exception) 对于 Code 属性来说并不是必须存在的, 如果出现的话, 它的结构如下</p><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">start_pc</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">end_pc</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">handler_pc</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">catch_type</td><td align="center">u2</td><td align="center">1</td></tr></tbody></table><p>第 start_pc 行开始 到 end_pc (不包含 end_pc) 行出现了 catch_type 类型或其子类的异常, 跳转到 handler_pc 行继续执行,<br>catch_type 为 0, 则任意异常到需要到 handler_pc 行去处理。</p><ul><li>Exception 属性</li></ul><p>此处的异常不是上面的异常表。 Exceptions 属性的作用是列举出方法中可能抛出的受查异常 (Checked Exceptions), 也就是方法描述时在<br>throws 关键字后面列举的异常</p><p>Exception 属性结构</p><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">attribute_name_index</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">attribute_length</td><td align="center">u4</td><td align="center">1</td></tr><tr><td align="center">number_of_exceptions</td><td align="center">u2</td><td align="center">1</td></tr><tr><td align="center">exception_index_table</td><td align="center">u2</td><td align="center">1</td></tr></tbody></table><p>number_of_exceptions 项表示方法可能抛出 number_of_exceptions 种受查异常, 每一种受查异常使用一个 exception_index_table<br>项表示; exception_index_table 是一个指向常量池中 CONSTANT_Class_info 型常量的索引。</p><p>至于属性表集合其他的属性, 这里就不一一列举了。<br>有兴趣可以阅读一下 周志明的《深入理解Java虚拟机》第 3 部分。 </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《深入理解Java虚拟机》- 周志明<br><a href="https://blog.csdn.net/fuzhongmin05/article/details/54880257">Java代码编译过程简述</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM 分析工具</title>
      <link href="/article/2021/2263417759/"/>
      <url>/article/2021/2263417759/</url>
      
        <content type="html"><![CDATA[<p>在 $JAVA_HOME&#x2F;bin 的目录下, 存在着许多小工具, 除了编译和运行 Java 程序外, 打包, 部署, 签名, 调试, 监控, 运维等各种场景都可能会用到它们。</p><h2 id="1-常用的命令行工具"><a href="#1-常用的命令行工具" class="headerlink" title="1 常用的命令行工具"></a>1 常用的命令行工具</h2><h2 id="1-1-jps-JVM-Process-Status-Tool-虚拟机进程状况工具"><a href="#1-1-jps-JVM-Process-Status-Tool-虚拟机进程状况工具" class="headerlink" title="1.1 jps (JVM Process Status Tool) - 虚拟机进程状况工具"></a>1.1 jps (JVM Process Status Tool) - 虚拟机进程状况工具</h2><p>列出正在运行的虚拟机进程, 并显示虚拟机执行主类 (Main Class, 也就是 main 方法所在的类) 的名称以及这些进程的本地虚拟机唯一 ID (LVMID，Local Virtual Machine Identifier)。</p><p>命令格式</p><pre class="language-bash" data-language="bash"><code class="language-bash">jps <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>hostid<span class="token operator">></span><span class="token punctuation">]</span></code></pre><p>options 列表</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-q</td><td align="center">只输出 LVMID, 省略主类的名称</td></tr><tr><td align="center">-m</td><td align="center">输出虚拟机进程启动时, 传递给 main 方法的参数</td></tr><tr><td align="center">-l</td><td align="center">输出主类的全名称, 如果进程执行的是 jar 包, 输出 jar 包路径</td></tr><tr><td align="center">-v</td><td align="center">输出 JVM 进程启动时的 JVM 参数</td></tr><tr><td align="center">-V</td><td align="center">输出 LVMID 和主类的类名, 不带任何参数的 jps, 默认就是这个格式</td></tr></tbody></table><p>jps 还可以查询开启了 RMI 服务的远程虚拟机进程状态, 参数 hostId 为 RMI 注册表中注册的主机名。开启 RMI 的步骤, 可以看<a href="https://blog.csdn.net/qq1169091731/article/details/83067108">这里</a>。</p><h3 id="1-2-jstat-JVM-Statistics-Monitoring-Tool-虚拟机统计信息监视工具"><a href="#1-2-jstat-JVM-Statistics-Monitoring-Tool-虚拟机统计信息监视工具" class="headerlink" title="1.2 jstat (JVM Statistics Monitoring Tool) - 虚拟机统计信息监视工具"></a>1.2 jstat (JVM Statistics Monitoring Tool) - 虚拟机统计信息监视工具</h3><p>用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类加载, 内存, 垃圾收集, 即时编译等运行时数据。</p><p>命令格式</p><pre class="language-bash" data-language="bash"><code class="language-bash">jstat -<span class="token operator">&lt;</span>options<span class="token operator">></span> <span class="token punctuation">[</span>-t<span class="token punctuation">]</span> <span class="token punctuation">[</span>-h<span class="token operator">&lt;</span>lines<span class="token operator">></span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>vmid<span class="token operator">></span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>interval<span class="token operator">></span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>count<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><p>options 列表</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-class</td><td align="center">监视类加载&#x2F;卸载数量, 总空间和类装载消耗时间</td></tr><tr><td align="center">-gc</td><td align="center">监视堆状况, 包括 Eden 区&#x2F; 2 个 Survivor 区&#x2F;老年代&#x2F;永久代 等容量, 已用空间, 垃圾收集时间合计等信息</td></tr><tr><td align="center">-gccapacity</td><td align="center">监视内容和 -gc 差不多, 但输出内容主要关注的是 Java 堆各个区域的使用到的最大, 最小空间</td></tr><tr><td align="center">-gcutil</td><td align="center">监视内容和 -gc 差不多, 但输出内容主要关注的是 Java 堆各个区域已使用空间占总空间的百分比</td></tr><tr><td align="center">-gccause</td><td align="center">和 -gcutil 功能一样, 但是会多输出导致上一次垃圾回收产生的原因</td></tr><tr><td align="center">-gcnew</td><td align="center">监视新生代垃圾回收情况</td></tr><tr><td align="center">-gcnewcapacity</td><td align="center">监视内容和 -gcnew 基本一样, 输出主要关注使用到的最大, 最小空间</td></tr><tr><td align="center">-gcold</td><td align="center">监视老年代垃圾回收情况</td></tr><tr><td align="center">-gcoldcapacity</td><td align="center">监视内容和 -gcold 基本一样, 输出主要关注使用到的最大, 最小空间</td></tr><tr><td align="center">-gcpermcapacity</td><td align="center">输出永久代使用到的最大, 最小空间</td></tr><tr><td align="center">-compiler</td><td align="center">输出即时编译器编译过的方法, 耗时等信息</td></tr><tr><td align="center">-printcompilation</td><td align="center">输出已经被即时编译的方法</td></tr></tbody></table><p>-t: 用于在最前面输出一个时间戳<br>-h: 格式 -h数字, 需要搭配后面的循环打印使用, 比如 5, 每个标题头下面输出 5 次结果后, 再次输出标题头, 再 5 次结果<br>vmid: 如果是本地的话, 就是 LVMID, 如果是远程的服务器的话, 则是类似于这样的格式 <strong>[protocol:][&#x2F;&#x2F;]lvmid[@hostname[:port]&#x2F;servername]</strong><br>interval: 间隔多少毫秒查询 1 次, 如果为 数字 + s, 则是多少秒查询 1 次<br>count: 循环查询的次数</p><p>例子:</p><pre class="language-none"><code class="language-none">jstat -gcutil 2764S0     S1     E       O      M     CCS      YGC     YGCT     FGC    FGCT       GCT0.00  29.95  22.24   0.01  94.34  82.22      1      0.011     0     0.000      0.011</code></pre><p>查询结果表明: 这台服务器的新生代 Eden 区 (E, 表示Eden) 使用了 22.24% 的空间, 2 个 Survivor 区 (S0, S1表示 Survivor0 和 Survivor1) 里面都是空的, 分别为空的和占了 29.95% 的空间, 老年代 (O, 表示 Old) 和 元空间 (M, 表示 Metaspace) 则分别使用了 0.01% 和 94.34% 的空间。</p><p>程序运行以来共发生 Minor GC (YGC, 表示 Young GC) 1次, 总耗时0.011秒; 发生 Full GC (FGC, 表示 Full GC) 0 次, 总耗时 (FGCT，表示 Full GC Time) 为 0.472 秒; 所有 GC 总耗时 (GCT, 表示 GC Time) 为 0.577 秒</p><h2 id="1-3-jinfo-Configuration-Info-for-Java-Java-配置信息工具"><a href="#1-3-jinfo-Configuration-Info-for-Java-Java-配置信息工具" class="headerlink" title="1.3 jinfo (Configuration Info for Java) - Java 配置信息工具"></a>1.3 jinfo (Configuration Info for Java) - Java 配置信息工具</h2><p>实时查看和调整虚拟机各项参数</p><p>命令格式</p><pre class="language-bash" data-language="bash"><code class="language-bash">jinfo -<span class="token operator">&lt;</span>options<span class="token operator">></span> <span class="token operator">&lt;</span>pid<span class="token operator">></span></code></pre><p>options 列表</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-flag name</td><td align="center">输出指定的 JVM 参数的值</td></tr><tr><td align="center">-flag +&#x2F;- name</td><td align="center">动态的启用&#x2F;关闭指定的 JVM 参数</td></tr><tr><td align="center">-flag name&#x3D;value</td><td align="center">动态的设置 JVM 参数为给定的值</td></tr><tr><td align="center">-flags</td><td align="center">输出所有的 JVM 参数</td></tr><tr><td align="center">-sysprops</td><td align="center">输出当前的 Java 系统属性, 内容等同与 Java 内部的 System.getProperties()</td></tr></tbody></table><h2 id="1-4-jmap-Memory-Map-for-Java-Java-内存映像工具"><a href="#1-4-jmap-Memory-Map-for-Java-Java-内存映像工具" class="headerlink" title="1.4 jmap (Memory Map for Java) - Java 内存映像工具"></a>1.4 jmap (Memory Map for Java) - Java 内存映像工具</h2><p>jmap 的作用并不仅仅是为了获取堆转储快照 (一般称为 heapdump 或 dump 文件), 它还可以查询 finalize 执行队列, Java 堆和方法区的详细信息, 如空间使用率, 当前用的是哪种收集器等</p><p>命令格式</p><pre class="language-bash" data-language="bash"><code class="language-bash">jmap -<span class="token operator">&lt;</span>options<span class="token operator">></span> <span class="token operator">&lt;</span>pid<span class="token operator">></span></code></pre><p>options 列表</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-dump</td><td align="center">生成 Java 堆转储快照, 格式为 -dump:[live,]format&#x3D;b,file&#x3D;&lt;文件名&gt;, live 参数用于控制是否只 dump 出存活的对象</td></tr><tr><td align="center">-finalizerinfo</td><td align="center">显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象, 只在 Linux&#x2F;Solaris 平台有效</td></tr><tr><td align="center">-heap</td><td align="center">显示 Java 堆的详细信息, 如使用的是哪种收集器, 参数配置, 分代状况等, 只在 Linux&#x2F;Solaris 平台有效</td></tr><tr><td align="center">-histo</td><td align="center">显示堆中对象统计信息, 包含类&#x2F;实例数量, 合集容量, 格式为 -histo[:live,][file&#x3D;&lt;文件名&gt;], live 参数用于控制统计活对象, 同样的也可以直接把内容输出为文件</td></tr><tr><td align="center">-permstat</td><td align="center">以 ClassLoader 为统计口径显示永久代内存状态, 只在 Linux&#x2F;Solaris 平台有效</td></tr><tr><td align="center">-F</td><td align="center">当虚拟机对 -dump 选项没有任何反应, 可使用这个参数强制 dump 出快照, 只在 Linux&#x2F;Solaris 平台有效</td></tr></tbody></table><p>除了手动生成快照的方式, 也可以通过配置 JVM 参数 XX: +HeapDumpOnOutOfMemoryError, 当程序内存溢出时, 生成 dump 文件<br>也可以通过设置 -XX: +HeapDumpOnCtrlBreak 参数, 然后通过 [Ctrl]+[Break] 键让虚拟机生成堆转储快照文件<br>在 Linux 中也可以通过 “Kill -3” 来获取堆转储快照</p><h3 id="1-5-jhat-JVM-Heap-Analysis-Tool-虚拟机堆转储快照分析工具"><a href="#1-5-jhat-JVM-Heap-Analysis-Tool-虚拟机堆转储快照分析工具" class="headerlink" title="1.5 jhat (JVM Heap Analysis Tool) - 虚拟机堆转储快照分析工具"></a>1.5 jhat (JVM Heap Analysis Tool) - 虚拟机堆转储快照分析工具</h3><p>jhat 内置了一个微型的HTTP&#x2F;Web服务器, 可以用来分析 jmap 生成的 dump 文件, 同时生成堆转储快照的分析结果后。<br>但是实际中很少会使用这个来分析 dump 文件, 有很多更智能的图形化工具可以使用。</p><p>命令格式</p><pre class="language-bash" data-language="bash"><code class="language-bash">jhat dump文件</code></pre><p>通过上面的命令, 当显示 “Server is Ready” 的提示后, 通过输入 localhost:7000 就能查看分析信息。</p><h2 id="1-6-jstack-Stack-Trace-for-Java-Java-堆栈跟踪工具"><a href="#1-6-jstack-Stack-Trace-for-Java-Java-堆栈跟踪工具" class="headerlink" title="1.6 jstack (Stack Trace for Java) - Java 堆栈跟踪工具"></a>1.6 jstack (Stack Trace for Java) - Java 堆栈跟踪工具</h2><p>用于生成虚拟机当前时刻的线程快照 (一般称为 threaddump 或者 javacore 文件)。<br>线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合, 生成线程快照的 目的通常是定位线程出现长时间停顿的原因, 如线程间死锁, 死循环, 请求外部资源导致的长时间挂起等, 都是导致线程长时间停顿的常见原因。<br>线程出现停顿时通过 jstack 来查看各个线程的调用堆栈, 就可以获知没有响应的线程到底在后台做些什么事情, 或者等待着什么资源。</p><p>命令格式</p><pre class="language-bash" data-language="bash"><code class="language-bash">jstack -<span class="token operator">&lt;</span>options<span class="token operator">></span> vmid</code></pre><p>options 列表</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-F</td><td align="center">当正常的输出请求无响应时, 强制输出线程堆栈信息</td></tr><tr><td align="center">-l</td><td align="center">除堆栈信息外, 显示锁的附加信息</td></tr><tr><td align="center">-m</td><td align="center">如果调用到了本地方法的话, 输出 C&#x2F;C++ 的堆栈</td></tr></tbody></table><p>在 $JAVA_HOME&#x2F;bin 下除了列出的这几个常用的工具外, 还有许多有用的工具, 如 javap 字节码分析工具, javac java 类文件转字节码文件等。</p><h2 id="2-JVM-可视化工具"><a href="#2-JVM-可视化工具" class="headerlink" title="2 JVM 可视化工具"></a>2 JVM 可视化工具</h2><h3 id="2-1-JHSDB-JDK-自带的工具"><a href="#2-1-JHSDB-JDK-自带的工具" class="headerlink" title="2.1 JHSDB - JDK 自带的工具"></a>2.1 JHSDB - JDK 自带的工具</h3><p>JHSDB 是一款基于服务性代理 (Serviceability Agent, SA) 实现的进程外调试工具。</p><p>服务性代理是 HotSpot 虚拟机中一组用于映射Java虚拟机运行信息的, 主要基于 Java 语言 (含少量 JNI 代码) 实现的 API 集合。<br>服务性代理以 HotSpot 内部的数据结构为参照物进行设计, 把这些 C++ 的数据抽象出 Java 模型对象, 相当于 HotSpot 的 C++ 代码的一个镜像。</p><p>通过服务性代理的 API, 可以在一个独立的 Java 虚拟机的进程里分析其他 HotSpot 虚拟机的内部数据, 或者从 HotSpot 虚拟机进程内存中 dump 出来的转储快照里还原出它的运行状态细节。</p><p>基于 JHSDB 的特点一般用于分析处于静止不变的程序, 比如卡在 debug 或者 dump 文件。</p><p>使用 JHSDB 的步骤</p><blockquote><ol><li>当前你有一个卡在 debug 的程序或者一份 dump 文件</li><li>启动 JHSDB, JDK8 中通过 <strong>java -cp $JAVA_HOME&#x2F;lib&#x2F;sa-jdi.jar sun.jvm.hotspot.HSDB</strong>, 启动 JHSDB 的图形化界面, 通过<br>  <strong>java -cp $JAVA_HOME&#x2F;lib&#x2F;sa-jdi.jar sun.jvm.hotspot.CLHSDB</strong> 启动 JHSDB 的命令行界面, JDK9 及以后可以转到 $JAVA_HOME&#x2F;bin,<br>  执行 <strong>jhsdb hsdb</strong> (本人在 Mac 一直失败, 貌似 JDK8 在 Mac 上有 bug, 可以尝试升级 JDK 的版本, 在 Window10 成功关联上了)</li><li>获取当前执行的中的 Java 程序的进程 ID</li><li>打开图形化界面, 左上角的 File, 选择关联进程 ID &#x2F; dump 文件 &#x2F; 服务地址</li></ol></blockquote><p>后面就是分析相关的操作了</p><p>操作可以看<a href="https://www.iteye.com/blog/rednaxelafx-1847971">这里</a></p><h3 id="2-2-JConsole"><a href="#2-2-JConsole" class="headerlink" title="2.2 JConsole"></a>2.2 JConsole</h3><p>JConsole (Java Monitoring and Management Console) 是一款基于 JMX (Java Management Extensions) 的可视化监视,管理工具。它的主要<br>功能是通过 JMX 的 MBean (Managed Bean) 对系统进行信息收集和参数动态调整。</p><p>在 $JAVA_HOME&#x2F;bin 下面有一个 jconsole 的脚本, 直接执行它, 就会出现一个图形化界面, 在首页选中自己的进程, 就能进入分析。</p><h3 id="2-3-VisualVM"><a href="#2-3-VisualVM" class="headerlink" title="2.3 VisualVM"></a>2.3 VisualVM</h3><p>VisualVM (All-in-One Java Troubleshooting Tool) 是功能最强大的运行监视和故障处理程序之一, 着它除了常规的运行监视, 故障处理外，还将提<br>供其他方面的能力, 譬如性能分析 (Profiling)。</p><p>在 $JAVA_HOME&#x2F;bin 下面有一个 jvisualvm 的脚本, 直接执行它, 就会出现一个图形化界面, 在左侧的应用程序选中自己的程序即可。</p><p>VisualVM 可以做到:</p><blockquote><ol><li>显示虚拟机进程以及进程的配置, 环境信息 (jps, jinfo)</li><li>监视应用程序的处理器, 垃圾收集, 堆, 方法区以及线程的信息 (jstat, jstack)</li><li>dump 以及分析堆转储快照 (jmap, jhat)</li><li>方法级的程序运行性能分析, 找出被调用最多, 运行时间最长的方法</li><li>离线程序快照: 收集程序的运行时配置, 线程 dump, 内存 dump 等信息建立一个快照, 可以将快照发送开发者处进行 Bug 反馈</li><li>VisualVM 只提供了基础的功能, 同时支持大量的插件, 通过安装插件, 可以带来的无限可能性</li></ol></blockquote><h3 id="2-4-商业版工具"><a href="#2-4-商业版工具" class="headerlink" title="2.4 商业版工具"></a>2.4 商业版工具</h3><p>Oracle 公司还开辟过带商业技术支持的工具</p><blockquote><ol><li>用于企业 JRE 定制管理的 AMC (Java Advanced Management Console) 控制台</li><li>系统跟踪的 JUT (Java Usage Tracker)</li><li>用于持续收集数据的飞行记录仪 JFR (Java Flight Recorder)</li><li>用于监控 Java 虚拟机的JMC (Java Mission Control)</li></ol></blockquote><h2 id="3-第三方工具"><a href="#3-第三方工具" class="headerlink" title="3 第三方工具"></a>3 第三方工具</h2><p>通过 jmap 生成的 dump 文件, 除了可以通过 jhat 来分析外, 还可以通过其他的工具来分析, 如下面的这些工具</p><blockquote><ol><li>MAT</li><li>JProfiler</li><li>第三方的网站, 如 <a href="https://account.heapdump.cn/">HeapDump</a></li></ol></blockquote><p>通过配置 JVM 启动参数生成的 GC 文件分析工具</p><blockquote><ol><li>GCViewer</li><li>第三方的网站, 如 <a href="https://gceasy.ycrash.cn/">Ycrash GCeasy</a></li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM 垃圾回收</title>
      <link href="/article/2021/3341463376/"/>
      <url>/article/2021/3341463376/</url>
      
        <content type="html"><![CDATA[<h2 id="1-垃圾回收的理论依据"><a href="#1-垃圾回收的理论依据" class="headerlink" title="1 垃圾回收的理论依据"></a>1 垃圾回收的理论依据</h2><p>当前大部分的垃圾收集器都遵循着 “分代收集” (Generational Collection) 的理论进行设计的, 建立在 2 个分代假设之上</p><blockquote><ol><li>弱分代假说 (Weak Generational Hypothesis): 绝大多数对象都是朝生夕灭的</li><li>强分代假说 (Strong Generational Hypothesis): 熬过越多次垃圾收集过程的对象就越难以消亡</li></ol></blockquote><p>根据这 2 个假说, 收集器将 Java 堆划分出不同的区域, 然后将回收对象依据其年龄 (年龄即对象熬过垃圾收集过程的次数) 分配到不同的区域之中存储。<br>现在主流的 Java 虚拟机实现通常将 Java 堆分为 2 个区域:</p><blockquote><ol><li>新生代 (Young Generation)</li><li>老年代 (Old Generation)</li></ol></blockquote><p>分代收集存在的一个问题: 新生代的对象有可能被老年代所引用, 为了确保完整的存活对象, 除了在固定的 GC Roots 之外, 还需要额外遍历整个老年代中所有<br>对象来确保可达性分析结果的正确性 (同样, 老年代也可能被新生代所引用)。基于这个问题, 有了第三条假设</p><blockquote><ol start="3"><li>跨代引用假说 (Intergenerational Reference Hypothesis): 跨代引用相对于同代引用来说仅占极少数</li></ol></blockquote><p>依据这条假说, 我们就不应再为了少量的跨代引用去扫描整个老年代, 也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用, 只需在新生代上建立<br>一个全局的数据结构 (该结构被称为 “记忆集”, Remembered Set), 这个结构把老年代划分成若干小块, 标识出老年代的哪一块内存会存在跨代引用。此后<br>当发生 Minor GC 时, 只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描。虽然这种方法需要在对象改变引用关系时 (如将自己或者某<br>个属性赋值维护), 记录数据的正确性, 这会增加一些运行时的开销, 但比起收集时扫描整个老年代来说仍然是划算的。</p><h3 id="1-1-记忆集-Remembered-Set"><a href="#1-1-记忆集-Remembered-Set" class="headerlink" title="1.1 记忆集 (Remembered Set)"></a>1.1 记忆集 (Remembered Set)</h3><p>记忆集是一种 “抽象” 的数据结构, 只定义了记忆集的行为意图, 并没有定义其行为的具体实现。<br>而现在常用的的具体实现为 “卡表”(Card Table), 2 者的关系类似于 Map 和 HashMap 的关系。</p><p>卡表最简单的形式可以只是一个字节数组。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token constant">CARD_TABLE</span> <span class="token punctuation">[</span><span class="token keyword">this</span> address <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>字节数组 CARD_TABLE 的每一个元素都对应着其标识的内存区域中一块特定大小的内存块, 这个内存块被称作 “卡页”(Card Page)。<br>一般来说, 卡页大小都是以 2 的 N 次幂的字节数, HotSpot 默认为 512 字节。<br>如果卡表标识内存区域的起始地址是 0x0000 的话, 数组 CARD_TABLE 的第 0, 1, 2 号元素分别对应了地址范围为<br>0x0000～0x01FF, 0x0200～0x03FF, 0x0400～0x05FF 的卡页内存块。</p><p>一个卡页的内存中通常包含不止一个对象, 只要卡页内有一个或更多对象的字段存在着跨代指针, 那就将对应卡表的数组元素的值标识为 1, 称为这个元素变<br>脏 (Dirty), 没有则标识为 0。</p><p>在垃圾收集发生时, 只要筛选出卡表中变脏的元素, 就能轻易得出哪些卡页内存块中包含跨代指针, 把它们加入 GC Roots 中一并扫描。<br>注意这里是把这个区域内的所有对象都加入的。</p><h4 id="1-1-1-记忆集的维护"><a href="#1-1-1-记忆集的维护" class="headerlink" title="1.1.1 记忆集的维护"></a>1.1.1 记忆集的维护</h4><p>在 HotSpot 虚拟机里是通过写屏障 (Write Barrier) 技术维护卡表状态的 (这里的写屏障不是解决并发的读写屏障), 看作在虚拟机层面对 “引用类型字<br>段赋值” 这个动作的 AOP 切面, 在引用对象赋值时会产生一个环形 (Around) 通知, 供程序执行额外的动作, 也就是说赋值的前后都在写屏障的覆盖范畴内。<br>在赋值前的部分的写屏障叫作写前屏障 (Pre-Write Barrier), 在赋值后的则叫作写后屏障 (Post-Write Barrier)。<br>HotSpot 虚拟机只用到了写后屏障。</p><pre class="language-C" data-language="C"><code class="language-C">void oop_field_store(oop* field, oop new_value) &#123;     &#x2F;&#x2F; 引用字段赋值操作     *field &#x3D; new_value;         &#x2F;&#x2F; 写后屏障, 在这里完成卡表状态更新     post_write_barrier(field, new_value); &#125;</code></pre><p>通过写屏障后, 虚拟机就可以为所有赋值操作生成相应的指令。<br>但是每个引用类型的赋值都会触发更新卡表操作, 无论更新的是不是老年代对新生代对象的引用, 都会产生额外的开销。<br>不过这个开销与 Minor GC 时扫描整个老年代的代价相比还是低得多的。</p><p>除了写屏障的开销外, 卡表在高并发场景下还面临着 “伪共享” (False Sharing) 问题。<br>什么是伪共享可以看<a href="https://blog.csdn.net/z735640642/article/details/84554706">这里</a>。</p><p>为了避免伪共享问题, 一种简单的解决方案是不采用无条件的写屏障, 而是先检查卡表标记, 只有当该卡表元素未被标记过时才将其标记为变脏, 即将卡表更新的<br>逻辑变为以下代码所示:</p><pre class="language-C" data-language="C"><code class="language-C">if (CARD_TABLE [this address &gt;&gt; 9] !&#x3D; 0)     CARD_TABLE [this address &gt;&gt; 9] &#x3D; 0;</code></pre><p>在 JDK 7 之后, HotSpot 虚拟机增加了一个新的参数 -XX: +UseCondCardMark, 用来决定是否开启卡表更新的条件判断。<br>开启会增加一次额外判断的开销, 但能够避免伪共享问题, 两者各有性能损耗, 是否打开要根据应用实际运行情况来进行测试权衡。</p><h2 id="2-常用的垃圾回收算法"><a href="#2-常用的垃圾回收算法" class="headerlink" title="2 常用的垃圾回收算法"></a>2 常用的垃圾回收算法</h2><h3 id="2-1-标记-清除算法"><a href="#2-1-标记-清除算法" class="headerlink" title="2.1 标记-清除算法"></a>2.1 标记-清除算法</h3><p>先标记所有需要回收的对象, 标记完成后, 统一回收所有标记的对象 (也可以反过来, 标记存活的对象, 回收未标记的对象)。<br>标记的依据通过可达性分析法。</p><p>存在 2 个问题:</p><blockquote><ol><li>执行效率不稳定, 标记和清除的过程会随着 Java 堆中的对象增多而变长</li><li>内存空间碎片化, 回收完成后, 会产生大量不连续的内存碎片, 空间碎片太多的话, 可能会导致后续大对象的分配找不到足够的连续内存</li></ol></blockquote><h3 id="2-2-标记-复制算法"><a href="#2-2-标记-复制算法" class="headerlink" title="2.2 标记-复制算法"></a>2.2 标记-复制算法</h3><p>为了解决<strong>标记-清除算法</strong> 面对大量可回收对象时执行效率低的问题。</p><p>将可用内存按容量划分为大小相等的两块, 每次只使用其中的一块。<br>当这一块的内存用完了, 就将还存活着的对象复制到另外一块上面, 然后再把已使用过的内存空间一次清理掉。</p><p>如果内存中多数对象都是存活的, 这种算法将会产生大量的内存间复制的开销, 但对于多数对象都是可回收的情况, 算法需要复制的就是占少数的存活对象,<br>而且每次都是针对整个半区进行内存回收, 分配内存时也就不用考虑有空间碎片的复杂情况, 只要移动堆顶指针, 按顺序分配即可。</p><p>这样实现简单, 运行高效。<br>最大的缺点: 是将可用内存缩小为了原来的一半, 空间浪费未免太多了。</p><p>针对空间浪费大的问题, 有一种更优化的半区复制分代策略 – Appel 式回收 (HotSpot 采用的就是这种策略)。</p><p>Appel 式回收</p><ul><li>将新生代划分为一块较大的 Eden 区域 + 两块较小的 Survivor 空间</li><li>每次分配内存只使用 Eden 和其中一块 Survivor</li><li>发生垃圾回收时, 将 Eden 和 Survivor 中存活的对象一次性复制到另外一块 Survivor 上, 然后把 Eden 和 已使用过的那块 Survivor 空间清理掉</li></ul><p>HotSpot 默认 Eden 和 Survivor 的比例是 8:1:1, 也就是每次新生代中可使用的内存占总量的 90%。</p><p>当然, 可能一次垃圾回收时, 10 % 的 Survivor 的区域无法存放存活的对象了, Appel 式回收会通过<strong>分配担保 (Handle Promotion)</strong>, 将这些对象直接放入老年代。</p><p>当一个对象进入到 Survivor 时, 他的年龄将会 + 1, 后续在 2 个 Survivor 区来回拷贝时, 每拷贝一次, 年龄就 + 1, 当年龄达到了 15 (HotSpot 默认的配置),<br>这个对象就会被移入到老年代。</p><h3 id="2-3-标记-整理算法"><a href="#2-3-标记-整理算法" class="headerlink" title="2.3 标记-整理算法"></a>2.3 标记-整理算法</h3><p><strong>标记-复制算法</strong>在对象存活率较高时就要进行较多的复制操作, 效率将会降低。<br>同时一定会有空间的浪费, 所以老年代一般都不会选用这种算法。</p><p>针对老年代的特点, 有一种针对性的<strong>标记-整理算法</strong>, 同样的先通过标记, 确定对象是否可回收, 然后让所有存活的对象都向内存空间的一端移动, 然后清<br>理掉边界以外的内存。这种移动式的算法是一项优缺点并存的风险决策。</p><p>如果移动存活对象, 尤其是在老年代这种每次回收都有大量对象存活区域, 移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作, 而且这种<br>对象移动操作必须全程暂停用户应用程序才能进行。</p><p>如果不移动对象, 则会有空间碎片, 这个问题就只能依赖更为复杂的内存分配器和内存访问器来解决。<br>基于以上两点, 是否移动对象都存在弊端, 移动则内存回收时会更复杂, 不移动则内存分配时会更复杂。</p><p>但是从垃圾收集的停顿时间来看, 不移动对象停顿时间会更短, 甚至可以不需要停顿,<br>但是从整个程序的性能来看, 移动对象会更划算 (因为内存分配和访问相比垃圾收集频率要高得多, 这部分的耗时增加, 最终可能导致性能的下降)。</p><p>HotSpot 里面的 Parallel Scavenge 收集器是基于<strong>标记-整理算法</strong>的, 而 CMS 收集器是基于<strong>标记-清除</strong> + <strong>标记-清除算法</strong> 2 种算法共同协作。</p><p>CMS 的实现: 平时多数时间都采用<strong>标记-清除</strong>算法, 暂时容忍内存碎片的存在, 直到内存空间的碎片化程度已经大到影响对象分配时, 再采用<strong>标记-整理</strong>算法收集<br>一次, 以获得规整的内存空间。</p><h2 id="3-经典垃圾收集器"><a href="#3-经典垃圾收集器" class="headerlink" title="3 经典垃圾收集器"></a>3 经典垃圾收集器</h2><p><img src="https://pic.imgdb.cn/item/65e6fbad9f345e8d035488d2.png" alt="Alt &#39;HotSpot 常用的收集器&#39;"></p><p>如图, 展示了 7 款 HotSpot 常用的收集器, 收集器所处的区域, 表示了他属于哪个分代的收集器。<br>连线表示 2 个收集器可以搭配使用 (注: JDK8 将 Serial + CMS 和 ParNew + Serial Old 声明为废弃, 并在 JDK9 中完全取消了这 2 个组合的支持)。</p><h3 id="3-1-Serial-串行收集器-复制算法"><a href="#3-1-Serial-串行收集器-复制算法" class="headerlink" title="3.1 Serial 串行收集器-复制算法"></a>3.1 Serial 串行收集器-复制算法</h3><p>Serial 是一个单线程工作的收集器。<br>它的 “单线程” 的意义不是指只会使用一个处理器或一条收集线程去完成垃圾收集工作, 而是强调在它进行垃圾收集时, 必须暂停其他所有工作线程, 直到它收集结束。</p><p>流程大体是这样的:<br><img src="https://pic.imgdb.cn/item/65e6fbb19f345e8d035493bc.png" alt="Alt &#39;Serial 收集器工作过程&#39;"></p><p>优点: 简单高效, 内存消耗 (Memory Footprint) 最小的。在 JVM 的 Client 模式下表现优异 (Client 模式下内存较小, CPU 较少, 能减少许多线程交互的开销)。<br>缺点: 回收工作需要 Stop The World, 不适用虚拟机 Server 模式 (Server 模式下内存较大, CPU 较多, 导致回收工作停顿时间过长)。  </p><h3 id="3-2-ParNew-并行收集器-复制算法"><a href="#3-2-ParNew-并行收集器-复制算法" class="headerlink" title="3.2 ParNew 并行收集器-复制算法"></a>3.2 ParNew 并行收集器-复制算法</h3><p>ParNew 收集器实质上是 Serial 收集器的多线程并行版本, 除了同时使用多条线程进行垃圾收集之外, 其他的行为, 调优参数都和 Serial 一样。</p><p>流程大体是这样的:<br><img src="https://pic.imgdb.cn/item/65e6fbb39f345e8d035498fc.png" alt="Alt &#39;ParNew 收集器工作过程&#39;"></p><p>优点: 多线程工作, 效率更高<br>缺点: 回收工作需要 Stop The World, 只能和 CMS 收集器搭配使用。</p><h3 id="3-3-Parallel-Scavenge-并行收集器-复制算法"><a href="#3-3-Parallel-Scavenge-并行收集器-复制算法" class="headerlink" title="3.3 Parallel Scavenge 并行收集器-复制算法"></a>3.3 Parallel Scavenge 并行收集器-复制算法</h3><p>Parallel Scavenge 又称为吞吐量优先收集器, 是 Java1.8 默认的收集器, 特点是并行的多线程回收, 以吞吐量优先。</p><p>流程大体是这样的:<br><img src="https://pic.imgdb.cn/item/65e6fbb59f345e8d03549ee7.png" alt="Alt &#39;Parallel Scavenge 收集器工作过程&#39;"></p><p>Parallel Scavenge 收集器的关注点与其他收集器不同, CMS 等收集器的关注点是尽可能地缩短垃圾收集时, 用户线程的停顿时间 (响应时间优先)。<br>Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量 (Throughput) (吞吐量优先)。</p><p>吞吐量 &#x3D; 运行用户代码时间 &#x2F; 运行用户代码时间 + 垃圾收集时间。</p><p>响应时间优先: 注重的是垃圾回收时 STW 的时间最短<br>吞吐量优先: 让<strong>单位时间内</strong> STW 的时间最短  </p><p>个人认为: 就是每隔多少时间就进行一次收集。可以通过<br><strong>-XX：MaxGCPauseMillis</strong> 设置最大垃圾收集停顿时间<br><strong>-XX：MaxGCPauseMillis</strong> 设置垃圾收集时间占总时间的比例</p><p>优点: 多线程工作, 注重系统吞吐量和 CPU 资源, 自适应调节策略<br>缺点: 回收工作需要 Stop The World;</p><h3 id="3-4-Serial-Old-串行收集器-标记整理算法"><a href="#3-4-Serial-Old-串行收集器-标记整理算法" class="headerlink" title="3.4 Serial Old 串行收集器-标记整理算法"></a>3.4 Serial Old 串行收集器-标记整理算法</h3><p>Serial Old 是 Serial 收集器的老年代版本, 它同样是一个单线程收集器, 使用标记-整理算法。</p><p>主要是供 Client 模式下的 HotSpot 虚拟机使用。如果在 Server 模式下的话, 可能是</p><blockquote><ol><li>在 JDK5 及之前的版本中和 Parallel Scavenge 收集器搭配使用</li><li>作为 CMS 收集器发生失败时的后备预案, 在并发收集发生 Concurrent Mode Failure 时使用。</li></ol></blockquote><p>流程大体是这样的:<br><img src="https://pic.imgdb.cn/item/65e6fbb89f345e8d0354a5f7.png" alt="Alt &#39;Serial Old 收集器工作过程&#39;"></p><p>优点: 虚拟机 Client 模式下表现尚可, CMS 收集器的后备预案 (在并发收集 Concurrent Mode Failure 时使用)<br>缺点: 回收工作需要 Stop The World, 单线程</p><h3 id="3-5-Parallel-Old-并行收集器-标记整理算法"><a href="#3-5-Parallel-Old-并行收集器-标记整理算法" class="headerlink" title="3.5 Parallel Old 并行收集器-标记整理算法"></a>3.5 Parallel Old 并行收集器-标记整理算法</h3><p>Parallel Old  是 Parallel Scavenge 收集器的老年代版本, 支持多线程并发收集, 使用标记-整理算法。</p><p>在注重吞吐量或者处理器资源较为稀缺的场合, 都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器这个组合。</p><p>流程大体是这样的:<br><img src="https://pic.imgdb.cn/item/65e6fbbb9f345e8d0354ae95.png" alt="Alt &#39;Parallel Old 收集器工作过程&#39;"></p><p>优点: 在注重吞吐量或者处理器资源较为稀缺的场合, 都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器这个组合<br>缺点: 回收工作需要 Stop The World, 可搭配的新生代收集器仅有 Parallel Scavenge 收集器</p><h3 id="3-6-CMS-Concurrent-Mark-Sweep-并行收集器-标记清除算法"><a href="#3-6-CMS-Concurrent-Mark-Sweep-并行收集器-标记清除算法" class="headerlink" title="3.6 CMS(Concurrent Mark Sweep)  并行收集器-标记清除算法"></a>3.6 CMS(Concurrent Mark Sweep)  并行收集器-标记清除算法</h3><p>CMS 是一款以获取最短<strong>回收停顿时间</strong>为目标的收集器, 是真正意义上与用户线程并发运行的收集器。<br>它的运作过程分为 4 个步骤</p><blockquote><ol><li>初始标记 (CMS initial mark): 只是标记一下 GC Roots 能直接关联到的对象, 速度很快</li><li>并发标记 (CMS concurrent mark): 从 GC Roots 的直接关联对象开始遍历整个对象图的过程, 这个过程耗时较长但是不需要停顿用户线程</li><li>重新标记 (CMS remark): 修正并发标记期间, 因用户程序继续运作而导致标记产生变动的那一部分对象, 这个阶段停顿的时间会比初始标记阶段稍长一些, 但也比并<br>  发标记阶段的时间短</li><li>并发清除 (CMS concurrent sweep): 清理删除标记阶段判断的已经失效的对象, 由于不需要移动对象, 这个节点也是和用户线程同时并发的</li></ol></blockquote><p>初始标记和重新标记这 2 个步骤仍然需要 Stop The World。<br>而耗时最长的为并发标记和并发清除 2 个阶段, 都是与用户线程一起工作的。</p><p>流程大体是这样的:<br><img src="https://pic.imgdb.cn/item/65e6fbbf9f345e8d0354baca.png" alt="Alt &#39;CMS 收集器工作过程&#39;"></p><p>优点: 并发收集, 低停顿, 对于大概 4GB 到 6GB 以下的堆内存, CMS 一般处理的比较好<br>缺点:</p><blockquote><ol><li>CMS 收集器对 CPU 资源非常敏感<br> 会占用一定的 CPU 资源, 在并发标记 &#x2F; 清理的时候, 虽然不会导致用户线程停顿, 但标记 &#x2F; 清理工作是要占用一部分 CPU 资源的, 这导致吞吐量降低。<br> CMS 默认启动的回收线程数是 (CPU 数量 + 3) &#x2F; 4。</li></ol></blockquote><blockquote><ol start="2"><li>CMS 收集器无法处理浮动垃圾, 可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。<br> 由于在垃圾收集阶段用户线程还需要运行, 那也就还需要预留有足够的内存空间给用户线程使用, 因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全<br> 被填满了再进行收集, 需要预留一部分空间提供并发收集时的程序运作使用。要是 CMS 运行期间预留的内存无法满足程序需要, 就会出现一次<br> “Concurrent Mode Failure” 失败, 这时虚拟机将启动后备预案: 停止用户线程, 临时启用 Serial Old 收集器来重新进行老年代的垃圾收集, 这样停顿<br> 时间就很长了。</li></ol></blockquote><blockquote><ol start="3"><li>CMS 收集器会产生大量空间碎片<br> CMS 是一款基于 “标记-清除” 算法实现的收集器, 收集结束时会有大量空间碎片产生。 空间碎片过多时, 将会给大对象分配带来很大麻烦, 往往会出现老年代<br> 还有很多剩余空间, 但就是无法找到足够大的连续空间来分配当前对象, 而不得不提前触发一次 Full GC 的情况。</li></ol></blockquote><h3 id="3-7-G1-Garbage-First-并行收集器-标记整理算法"><a href="#3-7-G1-Garbage-First-并行收集器-标记整理算法" class="headerlink" title="3.7 G1 (Garbage First)  并行收集器-标记整理算法"></a>3.7 G1 (Garbage First)  并行收集器-标记整理算法</h3><p>G1 是一款主要<strong>面向服务端应用</strong>的垃圾收集器, 在 JDK9 中正式使用。</p><p>G1 开创的<strong>基于 Region 的堆内存布局</strong>使其能<strong>面向局部收集</strong>。<br>G1 虽然<strong>遵循分代收集理论</strong>设计, 但内部的堆内存的布局和别的收集器有明显不一样的。G1 把 Java 堆划分为多个大小相等的独立区域 (Region),<br>每个 Region 都可以根据需要, 扮演新生代的 Eden 空间, Survivor 空间或者老年代空间。</p><p>虽然 G1 仍保留了新生代和老年代的概念, 但新生代和老年代不再是固定的了, 它们都是一系列 Region (可以不连续) 的动态集合。<br>收集器能够对扮演不同角色的 Region 采用不同的策略去处理。</p><p>Region 中还有一类特殊的 Humongous 区域, 专门用来存储大对象。 G1 认为只要大小超过了一个 Region 容量一半的对象即可判定为大对象 (每个 Region 的大小可以通过 -XX：G1HeapRegionSize 进行配置, 大小在 1 - 32M, 同时必须是 2 的 N 次幂)。<br>对于那些超过了整个 Region 容量的超级大对象, 将会被存放在 N 个连续的 Humongous Region 之中, <strong>G1 的大多数行为都把 Humongous Region 作为老年代的一部分进行看待</strong>。</p><p>G1 将 Region 作为单次回收的最小单元, 即每次收集到的内存空间都是 Region 大小的整数倍, 这样可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。<br>G1 收集器会跟踪各个 Region 里面的垃圾堆积的 “价值” 大小, 价值即回收所获得的空间大小以及回收所需时间的经验值, 然后在后台维护一个优先级列表,<br>每次根据用户设定允许的收集停顿时间(通过参数 -XX: MaxGCPauseMillis 设置, 默认为 200 毫秒), 优先处理回收价值收益最大的那些 Region。</p><p>G1 收集器的运作过程大致分为 4 个步骤</p><blockquote><ol><li>初始标记 (Initial Marking)<br>仅仅只是标记一下 GC Roots 能直接关联到的对象, 并且修改 TAMS 指针的值, 让下一阶段用户线程并发运行时, 能正确地在可用的 Region 中分配新对象。<br>这个阶段需要停顿用户线程, 但耗时很短, 而且是借用进行 Minor GC 的时候同步完成的, 所以这个阶段实际没有额外的停顿。</li></ol></blockquote><blockquote><ol start="2"><li>并发标记 (Concurrent Marking)<br>从 GC Root 开始对堆中对象进行可达性分析, 递归扫描整个堆里的对象图, 找出要回收的对象, 这阶段耗时较长, 但可与用户程序并发执行。当对象图扫描完成以后, 还要重新处理 SATB 记录下的在并发时有引用变动的对象。</li></ol></blockquote><blockquote><ol start="3"><li>最终标记 (Final Marking)<br>对用户线程做另一个短暂的暂停, 用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录。</li></ol></blockquote><blockquote><ol start="4"><li>筛选回收 (Live Date Counting and Evacuation)<br>负责更新 Region 的统计数据), 对各个 Region 的回收价值和成本进行排序, 根据用户所期望的停顿时间来制定回收计划, 可以自由选择任意多个 Region 构成回收集, 然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中, 再清理掉整个旧 Region 的全部空间。这里的操作涉及存活对象的移动, 是必须暂停用户线程, 由多条收集器线程并行完成的。</li></ol></blockquote><p>从上面的 4 个步骤可以看出, G1 收集器除了<strong>并发标记</strong>外, 其余阶段都是要暂停用户线程的。也就是他并发纯粹地追求低延迟, G1 的目标是在延迟可控的情况下, 获得尽可能高的吞吐量。</p><p>回收阶段其实是可以设计成和用户线程并发的, 但是考虑到实现成本高, 而且 G1只是回收一部分的 Region, 停顿时间是用户可控的, 就没迫切的实现。<br>同时, 停顿用户线程能最大幅度地提高垃圾收集效率。</p><p>G1 的流程大体是这样的:<br><img src="https://pic.imgdb.cn/item/65e6fbc29f345e8d0354c44f.png" alt="Alt &#39;G1 收集器工作过程&#39;"></p><p>在 G1 收集器中, 可以通过设置不同的期望停顿时间, 使得其在不同应用场景中取得吞吐量和关注延迟之间的最佳平衡。<br>但是这个设置的 “期望值” 必须符合实际, 如果将时间设置到很低, 可以导致每次选出来的回收集只占很小的一部分, 收集器收集的速度逐渐跟不上分配器的分配速度,<br>导致垃圾逐渐堆积, 最终占满对引发 Full GC, 所以这个期望停顿时间一般设置为一两百毫秒或者两三百毫秒。</p><p>从 G1 开始, 最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的内存分配速率 (Allocation Rate), 而不追求一次把整个 Java 堆全部清理干净。<br>这样, 应用在分配, 同时收集器在收集, 只要收集的速度能跟得上对象分配的速度, 那一切就能运作得很完美。</p><p>G1 从整体来看是基于 “标记-整理” 算法实现的收集器, 但从局部 (两个 Region 之间) 上看又是基于 “标记-复制” 算法实现,<br>无论如何, 这两种算法都意味着 G1 运作期间不会产生内存空间碎片, 垃圾收集完成之后能提供规整的可用内存。<br>这种特性有利于程序长时间运行, 在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。</p><p>G1 和 CMS 比起来也是有缺点的, 比如用户线程停顿的时间更长一些, 复杂的卡表设置, 占用的堆内存更多, 执行过程中,<br>G1 为了垃圾回收产生的内存和运行的额外执行负载都比 CMS 高。</p><p>最终是使用 CMS 和 G1 还是需要具体的场景进行考虑。</p><h4 id="3-7-1-G1-存在的问题"><a href="#3-7-1-G1-存在的问题" class="headerlink" title="3.7.1 G1 存在的问题"></a>3.7.1 G1 存在的问题</h4><p><strong>跨 Region 引用对象如何处理</strong></p><p>使用记忆集, 避免全堆扫描。<br>G1 记忆集的特殊点: 每个 Region 都维护有自己的记忆集, 这些记忆集会记录下别的 Region 指向自己的指针, 并标记这些指针分别在哪些卡页的范围之内。<br>G1 的记忆集是一个哈希表的结构, key 是 Region 的起始地址, Value 是一个集合, 存储的元素是卡表的索引号。<br>基于此, G1 至少要消耗大约相当 Java 堆容量 10% 至 20% 的额外内存来维持收集器的工作。</p><p><strong>并发标记阶段如何保证收集线程和用户线程互不干扰的运行</strong></p><p>G1 收集器通过原始快照 (STAB) 算法实现的。同时 G1 为每个 Region 设计了 2 个名为 TAMS (Top at Mark Start) 的指针, 把 Region 中的一部分空间划分处理用用并发回收过程中的新对象分配。<br>并发回收时, 新分配的对象地址都必须要在这两个指针位置以上, G1 默认在这个位置上的对象是被隐式标记过的, 既默认存活的, 不纳入回收返回。<br>同样的, 在回收的时候, 回收速度赶不上内存分配的速度, 也会像 CMS 的 ”Concurrent Mode Failure”, 冻结用户线程的执行, 导致 Full GC, 而产生长时间的 STW。</p><p><strong>如果建立可靠的停掉预测模型</strong></p><p>用户通过 -XX：MaxGCPauseMillis 参数指定的停顿时间只意味着垃圾收集发生之前的期望值, G1 是如何做到满人用户的期望的?<br>G1 收集器的停顿预测模型是以衰减均值 (Decaying Average) 为理论基础来实现的, 在垃圾收集过程中, G1 收集器会记录每个 Region 的回收耗时,<br>每个 Region 记忆集里的脏卡数量等各个可测量的步骤花费的成本, 并分析得出平均值, 标准偏差, 置信度等统计信息, 然后通过这些信息预测现在开始回收的话,<br>由哪些 Region 组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益。</p><h2 id="4-低延迟垃圾收集器-Low-Latency-Garbage-Collector"><a href="#4-低延迟垃圾收集器-Low-Latency-Garbage-Collector" class="headerlink" title="4 低延迟垃圾收集器 (Low-Latency Garbage Collector)"></a>4 低延迟垃圾收集器 (Low-Latency Garbage Collector)</h2><p>衡量垃圾收集器的三项最重要的指标是: 内存占用 (Footprint), 吞吐量 (Throughput) 和延迟 (Latency), 三者共同构成了一个”不可能三角”,<br>一款优秀的收集器通常最多可以同时达到其中的 2 项。</p><p>随着计算机软硬件的发展, 现在延迟的重要性更受关注。<br>大内存的出现, 使我们可以容忍收集器多占一点点内存的, 吞吐量也会更高等, 但是这些软硬件的提升, 对延迟反而带来了负面效果。</p><h3 id="4-1-Shenandoah"><a href="#4-1-Shenandoah" class="headerlink" title="4.1 Shenandoah"></a>4.1 Shenandoah</h3><p>Shenandoah 是一款只有 OpenJDK 才会包含, 而 OracleJDK 没有的收集器。<br>Shenandoah 是 RedHat 公司独立发展的新型收集器项目, 项目的目标是实现一种能在任何堆内存大小下都可以把垃圾收集的停顿时间限制在 10 毫秒以内的垃圾收集器。</p><p>Shenandoah 和 G1 类似, 也是使用基于 Region 的堆内存布局), 使用大对象的 Humongours Region, 默认的回收策略也是有限处理回收价值最大的 Region。<br>初始标记, 并发标记等阶段的处理思路也是类似的。</p><p>但是在管理内存方面,  它与 G1 至少有三个明细的不同之处</p><blockquote><ol><li>支持并发的整理算法</li><li>不使用分代收集</li><li>摒弃 G1 中耗费大量内存和计算资源去维护的记忆集, 改用名为 “连接矩阵” (Connection Matrix) 的全局数据结构来记录跨 Region 的引用关系, 降低了处理跨代指针是记忆集维护消耗, 也降低了伪共享问题的发生概率</li></ol></blockquote><p>连接矩阵可以简单理解为一张二维表格, 如果 Region N 中有对象指向了 Region M 就在表格的 N 行 M 列打上一个标记。</p><p>Shenandoah 收集器的工作过程大致分为 9 个阶段</p><blockquote><ol><li>初始标记 (Initial Marking)<br>和 G1 一样, 首先标记与 GC Roots 直接关联的对象, 这个阶段同样需要暂停用户线程, 但是停顿的时间和堆大小无法, 只和 GC Roots 的数量相关。</li></ol></blockquote><blockquote><ol start="2"><li>并发标记 (Concurrent Marking)<br>和 G1 一样, 遍历对象图, 标记处全部可达的对象, 这个阶段是与用户线程一起并发的, 时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。</li></ol></blockquote><blockquote><ol start="3"><li>最终标记 (Final Marking)<br>与 G1 一样, 处理剩余的 SATB 扫描, 并在这个阶段统计出回收价值最高的 Region, 将这些 Region 构成一组回收集(Collection Set)。最终标记阶段也会有一小段短暂的停顿。</li></ol></blockquote><blockquote><ol start="4"><li>并发清理 (Concurrent Cleanup)<br>这个阶段用于清理那些整个区域内连一个存活对象都没有找到的 Region (这类 Region 被称为 Immediate Garbage Region)</li></ol></blockquote><blockquote><ol start="5"><li>并发回收 (Concurrent Evacuation)<br>这一步是 Shenandoah 和 HotSpot 中和其他收集器的核心差异。 在这个阶段, Shenandoah 把回收集中存活对象先复制一份到其他未被使用的 Region 之中。<br>这个并发的过程是通过读屏障和 “Brooks Pointers” 的转发指针来保证过程中, 用户线程的准备性。并发回收阶段运行的时间长短取决于回收集的大小</li></ol></blockquote><blockquote><ol start="6"><li>初始引用更新 (Initial Update Reference)<br>并发回收阶段复制对象结束后, 还需要吧堆中所有指向旧对象的引用修正到复制后的新地址, 这个操作成为引用更新。<br>引用更新的初始化阶段实际上并未做什么具体的处理, 设立这个阶段只是为了建立一个线程集合点, 确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务而已。<br>初始引用更新时间很短, 会产生一个非常短暂的停顿。</li></ol></blockquote><blockquote><ol start="7"><li>并发引用更新 (Concurrent Update Reference)<br>真正开始进行引用更新操作, 这个阶段是与用户线程一起并发的, 时间长短取决于内存中涉及的引用数量的多少。<br>并发引用更新与并发标记不同, 它不再需要沿着对象图来搜索, 只需要按照内存物理地址的顺序, 线性地搜索出引用类型, 把旧值改为新值即可。</li></ol></blockquote><blockquote><ol start="8"><li>最终引用更新 (Final Update Reference)<br>解决了堆中的引用更新后, 还要修正存在于 GC Roots 中的引用。<br>这个阶段是 Shenandoah 的最后一次停顿, 停顿时间只与 GC Roots 的数量相关。</li></ol></blockquote><blockquote><ol start="9"><li>并发清理 (Concurrent Cleanup)<br>经过并发回收和引用更新之后, 整个回收集中所有的 Region 已再无存活对象, 这些 Region 都变成 Immediate Garbage Regions 了,<br>最后再调用一次并发清理过程来回收这些 Region 的内存空间, 供以后新对象分配使用。</li></ol></blockquote><p>流程大体是这样的:<br><img src="https://pic.imgdb.cn/item/65e6fbd29f345e8d0354eea2.jpg" alt="Alt &#39;Shenandoah 收集器工作过程&#39;"></p><p><strong>Brooks Pointers 说明</strong><br>Brooks 是一个人名, 其在 1984 年提出了使用转发指针 (Forwarding Pointer&#x2F;Indirection Pointer) 来实现对象移动和用户程序并发的一种解决方案。</p><p>为了实现对象移动和用户程序并发进行的同时, 数据的准确, 旧的实现逻辑:<br>在被移动对象原有的内存上设置保护陷阱 (Memory Protection Trap), 一旦用户程序访问到归属于旧对象的内存空间就会产生自陷中断,<br>进入预设好的异常处理器中, 再由其中的逻辑代码把访问转发到复制后的新对象。这种操作如果没有操作系统的直接支持, 会导致用户态频繁切换到核心态。</p><p>而 Brooks 的解决方案:<br>在原有的对象布局结构的最前面统一增加一个新的引用字段, 在正常不处于并发移动的情况下, 指向自身。</p><p><img src="https://pic.imgdb.cn/item/65e6fbd49f345e8d0354f45d.png" alt="Alt &#39;BrooksPointer 对象的布局&#39;"></p><p>正常情况:<br>访问这个对象, 通过这个对象的引用字段, 找到真正的对象</p><p>对象移动时:<br>向将这个对象的引用字段修改为移动后的对象, 访问这个对象, 通过这个对象的引用字段, 就能找到移动后的对象</p><p>Brooks Pointers 和早期 JVM 的句柄定位类型。</p><h4 id="4-1-1-存在的问题"><a href="#4-1-1-存在的问题" class="headerlink" title="4.1.1 存在的问题"></a>4.1.1 存在的问题</h4><p>(1) 所有间接对象访问技术都有一个相同的缺点: 每一次对象访问都会带来一次额外的转向开销 (这个开销在系统层面已经降到很低了), 但是对象的频繁访问, 也会成为一笔不小的执行成本</p><p>(2) 转发指针的作用, 当对象拥有一份新的副本时, 只需要修改一处指针的值, 即旧对象上转发指针的引用位置, 使其执行新的对象, 就可以将所有对该对象的访问转发到新的副本上。<br>这种设计必定存在并发问题, 在读的情况基本没问题, 但是但出现收集线程和用户线程并发写入, 就必须保证写操作只能发生在新复制的对象上, 而不是写入到旧对象的内存。</p><p>假设</p><ol><li>收集器线程复制了新的对象副本</li><li>用户线程更新了对象的某个值</li><li>收集器线程更新转发指针的引用值为新副本地址</li></ol><p>让事件 2 在事件 1 和事件 3 之间发生的话, 将导致的结果就是用户线程对对象的变更发生在旧对象上, 新对象的值还是旧的。<br>Shenandoah 收集器通过 CAS 操作来保证并发是对象的访问正确性。</p><p>(3) 执行频率的问题<br>对于面向对象的编程语言来说, “对象的访问” 是一个很频繁的事情, 读写, 加锁等, 要覆盖全部对象的访问操作, Shennadoah 设置了读, 写屏障去拦截。</p><p>为了实现 “Brooks Pointer”, Shennandoah 在原有的写屏障内加入了额外的转发处理, 还使用了读屏障, 代码里面对象的读取斌率的对对象的写入频率高很多的操作, 大量的读屏障开销会是一个性能问题。</p><p>而这个问题, Shenandoah 计划在 JDK13 中使用基于引用访问屏障 (Load Reference Barrier) 替代内存屏障模型。即只拦截对象中数据类型为引用类型的读写操作, 而不去管原生数据类型等其他非引用字段的对象, 省去大量对原生类型、对象比较、对象加锁等场景中设置内存屏障所带来的销毁。</p><h3 id="4-2-ZGC"><a href="#4-2-ZGC" class="headerlink" title="4.2 ZGC"></a>4.2 ZGC</h3><p>ZGC 是一款在 JDK11 中加入的具有实验性的低延迟垃圾收集器。<br>其目标和 Shenandoah 相似: 在尽可能对吞吐量影响不大的前提下, 实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在 10 毫秒以内的低延迟。</p><p>ZGC 收集器是一款基于 Region 内存布局的, (暂时) 不设分代的,<br>使用了读屏障, 染色指针和内存多重映射等技术来实现可并发的标记-整理算法的, 以低延迟为首要目标的一款垃圾收集器。</p><h4 id="4-2-1-ZGC-的特点"><a href="#4-2-1-ZGC-的特点" class="headerlink" title="4.2.1 ZGC 的特点"></a>4.2.1 ZGC 的特点</h4><p>(1) 基于 Region 的堆内存布局</p><p>ZGC 依旧是基于 Region 的堆内存布局, 但是 ZGC 的 Region 具有动态性 – 动态创建和销毁, 动态的区域容量大小。<br>在 x64 (64 位系统) 硬件平台下, ZGC 的 Region 具有如下的容量</p><ul><li><p>小型 Region (Small Region): 容量固定为 2 MB, 用于放置小于 256 KB 的小对象</p></li><li><p>中型 Region (Medium Region): 容量固定为 32 MB, 用于放置大于 256 KB 但小于 4 mb 的对象</p></li><li><p>大型 Region (Large Region): 容量不固定, 可以动态变化, 但必须是 2MB 的整数倍, 用于放置 4 MB 或以上的大对象, 每个大型 Region 只会存放一个大对象,<br>单它的世界容量完全有可能小于中型 Region, 最小容量可低至 4 MB。大型 Region 在 ZGC 的实现中是不会被重分配 (重分配是 ZGC 的一种处理动作), 用于复制对象的收集器阶段, 因为复制一个大对象的代价很大。</p></li></ul><p>(2) 使用染色指针技术 (Colored Pointer) 和读屏障实现并发整理</p><p>染色指针是一种直接将少量额外的信息存储在指针上的技术。 这个技术怎么实现的呢?<br>在 64 位系统中, 理论可以访问的内存搞定 16EB (2 的 64 次幂)。 实际上, 基于需求 (用不到那么多内存), 性能 (地址越宽在做地址转换时, 需要的页表级数越多), 成本 (消耗更多晶体管) 等原因的考虑,<br>很多系统不会真正做到 16EB 的内存支持。</p><blockquote><ol><li>AMD64 架构, 只支持到 52 位 (4 PB) 的地址总线和 48 位 (256 TB) 的虚拟地址空间, 目前 64 位的硬件实际只支持到最大内存为 256 TB</li><li>64 位 Linux 则支持 47 位 (128 TB) 的进程虚拟地址空间和 46 位 (64 TB) 的物理地址空间</li><li>64 位 Windows 则支持 44 位 (16 TB) 的物理地址空间</li></ol></blockquote><p>在 Linux 64位指针中有 18 位不可用来寻址, 有用的只剩下 46 位, 也就是支持 64 TB 的内存。<br>而 ZGC 的染色指针技术将这个 46 位的指针宽度利用起来, 将其高 4 位提取出来存储四个标志信息。<br>通过这些标志位, 虚拟机可以直接从指针中看到其引用对象的三色标记, 是否进入了重分配既 (被移动过), 是否只能通过 finalize() 方法才能被访问到。<br>由于这些标志位进一步压缩了原本 46 位的地址空间, 也直接导致了 ZGC 能管理的内存空间不能超过 4 TB (2 的 42 次幂)。</p><p>64 位 Linux 中的指针情况<br><img src="https://pic.imgdb.cn/item/65e6fbd79f345e8d0354faf0.png" alt="Alt &#39;64 位 Linux 系统对象指针情况&#39;"></p><p>虽然染色指针有 4 TB 的内存限制, 不支持 32 位系统, 不支持指针压缩等约束, 但是其带来的收益非常可观。</p><blockquote><ol><li>染色指针可以使得一旦某个 Region 的存活对象被移走之后, 这个 Region 立即就能够被释放和重用, 而不必等待整个堆中的所有指向该 Region 的引用都被修正后才能清理,<br> 使得理论上只要还有 1 个空闲 Region, ZGC 就能完成收集。而 Shenandoah 需要等到引用更新阶段结束以后才能释放回收集中的 Region, 这意味着堆中几乎所有对象都存活的极端情况,<br> 需要 1∶1 复制对象到新 Region 的话, 就必须要有一半的空闲 Region 来完成收集</li><li>染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量, 设置内存屏障, 尤其是写屏障的目的通常是为了记录对象引用的变动情况。<br> 如果将这些信息直接维护在指针中, 显然就可以省去一些专门的记录操作。实际上, 到目前为止 ZGC 都并未使用任何写屏障,<br> 只使用了读屏障 (一部分是染色指针的功劳, 一部分是 ZGC 现在还不支持分代收集, 天然就没有跨代引用的问题) 。</li><li>染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记, 重定位过程相关的数据, 以便日后进一步提高性能。 现在 Linux 下的 64 位指针中<br> 还有前 18 位未使用, 虽然他们不能用来寻址, 却可以用来做其他的事, 如果开发了这 18 位, 就能腾出当前 46 位中占去的 4 位, 支持的堆内存也能达到 64 TB。</li></ol></blockquote><p>要顺利使用染色指针有一个必须解决的前置问题: Java 虚拟机作为一个普通的进程, 随意重新定义内存中的某些指针的其中几位, 操作系统&#x2F;处理器是否支持等。<br>程序代码最终都要转换为机器指令流交给处理器执行, 处理器是无法区分指针中哪部分是什么, 只会把整个指针当做一个内存地址来处理。<br>这个问题在 Solaris&#x2F;SPARC 平台很容易实现, SPARC 硬件层面就支持虚拟地址掩码, 设置后, 其机器指令直接忽略掉染色指针中标志位。<br>而 x86-64 平台采取了其他的措施 – 虚拟内存映射技术。</p><p>Linux&#x2F;x86-64 平台上, ZGC 使用了多重映射将多个虚拟内存地址映射到同一个物理内存地址上, 这是一种多对一的映射, 意味着 ZGC 在虚拟内存中看到的地址空间要比时间的堆内存容量来得更大。<br>把染色指针红的标志位看着是地址的分段符, 那只需要将这些不同的地址段都映射到同一个物理内存空间, 经过多重映射转换后, 就可以通过染色指针正常进行寻址了。</p><h4 id="4-2-2-ZGC-的运行过程"><a href="#4-2-2-ZGC-的运行过程" class="headerlink" title="4.2.2 ZGC 的运行过程"></a>4.2.2 ZGC 的运行过程</h4><p>ZGC 的运行过程大致可以分为 4 个阶段, 4 个阶段都是并发执行的, 仅 2 个阶段中间存在短暂的停顿小阶段。</p><p>简单的 4 个阶段流程如下:<br><img src="https://pic.imgdb.cn/item/65e6fbda9f345e8d03550548.png" alt="Alt &#39;ZGC 收集器工作过程-简单版本&#39;"></p><blockquote><ol><li>并发标记 (Concurrent Mark)<br>并发标记是遍历对象图做可达性分析的阶段, 前后也要经过类似于 G1 的初始标记, 最终标记 (尽管 ZGC 中的名字不叫这些) 的短暂停顿。</li></ol></blockquote><blockquote><ol start="2"><li>并发预备重分配 (Concurrent Prepare for Relocate)<br>要根据特定的查询条件统计得出本次收集过程要清理哪些Region, 将这些 Region 组成重分配集 (Relocation Set)。 ZGC 划分 Region 的目的并非为了<br>像 G1 那样做收益优先的增量回收, 相反, ZGC 每次回收都会扫描所有的 Region, 用范围更大的扫描成本换取省去 G1 中记忆集的维护成本。 因此, ZGC 的<br>重分配集只是决定了里面的存活对象会被重新复制到其他的 Region 中, 里面的 Region 会被释放, 而并不能说回收行为就只是针对这个集合里面的 Region<br>进行, 因为标记过程是针对全堆的。 (JDK12 的 ZGC 开始支持的类卸载以及弱引用的处理, 也是在这个阶段完成的)</li></ol></blockquote><blockquote><ol start="3"><li>并发重分配 (Concurrent Relocate)<br>重分配是 ZGC 执行过程中的核心阶段, 这个过程要把重分配集中的存活对象复制到新的 Region 上, 并为重分配集中的每个 Region 维护一个转发表 (Forward Table),<br>记录从旧对象到新对象的转向关系。得益于染色指针的支持, ZGC 收集器能仅从引用上就明确得知一个对象是否处于重分配集之中, 如果用户线程此时并发访问了<br>位于重分配集中的对象, 这次访问将会被预置的内存屏障所截获, 然后立即根据 Region 上的转发表记录将访问转发到新复制的对象上, 并同时修正更新该引用<br>的值, 使其直接指向新对象, ZGC 将这种行为称为指针的 “自愈” (Self-Healing) 能力。</li></ol></blockquote><p>这样做的好处是只有第一次访问旧对象会陷入转发, 也就是只慢一次, 对比 Shenandoah 的 Brooks 转发指针, 那是每次对象访问都必须付出的固定开销, 简<br>单地说就是每次都慢,  因此 ZGC 对用户程序的运行时负载要比 Shenandoah 来得更低一些。</p><p>另外一个直接的好处是由于染色指针的存在, 一旦重分配集中某个 Region 的存活对象都复制完毕后, 这个 Region 就可以立即释放用于新对象的分配 (但是<br>转发表还得留着不能释放掉), 哪怕堆中还有很多指向这个对象的未更新指针也没有关系, 这些旧指针一旦被使用, 它们都是可以自愈的。</p><blockquote><ol start="4"><li>并发重映射 (Concurrent Remap)<br>重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用, 但是 ZGC 的并发重映射并不是一个必须要 “迫切” 去完成的任务。因为前面说过, 即使是旧<br>引用, 它也是可以自愈的, 最多只是第一次使用时多一次转发和修正操作。重映射清理这些旧引用的主要目的是为了不变慢 (还有清理结束后可以释放转发表<br>这样的附带收益), 所以说这并不是很”迫切”。 因此, ZGC 很巧妙地把并发重映射阶段要做的工作, 合并到了下一次垃圾收集循环中的并发标记阶段里去完成,<br>反正它们都是要遍历所有对象的, 这样合并就节省了一次遍历对象图的开销。一旦所有指针都被修正之后, 原来记录新旧对象关系的转发表就可以释放掉了。</li></ol></blockquote><p>简单地了解了过程后, 我们分析一下为什么需要 2 个标记位?<br>首先 Mark0, Mark1 和 Remapped 三个任何时候只会有 1 个为 1。</p><p>假设标记了两个对象 ObjA 和 ObjB, 在第一次回收后, 地址视图为 M0, 都是活跃对象。在转移阶段, ZGC 是按照页面进行部分内存垃圾回收的, 也就是说<br>当对象所在的页面需要回收时, 页面里面的对象需要被转移, 如果页面不需要转移, 页面里面的对象也就不需要转移。</p><p>假设 ObjA 所在的页面被回收, ObjB 所在的页面在这一次垃圾回收中不会被回收。<br>ObjA 被转移后, 它的地址视图从 M0 调整为 Remapped, ObjB 不会被转移, ObjB 的地址视图仍然为 M0。</p><p>那么下一次垃圾回收标记阶段开始的时候, 存在两种地址视图的对象</p><blockquote><ol><li>地址视图为 Remapped 的对象, 说明该对象在并发转移阶段被转移或者被访问过</li><li>地址视图为 M0 的对象, 说明该对象在前一次垃圾回收的标记阶段已经被标记</li></ol></blockquote><p><strong>如果本次垃圾回收标记阶段仍然使用 M0 这个地址视图, 那么就不能区分出对象是活跃的, 还是上一次垃圾回收标记过的</strong></p><p>所以新标记阶段使用了另外一个地址视图 M1, 则标记结束后所有活跃对象的地址视图都为 M1。<br>此时在这 3 个地址视图代表的含义是</p><blockquote><ol><li>M1: 本次垃圾回收中识别的活跃对象</li><li>M0: 前一次垃圾回收的标记阶段被标记过的活跃对象, 对象在转移阶段未被转移, 但是在本次垃圾回收中被识别为不活跃对象</li><li>Remapped: 前一次垃圾回收的转移阶段发生转移的对象或者是被应用程序线程访问的对象, 但是在本次垃圾回收中被识别为不活跃对象</li></ol></blockquote><p>如果将上面的 4 个步骤扩充出来这是这样的<br><img src="https://pic.imgdb.cn/item/65e6fbdd9f345e8d03550c5e.webp" alt="Alt &#39;ZGC 收集器具体工作流程图&#39;"></p><p>过程是这样的<br><img src="https://pic.imgdb.cn/item/65e6fbe09f345e8d0355154b.webp" alt="Alt &#39;ZGC 收集器具体工作流程-具体版本&#39;"></p><p>ZGC 提供了 2 个参数 ParallelGCThreads 和 ConcGCThreads, 分别用于 STW 并行时候的线程数和并发阶段的线程数。<br>不过 ConcGCThreads 数量需要注意, 因为此阶段是和应用线程并发, 如果线程数过多会影响应用线程。</p><p>ZGC 没有使用记忆集, 它甚至连分代都没有, 减少各种中间结构的维护, 没有使用写屏障, 减少对用户线程的运行负担等。 这些权衡必定要有优有劣,<br>ZGC 的这种权衡也限制了它能承受的对象分配速率不会太高。 假设 ZGC 准备要对一个很大的堆做一次完整的并发收集, 在这段时间里面, 由于应用的对象分配<br>速率很高, 将创造大量的新对象, 这些新对象很难进入当次收集的标记范围, 通常就只能全部当作存活对象来看待 – 尽管其中绝大部分对象都是朝生夕灭的,<br>这就产生了大量的浮动垃圾。 这种情况如果持续位置, 那么就会导致堆的可用空间越来越小。 目前唯一的解决方法就是增大堆空间, 获得更多的执行时间。</p><p>ZGC 还支持 “MUMA-Aware (Non-Uniform Memory Access, 非统一内存访问架构)” 的内存分配。<br>在 NUMA 架构下, ZGC 收集器会优先尝试在请求线程当前所处的处理器的本地内存上分配对象, 以保证高效内存访问。</p><h2 id="5-垃圾收集器的选择"><a href="#5-垃圾收集器的选择" class="headerlink" title="5 垃圾收集器的选择"></a>5 垃圾收集器的选择</h2><p><strong>(1) 应用程序的主要关注点是什么</strong></p><p>数据分析, 科学计算类的任务, 目标是能尽快算出结果, 那吞吐量就是主要关注点。<br>SLA 应用, 那停顿时间直接影响服务质量, 严重的甚至会导致事务超时, 这样延迟就是主要关注点。<br>客户端应用或者嵌入式应用, 那垃圾收集的内存占用则是不可忽视的。</p><p><strong>(2) 运行应用的基础设施如何</strong></p><p>可以从硬件规格, 系统架构, 处理器数量, 分配的内存大小等进行考虑</p><p><strong>(3) JDK 的发行商</strong></p><p>OpenJDK, OracleJDK, ZingJDK 等</p><h2 id="6-垃圾收集器日志"><a href="#6-垃圾收集器日志" class="headerlink" title="6 垃圾收集器日志"></a>6 垃圾收集器日志</h2><p>通过垃圾收集器的日志, 我们可以了解到每次 GC 前后的变化。 在 JDK9 之前, 每个收集器的日志输入参数不一定都一致, 但是<br>在 JDK9 后, HotSpot 所有功能的日志都可以通过 “-Xlog” 参数进行配置。</p><p>JDK9 之前<br>HotSpot 虚拟机提供了 -XX: +PrintGCDetails 这个收集器日志参数, 告诉虚拟机在发生垃圾收集行为时打印内存回收日志, 并且在进程退出的时候输出当前<br>的内存各区域分配情况</p><h2 id="7-JVM-的一些参数"><a href="#7-JVM-的一些参数" class="headerlink" title="7 JVM 的一些参数"></a>7 JVM 的一些参数</h2><p>HotSpot 虚拟机提供了 -XX: PretenureSizeThreshold 参数, 指定大于该设置值的对象直接在老年代分配, 这样做的目的就是避免在 Eden 区及两个 Survivor<br>区之间来回复制, 产生大量的内存复制操作。这个参数只对 Serial 和 ParNew 两款新生代收集器有效。</p><p>对象晋升老年代的年龄阈值, 可以通过参数 -XX: MaxTenuringThreshold 设置</p><p>-XX: HandlePromotionFailure 参数设置值是否允许担保失败</p><h2 id="8-参考"><a href="#8-参考" class="headerlink" title="8 参考"></a>8 参考</h2><p>《深入理解Java虚拟机》- 周志明<br><a href="https://blog.csdn.net/weixin_33913377/article/details/89179815">Java 12正式发布), 新特性解读！</a><br><a href="https://www.jianshu.com/p/664e4da05b2c">ZGC 详解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM 对象回收判断</title>
      <link href="/article/2021/197956318/"/>
      <url>/article/2021/197956318/</url>
      
        <content type="html"><![CDATA[<p>Java 对象回收判断是程序设计中至关重要的一环。在面向对象的编程中, 合理的对象回收策略直接影响着程序的性能和内存利用效率。<br>因此, 深入了解和准确判断 Java 对象的回收时机, 不仅可以优化程序的运行性能, 还能有效避免内存泄漏和资源浪费。<br>本文将简单的分析一下 JVM 中对象回收的判断机制, 了解一下整体的对象回收过程。</p><h2 id="1-对象回收算法"><a href="#1-对象回收算法" class="headerlink" title="1 对象回收算法"></a>1 对象回收算法</h2><p>在 JVM 中, 如果一个对象不被任何对象所引用的话, 那么这个对象就是可回收对象。<br>那么如何判断一个对象是可回收的话, 现在常用的有 2 种方式。</p><h3 id="1-1-引用计数算法-Reference-Counting"><a href="#1-1-引用计数算法-Reference-Counting" class="headerlink" title="1.1 引用计数算法 (Reference Counting)"></a>1.1 引用计数算法 (Reference Counting)</h3><p>在对象中添加一个引用计数器, 每当有一个地方引用它时, 计数器值就加一, 当引用断开时, 计数器值就减一。<br>任何时刻计数器为零的对象就是不可能再被使用的, 可以判定为可以回收的对象。</p><p>优点: 实现简单, 判定的效率也很高<br>缺点: 需要占用一下额外的内存空间, 很多复杂的情景没有考虑, 很难解决对象之间相互循环引用的问题。</p><p>比如: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Obj</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Obj</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span>attr <span class="token operator">=</span> b<span class="token punctuation">;</span>b<span class="token punctuation">.</span>attr <span class="token operator">=</span> a<span class="token punctuation">;</span></code></pre><p>上面 2 个对象实际已经没有作用了, 但是互相持有对方的引用, 导致他们的引用计数不为 0, 无法回收。<br>所以在主流的 Java 虚拟机中没有选用引用计数法作用内存管理的方式。</p><h3 id="1-2-可达性分析算法-Reachability-Analysis"><a href="#1-2-可达性分析算法-Reachability-Analysis" class="headerlink" title="1.2 可达性分析算法 (Reachability Analysis)"></a>1.2 可达性分析算法 (Reachability Analysis)</h3><p>先人为地将一批对象设为<strong>根节点</strong>, 作为起始节点, 从这些起始节点开始, 根据对象间的引用关系向下寻找其他的对象, 通过这些引用关系找到的对象就是<strong>需要的对象</strong>, 不可以回收。<br>同理如果某个对象跟这些根节点间没有任何直接或间接的引用关系, 则证明此对象是不可能再被使用, 可以回收的。</p><p><img src="https://pic.imgdb.cn/item/65e5c15e9f345e8d03a3cda2.png" alt="Alt &#39;可达性分析算法过程&#39;"></p><p>如图: 从 GC Root 出发, 可以依次找到 obj1, obj2, obj3, 所以它们属于不可回收对象,<br>而 obj4, obj5, obj6 之间虽然有引用关系, 但是没有和 GC Root 相同的链路, 所以为可回收对象。</p><h2 id="2-GC-Roots"><a href="#2-GC-Roots" class="headerlink" title="2 GC Roots"></a>2 GC Roots</h2><p>在上面可达性分析算法的介绍中, 整个算法的前提的需要先设定一批<strong>根节点</strong>, 而在 JVM 中这些根节点被称为 “GC Roots”。<br>官方的定义如下:</p><pre class="language-log" data-language="log"><code class="language-log">A pointer into the Java object heap from outside the heap<span class="token punctuation">.</span> These come up<span class="token punctuation">,</span> e<span class="token punctuation">.</span>g<span class="token punctuation">.</span><span class="token punctuation">,</span> from static fields of classes<span class="token punctuation">,</span> local references in activation frames<span class="token punctuation">,</span> etc<span class="token punctuation">.</span>从堆外部指向 Java 对象堆的指针。例如<span class="token operator">:</span> 类的静态字段<span class="token punctuation">,</span> 激活帧中的局部引用等。</code></pre><p>那么具体哪些对象是可以作为 “GC Roots” 呢?<br>网上的说法有很多 (暂时未找到官方的定义), 但是大体的方向是一样的, 在细节上有些不同而已。</p><p><strong>《深入理解java虚拟机》</strong> 中对 GC Roots 的分类如下:</p><ul><li>在虚拟机栈中引用的对象, 例如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</li><li>在方法区中类静态属性引用的对象, 例如 Java 类的引用类型静态变量</li><li>在方法区中常量引用的对象, 例如字符串常量池 (String Table) 里的引用</li><li>本地方法栈中 JNI (即 Native 方法) 引用的对象</li><li>Java 虚拟机内部的引用, 如基本数据类型对应的 Class 对象、常驻异常对象 (如 NullPointException 等)、系统类加载器</li><li>所有被同步锁持有的对象</li><li>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等</li></ul><p><strong>Java 语言里</strong>, 可作为 GC Roots 对象的包括如下几种</p><ul><li>虚拟机栈 (栈帧中的本地变量表) 引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI (即 Native 方法) 引用的对象</li></ul><p><strong>Eclipse Memory Analyzer (MAT)</strong> <a href="https://help.eclipse.org/latest/index.jsp?topic=/org.eclipse.mat.ui.help/concepts/gcroots.html&cp=37_2_3">文章</a> 中对 GC Roots 的分类如下:</p><pre class="language-log" data-language="log"><code class="language-log">System Class    Class loaded by bootstrap<span class="token operator">/</span>system class loader<span class="token punctuation">.</span> For example<span class="token punctuation">,</span> everything from the <span class="token domain constant">rt.jar</span> like java<span class="token punctuation">.</span>util<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token punctuation">.</span>JNI Local    Local variable in native code<span class="token punctuation">,</span> such as user defined JNI code or JVM internal code<span class="token punctuation">.</span>JNI Global    Global variable in native code<span class="token punctuation">,</span> such as user defined JNI code or JVM internal code<span class="token punctuation">.</span>Thread Block    Object referred to from a currently active thread block<span class="token punctuation">.</span>Thread    A started<span class="token punctuation">,</span> but not stopped<span class="token punctuation">,</span> thread<span class="token punctuation">.</span>Busy Monitor    Everything that has called wait<span class="token operator">(</span><span class="token operator">)</span> or notify<span class="token operator">(</span><span class="token operator">)</span> or that is synchronized<span class="token punctuation">.</span> For example<span class="token punctuation">,</span> by calling synchronized<span class="token operator">(</span>Object<span class="token operator">)</span> or by entering a synchronized method<span class="token punctuation">.</span> Static method means class<span class="token punctuation">,</span> non<span class="token operator">-</span>static method means object<span class="token punctuation">.</span>Java Local    Local variable<span class="token punctuation">.</span> For example<span class="token punctuation">,</span> input parameters or locally created objects of methods that are still in the stack of a thread<span class="token punctuation">.</span>Native Stack    In or out parameters in native code<span class="token punctuation">,</span> such as user defined JNI code or JVM internal code<span class="token punctuation">.</span> This is often the case as many methods have native parts and the objects handled as method parameters become GC roots<span class="token punctuation">.</span> For example<span class="token punctuation">,</span> parameters used for file<span class="token operator">/</span>network I<span class="token operator">/</span>O methods or reflection<span class="token punctuation">.</span>Finalizable    An object which is in a queue awaiting its finalizer to be run<span class="token punctuation">.</span>Unfinalized    An object which has a finalize method<span class="token punctuation">,</span> but has not been finalized and is not yet on the finalizer queue<span class="token punctuation">.</span>Unreachable    An object which is unreachable from any other root<span class="token punctuation">,</span> but has been marked as a root by MAT to retain objects which otherwise would not be included in the analysis<span class="token punctuation">.</span>Java Stack Frame    A Java stack frame<span class="token punctuation">,</span> holding local variables<span class="token punctuation">.</span> Only generated when the dump is parsed with the preference set to treat Java stack frames as objects<span class="token punctuation">.</span>Unknown    An object of unknown root type<span class="token punctuation">.</span> Some dumps<span class="token punctuation">,</span> such as IBM Portable Heap Dump files<span class="token punctuation">,</span> do not have root information<span class="token punctuation">.</span> For these dumps the MAT parser marks objects which are have no inbound references or are unreachable from any other root as roots of this type<span class="token punctuation">.</span> This ensures that MAT retains all the objects in the dump<span class="token punctuation">.</span></code></pre><p>各种说法, 但是大体的方向是一样的, 就是细节的区分而已。</p><h2 id="3-可达性分析算法在-JVM-中的大体步骤"><a href="#3-可达性分析算法在-JVM-中的大体步骤" class="headerlink" title="3 可达性分析算法在 JVM 中的大体步骤"></a>3 可达性分析算法在 JVM 中的大体步骤</h2><p>总体的步骤就 2 步: </p><ol><li>根节点枚举 (GC Roots Enumeration)</li><li>引用链查询标记</li></ol><h3 id="3-1-根节点枚举"><a href="#3-1-根节点枚举" class="headerlink" title="3.1 根节点枚举"></a>3.1 根节点枚举</h3><p>整个可达性分析的过程, 第一步就是先确定哪些对象的是 GC  Roots, 也就是根节点枚举 (有了 GC Roots 就能通过引用链查找可回收对象了)。</p><p>从上面列举的可作为 GC Roots 的对象列表可知, 可以作为 GC Roots 的主要在全局性的引用 (例如常量或类静态属性) 与执行上下文 (例如栈帧中的本地变量表) 中。<br>但是</p><blockquote><ol><li>尽管目标明确, 但是在程序实际运行中, 真正的 GC Roots 集合会随着程序的运行变更的</li><li>根节点枚举期间要求在一个能保障一致性的快照中才得以进行, 这里的一致性指定是: 在分析过程, 根节点集合的对象引用关系不会发生变化, 所以需要暂停所有的线程</li></ol></blockquote><p>所以在根节点枚举的过程, 如果一个个的遍历所有符合条件的对象, 将是一个耗时的过程。<br>现在主流的 Java 虚拟机使用了一组称为 OopMap 的数据结构来达到优化查找的过程, 避免一个不漏的检查所有的的对象。<br>通过扫描 OopMap 存储的引用类型的指针, 也就是 GC Roots 集合, 就能通过引用链找到存活的对象。</p><p>注: 现在所有的收集器, 在 GC Roots 这一步骤时都是必须暂停用户线程的, 也就是 “Stop the world”, 而耗时更长的查找引用链的过程已经可以做到与用户线程一起并发。</p><h4 id="3-1-1-OopMap-是怎么样工作的"><a href="#3-1-1-OopMap-是怎么样工作的" class="headerlink" title="3.1.1 OopMap 是怎么样工作的"></a>3.1.1 OopMap 是怎么样工作的</h4><p>在上面的分析中, 可以知道 GC Roots 的主要在全局性的引用与执行上下文中, 对这个结论在更具体的说明, GC Roots 主要存在于</p><blockquote><ol><li>方法区中类的常量和静态属性</li><li>Java 虚拟机栈中的本地变量表记录的引用对象</li><li>本地方法栈中 JNI (即 Native 方法) 引用的对象</li></ol></blockquote><h5 id="3-1-1-1-方法区中类的常量和静态属性"><a href="#3-1-1-1-方法区中类的常量和静态属性" class="headerlink" title="3.1.1.1 方法区中类的常量和静态属性"></a>3.1.1.1 方法区中类的常量和静态属性</h5><p>在 HotSpot 中, 对象的类型信息 (即 Klass 对象, Java 的 .class 文件加载到 JVM 中就会形成一个 Klass 对象) 里有记录自己的 OopMap,<br>记录了在该类型的对象内<strong>什么偏移量上是什么类型的数据</strong>, 这些数据是在类加载过程中计算得到的, 后续直接从这个类型对象开始向外的扫描即可。</p><p>所以, 方法区内的静态属性引用, 常量, 这些不太会改变的 GC Roots 会在类加载成功后, 就确定好了。</p><h5 id="3-1-1-2-Java-虚拟机栈中的本地变量表记录的引用对象"><a href="#3-1-1-2-Java-虚拟机栈中的本地变量表记录的引用对象" class="headerlink" title="3.1.1.2 Java 虚拟机栈中的本地变量表记录的引用对象"></a>3.1.1.2 Java 虚拟机栈中的本地变量表记录的引用对象</h5><p>对于虚拟机方法栈的 GC Roots 的话, 则是这样的:<br>每个被 JIT 编译过后的方法会在一些<strong>特定的位置</strong>更新这个方法栈帧的 OopMap。 记录执行到这个位置时, 方法栈上和寄存器里哪些位置是引用。</p><p>上面说的<strong>特定的位置</strong>主要在：</p><blockquote><ol><li>循环的末尾</li><li>方法临返回前</li><li>调用方法的 call 指令后面</li><li>可能抛异常的位置</li></ol></blockquote><p>这种位置被称为 “安全点” (safe point)。</p><p>安全点的选定标准  </p><ol><li>不能太少以至于让收集器等待时间过长 (太少, 2 个安全点之间的间隔会变大, 也就是 2 个安全点之间达到的时间也会变大)</li><li>不能太过频繁以至于过分增大运行时的内存负荷</li></ol><p>所以选用一些比较关键的位置来记录就能有效的缩小需要记录的数据量, 但仍然能达到区分引用的目的。<br>同时, HotSpot 中进行 GC 也不是在任意位置都可以进入, 同样也是需要所有线程达到 safe point 处才会 GC, 所以选择这些位置基本足够记录完整的 OopMap</p><p>通过上面的分析, 可以知道安全点的作用:<br>线程执行到 <strong>安全点</strong></p><blockquote><ol><li>更新这个方法栈帧的 OopMap</li><li>如果当前正在 GC, 当前线程进行挂起</li></ol></blockquote><p>至于如何让线程在 <strong>安全点</strong> 时挂起的, 在附录中再简单分析。</p><p>安全点的优化点<br>上面提到安全点的位置中有一个是<strong>循环的末尾</strong>, HotSpot 虚拟机为了避免安全点过多带来过重的负担, 对循环还做了一项优化措施:<br>认为循环次数较少的话, 执行时间应该也不会太长, 所以使用 int 类型或范围更小的数据类型作为索引值的循环默认是不会被放置安全点的, 这种优化被称为: 可数循环 (Counted Loop)。<br>相应的, 使用 long 或者范围更大的数据类型作为索引值的循环就被称为不可数循环 (Uncouted Loop), 将会被放置安全点。</p><p>但是循环执行的次数少, 并不是代表了循环执行的时间短, 如果每次执行里面的操作很耗时, 可能会导致线程执行到安全点需要消耗很多时间。<br>HotSpot 原本提供了 -XX:+UseCountedLoopSafepoints 参数去强制在可数循环中也放置安全点, 不过这个参数在 JDK8 下有 Bug。</p><h5 id="3-1-1-3-本地方法栈中-JNI-即-Native-方法-引用的对象"><a href="#3-1-1-3-本地方法栈中-JNI-即-Native-方法-引用的对象" class="headerlink" title="3.1.1.3 本地方法栈中 JNI (即 Native 方法) 引用的对象"></a>3.1.1.3 本地方法栈中 JNI (即 Native 方法) 引用的对象</h5><p>对 Java 线程中的 JNI 方法, 它们既不是由 JVM 里的解释器执行的, 也不是由 JVM 的 JIT 编译器生成的, 所以会缺少OopMap 信息。那么GC碰到这样的栈帧该如何维持准确性呢？</p><p>HotSpot 的解决方法是: 所有经过 JNI 调用边界 (调用 JNI 方法传入的参数, 从 JNI 方法传回的返回值) 的引用都必须用 “句柄” (handle) 包装起来, JNI 需要调用 Java API 的时候也必须自己用句柄包装指针。<br>在这种实现中, JNI 方法里写的 “jobject” 实际上不是直接指向对象的指针, 而是先指向一个句柄, 通过句柄才能间接访问到对象。<br>这样在扫描到 JNI 方法的时候就不需要扫描它的栈帧了 – 只要扫描句柄表就可以得到所有从 JNI 方法能访问到的 GC 堆里的对象。<br>但这也就意味着调用 JNI 方法会有句柄的包装&#x2F;拆包装的开销, 是导致 JNI 方法的调用比较慢的原因之一。</p><p><strong>Java 虚拟机栈中的本地变量表记录的引用对象</strong></p><p>所以, 方法区内的静态属性引用, 常量, 这些不太会改变的 GC Roots 会在类加载成功后, 就确定好了。</p><p>对于方法栈的 GC Roots 的话, 则是这样的:<br>每个被 JIT 编译过后的方法会在一些<strong>特定的位置</strong>更新这个方法栈帧的 OopMap。 记录执行到这个位置时, 方法栈上和寄存器里哪些位置是引用。</p><h3 id="3-2-引用链查询标记"><a href="#3-2-引用链查询标记" class="headerlink" title="3.2 引用链查询标记"></a>3.2 引用链查询标记</h3><p>通过根节点枚举, 得到当前应用所有的 GC Roots, 接下来通过这些 GC Roots 的引用, 就能确定出当前哪些对象是不可回收, 哪些是可回收的了。<br>但是根据引用链 (引用关系) 标记可回收对象, 随着堆的增大, 整个过程会随之增长。<br>为了解决这个问题, JVM 的解决方案是让用户线程和垃圾收集器并发并行, 但是并发的过程, 存在修改引用链的情况, 导致标记的结果不正确。</p><p>为了这个问题, 引入了 “三色标记 (Tri-color Marking)” 作为补助手段, 把遍历对象过程中遇到的对象, 按照 “是否访问过” 这个条件标记成以下三种颜色</p><p>白色: 对象尚未被垃圾收集器访问过。在可达性分析刚刚开始的阶段, 所有的对象都是白色的, 若在分析结束的阶段, 仍然是白色的对象, 即代表不可达, 对象可回收<br>黑色: 对象已经被垃圾收集器访问过, 且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过, 它是安全存活的, 如果有其他对象引用指向了黑色对象, 无须重新扫描一遍。<br>黑色对象不可能直接 (不经过灰色对象) 指向某个白色对象<br>灰色: 对象已经被垃圾收集器访问过, 但这个对象上至少存在一个引用还没有被扫描过    </p><p>标记的过程, 基本就是从根节点, 找到下一个引用, 标记为黑色或者灰色, 如果为黑色, 这里的引用结束了。如果为灰色, 从这个节点向下继续标记。</p><p>一般情况是这样的<br><img src="https://pic.imgdb.cn/item/65e5c1869f345e8d03a4569f.gif" alt="Alt &#39;三色标记法正常过程&#39;"></p><p>但是扫描的过程中, 用户线程与收集器是并发工作的过程, 收集器在对象标记了颜色, 同时用户线程在修改引用关系, 这会导致</p><ol><li>把原本消亡的对象错误标记为存活, 这种情况, 是可以容忍的, 只不过产生了一点逃过本次收集的浮动垃圾而已, 下次收集清理掉就好。</li><li>把原本存活的对象错误标记为已消亡, 这种情况的话, 则会导致我们程序的异常了。</li></ol><h4 id="3-2-1-标记过程中的特殊情况"><a href="#3-2-1-标记过程中的特殊情况" class="headerlink" title="3.2.1 标记过程中的特殊情况"></a>3.2.1 标记过程中的特殊情况</h4><h5 id="3-2-1-1-情况一-多标了"><a href="#3-2-1-1-情况一-多标了" class="headerlink" title="3.2.1.1 情况一: 多标了"></a>3.2.1.1 情况一: 多标了</h5><p>假设已经遍历到 E (变为灰色了), 此时应用程序执行了 D.E &#x3D; null (D -&gt; E 的引用断开):</p><p><img src="https://pic.imgdb.cn/item/65e5c15a9f345e8d03a3c07b.png" alt="Alt &#39;三色标记法多标过程&#39;"></p><p>此时, 对象 E&#x2F;F&#x2F;G 是 “应该” 被回收的。但是因为 E 已经变为灰色了, 其仍会被当作存活对象继续遍历下去。<br>最终的结果是: 这部分对象仍会被标记为存活, 即本轮 GC 不会回收这部分内存。<br>这部分本应该回收, 但是没有回收到的内存, 被称之为 “浮动垃圾(Floating Garbage)”。</p><p>另外, 在并发标记开始后, 创建的新的对象, 通常的做法是直接全部当成黑色, 本轮不会进行清除。<br>这部分对象期间可能会变为垃圾, 这也算是浮动垃圾的一部分。</p><h5 id="3-2-1-2-情况二-漏标了"><a href="#3-2-1-2-情况二-漏标了" class="headerlink" title="3.2.1.2 情况二: 漏标了"></a>3.2.1.2 情况二: 漏标了</h5><p>假设已经遍历到 E (变为灰色了), 此时应用程序执行了</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">G</span> g <span class="token operator">=</span> <span class="token class-name">E</span><span class="token punctuation">.</span>g<span class="token punctuation">;</span><span class="token class-name">E</span><span class="token punctuation">.</span>g <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token class-name">D</span><span class="token punctuation">.</span>g <span class="token operator">=</span> g<span class="token punctuation">;</span></code></pre><p><img src="https://pic.imgdb.cn/item/65e5c15c9f345e8d03a3c925.png" alt="Alt &#39;三色标记法漏标过程&#39;"></p><p>GC 线程继续跑, 因为 E 已经没有对 G 的引用了, 所以不会将 G 放到灰色集合, 尽管因为 D 重新引用了 G, 但因为 D 已经是黑色了, 不会再重新做遍历处理。<br>最终导致的结果是：G 会一直停留在白色集合中, 最后被当作垃圾进行清除。</p><p>但是通过分析上面的过程, 可以发现出现对象漏标的话, 需要同时满足 2 个条件</p><ol><li>灰色对象断开了白色对象的直接或间接引用</li><li>黑色对象重新引用了该白色对象</li></ol><p>因此, 我们要解决并发扫描时的对象消失问题, 只需破坏这两个条件的任意一个即可。<br>由此分别产生了两种解决方案: 原始快照 (Snapshot At The Beginning, SATB) 和增量更新 (Incremental Update)。</p><h4 id="3-2-3-写屏障-Writer-Barrier"><a href="#3-2-3-写屏障-Writer-Barrier" class="headerlink" title="3.2.3 写屏障 (Writer Barrier)"></a>3.2.3 写屏障 (Writer Barrier)</h4><p>原始快照和增量更新两种解决方案都是基于<strong>写屏障</strong>实现的, 具体是怎么样呢?</p><p>给某个对象的成员变量赋值时, 其底层代码大概长这样:</p><pre class="language-C" data-language="C"><code class="language-C">void oop_field_store(oop* field, oop new_value) &#123;    &#x2F;&#x2F; 赋值操作   *field &#x3D; new_value; &#125;</code></pre><p>这里的写屏障不是解决并发的读写屏障, 看作在虚拟机层面对 “引用类型字段赋值” 这个动作的 AOP 切面, 在引用对象赋值时会产生一个环形 (Around) 通知,<br>供程序执行额外的动作, 也就是说赋值的前后都在写屏障的覆盖范畴内。<br>在赋值前的部分的写屏障叫作写前屏障 (Pre-Write Barrier), 在赋值后的则叫作写后屏障 (Post-Write Barrier)。</p><pre class="language-C" data-language="C"><code class="language-C">void oop_field_store(oop* field, oop new_value) &#123;      &#x2F;&#x2F; 写屏障-写前操作    pre_write_barrier(field);         &#x2F;&#x2F; 赋值操作    *field &#x3D; new_value;         &#x2F;&#x2F; &#x2F;&#x2F; 写屏障-写后操作    post_write_barrier(field, value);&#125;</code></pre><p>HotSpot 虚拟机只用到了<strong>写后屏障</strong>。</p><h4 id="3-2-3-漏标情况的解决"><a href="#3-2-3-漏标情况的解决" class="headerlink" title="3.2.3 漏标情况的解决"></a>3.2.3 漏标情况的解决</h4><h5 id="3-2-3-1-原始快照-Snapshot-At-The-Beginning-SATB"><a href="#3-2-3-1-原始快照-Snapshot-At-The-Beginning-SATB" class="headerlink" title="3.2.3.1 原始快照 (Snapshot At The Beginning, SATB)"></a>3.2.3.1 原始快照 (Snapshot At The Beginning, SATB)</h5><p>原始快照要破坏的是第一个条件, 当灰色对象要删除指向白色对象的引用关系时, 就将这个要删除的引用记录下来, 在并发扫描结束之后, 再将这些记录过的<br>引用关系, 标记为灰色, 然后以这些灰色对象为根, 重新扫描一次。<br>这可以简化理解为, 无论引用关系删除与否, 都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</p><p>因为从灰色对象删除指向白色对象的引用关系时, 就把这个引用记录下来。那么存在的确是要删除这个引用关系的, 后续不在会对其做任何变更了, 那么重新把<br>这个引用当做灰色对象, 就会造成 “浮动垃圾”。</p><p>在 HotSpot 中, G1 和 Shenandoah 则是用原始快照来实现。</p><h5 id="3-2-3-2-增量更新-Incremental-Update"><a href="#3-2-3-2-增量更新-Incremental-Update" class="headerlink" title="3.2.3.2 增量更新 (Incremental Update)"></a>3.2.3.2 增量更新 (Incremental Update)</h5><p>增量更新要破坏的是第二个条件, 当黑色对象插入新的指向白色对象的引用关系时, 就将这个新插入的引用记录下来, 等并发扫描结束之后, 再将这些记录过的<br>引用关系为根, 重新扫描一次。<br>这可以简化理解为, 黑色对象一旦新插入了指向白色对象的引用之后, 它就变回灰色对象了。</p><p>在 HotSpot 中, CMS 是基于增量更新来做并发标记的。</p><p>2 种方式, 都是通过写屏障实现的。</p><h2 id="4-finalize-让对象再活一次"><a href="#4-finalize-让对象再活一次" class="headerlink" title="4 finalize 让对象再活一次"></a>4 finalize 让对象再活一次</h2><p>理论上通过可达性分析算法, 可以判定出一个对象是否可以回收。<br>可回收的对象会在最后执行一次他的 finalize 方法, 可以通过这个方法让这个对象再次活一次。</p><p>判定一个对象是否需要回收, 可以实际需要经过 2 次标记</p><ol><li>对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链, 那它将会被第一次标记</li><li>在 1 的基础上, 再进行一次筛选, 筛选的条件是此对象是否有必要执行 finalize() 方法, 对象没有覆盖 finalize() 方法, 或者 finalize() 方法<br>已经被虚拟机调用过 (每个对象的 finalize 方法只会被执行一次), 那么虚拟机将这两种情况都视为 “没有必要执行”, 标记为可回收</li></ol><p>如果对象判定为需要执行 finalize 方法, 该对象将会先被放置在一个名为 <strong>F-Queue</strong> 的队列, 并在稍后由一条由虚拟机自动建立的, 低调度优先级<br>的 Finalizer 线程去执行它们的 finalize 方法 (虚拟机会触发这个方法开始运行, 但不承诺一定会等待它运行结束, 如果某个对象的 finalize方法执行缓慢,<br>或者死循环等, 这会导致 F-Queue 队列的对象消除的很慢 &#x2F; 一直处于等待, 最终可能导致系统崩溃)。</p><p>对象可以在 finalize 让自己不被回收。<br>收集器将对 F-Queue 中的对象进行第二次小规模的标记时, 判定需要执行 finalize 方法。只要对象将自己和引用链上的任意一个对象进行关联, 比如把<br>自己 (this 关键字) 赋值给某个类变量或者对象的成员变量, 那在第二次标记时它将被移出 “可回收” 的集合。</p><h2 id="5-附录-线程挂起"><a href="#5-附录-线程挂起" class="headerlink" title="5 附录: 线程挂起"></a>5 附录: 线程挂起</h2><p>对于安全点, 另外一个需要考虑的问题是, 如何在垃圾收集发生时让所有线程 (这里其实不包括执行 JNI 调用的线程) 都跑到最近的安全点, 然后停顿下来。</p><p>这里有两种方案可供选择: 抢先式中断 (Preemptive Suspension) 和主动式中断 (Voluntary Suspension) 。</p><p>抢先式中断不需要线程的执行代码主动去配合, 在垃圾收集发生时, 系统首先把所有用户线程全部中断, 如果发现有用户线程中断的地方不在安全点上, 就恢复这条线程执行, 让它一会再重新中断, 直到跑到安全点上。<br>现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应 GC 事件</p><p>主动式中断的思想是当垃圾收集需要中断线程的时候, 不直接对线程操作, 仅仅简单地设置一个标志位, 各个线程执行过程时会不停地主动去轮询这个标志, 一旦发现中断标志为真时, 就在自己最近的安全点上主动中断挂起。</p><h3 id="5-1-3-安全区域-Safe-Region"><a href="#5-1-3-安全区域-Safe-Region" class="headerlink" title="5.1.3 安全区域 (Safe Region)"></a>5.1.3 安全区域 (Safe Region)</h3><p>安全点机制保证了程序执行时, 在不太长的时间内就会遇到可进入垃圾收集过程的安全点。<br>但是线程还有可能存在不在执行的状态, 比如 Sleep 状态或者 Blocked 状态, 这些线程无法走到安全点的位置, 然后中断挂起自己。</p><p>而虚拟机也不会等待这些线程唤醒然后执行的, 这种情况虚拟机通过 “安全区域” 的方式进行解决。<br>安全区域是指能够确保在某一段代码片段之中, 引用关系不会发生变化, 因此, 在这个区域中任意地方开始垃圾收集都是安全的。</p><p>当用户线程执行到安全区域里面的代码时, 首先会标识自己已经进入了安全区域, 那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。<br>当线程要离开安全区域时, 它要检查虚拟机是否已经完成了根节点枚举</p><blockquote><p>如果完成了, 那线程就当作没事发生过, 继续执行<br>否则它就必须一直等待, 直到收到可以离开安全区域的信号为止</p></blockquote><p>可以认为: 可以使线程挂起的代码, 就是在安全区域中。</p><p>另一种情况: 当一个线程在执行 native 方法时, 由于此时该线程在执行 JVM 管理之外的代码, 不能对 JVM 的执行状态做任何修改, 因而 JVM要 进入 safe point 不需要关心它。<br>所以也可以把正在执行 native 函数的线程看作 “已经进入了 safe point”, 或者把这种情况叫做 “在 safe-region 里”。</p><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h2><p>《深入理解Java虚拟机》- 周志明<br><a href="https://www.iteye.com/blog/rednaxelafx-1044951">找出栈上的指针&#x2F;引用</a><br><a href="https://www.cnblogs.com/jmcui/p/14165601.html">JVM系列十六（三色标记法与读写屏障）.</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM 实例对象的访问定位</title>
      <link href="/article/2021/3656336691/"/>
      <url>/article/2021/3656336691/</url>
      
        <content type="html"><![CDATA[<p>Java 程序会通过栈上的 reference 数据来操作堆上的具体对象。<br>但是 reference 类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用, 并没有定义这个引用应该通过什么方式去定位, 访问到堆中对象的具体位置,<br>所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用<strong>句柄</strong>和<strong>直接指针</strong>两种。</p><h2 id="1-句柄"><a href="#1-句柄" class="headerlink" title="1 句柄"></a>1 句柄</h2><p><img src="https://pic.imgdb.cn/item/658988e9c458853aefba3163.png" alt="Alt &#39;句柄定位实例对象&#39;"></p><p>如图: Java 堆中将可能会划分出一块内存来作为句柄池, reference 中存储的就是对象的句柄地址, 而句柄中包含了对象实例数据与类型数据各自具体的地址<br>信息。</p><p>使用句柄来访问的最大好处就是 reference 中存储的是稳定句柄地址, 在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针,<br>而 reference 本身不需要被修改。</p><h2 id="2-直接指针"><a href="#2-直接指针" class="headerlink" title="2 直接指针"></a>2 直接指针</h2><p><img src="https://pic.imgdb.cn/item/658989c2c458853aefbdd0f3.png" alt="Alt &#39;直接指针定位实例对象&#39;"></p><p>如图: reference 中存储的就是对象地址, 而实例对象有一个指向具体的类型的指针。</p><p>使用直接指针来访问最大的好处就是速度更快, 它节省了一次指针定位的时间开销, 由于对象访问在 Java 中非常频繁, 因此这类开销积少成多也是一项极为可观的执行成本。<br>就 HotSpot 而言, 它主要使用第二种方式进行对象访问(有例外情况，如果使用了Shenandoah收集器的 话也会有一次额外的转发)。</p><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h2><p>《深入理解Java虚拟机》- 周志明  </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM 实例对象的创建</title>
      <link href="/article/2021/2329229394/"/>
      <url>/article/2021/2329229394/</url>
      
        <content type="html"><![CDATA[<p>当我们涉及 Java 编程时, 对象的创建是一个基础而关键的概念。在 Java 中, 一切皆为对象, 而对象的创建方式直接影响代码的结构和性能。<br>本博客将探讨一下 Java 实例对象的创建过程。</p><h2 id="1-创建对象的方法有哪些"><a href="#1-创建对象的方法有哪些" class="headerlink" title="1 创建对象的方法有哪些"></a>1 创建对象的方法有哪些</h2><p>在 Java 中如果要创建一个对象, 有哪些方式呢? </p><blockquote><ol><li>运用 new 关键字创建实例, 这是最常用的创建对象方法</li><li>通过反射, 调用 java.lang.Class 的 newInstance 方法, 相当于调用一个类的无参的构造函数创建对象</li><li>通过反射, 调用 java.lang.reflect.Constructor 类的 newInstance 方法, 支持无参&#x2F;有参&#x2F;私有的构造函数</li><li>通过对象的 clone 方法, 对象需要实现 java.lang.Cloneable 接口</li><li>通过反序列化, 对象需要实现 java.io.Serializable</li><li>通过 sun.misc.Unsafe 的 allocateInstance 方法</li></ol></blockquote><p>其中方法 1, 2, 3 本质都是通过类的构造函数创建对象, 就是 Java 的 new 机制。<br>而方法 4, 5, 6 不会调用构造函数。我们这里只讨论正常的构造函数创建对象的方式。</p><h2 id="2-创建的过程"><a href="#2-创建的过程" class="headerlink" title="2 创建的过程"></a>2 创建的过程</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Demo</span> main <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>上面是一个逻辑很简单, 就是通过 new 创建出了一个 Demo 的实例。<br>从 Java 层面这个对象的创建就完成了, 如何还需要进行深入分析的话, 我们需要进入到字节码的层面了。</p><p>对应如何将类文件转为字节码, 可以看一下后面的附录 1。</p><p>上面的 Demo 例子转为字节码后如下</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Classfile</span> <span class="token operator">/</span><span class="token class-name">Users</span><span class="token operator">/</span>lcn29<span class="token operator">/</span><span class="token class-name">Projects</span><span class="token operator">/</span><span class="token class-name">Demo</span><span class="token operator">/</span>src<span class="token operator">/</span>main<span class="token operator">/</span>java<span class="token operator">/</span>io<span class="token operator">/</span>github<span class="token operator">/</span>lcn29<span class="token operator">/</span><span class="token class-name">Demo</span><span class="token punctuation">.</span><span class="token keyword">class</span>  <span class="token class-name">Last</span> modified xxxx年xx月xx日<span class="token punctuation">;</span> size <span class="token number">286</span> bytes  <span class="token constant">SHA</span><span class="token operator">-</span><span class="token number">256</span> checksum de9e200e3a5848520480df67e259986c46dca7342bbaf8f1b84b094815e04ee5  <span class="token class-name">Compiled</span> from <span class="token string">"Demo.java"</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token namespace">io<span class="token punctuation">.</span>github<span class="token punctuation">.</span>lcn29<span class="token punctuation">.</span></span>Demo</span>  minor version<span class="token operator">:</span> <span class="token number">0</span>  major version<span class="token operator">:</span> <span class="token number">65</span>  flags<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token number">0x0021</span><span class="token punctuation">)</span> <span class="token constant">ACC_PUBLIC</span><span class="token punctuation">,</span> <span class="token constant">ACC_SUPER</span>  this_class<span class="token operator">:</span> #<span class="token number">7</span>                          <span class="token comment">// io/github/lcn29/Demo</span>  super_class<span class="token operator">:</span> #<span class="token number">2</span>                         <span class="token comment">// java/lang/Object</span>  interfaces<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> fields<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> methods<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> attributes<span class="token operator">:</span> <span class="token number">1</span><span class="token class-name">Constant</span> pool<span class="token operator">:</span>   #<span class="token number">1</span> <span class="token operator">=</span> <span class="token class-name">Methodref</span>          #<span class="token number">2.</span>#<span class="token number">3</span>          <span class="token comment">// java/lang/Object."&lt;init>":()V</span>   #<span class="token number">2</span> <span class="token operator">=</span> <span class="token class-name">Class</span>              #<span class="token number">4</span>             <span class="token comment">// java/lang/Object</span>   #<span class="token number">3</span> <span class="token operator">=</span> <span class="token class-name">NameAndType</span>        #<span class="token number">5</span><span class="token operator">:</span>#<span class="token number">6</span>          <span class="token comment">// "&lt;init>":()V</span>   #<span class="token number">4</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               java<span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">Object</span>   #<span class="token number">5</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token generics"><span class="token punctuation">&lt;</span>init<span class="token punctuation">></span></span>   #<span class="token number">6</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token class-name">V</span>   #<span class="token number">7</span> <span class="token operator">=</span> <span class="token class-name">Class</span>              #<span class="token number">8</span>             <span class="token comment">// io/github/lcn29/Demo</span>   #<span class="token number">8</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               io<span class="token operator">/</span>github<span class="token operator">/</span>lcn29<span class="token operator">/</span><span class="token class-name">Demo</span>   #<span class="token number">9</span> <span class="token operator">=</span> <span class="token class-name">Methodref</span>          #<span class="token number">7.</span>#<span class="token number">3</span>          <span class="token comment">// io/github/lcn29/Demo."&lt;init>":()V</span>  #<span class="token number">10</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token class-name">Code</span>  #<span class="token number">11</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token class-name">LineNumberTable</span>  #<span class="token number">12</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               main  #<span class="token number">13</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token class-name">Ljava</span><span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">String</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token class-name">V</span>  #<span class="token number">14</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token class-name">SourceFile</span>  #<span class="token number">15</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token class-name">Demo</span><span class="token punctuation">.</span>java<span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token class-name"><span class="token namespace">io<span class="token punctuation">.</span>github<span class="token punctuation">.</span>lcn29<span class="token punctuation">.</span></span>Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token class-name">V</span>    flags<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token number">0x0001</span><span class="token punctuation">)</span> <span class="token constant">ACC_PUBLIC</span>    <span class="token class-name">Code</span><span class="token operator">:</span>      stack<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>         <span class="token number">0</span><span class="token operator">:</span> aload_0         <span class="token number">1</span><span class="token operator">:</span> invokespecial #<span class="token number">1</span>                  <span class="token comment">// Method java/lang/Object."&lt;init>":()V</span>         <span class="token number">4</span><span class="token operator">:</span> <span class="token keyword">return</span>      <span class="token class-name">LineNumberTable</span><span class="token operator">:</span>        line <span class="token number">3</span><span class="token operator">:</span> <span class="token number">0</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token class-name">Ljava</span><span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">String</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token class-name">V</span>    flags<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token number">0x0009</span><span class="token punctuation">)</span> <span class="token constant">ACC_PUBLIC</span><span class="token punctuation">,</span> <span class="token constant">ACC_STATIC</span>    <span class="token class-name">Code</span><span class="token operator">:</span>      stack<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>         <span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">7</span>                  <span class="token comment">// class io/github/lcn29/Demo</span>         <span class="token number">3</span><span class="token operator">:</span> dup         <span class="token number">4</span><span class="token operator">:</span> invokespecial #<span class="token number">9</span>                  <span class="token comment">// Method "&lt;init>":()V</span>         <span class="token number">7</span><span class="token operator">:</span> astore_1         <span class="token number">8</span><span class="token operator">:</span> <span class="token keyword">return</span>      <span class="token class-name">LineNumberTable</span><span class="token operator">:</span>        line <span class="token number">6</span><span class="token operator">:</span> <span class="token number">0</span>        line <span class="token number">7</span><span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token class-name">SourceFile</span><span class="token operator">:</span> <span class="token string">"Demo.java"</span></code></pre><p>备注:<br>从上面的字节码内容中可以看到很多注释的内容 (<strong>&#x2F;&#x2F;</strong> 后面的内容), 在实际的字节码中是不会有后面的注释内容的, 只有一个简单的 **指令 #参数 (也可能没这个参数)**。</p><p>后面注释的内容是 javap 为了方便我们阅读, 提前帮我们把 <strong>#参数</strong> 的内容转换了, 即后面注释的内容就是 <strong>#参数</strong> 的真正内容。</p><p><strong>#参数 的真正内容如何查找的?</strong><br>这里的 <strong>#参数</strong> 可以看作是一个坐标, 通过这个指标可以到字节码文件的<strong>常量池</strong>中获取对应的内容, 即字节码文件中的 <strong>Constant pool</strong> 项。  </p><p>比如: <strong>#7</strong> 在我们的字节码文件的 <strong>Constant pool</strong> 从中找到的内容是 <strong>#8</strong>, 同理通过 <strong>#8</strong> 在 <strong>Constant pool</strong> 中最终获取到了内容 <strong>io&#x2F;github&#x2F;lcn29&#x2F;Demo</strong>, 也就是 <strong>#7 的内容就是 io&#x2F;github&#x2F;lcn29&#x2F;Demo</strong></p><p>OK, 转为字节码后, 我们可以看到 JVM 创建对象的更多步骤。<br>下面我们就围绕这个字节码过程, 简单梳理一下 JVM 层面创建对象的过程。</p><h3 id="2-1-检查类的加载"><a href="#2-1-检查类的加载" class="headerlink" title="2.1 检查类的加载"></a>2.1 检查类的加载</h3><p>从 main 方法入手, 我们遇到的第一个字节码</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span>           #<span class="token number">7</span>                  <span class="token comment">// class io/github/lcn29/Demo</span></code></pre><p>JVM 虚拟机遇到一条 new 指令时, 首先会去检查这个指令的后面参数是否能在<strong>运行时常量池</strong>中定位到一个类的符号引用, 并且检查这个符号引用代表的类是否已被加载, 解析和初始化过。<br>如果没有, 那必须先执行相应的<strong>类加载</strong>过程。</p><p><strong>类加载</strong> 的过程就不在这里展开了。</p><p>所以 new 的是 <strong>io&#x2F;github&#x2F;lcn29&#x2F;Demo</strong> 这个类, 所以首先需要确保在内存中有这个类存在。</p><h3 id="2-2-分配内存"><a href="#2-2-分配内存" class="headerlink" title="2.2 分配内存"></a>2.2 分配内存</h3><p>在<strong>类加载检查</strong>通过后, 接下来虚拟机将为新生对象分配内存。  </p><p>一个对象需要分配内存的就 3 个部分</p><blockquote><ol><li>对象头 (Object Header) 的大小固定的</li><li>实例数据 (Instance Data) 的大小可以通过类的各个属性的大小计算出来</li><li>对齐填充 (Padding) 只需要在得到前 2 个的大小后, 保证整个对象为 8 个字节的倍数即可</li></ol></blockquote><p>所以一个对象所需内存的大小在类加载完成后便可完全确定, 这时就可以给这个对象分配内存空间。<br>这个过程实际就是把一块确定大小的内存从 Java 堆中划分出来。</p><h4 id="2-2-1-内存分配方式"><a href="#2-2-1-内存分配方式" class="headerlink" title="2.2.1 内存分配方式"></a>2.2.1 内存分配方式</h4><p><strong>方式一</strong><br>如果 Java 堆中内存是绝对规整的, 所有用过的内存都放在一边, 空闲的内存放在另一边, 中间放着一个指针作为分界点的指示器, 那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离, 这种分配方式称为 “指针碰撞 (Bump the Pointer)”</p><p><strong>方式二</strong><br>如果 Java 堆中的内存并不是规整的, 已使用的内存和空闲的内存相互交错, 那就没有办法简单地进行指针碰撞了, 虚拟机就必须维护一个列表, 记录哪些内存块是可用的, 在分配的时候从列表中找到一块足够大的空间划分给对象实例, 并更新列表上的记录, 这种分配方式称为 “空闲列表 (Free List)”</p><pre class="language-log" data-language="log"><code class="language-log">至于选择哪种分配方式由 Java 堆是否规整决定。  而 Java 堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理 <span class="token operator">(</span>Compact<span class="token operator">)</span> 功能决定。  Serial<span class="token punctuation">,</span> ParNew 等带压缩整理过程的收集器就使用指针碰撞<span class="token punctuation">,</span> 基于 CMS 这种清除算法就使用空闲列表</code></pre><h4 id="2-2-2-内存分配的安全问题"><a href="#2-2-2-内存分配的安全问题" class="headerlink" title="2.2.2 内存分配的安全问题"></a>2.2.2 内存分配的安全问题</h4><p>对象的创建需要申请内存, 这个过程不是线程安全的。<br>如果现在正在给对象 A 分配内存, <strong>临界指针&#x2F;空闲列表的值</strong>还未改变, 这时候又要一个对象 B 进行<br>内存的申请, 那么就导致线程不安全。  </p><p>为了解决这个问题, 有 2 种方式  </p><blockquote><ol><li>对分配内存空间的动作进行同步处理, 虚拟机是可以通过 CAS 加上<strong>失败重试</strong>的方式保证更新操作的原子性  </li><li>把内存分配的动作按照线程划分在不同的空间之中进行, 每个线程在 Java 堆中预先分配一小块内存, 称为本地线程分配缓冲 (Thread Local Allocation Buffer, TLAB), 哪个线程要分配内存, 就在哪个线程的本地缓冲区中分配, 只有本地缓冲区用完了, 分配新的缓存区时才需要同步锁定。</li></ol></blockquote><h3 id="2-3-空间初始化"><a href="#2-3-空间初始化" class="headerlink" title="2.3 空间初始化"></a>2.3 空间初始化</h3><p>内存分配完成后, 虚拟机需要将分配到的内存空间都初始化为默认值 (不包括对象头), 如果使用了 TLAB 的话, 这一项工作也可以提前至 TLAB 分配时顺便进行。<br>这步操作保证了对象的实例字段在 Java 代码中可以不赋自定义值就可以直接使用, 使程序能访问这些字段的数据类型所对应的初始值。</p><p>各种数据类型的初始值:</p><table><thead><tr><th align="center">类型</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center">false(0)</td></tr><tr><td align="center">char</td><td align="center">\u0000(unicode 编码, 转为十进制就是 0)</td></tr><tr><td align="center">byte</td><td align="center">0</td></tr><tr><td align="center">short</td><td align="center">0</td></tr><tr><td align="center">int</td><td align="center">0</td></tr><tr><td align="center">float</td><td align="center">0.0f</td></tr><tr><td align="center">double</td><td align="center">0.0d</td></tr><tr><td align="center">long</td><td align="center">0L</td></tr><tr><td align="center">reference(引用类型)</td><td align="center">null</td></tr></tbody></table><h3 id="2-4-其他必要的设置"><a href="#2-4-其他必要的设置" class="headerlink" title="2.4 其他必要的设置"></a>2.4 其他必要的设置</h3><p>JVM 会对这个对象的对象头等相关的属性进行设置, 比如确定是哪个类的实例, 将 klass Pointer 指向对应的 Class, 设置对象的哈希码, 对象的 GC 分代年龄, 偏向锁标识等。</p><p>到了这一步, 字节码 <strong>new</strong> 引起的对象创建就完成。<br>但是这时创建出来的的对象所有的属性都是默认值, 还是一个未完整的对象的。</p><h3 id="2-5-执行-方法"><a href="#2-5-执行-方法" class="headerlink" title="2.5 执行 &lt;init&gt; 方法"></a>2.5 执行 &lt;init&gt; 方法</h3><p>顺着字节码, 下一个 <strong>dup</strong>, 这个只是单纯的为了更方便地为后面的赋值操作而执行的,<br>本身不会改变到对象的任何属性, 所以跳过。</p><p>下一个 <strong>invokespecial #9 (Method “<init>“:()V)</strong> 字节码。</p><p>invokespecial 字节码, 可以先简单看作是调用后面参数指定的方法。</p><p>而 <strong><init></strong> 是 JVM 在编译时间, 根据我们的类生成的一个统一的属性初始化方法 (对应了上面的例子的public io.github.lcn29.Demo() 方法)。</p><p>举个例子:  </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> num2<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> num3<span class="token punctuation">;</span>    <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>num2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>num3 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></code></pre><p>上面 A 有 3 个属性 num, num2, num3, 它们分别在 3 个地方被赋值了</p><blockquote><ol><li>声明赋值</li><li>代码块赋值</li><li>构造函数赋值</li></ol></blockquote><p>而编译为字节码后, 编译器会把所有的赋值操作都统一在自己生成的 <strong><init></strong> 方法中, 就像下面</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> num2<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> num3<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span>init<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 先调用父类的 &lt;init> 方法, 确保父类的属性设置完成</span>      <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span>init<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 自己的属性赋值</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>num2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>num3 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>了解完 <strong><init></strong> 方法, 我们可以了解到 <strong>invokespecial #9</strong> 这条字节码指令的效果: 对自己的父类和属性进行真正的赋值。</p><p>到了这里, 一个真正完整的实例对象就创建完成。 </p><p>后面的 astore_1 和 return 都不涉及到对象的情况的处理, 跳过。</p><p>至此一个 实例对象的创建就完成。 </p><h2 id="3-方法和-方法"><a href="#3-方法和-方法" class="headerlink" title="3 &lt;init&gt; 方法和 &lt;clinit&gt; 方法"></a>3 &lt;init&gt; 方法和 &lt;clinit&gt; 方法</h2><p><strong><init></strong> 方法是编译器生成的, 生成的字节码中一般都会有, 但是不一定就会执行。</p><p>一般来说 <strong><init></strong> 方法是否执行, 由 new 指令后面是否跟随 invokespecial 指令决定。<br>Java 编译器会在遇到 new 关键字的地方同时生成这 2 条指令, 如果不是通过 new 方式创建的, 则不会有。</p><p>在 Java 类的定义中, 除了正常的属性外, 我们还可以再类中定义静态属性, 同理编译器会将静态属性和静态代码块中的属性赋值, 统一到一个 <strong><clinit></strong> 方法中。  </p><p><strong><init></strong> 方法在我们创建类实例时调用, 而 <strong><clinit></strong> 则是在类加载时执行。</p><h3 id="3-1-举个例子加深理解"><a href="#3-1-举个例子加深理解" class="headerlink" title="3.1 举个例子加深理解"></a>3.1 举个例子加深理解</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> pNum1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">int</span> pNum2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>   <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>      pNum1 <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#123;</span>      pNum2 <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">public</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>pNum2 <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> sNum1 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">int</span> sNum2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>   <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>      sNum1 <span class="token operator">=</span> <span class="token number">21</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#123;</span>      sNum2 <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">public</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>sNum2 <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>当我们创建 Son 的实例的时候, 上面的构造函数, 代码块, 静态代码块的执行顺序是怎么样的?</p><p>上面的执行顺序差不多是这样的</p><ol><li>Parent 的静态变量赋值</li><li>Parent 的静态代码块执行</li><li>Son 的静态变量赋值</li><li>Son 的静态代码块执行</li><li>Parent 的实例变量赋值</li><li>Parent 的代码块执行</li><li>Parent 的构造函数执行   </li><li>Son 的实例变量赋值</li><li>Son 的代码块执行</li><li>Son 的构造函数执行</li></ol><p>出现上面的执行顺序, 主要是由 <code>&lt;init&gt;</code> 和 <code>&lt;clinit&gt;</code> 造成的。</p><ol><li><code>&lt;clinit&gt;</code> 主要针对我们当前类的初始化, 而 <code>&lt;init&gt;</code> 主要针对我们当前类的实例的初始化, 而且他的初始会先调用父级的无参 <code>&lt;init&gt;</code> 方法。  </li><li>这里的初始化指的是类中的属性直接赋值执行, 代码块执行, 构造函数执行, 这三个执行最终会整合到<code>&lt;init&gt;</code>(实例相关的), 或者<code>&lt;clinit&gt;</code>(静态相关的), 并按照的执行顺序执行</li><li>类加载机制中, 会先加载父类, 再加载子类。</li></ol><p>从 new Son() 时, 先加载 Parent 对应的类, 然后调用 Parent 的<code>&lt;clinit&gt;</code> 方法</p><ol><li><p>在 Parent 的 <code>&lt;clinit&gt;</code> 方法</p><blockquote><p>1.1 执行 Parent 的属性直接赋值, 给 pNum1 赋值为 10<br>1.2 执行 Parent 的静态代码块, 给 pNum2 赋值为 11<br>1.3 静态代码块和直接赋值没有层级关系, 谁在前谁先, 如果这时静态代码块在直接赋值前, 那么先给 pNum2 赋值 (代码块和实例属性也是遵循这个规则)</p></blockquote></li><li><p>调用 Son 的 <code>&lt;clinit&gt;</code> 方法</p><blockquote><p>2.1 执行 Son 的属性直接赋值, 给 sNum1 赋值为 20<br>2.2 执行 Son 的静态代码块, 给  sNum1 赋值为 21</p></blockquote></li><li><p>执行 Son 的 <code>&lt;init&gt;</code> 方法</p><blockquote><p>3.1 <code>&lt;init&gt;</code> 第一步会直接调用他的直接父级的 <code>&lt;init&gt;</code> 方法, 也就是 Parent 的 <code>&lt;init&gt;</code> 方法, 然后调用自身的代码块执行, 再构造函数执行 (Parent 的 <code>&lt;init&gt;</code> 还会调用父类的, 这里省略)<br>3.2 Parent 的 <code>&lt;init&gt;</code> 方法, 先执行属性直接赋值, pNum2 赋值为 10<br>3.3 Parent 的 <code>&lt;init&gt;</code> 方法, 执行 Parent 的代码块, pNum2 赋值为 12<br>3.3 Parent 的 <code>&lt;init&gt;</code> 方法, 执行 Parent 的构造函数, pNum2 赋值为 13<br>3.4 Parent 的 <code>&lt;init&gt;</code> 执行完成, 执行 Son 自己的 <code>&lt;init&gt;</code> 方法, 直接属性赋值, sNum2 赋值为 20<br>3.5 Son 的代码块, sNum2 赋值为 22<br>3.6 Son 的构造函数, sNum3 赋值为 23</p></blockquote></li></ol><p>从上面的例子, 应该可以区分出 <code>&lt;clinit&gt;</code> 和 <code>&lt;init&gt;</code> 的作用和区别了吧<br>2 个方法都是编译器, 对我们编写的初始的整合, static 属性赋值和静态代码块整合为 <code>&lt;clinit&gt;</code>, 实例属性赋值, 代码块和构造方法整合为 <code>&lt;init&gt;</code>, 而且 <code>&lt;init&gt;</code> 方法会先调用直接父级的 init 的方法。</p><p>到此, 所有的内容就整理完成了。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p>《深入理解Java虚拟机》- 周志明<br><a href="https://my.oschina.net/u/4942072/blog/4903326">Java对象的创建过程详解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM 实例对象内存布局</title>
      <link href="/article/2021/2216518655/"/>
      <url>/article/2021/2216518655/</url>
      
        <content type="html"><![CDATA[<p>当 Java 应用启动后, 基本就是在不断的创建对象, 回收对象的过程中。<br>而这些创建的对象基本都是存放在应用的堆 (heap) 中, 但是这些对象在堆中又是什么样子的呢?<br>在这篇文章中, 我们分析一下 Java JVM 中实例对象的内存布局。</p><p>在 HotSpot 虚拟机里, 对象在堆内存中的存储布局可以划分为三个部分: 对象头 (Object Header), 实例数据 (Instance Data) 和对齐填充 (Padding)。</p><p>大体的样子如下:<br><img src="https://pic.imgdb.cn/item/657d3c11c458853aefd22d57.png" alt="Alt &#39;JVM 实例的内存布局&#39;"> </p><h2 id="1-对象头-Object-Header"><a href="#1-对象头-Object-Header" class="headerlink" title="1 对象头 (Object Header)"></a>1 对象头 (Object Header)</h2><p>Java 实例的对象头主要包含 2&#x2F;3 个部分, 如果是对象的话, 只包含 2 部分 Mark Word 和 Klass Pointer, 如果是数组的话, 还会多一个 Array Length。</p><p><strong>Mark Word</strong><br>用于存储对象自身的运行时数据, 如哈希码 (HashCode), GC 分代年龄, 锁状态标志, 线程持有的锁, 偏向线程 ID, 偏向时间戳等。<br>这一部分在 32 位系统里面的大小为 4 个字节, 而 64 位系统里面则为 8 个字节。</p><p><strong>Klass Pointer</strong><br>类型指针, 即对象指向它的类型元数据的指针, Java 虚拟机通过这个指针来确定该对象是哪个类的实例 (并不是所有的虚拟机实现都必须在对象数据上保留类型指针, 即查找对象的元数据信息并不一定要经过对象本身)。<br>这一部分在 32 位系统里面的大小为 4 个字节, 而 64 位系统里面则为 8 个字节。</p><p><strong>Array Length</strong><br>当我们的对象实例是数组对象的话, 对象头里面还会有一个用于记录数组长度的数据, 大小为 4 个字节, 主要用于确定对象的大小。因为普通的 Java 对象可以通过<br>元数据 (即类中的属性, int 32 位, long 32 位, 所以通过属性基本可以确定一个类实例的大小) 推算出对象的大小, 但是数组的长度不确定时, 无法推算出数组的大小。  </p><p>在 32 位系统中, HotSpot 里面的 Mark Work 正常情况 (对象没有被加锁, 即没有被 synchronized 加锁) 的分布如下:</p><p><img src="https://pic.imgdb.cn/item/657d3c0dc458853aefd22028.png" alt="Alt &#39;32 位系统无锁状态 MarkWord 的结构&#39;"></p><p>64 位系统的话, 如图:<br><img src="https://pic.imgdb.cn/item/657d3c0fc458853aefd22667.png" alt="Alt &#39;64 位系统无锁状态 MarkWord 的结构&#39;"></p><p>注: Mark Work 的内容不是一成不变的, 如果对象被当做 synchronized 锁的话, 其内部的内容会随锁的状态变更。</p><p>对象头一般情况下的大小:</p><p>32 位系统下: Class Pointer 4 个字节, MarkWord 4 个字节, 对象头为 8 个字节, 如果是数组的话, 再加上 4 个字节的数组长度。<br>64 位系统下: Class Pointer 8 个字节, MarkWord 8 个字节, 对象头为 16 个字节, 如果是数组的话, 再加上 4 个字节的数组长度。  </p><p>Java 中还有一项技术会影响到对象头的大小: <strong>指针压缩技术</strong>, 看后面的介绍。</p><h2 id="2-实例数据-Instance-Data"><a href="#2-实例数据-Instance-Data" class="headerlink" title="2 实例数据 (Instance Data)"></a>2 实例数据 (Instance Data)</h2><p>对象真正有效的信息, 也就是我们类中声明的各个字段 (包括从父类继承下来的), 每个字段都有自己的大小限制。</p><table><thead><tr><th align="center">字段类型</th><th align="center">内存大小(单位: 字节)</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center">1</td></tr><tr><td align="center">byte</td><td align="center">1</td></tr><tr><td align="center">short</td><td align="center">2</td></tr><tr><td align="center">char</td><td align="center">2</td></tr><tr><td align="center">int</td><td align="center">4</td></tr><tr><td align="center">float</td><td align="center">4</td></tr><tr><td align="center">long</td><td align="center">8</td></tr><tr><td align="center">double</td><td align="center">8</td></tr><tr><td align="center">reference(引用类型)</td><td align="center">4 (32 位系统), 8 (64 位系统)</td></tr></tbody></table><p>通过上面的大小的字段类型的, 基本可以确定每个对象的实际数据大小 (静态属性维护在类 (也就是具体的 Class 上)上, 所以不算在对象大小里面)。</p><p>每个实例的属性在内存的存储顺序会受到虚拟机的分配策略影响 (-XX:FieldsAllocationStyle) 和字段在 Java 源码中定义的顺序的影响。<br>HotSpot 虚拟机默认的分配顺序为 long&#x2F;double, int&#x2F;float, short&#x2F;char, byte&#x2F;boolean, reference。<br>在满足这个前提条件下, 父类中定义的变量会在子类的前面。<br>如果 HotSpot 虚拟机的 +XX:CompactFields 参数值为 true (默认为 true), 那子类之中较窄的变量也允许插入父类变量的空隙之中, 以节省出一点点空间。</p><p>举个列子, 当前父类有 2 个属性 long 和 int, 子类有 3 个属性 int, short, short。<br>如果按照上面的规则 4 个属性在内存的分配顺序为 long (8 个字节) int (4 个字节) int (4 个字节) short (2 个字节) short (2 个字节)。<br>+XX:CompactFields 设置为 true 后, 分配的顺序可能变为 long (8 个字节) int (4 个字节) short (2 个字节) short (2 个字节) int (4 个字节)。<br>子类 2 个 short 属性插入到父类的变量空隙中了。</p><h2 id="3-对齐填充-Padding"><a href="#3-对齐填充-Padding" class="headerlink" title="3 对齐填充 (Padding)"></a>3 对齐填充 (Padding)</h2><p>这个不是必须, 也没有具体的含义, 只是单纯的起占位作用。他的出现与否取决于当前对象实例的内存大小。<br>所有的 Java 对象所占用的字节数必须是 8 的倍数。比如 一个对象的对象头的大小为 12 byte, 实例数据为 13 byte, 当前对象所占的大小为 25 byte。<br>但是 JVM 要求每个对象的大小必须是 8 的倍数, 这时候 padding 就其作用了, 填充 7 个字节, 凑够 32, 达到 8 的倍数。<br>而当对象头和实例数据刚好达到 8 的倍数, 这时候就不需要 padding 了。</p><p>之所以强制为对象大小为 8 的倍数是为了内存访问的效率, 数据对齐对处理器的访问是最佳的。</p><h2 id="4-指针压缩-CompressedOops"><a href="#4-指针压缩-CompressedOops" class="headerlink" title="4 指针压缩 (CompressedOops)"></a>4 指针压缩 (CompressedOops)</h2><p>在了解指针压缩之前, 先了解一点别的。<br>我们在买电脑的时候, 很多时候都会说<strong>多少位系统, 内存是多少的</strong>, 比如 64 位系统 16g 内存, 32 位系统 4g 内存。<br>那么是否存在 32 位系统 16g 内存, 64 位系统 64g 的内存呢?  </p><p>这里面涉及一点计算机的知识。32 位系统最大支持的内存为 4g, 64 位系统最大支持的则为 1T。能支持的内存的大小取决于 CPU 的寻址能力。  </p><p>CPU 的寻址能力以<strong>字节</strong>为单位。  </p><ol><li>内存把 8 个比特 (8 bit) 排成一组, 每一组为一个单位, 记为一个字节 (Byte), CPU 每次只能访问去访问一个字节 (Byte), 不能去访问每一个比特</li><li>计算机系统会给内存中的每一个<strong>字节</strong>分配一个内存地址, CPU 只要知道某个数据类型的地址, 就可以到地址所指向的内存去读取数据</li><li>在 32 位系统中, 内存地址就是 32 位的二进制数, 既从 0x00000000 到 0xFFFFFFFF, 即一共有 2^32 个地址, 每个地址对应一个字节</li><li>32 位系统的 2^32 个地址, 对应了 2^32 个字节, 也就是 4GB 的内存 (如果给 32 位系统配上了 8G 内存, 操作系统最多只能给其中的 4GB 分配地址, 其他 4GB 是没有地址的)</li></ol><p>而我们常说的<strong>指针</strong>, 在程序中内存地址映射, 可以理解一个指针就对应了一个内存地址。通过指针就能定位到内存对应的某个位置。<br>在 32 位系统, 指针的大小只要 4 个字节就能包含所有的地址了, 同样的 64 位系统, 指针的大小只要 8 个字节就够了。</p><p>OK, 聊完了。下面就开始真正的指针压缩的分析!</p><p>在 JVM 中, 32 位系统的对象引用 (指针) 占 4 个字节 (4 个字节已经能够囊括所有的内存地址), 而 64 位系统的对象引用占 8 个字节。<br>也就是说, 64 位的对象引用大小是 32 位的 2 倍。<br>64 位 JVM 在支持更大堆内存的同时, 由于对象引用指针的变大却带来了其他的性能问题, 如对象占用的内存变大, 降低 CPU 缓存命中率等。  </p><p>为了能够利用 64 位系统的大内存的前提, 又能使用到 32 位系统的的小内存引用指针, 就有了压缩指针 (CompressedOops) 技术 (在 64 位的机器上使用 32 位的引用的同时, 使用超过 4g 的内存)。  </p><p>要达到这个的前提:<br>Java 中实例对象的内存大小都是 8 的倍数, 一个数是 8 的倍数的话, 那么其二进制的表示的后面三位必定是 3 个 000 (8-&gt;1000, 16-&gt;10000)。</p><p>JVM 知道每个 Java 对象的大小都是 8 的倍数, 正常存储的话, 每个的指针最后的 3 为必定都是 0, 那么这最后的 3 位完全没必要存了。<br>32 位的引用空出来的 3 位, 完全可以用来存储多 3 位数据, 既将一个 35 位的指针用 32 位的形式存储在 JVM 中。</p><p><img src="https://pic.imgdb.cn/item/657d3c14c458853aefd2385b.png" alt="Alt &#39;35 位指针达到 32 位指针的效果&#39;"></p><p>落实到实现中就是, 将引用的数字向左移动 3 位, 得到真正的内存地址, 通过这个转换就能实现指针和真正的内存进行关联。<br>比如我们堆中某个变量的指针为 0, 那么都内存中的 0 (00000000 &lt;&lt; 3, 还是 0) 的位置就能找到这个对象的实际内容。<br>变量的指针为 1, 那么到内存 8 (00000001 &lt;&lt; 3, 00001000, 十进制 8) 的位置查找就行了。</p><p>说到底, 压缩指针的前提就是存储的内容本身是一个指针引用, 那么在 Java 实例中, 哪些数据是指针引用呢</p><blockquote><ol><li>the klass field of every object (每个普通对象对象头里面的 Klass Pointer)</li><li>every oop instance field (每个普通对象的属性)</li><li>every element of an oop array (objArray) (每个普通对象数组里面的每个元素)</li></ol></blockquote><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p>《深入理解Java虚拟机》- 周志明<br><a href="https://www.jianshu.com/p/355374e03fb3">为什么32位系统最大只支持4G内存</a><br><a href="https://wiki.openjdk.java.net/display/HotSpot/CompressedOops">CompressedOops</a><br><a href="https://www.baeldung.com/jvm-compressed-oops">Compressed OOPs in the JVM</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM 运行时数据区</title>
      <link href="/article/2021/197956317/"/>
      <url>/article/2021/197956317/</url>
      
        <content type="html"><![CDATA[<p>JVM 在执行 Java 程序的过程中会把它管理的内存分为若干个不同的数据区域, 这些区域有着各自的用途。<br>根据《Java虚拟机规范》中规定, JVM 所管理的内存大致包括以下几个运行时数据区域, 如图所示:<br><img src="https://pic.imgdb.cn/item/657d2463c458853aef6e0d8c.png" alt="Alt &#39;JVM 运行时数据区&#39;"><br>这个运行时数据区被分为了 5 大块</p><blockquote><ol><li>方法区 (Method Area)</li><li>堆 (Heap)</li><li>虚拟机栈 (Virtual Machine Stacks)</li><li>本地方法栈 (Native Method Stacks)</li><li>PC 寄存器 (Program Counter Register)</li></ol></blockquote><p>其中: 绿色部分是各个线程之间独享的部分, 而蓝色部分是所有线程共享的区域。</p><h2 id="1-PC-寄存器-Program-Counter-Register"><a href="#1-PC-寄存器-Program-Counter-Register" class="headerlink" title="1 PC 寄存器  (Program Counter Register)"></a>1 PC 寄存器  (Program Counter Register)</h2><ol><li><p>程序计数器是一块较小的内存分区, 你可以把它看做当前线程所执行的字节码的指示器(类似于, 记录了线程执行到了哪个位置, 下一步的位置)。在虚拟机的概念模型里, 字节码解释器工作时, 就是通过改变计数器的值来选择下一条需要执行的字节码指令。</p></li><li><p>程序技术器为线程私有, 每个线程都有它们各自的程序计数器, 这样在多线程的情况下, 线程之间的来回切换, 也能正确找到上次切换时执行的位置。</p></li><li><p>如果线程正在执行的是一个 Java 方法, 那么程序计数器记录的是当前线程正在执行的字节码指令的地址; 如果线程正在执行的是一个 native 方法, 则计数器值为空。</p></li><li><p>此内存区域是唯一一个 Java 虚拟机规范中没有规定任何 OutOfMemoryError (OOM) 情况的区域。</p></li></ol><h2 id="2-虚拟机栈-Virtual-Machine-Stacks"><a href="#2-虚拟机栈-Virtual-Machine-Stacks" class="headerlink" title="2 虚拟机栈 (Virtual Machine Stacks)"></a>2 虚拟机栈 (Virtual Machine Stacks)</h2><ol><li><p>虚拟机栈是线程私有的, 它的生命周期与线程相同。</p></li><li><p><strong>虚拟机栈可以看做是 Java 方法执行的内存模型: 每个方法执行的同时都会创建一个栈帧用于存储局部变量表, 操作数栈, 动态链接, 方法返回等信息</strong>。 一个 Java 方法从调用到执行完的过程, 就对应着一个栈帧从虚拟机栈入栈到出栈的过程。 </p></li><li><p>局部变量表中存放了编译期可知的基本数据类型, 对象引用, returnAddress 类型 (指向了一条字节码指令的地址)。局部变量表里面的数据类型的存储空间是以槽 (Slot) 表示的, 64 位的 long 和 double 类型占 2 个槽, 其他的只占 1 个。局部变量表所需的内存空间在编译器就完成分配了, 运行期间不会改变局部变量表的大小, 既槽的个数是确定的 (但是一个槽的所占的空间大小, 则是有 JVM 自行实现的, 可以是 32b, 64b 等)。</p></li><li><p>在虚拟机栈中可能会出现两种异常：StackOverflowError 和 OutOfMemory。</p><blockquote><p>4.1 如果线程请求的栈深度大于当前 JVM 所允许的深度, 会抛出 StackOverflowError 异常<br>4.2 虚拟机栈可以动态扩展, 当扩展时无法申请到足够的内存, 会抛出 OutOfMemory 异常</p></blockquote></li></ol><h2 id="3-本地方法栈-Native-Method-Stacks"><a href="#3-本地方法栈-Native-Method-Stacks" class="headerlink" title="3 本地方法栈 (Native Method Stacks)"></a>3 本地方法栈 (Native Method Stacks)</h2><ol><li><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的, 其区别只是虚拟机栈为 JVM 执行 Java 方法服务, 而本地方法栈则是为虚拟机使用到的本地 (Native) 方法服务。</p></li><li><p>在 HotSpot 虚拟机中直接把本地方法栈和虚拟机栈合二为一。</p></li><li><p>同样的本地方法栈也会抛出 StackOverflowError 和 OutOfMemory。</p></li></ol><h2 id="4-堆-Heap"><a href="#4-堆-Heap" class="headerlink" title="4 堆 (Heap)"></a>4 堆 (Heap)</h2><ol><li><p>JVM 只有一个堆, 同样的所有的线程共享这个堆, 他的生命周期同样和 JVM 一样。</p></li><li><p>堆主要存放的是类的实例和被分配的数组数据。</p></li><li><p>堆是 JVM 中内存最大的一块, 也是垃圾回收管理的主要区域, 堆在物理上是可以为不连续的内存空间, 只要逻辑上连续即可。</p></li><li><p>堆的实现是可以固定大小, 也可以是动态扩展的, 当堆的内存使用完了, 同样会抛出 OutOfMemoryError。</p></li></ol><h2 id="5-方法区-Method-Area"><a href="#5-方法区-Method-Area" class="headerlink" title="5 方法区 (Method Area)"></a>5 方法区 (Method Area)</h2><ol><li><p>JVM 只有一个方法区, 所有的线程共享着这个唯一的方法区, 他的生命周期和 JVM 一样。</p></li><li><p>方法区用于存储已被 JVM 加载的类型信息, 常量, 静态变量, 即时编译器编译后的代码等数据。</p></li><li><p>方法区逻辑上是属于堆的一部分, 它却有一个别名叫作 “非堆” (Non-Heap), 用于区分堆 (Heap)。</p></li><li><p>方法区中, 垃圾回收比较少见, 但并不是不进行 GC, 这个区域的回收目标主要是针对常量池的回收和对类的卸载, 当方法区内存不足时, 会导致 OutOfMemoryError (OOM)。</p></li><li><p>《Java虚拟机规范》对方法区的约束是非常宽松的, 所以导致对不同的 JVM 对这个区域的实现有差异。比如: HotSpot 用永久代来实现方法区, 但是其他的 JVM 没有这种方式, 不存在永久代的概念的。</p></li></ol><p><strong>说到 HotSpot, 就不能不说不同 JDK 版本下, 方法区的实现和几个常量池的概念。</strong></p><h3 id="5-1-HotSpot-方法区的实现"><a href="#5-1-HotSpot-方法区的实现" class="headerlink" title="5.1 HotSpot 方法区的实现"></a>5.1 HotSpot 方法区的实现</h3><p>在 JDK8 之前, HotSpot 方法区是通过永久代的方式实现的, 但是到了 JDK8, 方法区的实现改为元空间 (MetaSpace) 的方式, 同时从以前的堆空间移到了本地内存 (Native memory) 中。</p><p>Metaspace 的组成</p><blockquote><ol><li>Klass Metaspace: 就是用来存 klass 的, klass 是我们熟知的 class 文件在 JVM 里的运行时数据结构, 这个区域不一定有的, 只有开启<strong>压缩指针</strong>, 同时 <code>-Xmx</code> (设定程序运行期间最大可占用的内存大小) 小于等于 32G (大于这个临界值, 会导致压缩指针关闭), 才会有这个区域</li><li>NoKlass Metaspace: 专门来存 klass 相关的其他的内容, 比如 method, constantPool 等, 虽然叫做 NoKlass Metaspace, 但是也其实可以存 klass 的内容。当然了, 如果没有 Metaspace 的时候, klass 内容也会存储在这里。</li></ol></blockquote><p>上面说的临界值 32G 的确定, 可以看这里 <a href="https://blog.csdn.net/liujianyangbj/article/details/108049482">聊一聊JAVA指针压缩的实现原理 (图文并茂, 让你秒懂)</a></p><h3 id="5-2-常量池-Constant-Pool"><a href="#5-2-常量池-Constant-Pool" class="headerlink" title="5.2 常量池(Constant Pool)"></a>5.2 常量池(Constant Pool)</h3><p>在 JVM 中关于常量池的关键字有 <strong>class 常量池</strong>, <strong>字符串常量池</strong>, <strong>运行时常量池</strong>。</p><h4 id="5-2-1-class-常量池"><a href="#5-2-1-class-常量池" class="headerlink" title="5.2.1 class 常量池"></a>5.2.1 class 常量池</h4><p>这里的 class 常量池, 主要指的是 class 文件里面的常量池。<br>当我们的 .java 文件编译为 .class 文件后, .class 文件里面有一个常量池的项,<br>用于存放编译器生成的各种字面量 (Literal) 和符号引用 (Symbolic References)。  </p><p>字面量: 各种常量, 如文本字符串, final 的常量值。<br>符号引用: 一组符号描述所引用的目标。  </p><p>class 常量池的内容, 如图<br><img src="https://pic.imgdb.cn/item/657d2464c458853aef6e11f1.png" alt="Alt &#39;常量池项包含的内容&#39;"><br>在 .class 文件中的样子大体如下</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Constant</span> pool<span class="token operator">:</span>   #<span class="token number">1</span> <span class="token operator">=</span> <span class="token class-name">Methodref</span>          #<span class="token number">4.</span>#<span class="token number">13</span>         <span class="token comment">// java/lang/Object."&lt;init>":()V</span>   #<span class="token number">2</span> <span class="token operator">=</span> <span class="token class-name">Methodref</span>          #<span class="token number">3.</span>#<span class="token number">14</span>         <span class="token comment">// SymbolicReference.fn2:()V</span>   #<span class="token number">3</span> <span class="token operator">=</span> <span class="token class-name">Class</span>              #<span class="token number">15</span>            <span class="token comment">// SymbolicReference</span>   #<span class="token number">4</span> <span class="token operator">=</span> <span class="token class-name">Class</span>              #<span class="token number">16</span>            <span class="token comment">// java/lang/Object</span></code></pre><h4 id="5-2-2-字符串常量池-String-Constant-Pool"><a href="#5-2-2-字符串常量池-String-Constant-Pool" class="headerlink" title="5.2.2 字符串常量池 (String Constant Pool)"></a>5.2.2 字符串常量池 (String Constant Pool)</h4><p>在 JVM 中有一个字符串常量池, 在我们平常创建字符串时, 会先到这个字符串池中查看是否已有相关的字符串了, 有的话直接使用这个字符串, 没有再创建然后加入到这个字符串常量池中。</p><p>在 HotSpot 里实现的<strong>字符串常量池功能</strong>的是一个 StringTable 类, 它是一个 Hash 表, 默认值大小长度是 1009  (JDK7 及后面的版本可以通过参数进行修改)。</p><p>这个 StringTable 在每个 HotSpot 的实例只有一份, 被所有的类共享。</p><p>当类加载到了 JVM 后, 类中涉及到的字符串常量, 在堆中生成字符串对象实例, 会将这些字符串对象实例的引用值存到字符串常量池中, 既存到 StringTable 中。<br>也就是我们的字符串常量<strong>具体的值</strong>是放在<strong>堆</strong>中的, 但是会有个<strong>引用</strong>指向它, 同时这个引用存放在 <strong>StringTable</strong> 中。</p><p> Java 有一道经典的题目</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"s1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>一共创建的多少个对象? 里面就涉及到对应的字符串是否已经在字符串常量池中存在。<br>具体的分析可以看一下这篇文章: <a href="https://cloud.tencent.com/developer/article/1686226">面试题系列第2篇：new String()创建几个对象？有你不知道的</a></p><h4 id="5-2-3-运行时常量池-Runtime-Constant-Pool"><a href="#5-2-3-运行时常量池-Runtime-Constant-Pool" class="headerlink" title="5.2.3 运行时常量池 (Runtime Constant Pool)"></a>5.2.3 运行时常量池 (Runtime Constant Pool)</h4><p>当类加载到内存中后, JVM 就会将 class 文件的常量池中的内容存放到运行时常量池中。<br>运行时常量池相对于 class 文件常量池的另外一个重要特征是具备动态性</p><blockquote><ol><li>class 文件常量池的符号引用存在运行时常量池中, 经过解析之后, 也就是把符号引用替换为直接引用</li><li>运行期间也可以将新的常量放入池中, 比如 String 的 intern() 方法</li></ol></blockquote><p>在 JDK8 之前 运行时常量池都是存放在方法区中, JDK8 及后面版本, 则将运行时常量池放到了堆中。</p><p>所以 HotSpot 在 JDK8 的时候, 运行时数据区是这样的<br><img src="https://pic.imgdb.cn/item/657d2461c458853aef6e08a0.png" alt="Alt &#39;JDK8 运行时数据区&#39;"></p><h3 id="6-直接内存-Direct-Memory"><a href="#6-直接内存-Direct-Memory" class="headerlink" title="6 直接内存 (Direct Memory)"></a>6 直接内存 (Direct Memory)</h3><p>HotSpot 在JDK8 中, 将方法区的实现修改为了元空间的方式, 同时将元空间的存储移到了直接内存。</p><p>直接内存 (Direct Memory) 并不是虚拟机运行时数据区的一部分, 也不是《Java虚拟机规范》中定义的内存区域。</p><p>本机的直接内存的分配不会受到 Java 堆大小的限制, 但是会受到本机总内存的影响, 所以在内存不够的时候, 也会导致 OutOfMemoryError 异常。</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h2><p>《深入理解Java虚拟机》- 周志明</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Throwable</title>
      <link href="/article/2020/1567550520/"/>
      <url>/article/2020/1567550520/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic.imgdb.cn/item/656b18bac458853aefa00f2a.png" alt="Alt &#39;Java Throwable UML 图&#39;"></p><p>如图展示了 Java 整个异常体系的关系。</p><p>Throwable 的 Java 异常体系的基类, 他的直接子类有 Error 和 Exception 2 个。 </p><h2 id="1-Error"><a href="#1-Error" class="headerlink" title="1 Error"></a>1 Error</h2><p>Error 表示的是由于系统错误, Java 虚拟机抛出的异常, 例如 Java 虚拟机崩溃, 内存不够等, 这种情况仅凭程序自身是无法处理的, 在程序中也不会对 Error 异常进行捕捉和抛出。   </p><p>常见的实现有</p><blockquote><ol><li>OutOfMemoryError</li><li>StackOverflowError</li><li>IOError</li></ol></blockquote><h2 id="2-Exception"><a href="#2-Exception" class="headerlink" title="2 Exception"></a>2 Exception</h2><p>Exception 一般是由程序逻辑错误引起的，需要从程序逻辑角度进行处理, 尽可能避免这类异常的发生。   </p><p>总体可以细分为 2 类 RuntimeException (运行时异常) 和 非 RuntimeException (非运行时异常),<br>也叫做 CheckedException (检查时异常)。</p><h3 id="2-1-RuntimeException"><a href="#2-1-RuntimeException" class="headerlink" title="2.1 RuntimeException"></a>2.1 RuntimeException</h3><p>程序运行过程中才可能发生的异常, 一般为代码的逻辑错误: 空指针, 类型错误转换，数组下标访问越界，网络端口被占用等。 这里异常在代码编译期是无感知, 无法检查出来的, 只有在实际运行代码时则会暴露出来。</p><p>常见的实现有</p><blockquote><ol><li>ArrayIndexOutOfBoundsException</li><li>ClassCastException</li><li>NullPointerException</li></ol></blockquote><p>在编译期间, 一般不会强制要求处理这种异常。</p><h3 id="2-2-非-RuntimeException-CheckedException"><a href="#2-2-非-RuntimeException-CheckedException" class="headerlink" title="2.2 非 RuntimeException (CheckedException)"></a>2.2 非 RuntimeException (CheckedException)</h3><p>编译期间可以检查到的异常, 必须显式的进行处理</p><blockquote><ol><li>通过 try - catch 进行捕获处理</li><li>通过 throw - throws 抛出给上一层</li></ol></blockquote><p>常见的实现有  </p><blockquote><ol><li>IOException</li><li>InterruptedException</li><li>NoSuchMethodException</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL like 走不走索引的特殊情况</title>
      <link href="/article/2020/3873969322/"/>
      <url>/article/2020/3873969322/</url>
      
        <content type="html"><![CDATA[<p>在 MySQL 使用 InnoDB 的引擎的情况下, 对某一建过索引的列进行 like 模糊查询时, 一般情况下</p><blockquote><ol><li>like “%XX” 是不会走索引的</li><li>like “XX%” 还是会走索引的</li></ol></blockquote><p>但是还是存在一些特殊的情况, MySQL 的底层会帮我们优化, 使上面的 2 条结论变成不一定, 下面做一个小小的总结。</p><h2 id="1-表结构-SQL"><a href="#1-表结构-SQL" class="headerlink" title="1 表结构 SQL"></a>1 表结构 SQL</h2><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span>  <span class="token identifier"><span class="token punctuation">`</span>test_table<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span> <span class="token keyword">unsigned</span> <span class="token keyword">auto_increment</span> <span class="token keyword">comment</span> <span class="token string">'主键'</span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">comment</span>  <span class="token string">'姓名'</span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">tinyint</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'年龄'</span><span class="token punctuation">,</span><span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">unique</span> <span class="token identifier"><span class="token punctuation">`</span>name_index<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span> <span class="token keyword">INNODB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span></code></pre><h2 id="2-like-“-XX”-走索引"><a href="#2-like-“-XX”-走索引" class="headerlink" title="2 like “%XX” 走索引"></a>2 like “%XX” 走索引</h2><p>执行 SQL</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 第一句</span><span class="token keyword">explain</span> <span class="token keyword">SELECT</span> <span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">`</span>test_table<span class="token punctuation">`</span></span> <span class="token keyword">WHERE</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token operator">like</span> <span class="token string">'%123'</span><span class="token punctuation">;</span><span class="token comment"># 第二句</span><span class="token keyword">explain</span> <span class="token keyword">SELECT</span> <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">`</span>test_table<span class="token punctuation">`</span></span> <span class="token keyword">WHERE</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token operator">like</span> <span class="token string">'%123'</span><span class="token punctuation">;</span><span class="token comment"># 第三句</span><span class="token keyword">explain</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">`</span>test_table<span class="token punctuation">`</span></span> <span class="token keyword">WHERE</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token operator">like</span> <span class="token string">'%123'</span><span class="token punctuation">;</span></code></pre><p><strong>第一句</strong>的执行计划为:</p><table><thead><tr><th align="center">id</th><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">SIMPLE</td><td align="center">test_table</td><td align="center"></td><td align="center">index</td><td align="center"></td><td align="center">name_index</td><td align="center">32</td><td align="center"></td><td align="center">1</td><td align="center">100</td><td align="center">Using where; Using index</td></tr></tbody></table><p>从 <code>type = index</code> 和 <code>key = name_index</code> 可以知道走了索引。<br>为什么呢? 一般情况下的确是不会走索引的, 但是这里刚好满足了一个情况：”覆盖索引”。在后面的 Extra 说明了这条 SQL 走了覆盖索引。</p><p>在理解这个问题前, 只要知道几个概念就能解决了。</p><h3 id="2-1-主键索引和二级索引"><a href="#2-1-主键索引和二级索引" class="headerlink" title="2.1 主键索引和二级索引"></a>2.1 主键索引和二级索引</h3><p>在基于 InnoDB 为引擎的 MySQL 的索引是基于 B+Tree 实现的, 同时在基于 B+Tree 的基础上有 2 种实现方式: </p><blockquote><ol><li>主键索引: 简单理解的话, 就是通过 <code>primary key</code> 创建的索引, 在 <code>test_table</code> 里面就是我们的 id </li><li>二级索引: 可以简单的理解为除了主键索引以外的索引类型, 比如：普通索引, 复合索引, 唯一索引等,  在 <code>test_table</code> 里面就是唯一索引 name</li></ol></blockquote><p>其中主键索引的实现是这样的是(注这是简略版):<br><img src="https://pic.imgdb.cn/item/6555b308c458853aef0ae67a.png" alt="Alt &#39;主键索引实现&#39;"></p><p>在树的非叶子节点, 存放的就是我们的主键的值, 而叶子节点存放的是主键和主键对应的数据行。</p><p><strong>【注】</strong>：想要真正了解 B+Tree 所有的话, 可以看一下<a href="https://blog.csdn.net/u013235478/article/details/50625677">这里</a></p><p>二级索引的实现是这样的(同样的, 这也是简略版):  </p><p><img src="https://pic.imgdb.cn/item/6555b30fc458853aef0afa51.png" alt="Alt &#39;二级索引实现&#39;"></p><p>在树的非叶子节点, 存放的是索引的值, 而叶子节点存放的是索引的值 + 对应的行的主键 Id。(所以平时在使用非主键索引查询数据时, 都是在二级索引的 B+Tree 里面找到了对应的行的主键 Id, 在通过这个 Id 到主键索引的 B+Tree 查找)</p><h3 id="2-2-覆盖索引"><a href="#2-2-覆盖索引" class="headerlink" title="2.2 覆盖索引"></a>2.2 覆盖索引</h3><p>定义: 指一个查询语句的执行只需要从索引中就可以得到查询记录, 而不用从数据表中读取。也可以称之为实现了索引覆盖。</p><p>举个例子：一张表</p><table><thead><tr><th align="center">id</th><th align="center">first_name</th><th align="center">last_name</th><th align="center">birthday</th><th align="center">sex</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">can</td><td align="center">lee</td><td align="center">2020-03-23</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">cn</td><td align="center">l</td><td align="center">2020-02-23</td><td align="center">2</td></tr></tbody></table><p>在这种表中, 我们建立了一个复合索引 index(‘first_name’, ‘last_name’, ‘birthday’);<br>然后查询的时候 <code>select first_name, last_name from 表名 where first_name like &quot;c%&quot;; </code> 这时观察我们的 SQL 发现了需要的几列刚好是我们复合索引里面有的。<br>这时 MySQL 就会在我们的 B+Tree 的非叶子节点找到了需要的数据了, 直接返回, 而不用到叶子节点去取数据, 这就是 “覆盖索引”。</p><p>从中我们知道: 覆盖索引不是一种索引, 更类似于一种行为。</p><p>需要理解的 2 个概念都讲完了, 那么为什么 like “%XX” 走索引的情况, 应该可以分析出来了。</p><blockquote><ol><li>查询的是列有 id, name, 查询的条件为 name like “%123”。</li><li>在 name 上面建了唯一索引, 也就是二级索引</li><li>在这里二级索引的叶子节点存放的是 name + id</li><li>需要的列数据在二级索引树的叶子节点就有了, 那么 MySQL 直接去遍历索引也能找到数据了, 而不用直接全表扫描。</li></ol></blockquote><p>所以这里走了索引。</p><p><strong>第二句</strong>的执行计划  </p><table><thead><tr><th align="center">id</th><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">SIMPLE</td><td align="center">test_table</td><td align="center"></td><td align="center">ALL</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center">100</td><td align="center">Using where</td></tr></tbody></table><p>就是我们平时常说的 like “%XX” 不走索引的情况了。</p><p><strong>第三句</strong>的分析, 类似的情况</p><h2 id="3-like-“XXX-”-不走索引"><a href="#3-like-“XXX-”-不走索引" class="headerlink" title="3 like “XXX%” 不走索引"></a>3 like “XXX%” 不走索引</h2><p>依旧是上面的 <code>test_table</code> 表, 我们先通过一个存储过程, 给这张表填充一些数据</p><p>新建一个存储过程: 给表里面填充 140 条数据, 每条的 name 的前缀都是 ‘name’ + 数字</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">delimiter</span>  <span class="token comment">//</span><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> insertdata<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">begin</span><span class="token keyword">declare</span> tempName <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">DECLARE</span> sourceStr <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">declare</span> count <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token keyword">set</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">WHILE</span> count <span class="token operator">&lt;</span><span class="token number">140</span> <span class="token keyword">DO</span><span class="token keyword">set</span> tempName<span class="token operator">=</span>CONCAT<span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">set</span> count <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> test_table<span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>tempName<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token comment">//</span></code></pre><p>执行存储过程, 填充数据</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">call</span> insertdata<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>准备完成, 开始</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> test_table <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'name%'</span><span class="token punctuation">;</span></code></pre><p>他的执行计划是这样的</p><table><thead><tr><th align="center">id</th><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">SIMPLE</td><td align="center">test_table</td><td align="center"></td><td align="center">ALL</td><td align="center">name_index</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">140</td><td align="center">100</td><td align="center">Using where;</td></tr></tbody></table><p>可以看到 type 的类型是 all, 走的是全表扫描。<br>之所以为这样是存的值的相似度高 + like 的条件刚好在他们相似的地方。</p><p>我们存的 name 的格式都是 name + 数字, 同时查询条件为 like ‘name%’, MySQL 判断走全表扫描比索引快。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Nacos 作为注册中心日志不打印</title>
      <link href="/article/2019/3744590012/"/>
      <url>/article/2019/3744590012/</url>
      
        <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>项目使用 log4j2 作为日志框架, 配置一切正常, 程序启动日志的打印也没有问题, 但是引入了 nacos 作为注册中心后, 日志在打印了一句 <code>WARN No Root logger was configured, creating default ERROR-level Root logger with Console appender</code> 后日志都不打印了。</p><p>引入的依赖</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.9.0.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h2 id="2-原因"><a href="#2-原因" class="headerlink" title="2 原因"></a>2 原因</h2><p>在项目的启动过程中, nacos-discovery 会尝试去读系统内的日志配置文件, 然后刷新配置, 但是如果找不到的话, 会使用自身内部的默认配置, 但是默认的日志配置没有设置日志的 <code>Root</code> 的信息。</p><h2 id="3-原因分析"><a href="#3-原因分析" class="headerlink" title="3 原因分析"></a>3 原因分析</h2><ol><li><p>在 com.alibaba.nacos.client.utils.LogUtils 中有一段逻辑如下: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">AbstractNacosLogging</span> nacosLogging<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"ch.qos.logback.classic.Logger"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    nacosLogging <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LogbackNacosLogging</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    isLogback <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    nacosLogging <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Log4J2NacosLogging</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>nacosLogging<span class="token punctuation">.</span><span class="token function">loadConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 从代码可以知道LogUtils, 会尝试加载 `ch.qos.logback.classic.Logger` 这个类, 加载成功的话, 说明项目使用的是 logback 日志框架, 加载不到的话, 就是使用 log4j2(我的项目中使用的是 log4j2) </span></code></pre></li><li><p>进入到 <code>Log4J2NacosLogging</code> 的构造函数</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Log4J2NacosLogging</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractNacosLogging</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token class-name">Log4J2NacosLogging</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// NACOS_LOG4J2_LOCATION ===> "classpath:nacos-log4j2.xml"</span>        <span class="token class-name">String</span> location <span class="token operator">=</span> <span class="token function">getLocation</span><span class="token punctuation">(</span><span class="token constant">NACOS_LOG4J2_LOCATION</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// location 有值, 将值放到 locationList, 用于后续的日志加载</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            locationList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 父类的方法, 为了方便, 写在这里</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> <span class="token function">getLocation</span><span class="token punctuation">(</span><span class="token class-name">String</span> defaultLocation<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取系统属性 NACOS_LOGGING_CONFIG_PROPERTY 的值, 值不为空 返回 NACOS_LOGGING_CONFIG_PROPERTY 的值</span>        <span class="token class-name">String</span> location <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token constant">NACOS_LOGGING_CONFIG_PROPERTY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// NACOS_LOGGING_CONFIG_PROPERTY 的值为空, 根据是否需要返回默认值, 来返回 null 或者  defaultLocation</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDefaultConfigEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 返回 defaultLocation 也就是 classpath:nacos-log4j2.xml, 这个配置文件在 nacos-client.jar 这个 jar 包里面可以找到</span>                <span class="token keyword">return</span> defaultLocation<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> location<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isDefaultConfigEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 判断是否设置了系统属性 NACOS_LOGGING_DEFAULT_CONFIG_ENABLED_PROPERTY, 如果设置了, 同时值为 false, 则返回false, 否则为 true</span>        <span class="token class-name">String</span> property <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token constant">NACOS_LOGGING_DEFAULT_CONFIG_ENABLED_PROPERTY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// The default value is true.</span>        <span class="token keyword">return</span> property <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token class-name">BooleanUtils</span><span class="token punctuation">.</span><span class="token function">toBoolean</span><span class="token punctuation">(</span>property<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></li><li><p>进入到 <code>Log4J2NacosLogging</code> 的 <code>loadConfiguration</code> 方法</p></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Log4J2NacosLogging</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractNacosLogging</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">loadConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 构造函数中处理的 locationList, 如果为空, 直接返回了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>locationList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 获取到当前系统能支持的配置文件的路径</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> configList <span class="token operator">=</span> <span class="token function">findConfig</span><span class="token punctuation">(</span><span class="token function">getCurrentlySupportedConfigLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>configList <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            locationList<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>configList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">AbstractConfiguration</span><span class="token punctuation">></span></span> configurations <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">AbstractConfiguration</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">LoggerContext</span> loggerContext <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">LoggerContext</span><span class="token punctuation">)</span><span class="token class-name">LogManager</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> location <span class="token operator">:</span> locationList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token comment">// 把配置文件转为配置</span>                <span class="token class-name">Configuration</span> configuration <span class="token operator">=</span> <span class="token function">loadConfiguration</span><span class="token punctuation">(</span>loggerContext<span class="token punctuation">,</span> location<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>configuration <span class="token keyword">instanceof</span> <span class="token class-name">AbstractConfiguration</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    configurations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">AbstractConfiguration</span><span class="token punctuation">)</span>configuration<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Could not initialize Log4J2 Nacos logging from "</span> <span class="token operator">+</span> location<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token class-name">CompositeConfiguration</span> compositeConfiguration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CompositeConfiguration</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 重新加载日志配置</span>        loggerContext<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>compositeConfiguration<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getCurrentlySupportedConfigLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> supportedConfigLocations <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// YAML_PARSER_CLASS_NAME ===> com.fasterxml.jackson.dataformat.yaml.YAMLParser</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ClassUtils</span><span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token constant">YAML_PARSER_CLASS_NAME</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>supportedConfigLocations<span class="token punctuation">,</span> <span class="token string">"log4j2.yaml"</span><span class="token punctuation">,</span> <span class="token string">"log4j2.yml"</span><span class="token punctuation">,</span> <span class="token string">"log4j2-test.yaml"</span><span class="token punctuation">,</span> <span class="token string">"log4j2-test.yml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// JSON_PARSER_CLASS_NAME ===> com.fasterxml.jackson.databind.ObjectMapper</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ClassUtils</span><span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token constant">JSON_PARSER_CLASS_NAME</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>supportedConfigLocations<span class="token punctuation">,</span> <span class="token string">"log4j2.json"</span><span class="token punctuation">,</span> <span class="token string">"log4j2.jsn"</span><span class="token punctuation">,</span> <span class="token string">"log4j2-test.json"</span><span class="token punctuation">,</span> <span class="token string">"log4j2-test.jsn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        supportedConfigLocations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"log4j2.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        supportedConfigLocations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"log4j2-test.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 把当前系统支持的配置文件的格式, 以数组的格式返回回去</span>        <span class="token keyword">return</span> supportedConfigLocations<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>supportedConfigLocations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">findConfig</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> locations<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 把上面 getCurrentlySupportedConfigLocations 获取到的 配置文件格式拼接成程序能找到的路径</span>        <span class="token keyword">final</span> <span class="token class-name">String</span> configLocationStr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>strSubstitutor<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token class-name">PropertiesUtil</span><span class="token punctuation">.</span><span class="token function">getProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStringProperty</span><span class="token punctuation">(</span><span class="token constant">CONFIGURATION_FILE_PROPERTY</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>configLocationStr <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>configLocationStr<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> location <span class="token operator">:</span> locations<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">ClassLoader</span> defaultClassLoader <span class="token operator">=</span> <span class="token class-name">ClassUtils</span><span class="token punctuation">.</span><span class="token function">getDefaultClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>defaultClassLoader <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> defaultClassLoader<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"classpath:"</span> <span class="token operator">+</span> location<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> list<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>从上面看下来, 报错的原因是, nacos 会重新加载日志的配置, 但是需要的配置文件都没有, 后续的默认的配置文件 <code>classpath:nacos-log4j2.xml</code> 也没有设置日志的 <code>Root</code>, 所以报错了。</p><h2 id="4-解决"><a href="#4-解决" class="headerlink" title="4 解决"></a>4 解决</h2><ol><li><p><code>isDefaultConfigEnabled</code> 方法提示了, 只需要在项目启动的时候设置一下 <code>System.setProperty(&quot;nacos.logging.default.config.enabled&quot;, &quot;false&quot;);</code> 就行了</p></li><li><p><code>getCurrentlySupportedConfigLocations</code> 方法提示了, 只需要把你的日志配置文件的修改为里面的其中的一种格式就行了 (因为基于 springboot 搭建的, 所以我的日志命名为了 log4j2-spring.xml 所以读取不到)</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 开发问题 </tag>
            
            <tag> 框架使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 日志框架修改为 Log4j2</title>
      <link href="/article/2019/3744590112/"/>
      <url>/article/2019/3744590112/</url>
      
        <content type="html"><![CDATA[<p>在使用 SpringBoot 的时候, 默认使用的日志框架是 Logback。 现在如果想要使用 Log4j2, 如何做修改？</p><h2 id="1-使用-Log4j2"><a href="#1-使用-Log4j2" class="headerlink" title="1 使用 Log4j2"></a>1 使用 Log4j2</h2><blockquote><ol><li>排除 SpringBoot 默认的 logback 依赖</li></ol></blockquote><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><blockquote><ol start="2"><li>添加 Log4j2 的依赖</li></ol></blockquote><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--  使用 Log4j2 替代 logback      --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-log4j2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><blockquote><ol start="3"><li>在 resources 目录下新建一个 log4j2-spring.xml 的日志配置文件</li></ol></blockquote><p>一般情况下, 这样就能在 SpringBoot 里面使用 Log4j2 了。<br>但是还能做继续做一些完善的 !</p><h2 id="2-完善-Log4j2-的使用"><a href="#2-完善-Log4j2-的使用" class="headerlink" title="2 完善 Log4j2 的使用"></a>2 完善 Log4j2 的使用</h2><h3 id="2-1-移除警告日志"><a href="#2-1-移除警告日志" class="headerlink" title="2.1 移除警告日志"></a>2.1 移除警告日志</h3><p>当项目启动的时候, 可能会看到这样的日志信息</p><pre class="language-log" data-language="log"><code class="language-log"><span class="token property">SLF4J:</span> Class path contains multiple SLF4J bindings<span class="token punctuation">.</span><span class="token property">SLF4J:</span> Found binding in <span class="token punctuation">[</span>jar<span class="token operator">:</span>file<span class="token operator">:</span><span class="token file-path string">/E</span><span class="token operator">:</span><span class="token file-path string">/Repertory/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar!/org/slf4j/impl/StaticLoggerBinder.class</span><span class="token punctuation">]</span><span class="token property">SLF4J:</span> Found binding in <span class="token punctuation">[</span>jar<span class="token operator">:</span>file<span class="token operator">:</span><span class="token file-path string">/E</span><span class="token operator">:</span><span class="token file-path string">/Repertory/org/apache/logging/log4j/log4j-slf4j-impl/2.12.1/log4j-slf4j-impl-2.12.1.jar!/org/slf4j/impl/StaticLoggerBinder.class</span><span class="token punctuation">]</span><span class="token property">SLF4J:</span> See <span class="token url">http://www.slf4j.org/codes.html#multiple_bindings</span> for an explanation<span class="token punctuation">.</span><span class="token property">SLF4J:</span> Actual binding is of type <span class="token punctuation">[</span>ch<span class="token punctuation">.</span>qos<span class="token punctuation">.</span>logback<span class="token punctuation">.</span>classic<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ContextSelectorStaticBinder<span class="token punctuation">]</span></code></pre><p>这个虽然不影响使用, 但是强迫症, 看着不舒服。   </p><p>至于原因: 项目里面使用了 slf4f 做门面, 但是项目里面有复数的实现方式, 解决方式也很简单：将项目里面的其他的日志框架排除就行了。 比如使用 myBatis 导入的 starter 里面就有 logbak 的实现。</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.spring.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;mybatis.starter.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>项目的依赖查看, 可以通过 Idea 右侧的 Maven 选项进行查看。</p><h3 id="2-2-使用彩色日志"><a href="#2-2-使用彩色日志" class="headerlink" title="2.2 使用彩色日志"></a>2.2 使用彩色日志</h3><p>在使用 SpringBoot 默认的日志框架时, 可以发现输出在控制台的日志是彩色的, 但是现在换成了 Log4j2, 日志却是白色的, 其实这里面也是可以通过修改<strong>日志配置文件</strong>进行配置的。</p><p>首先在<strong>日志配置文件</strong>配置控制台的输出格式: </p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">name</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ConsoleLogPattern<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>%d&#123;yyy-MM-dd HH:mm:ss&#125; %style&#123;[%15t]&#125;&#123;bright, blue&#125; %clr&#123;%-5level&#125; %style&#123;%logger&#123;80&#125;&#125;&#123;cyan&#125; %style&#123;[%L]&#125;&#123;magenta&#125; - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Property</span><span class="token punctuation">></span></span></code></pre><p>格式基本就是 <code>%style&#123;日志&#125;&#123;想要显示的颜色&#125;</code>  </p><p>然后引入到控制台输出, 然后设置 <code>disableAnsi=&quot;false&quot; noConsoleNoAnsi=&quot;false&quot;</code> 就能达到彩色日志的效果。</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Console</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>console<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SYSTEM_OUT<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--输出日志的格式--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>patternLayout</span> <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;ConsoleLogPattern&#125;<span class="token punctuation">"</span></span> <span class="token attr-name">disableAnsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">noConsoleNoAnsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Console</span><span class="token punctuation">></span></span></code></pre><h3 id="2-3-在日志配置文件使用-application-yml-配置的属性"><a href="#2-3-在日志配置文件使用-application-yml-配置的属性" class="headerlink" title="2.3 在日志配置文件使用 application.yml 配置的属性"></a>2.3 在日志配置文件使用 <strong>application.yml</strong> 配置的属性</h3><p>在 SpringBoot + logback 的时候, 可以通过在 application.yml 里面配置 <code>logging.file.path=日志路径</code> 来指定日志的保存地方 (本身还支持了其他日志相关的配置), 但是在使用 Log4j2 的时候, 不起作用了。<br>原因是: log4j2-spring.xml 是不归 Spring 管理的, 所以也就没法读取到 application.yml 里面的配置了。   </p><p>解决方式： 通过 Spring 的监听器 (Listener)功能, 将我们读取到的 application.yml 的日志路径设置到系统属性, 然后在日志文件里面读取对应的系统属性就行了。  </p><p>首先: 新建一个监听器</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggingListener</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token punctuation">,</span> <span class="token class-name">Ordered</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 提供给日志文件读取配置的key, 使用时需要在前面加上 sys:     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token constant">LOG_PATH</span> <span class="token operator">=</span> <span class="token string">"log.path"</span><span class="token punctuation">;</span>    <span class="token comment">/**     * spring 内部设置的日志文件的配置key     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token constant">SPRING_LOG_PATH_PROP</span> <span class="token operator">=</span> <span class="token string">"logging.file.path"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">ApplicationEvent</span> applicationEvent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>applicationEvent <span class="token keyword">instanceof</span> <span class="token class-name">ApplicationEnvironmentPreparedEvent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">ConfigurableEnvironment</span> environment <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ApplicationEnvironmentPreparedEvent</span><span class="token punctuation">)</span> applicationEvent<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> filePath <span class="token operator">=</span> environment<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token constant">SPRING_LOG_PATH_PROP</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>filePath <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>filePath<span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token constant">LOG_PATH</span><span class="token punctuation">,</span> filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 当前监听器的启动顺序需要在日志配置监听器的前面, 所以此处减 1</span>        <span class="token keyword">return</span> <span class="token class-name">LoggingApplicationListener</span><span class="token punctuation">.</span><span class="token constant">DEFAULT_ORDER</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>然后: 在项目启动的时候, 将我们的监听器交给应用</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationStarter</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span> application <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span><span class="token class-name">ApplicationStarter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 添加日志监听器, 使 log4j2-spring.xml 可以间接读取到配置文件的属性</span>        <span class="token comment">// LoggingListener 也可以通过配置类等方式注入</span>        application<span class="token punctuation">.</span><span class="token function">addListeners</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoggingListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        application<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>最后: log4j2-spring.xml 里面的日志路径配置</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--  文件保存路径 前缀 sys: 不能省   --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>LogPath<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>$&#123;sys:log.path&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Property</span><span class="token punctuation">></span></span></code></pre><p>至此： SpringBoot 整合 Log4j2 就此结束了！</p><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h2><p><a href="https://stackoverflow.com/questions/48941104/use-spring-boot-application-properties-in-log4j2-xml">Use Spring boot application properties in log4j2.xml</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 开发问题 </tag>
            
            <tag> 框架使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Stream</title>
      <link href="/article/2019/2744590102/"/>
      <url>/article/2019/2744590102/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Stream-是什么"><a href="#1-Stream-是什么" class="headerlink" title="1 Stream 是什么?"></a>1 Stream 是什么?</h2><p>Stream 是对集合（Collection）对象功能的增强。<br>它专注于对集合对象各种高效的聚合操作（aggregate operation）[注: 和数据库中的聚合函数类似, 如求平均值、最大值、前几个等操作], 或者大批量数据操作 (bulk data operation)。</p><h2 id="2-Stream-的特点"><a href="#2-Stream-的特点" class="headerlink" title="2 Stream 的特点"></a>2 Stream 的特点</h2><blockquote><ol><li>Stream 不存储数据<br>Stream 不是集合元素, 它不是数据结构并不保存数据, 它是有关算法和计算。<br>如果硬要说的话, 它更像一个高级版本的 Iterator。 我们平时使用的 Iterator, 只能显式地一个一个遍历元素并对元素进行我们想要的操作。<br>但是 Stream, 只要给出对其包含的元素执行什么操作, 比如 “过滤掉长度大于 10 的字符串”, Stream 会隐式地在内部进行遍历, 做出相应的数据转换。</li></ol></blockquote><blockquote><ol start="2"><li>Stream 不改变源数据<br>当我们将一个集合转为 Stream, 然后对 Stream 进行的任何操作, 我们的数据源不会受到任何影响。</li></ol></blockquote><blockquote><ol start="3"><li>Stream 具有延迟执行的特性。<br>Stream 流的很多操作如 filter, map 等中间操作 (intermediate operations, 返回值还是一个 Stream, 因此可以通过链式调用将中间操作串联起来) 是延迟执行的, 只有到最终操作 (terminal operation, 只能返回 void 或者一个非stream 的结果) 才会将操作顺序执行。</li></ol></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">Student</span> stu<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始过滤"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> stu<span class="token punctuation">.</span><span class="token function">getScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">80</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> stuList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stuList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stuList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stuList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 此处的 filter 就是我们说的 中间操作</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> stream <span class="token operator">=</span> stuList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">::</span><span class="token function">filter</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"准备开始了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// collect 就是我们说的终点操作</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> stus <span class="token operator">=</span>  stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 通过日志可知： </span><span class="token comment">// filter方法是在 collect 执行时才会执行</span><span class="token comment">/**  *输出日志：    *  准备开始了 *  开始过滤 *开始过滤 * 开始过滤 */</span></code></pre><blockquote><ol start="4"><li>对于 Stream 的聚合、消费或收集操作只能进行一次, 再次操作会报错</li></ol></blockquote><pre class="language-java" data-language="java"><code class="language-java"> <span class="token comment">// generate 不断生成字符串, Limit(20) 限制 20 条。</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> stream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 正常执行</span>stream<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 报错：同一个stream对象只能进行一次</span>stream<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="5"><li>Steam 的数据源本身可以是无限的。</li></ol><p>除了上面说的中间操作和最终操作, 其中还有一种短路操作 (short-circuiting)</p><ul><li>对于一个中间操作, 如果它接受的是一个无限大的 Stream, 但返回一个有限的新 Stream, 比如 limit (限制前多少个)</li><li>对于一个最终操作, 如果它接受的是一个无限大的 Stream, 但能在有限的时间计算出结果, 比如 findFirst (找第一个)</li></ul><h2 id="3-Stream-的使用"><a href="#3-Stream-的使用" class="headerlink" title="3 Stream 的使用"></a>3 Stream 的使用</h2><h3 id="3-1-Stream-的创建"><a href="#3-1-Stream-的创建" class="headerlink" title="3.1 Stream 的创建"></a>3.1 Stream 的创建</h3><h4 id="3-1-1-List-转为-Stream"><a href="#3-1-1-List-转为-Stream" class="headerlink" title="3.1.1 List 转为 Stream"></a>3.1.1 List 转为 Stream</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> stuList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 普通的流</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> stream <span class="token operator">=</span> stuList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 并行流</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> stream1 <span class="token operator">=</span> strs<span class="token punctuation">.</span><span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-1-2-通过数组创建"><a href="#3-1-2-通过数组创建" class="headerlink" title="3.1.2 通过数组创建"></a>3.1.2 通过数组创建</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 基本类型</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">IntStream</span> intStream <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 引用类型</span><span class="token class-name">Student</span><span class="token punctuation">[</span><span class="token punctuation">]</span> studentArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"s1"</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"s2"</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> studentStream <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>studentArr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-1-3-通过数据集合创建"><a href="#3-1-3-通过数据集合创建" class="headerlink" title="3.1.3 通过数据集合创建"></a>3.1.3 通过数据集合创建</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> stream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"小红"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Student</span><span class="token punctuation">[</span><span class="token punctuation">]</span> studentArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"s1"</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"s2"</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">Student</span><span class="token punctuation">[</span><span class="token punctuation">]</span> studentArr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"s1"</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"s2"</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// Stream.of  里面的数据类型是什么, 那么返回的 Stream 的泛型就是什么</span><span class="token class-name">Stream</span><span class="token operator">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> stream01 <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>studentArr<span class="token punctuation">,</span> studentArr2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-1-4-创建空的流"><a href="#3-1-4-创建空的流" class="headerlink" title="3.1.4 创建空的流"></a>3.1.4 创建空的流</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建 空的流</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> s <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> s <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-1-5-创建无限流"><a href="#3-1-5-创建无限流" class="headerlink" title="3.1.5 创建无限流"></a>3.1.5 创建无限流</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 通过 limit 截取需要的个数</span><span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-1-6-创建规律的无限流"><a href="#3-1-6-创建规律的无限流" class="headerlink" title="3.1.6 创建规律的无限流"></a>3.1.6 创建规律的无限流</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 0: 基点, 从 0 开始, 生成 0, 1, 2, 3 ... 顺序的 10 个</span><span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token operator">-></span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 0: 基点, 从 0 开始, 生成 0, 0, 0  10 个数</span><span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token operator">-></span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="3-2-Stream-转为集合"><a href="#3-2-Stream-转为集合" class="headerlink" title="3.2 Stream 转为集合"></a>3.2 Stream 转为集合</h3><h4 id="3-2-1-转为-List"><a href="#3-2-1-转为-List" class="headerlink" title="3.2.1 转为 List"></a>3.2.1 转为 List</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> stuList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-2-2-转为-Set"><a href="#3-2-2-转为-Set" class="headerlink" title="3.2.2 转为 Set"></a>3.2.2 转为 Set</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> set <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>students<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-2-3-转为-Array"><a href="#3-2-3-转为-Array" class="headerlink" title="3.2.3 转为 Array"></a>3.2.3 转为 Array</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Student</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>students<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-2-4-转为指定的-Collection-对象"><a href="#3-2-4-转为指定的-Collection-对象" class="headerlink" title="3.2.4 转为指定的 Collection 对象"></a>3.2.4 转为指定的 Collection 对象</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> s <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>students<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toCollection</span><span class="token punctuation">(</span><span class="token class-name">HashSet</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-2-5-转为-Map"><a href="#3-2-5-转为-Map" class="headerlink" title="3.2.5 转为 Map"></a>3.2.5 转为 Map</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 参数 1: key  参数2: value  参数三: 当 map 的 key 相同时, 如何处理,  s --> 新的值(s 遍历的值), a --> 已有的和新的值 key 相同的对象 (已有的值) </span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>students<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">toMap</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getScore</span><span class="token punctuation">,</span> <span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>s<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> s <span class="token operator">+</span> a <span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="3-3-对流的操作"><a href="#3-3-对流的操作" class="headerlink" title="3.3 对流的操作"></a>3.3 对流的操作</h3><h4 id="3-3-1-筛选"><a href="#3-3-1-筛选" class="headerlink" title="3.3.1 筛选"></a>3.3.1 筛选</h4><p><strong>filter: 条件过滤</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// filter 里面的 lambda 表达式 返回一个 Boolean 值, 如果为 true 将这个对象保留</span>stuList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>x <span class="token operator">-></span> x<span class="token punctuation">.</span><span class="token function">getScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>distinct: 去重</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// stuList 中重复的项会被去掉</span>stuList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-3-2-截取"><a href="#3-3-2-截取" class="headerlink" title="3.3.2 截取"></a>3.3.2 截取</h4><p><strong>limit: 截取前几个</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 获取 stuList 中的前 3 个</span>stuList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">3L</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>skip: 跳过前几个</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 去掉 stuList 中的前 3 个</span>stuList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">3L</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-3-3-转换-映射"><a href="#3-3-3-转换-映射" class="headerlink" title="3.3.3 转换 (映射)"></a>3.3.3 转换 (映射)</h4><p><strong>map: 对象转换</strong></p><pre class="language-java" data-language="java"><code class="language-java"> <span class="token comment">// 获取一个 Student List</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> stus <span class="token operator">=</span> stuList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通过 map 将输出结果转为 List&lt;String>, String 值为每个对象的 name 属性</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> strList <span class="token operator">=</span> stuList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>item <span class="token operator">-></span> item<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span>toList<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>flatMap: 将每个值转换成另一个流, 然后将所有的流连起来</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"e"</span><span class="token punctuation">,</span> <span class="token string">"f"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 返回结果 List&lt;String[]> </span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span>toList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  返回结果 List&lt;String>  2 个数组合并成 1 个</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token operator">::</span><span class="token function">stream</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-3-4-查找"><a href="#3-3-4-查找" class="headerlink" title="3.3.4 查找"></a>3.3.4 查找</h4><p><strong>findFirst: 查找第一个</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// orElse(): 如果数据没有返回 nothing</span><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parallel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>x <span class="token operator">-></span> x<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"nothing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>findAny: 查找一个 (findFirst() 返回的是第一个, findAny() 不一定返回第一个)</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> optional <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parallel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>x <span class="token operator">-></span> x<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findAny</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>optional<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-3-5-匹配"><a href="#3-3-5-匹配" class="headerlink" title="3.3.5.匹配"></a>3.3.5.匹配</h4><p><strong>anyMatch: 是否包含匹配元素</strong></p><pre class="language-java" data-language="java"><code class="language-java"> <span class="token comment">// 有一个符合就 true</span><span class="token class-name">Boolean</span> aBoolean <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span>x<span class="token operator">-></span>x<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>allMatch：是否全部符合</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 有一个不符合就 false</span><span class="token class-name">Boolean</span> aBoolean <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">allMatch</span><span class="token punctuation">(</span>x<span class="token operator">-></span>x<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>noneMatch: 是否存在不符合条件</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 是否存在不大于 10 的, 有一个符合条件就返回 true</span><span class="token class-name">Boolean</span> result <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">noneMatch</span><span class="token punctuation">(</span> x <span class="token operator">-></span> x <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-3-6-遍历"><a href="#3-3-6-遍历" class="headerlink" title="3.3.6 遍历"></a>3.3.6 遍历</h4><p><strong>forEach: 对流的数据进行遍历操作</strong></p><pre class="language-java" data-language="java"><code class="language-java">stuList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-3-7-流数据操作"><a href="#3-3-7-流数据操作" class="headerlink" title="3.3.7 流数据操作"></a>3.3.7 流数据操作</h4><p><strong>peek: 对流中的每个数据进行需要的操作</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 对数据里面的每一项减去 100</span>stuList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>item <span class="token operator">-></span> item<span class="token punctuation">.</span><span class="token function">setScore</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-3-8-流合并"><a href="#3-3-8-流合并" class="headerlink" title="3.3.8 流合并"></a>3.3.8 流合并</h4><p><strong>concat: 2 个相同类型的流进行合并</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> stream1 <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> stream2 <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 合并后去重</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>stream1<span class="token punctuation">,</span> stream2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-3-9-规约-将流中的数据-按照需要-归并成一个值"><a href="#3-3-9-规约-将流中的数据-按照需要-归并成一个值" class="headerlink" title="3.3.9 规约(将流中的数据, 按照需要, 归并成一个值)"></a>3.3.9 规约(将流中的数据, 按照需要, 归并成一个值)</h4><p><strong>reduce: 归并操作的函数</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 求和 参数 1: 提供给归并操作的起始值, 参数 2: 数据的处理方式, 结果返回一个值</span><span class="token keyword">int</span> sum1 <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 效果同上</span><span class="token keyword">int</span> sum2 <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">sum</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-3-10-数学操作"><a href="#3-3-10-数学操作" class="headerlink" title="3.3.10 数学操作"></a>3.3.10 数学操作</h4><p><strong>sorted: 排序</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 按照 comparing 里面的值进行顺序排序</span>stuList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getScore</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span>toList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 逆序排序</span>stuList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getScore</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span>toList<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>max&#x2F;min: 最大值&#x2F;最小值</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// max 返回了 Optional&lt;T></span><span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// min 返回了 Optional&lt;T></span><span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>count: 统计</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> count <span class="token operator">=</span><span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-3-11-分组"><a href="#3-3-11-分组" class="headerlink" title="3.3.11 分组"></a>3.3.11 分组</h4><p><strong>groupingBy: 按照条件进行分组</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 按照 相同的 score 为一组, 进行分组</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span><span class="token punctuation">></span></span> groups <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getScore</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 级分组</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span><span class="token punctuation">></span><span class="token punctuation">></span></span> twoGroup <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getScore</span><span class="token punctuation">,</span> <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 可以继续多级分组</span><span class="token comment">// 第二个参数也可以传递其他参数</span> <span class="token comment">// 统计同一组的个数</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">></span></span> groups <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getScore</span><span class="token punctuation">,</span> <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">counting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 按照分数分值, 统计同一组的分数</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> groups <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getScore</span><span class="token punctuation">,</span> <span class="token function">summingInt</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getScore</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 按照分数分值, 统计同一组里面的最大值</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Optional</span><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getScore</span><span class="token punctuation">,</span> <span class="token function">maxBy</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getScore</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 按照分数分值, 将一组内的分数转为 Set</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getScore</span><span class="token punctuation">,</span> <span class="token function">mapping</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getScore</span><span class="token punctuation">,</span> <span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-3-12-分区-分组的特殊情况-k-值为-true-false"><a href="#3-3-12-分区-分组的特殊情况-k-值为-true-false" class="headerlink" title="3.3.12 分区 (分组的特殊情况, k 值为 true&#x2F;false)"></a>3.3.12 分区 (分组的特殊情况, k 值为 true&#x2F;false)</h4><p><strong>partitioningBy: 按照条件进行分组</strong></p><pre class="language-java" data-language="java"><code class="language-java"> <span class="token comment">// 按照分数是否大于 90 分进行分区, true/false 2 个分区</span><span class="token class-name">Map</span><span class="token operator">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> groups <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">partitioningBy</span><span class="token punctuation">(</span>student <span class="token operator">-></span> student<span class="token punctuation">.</span><span class="token function">getScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-3-13-统计-IntSummaryStatistics"><a href="#3-3-13-统计-IntSummaryStatistics" class="headerlink" title="3.3.13 统计 (IntSummaryStatistics)"></a>3.3.13 统计 (IntSummaryStatistics)</h4><p><strong>IntSummaryStatistics: 数学操作</strong></p><pre class="language-java" data-language="java"><code class="language-java"> <span class="token comment">// 将传入的学生的分数转为一个 Int 的统计分析对象</span><span class="token class-name">IntSummaryStatistics</span> summaryStatistics <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>students<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">summarizingInt</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getScore</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取传入的学生的分数的平均分, 其他类似</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getAverage->"</span><span class="token operator">+</span>summaryStatistics<span class="token punctuation">.</span><span class="token function">getAverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getMax->"</span><span class="token operator">+</span>summaryStatistics<span class="token punctuation">.</span><span class="token function">getMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getMin->"</span><span class="token operator">+</span>summaryStatistics<span class="token punctuation">.</span><span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getCount->"</span><span class="token operator">+</span>summaryStatistics<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getSum->"</span><span class="token operator">+</span>summaryStatistics<span class="token punctuation">.</span><span class="token function">getSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="3-4-并行流"><a href="#3-4-并行流" class="headerlink" title="3.4 并行流"></a>3.4 并行流</h3><p>只需要调用顺序流的 parallel() 方法, 就可以将普通顺序执行的流转变为并行流</p><ol><li><p>顺序流： 所有的顺序按照顺序进入流, 在这个数据被流过滤掉, 或者输出, 后下个数据才能进入流, 进行处理</p></li><li><p>并行流： 开启多个线程 (线程数由电脑决定), 并行的处理这些数据</p></li><li><p>并行流对 sorted(), distinct() 类似的元素操作 api 没有影响</p></li><li><p>并行流对 sorted(), distinct() 类似的元素操作 api 会比顺序流耗时</p></li><li><p>并行流对数据的数据的输出是无序的, 如果需要有序的输出请用：forEachOrdered</p></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 顺序流： 0, 1, 2 ...</span><span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x <span class="token operator">-></span> x <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 并行流： 3, 1, 0 ...</span><span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x <span class="token operator">-></span> x <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parallel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 并行流： 0, 1, 2</span><span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x <span class="token operator">-></span> x <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parallel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEachOrdered</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="3-5-原始类型流"><a href="#3-5-原始类型流" class="headerlink" title="3.5 原始类型流"></a>3.5 原始类型流</h3><p>在数据量比较大的情况下, 将基本数据类型（int, double…）包装成相应对象流的做法是低效的。<br>因此, 我们也可以直接将数据初始化为原始类型流, 在原始类型流上的操作与对象流类似</p><h4 id="3-5-1-原始流的生成"><a href="#3-5-1-原始流的生成" class="headerlink" title="3.5.1 原始流的生成"></a>3.5.1 原始流的生成</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">DoubleStream</span> doubleStream <span class="token operator">=</span> <span class="token class-name">DoubleStream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">,</span> <span class="token number">0.4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">IntStream</span> intStream <span class="token operator">=</span> <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 生成 [0, 100]</span><span class="token class-name">IntStream</span> intStream2 <span class="token operator">=</span> <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">rangeClosed</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 生成 [0, 100)</span><span class="token class-name">IntStream</span> intStream3 <span class="token operator">=</span> <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-5-2-原始流和对象流的转换"><a href="#3-5-2-原始流和对象流的转换" class="headerlink" title="3.5.2 原始流和对象流的转换"></a>3.5.2 原始流和对象流的转换</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">></span></span> stream <span class="token operator">=</span> doubleStream<span class="token punctuation">.</span><span class="token function">boxed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">DoubleStream</span> doubleStream <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">mapToDouble</span><span class="token punctuation">(</span><span class="token class-name">Double</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="3-6-Optional"><a href="#3-6-Optional" class="headerlink" title="3.6 Optional"></a>3.6 Optional</h3><p>通常聚合操作会返回一个 Optional 类型, Optional 表示一个安全 (安全指的是避免调用<strong>直接</strong>返回 null 值而造成空指针异常) 的指定结果类型。  </p><p>Optional 常用的操作: </p><blockquote><p>Optional.isPresent(): 可以判断返回值是否为空<br>Optional.ifPresent(Consumer&lt;? super T&gt; consumer): 可以在结果为空时, 调用传入的 Conumer lambda 表达时<br>Optional.get(): 获取 Optional 内真实的返回值</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建了一个空的Optional</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> opt1 <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// false</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>opt1<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 类似给予了一个初始值</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> opt <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"andy with u"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>opt<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取Optional的默认值</span><span class="token class-name">String</span> result <span class="token operator">=</span> opt<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 如果Optional有值进行操作</span>opt<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>item <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-6-1-Optional-的创建"><a href="#3-6-1-Optional-的创建" class="headerlink" title="3.6.1 Optional 的创建"></a>3.6.1 Optional 的创建</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> studentOptional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"user1"</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 转换 返回值 --->Option&lt;返回值></span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> optionalStr <span class="token operator">=</span> studentOptional<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 迭代 (后者覆盖前者), 方法 fn 返回值为 Option&lt;String>, fn2 返回值为 Option&lt;String>, 要求返回值为 Option&lt;T>, 替代前者</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> opt <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-6-2-给-Optional-指定没有值时的行为"><a href="#3-6-2-给-Optional-指定没有值时的行为" class="headerlink" title="3.6.2 给 Optional 指定没有值时的行为"></a>3.6.2 给 Optional 指定没有值时的行为</h4><pre class="language-java" data-language="java"><code class="language-java"> <span class="token comment">// Optional 里面为 null, 返回 100</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>item <span class="token operator">-></span> item <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">naturalOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Optional 里面为 null, 调用最后面的  lambda 表达示并返回其返回值</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>item <span class="token operator">-></span> item <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">naturalOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Optional 里面为 null, 抛出 RuntimeException 异常</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>item <span class="token operator">-></span> item <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">naturalOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElseThrow</span><span class="token punctuation">(</span><span class="token class-name">RuntimeException</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html">Java 8 中的 Streams API 详解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Config 简单使用</title>
      <link href="/article/2019/4117083830/"/>
      <url>/article/2019/4117083830/</url>
      
        <content type="html"><![CDATA[<h2 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h2><p>因为 SpirngBoot, SpringCloud 的各个版本之间差异还是挺大的, 所以在参照本博客进行学习时, 有可能出现因为版本不一致, 而出现不同的问题。<br>如果可以和本项目使用的环境保持一致, 即使不一致, 也尽可能不要跨大版本。</p><p>环境清单</p><table><thead><tr><th align="center">框架</th><th align="center">版本</th></tr></thead><tbody><tr><td align="center">JDK</td><td align="center">1.8</td></tr><tr><td align="center">Spring Boot</td><td align="center">2.1.4.RELEASE</td></tr><tr><td align="center">Spring Cloud</td><td align="center">Greenwich.SR1</td></tr></tbody></table><h2 id="2-准备"><a href="#2-准备" class="headerlink" title="2 准备"></a>2 准备</h2><h3 id="2-1-Maven-父模块配置"><a href="#2-1-Maven-父模块配置" class="headerlink" title="2.1 Maven 父模块配置"></a>2.1 Maven 父模块配置</h3><ol><li>先建立一个 Maven 的父模块, 也就是整个项目里面只有一个 pom 文件  </li><li>在父 pom 里面添加一些共用的配置, 比如 SpringBoot, SpringCloud 的依赖</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 手动引入 spring boot 版本依赖--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.4.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>lcn29.github.io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-eureka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- 手动引入 spring cloud 对应的配置 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>Greenwich.SR1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 手动 引入 spring cloud 的基础模块--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 省略一些打包相关的配置 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h3 id="2-2-启动-2-个服务端-注册中心"><a href="#2-2-启动-2-个服务端-注册中心" class="headerlink" title="2.2 启动 2 个服务端 (注册中心)"></a>2.2 启动 2 个服务端 (注册中心)</h3><ol><li>在父模块里面新建一个子模块, 模块名 <code>eureka-server</code>  </li><li>在子模块引入 Eureka 服务端需要的依赖</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- eureka 服务端的依赖--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><ol start="3"><li>在启动类上加上注解 <code>@EnableEurekaServer</code></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableEurekaServer</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaServe</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaServe</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li><p>在 src&#x2F;main&#x2F;resources 里面新建 3 个配置文件, 分别是 <code>application.yml</code>, <code>application-8081.yml</code>, <code>application-8081.yml</code></p></li><li><p>在 <code>application.yml</code> 里面加上这 2 个配置</p></li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># eureka 服务端的通用配置</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> server<span class="token punctuation">-</span>eureka<span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>spring.application.name<span class="token punctuation">&#125;</span><span class="token punctuation">:</span>$<span class="token punctuation">&#123;</span>server.port<span class="token punctuation">&#125;</span></code></pre><ol start="6"><li>在 <code>application-8081.yml</code> 里面加上这 2 个配置</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># eureka 服务端 1 的配置</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8081</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>8081.com  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8082.com<span class="token punctuation">:</span>8082/eureka/</code></pre><ol start="7"><li>在 <code>application-8082.yml</code> 里面加上这 2 个配置</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># eureka 服务端 1 的配置</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8082</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>8082.com  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8081.com<span class="token punctuation">:</span>8081/eureka/</code></pre><ol start="8"><li>在电脑的 hosts 文件里面添加这 2 行映射</li></ol><pre class="language-txt" data-language="txt"><code class="language-txt">127.0.0.1 eureka-8081.com127.0.0.1 eureka-8082.com</code></pre><ol start="9"><li>为了让我们的子模块能够启动为 2 个服务端, 需要我们做一下启动的配置</li></ol><blockquote><ol><li>Idea 找到右上角的这个<br><img src="https://pic.imgdb.cn/item/654b5368c458853aef8dfdb7.png" alt="Alt &#39;模块多实例配置&#39;"></li></ol></blockquote><blockquote><ol start="2"><li>点一下左边的 +, 找到 SpringBoot 项, 配置一下下面的三项<br><img src="https://pic.imgdb.cn/item/654b5a28c458853aefa1b906.png" alt="Alt &#39;模块多实例参数配置&#39;"><br>(如果 Program arguments 没有的话, 可以在绿色区域搜索添加)</li></ol></blockquote><blockquote><ol start="3"><li>Program arguments 配置的内容为 <code>--spring.profiles.active=8081</code>, 作用是启动这个 SpringBoot 应用时使用<code>8081</code> 环境, 也就是对应 <code>application-8081.yml</code> 里面的配置</li></ol></blockquote><blockquote><ol start="4"><li>同理, 在配置多一条 <code>8082</code> 环境的启动命令, 这样子模块就能启动 2 个程序了</li></ol></blockquote><h3 id="2-3-创建-1-个配置客户端-配置中心"><a href="#2-3-创建-1-个配置客户端-配置中心" class="headerlink" title="2.3 创建 1 个配置客户端 (配置中心)"></a>2.3 创建 1 个配置客户端 (配置中心)</h3><ol><li><p>在父模块里面新建一个子模块, 模块名 <code>config-server</code>  </p></li><li><p>在模块里面添加如下依赖</p></li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- eureka 服务端的依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- web 功能的支持, 没有这个 客户端就会启动完就结束程序 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><ol start="3"><li>然后在启动类上加上注解 <code>@EnableEurekaClient</code></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableEurekaClient</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigServer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaClientOne</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li><p>同样在 src&#x2F;main&#x2F;resources 里面新建 1 个配置文件, <code>application.yml</code></p></li><li><p>在 <code>application.yml</code> 里面加上这 2 个配置</p></li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> spring<span class="token punctuation">-</span>cloud<span class="token punctuation">-</span>config<span class="token punctuation">-</span>server<span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9091</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>spring.application.name<span class="token punctuation">&#125;</span><span class="token punctuation">:</span>$<span class="token punctuation">&#123;</span>server.port<span class="token punctuation">&#125;</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token comment"># 向服务端的注册地址</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8081.com<span class="token punctuation">:</span>8081/eureka/<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8082.com<span class="token punctuation">:</span>8082/eureka</code></pre><h3 id="2-4-创建-1-个客户端-用来测试功能"><a href="#2-4-创建-1-个客户端-用来测试功能" class="headerlink" title="2.4 创建 1 个客户端 (用来测试功能)"></a>2.4 创建 1 个客户端 (用来测试功能)</h3><ol><li><p>在父模块里面再建立一个子模块, 模块名<code>config-client</code>, 作为服务的调用方</p></li><li><p>在模块里面添加如下依赖</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- eureka 服务端的依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- web 功能的支持, 没有这个 客户端就会启动完就结束程序 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--远程调用--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>然后在启动类上加上注解 <code>@EnableEurekaClient</code></p></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token annotation punctuation">@EnableEurekaClient</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClientConsumer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">ClientConsumer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li>在 <code>application.yml</code> 中添加配置</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> client<span class="token punctuation">-</span>consumer<span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10101</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>spring.application.name<span class="token punctuation">&#125;</span><span class="token punctuation">:</span>$<span class="token punctuation">&#123;</span>server.port<span class="token punctuation">&#125;</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token comment"># 向服务端的注册地址</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8081.com<span class="token punctuation">:</span>8081/eureka/<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8082.com<span class="token punctuation">:</span>8082/eureka</code></pre><ol start="5"><li>声明一个 Controller (用于测试), 注入刚声明的接口</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PropertyController</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"local"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/property"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> resp <span class="token operator">=</span> <span class="token string">"从远程获取到的配置"</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>        <span class="token keyword">return</span> resp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-5-在-GitHub-上创建一个仓库-用于存放配置文件"><a href="#2-5-在-GitHub-上创建一个仓库-用于存放配置文件" class="headerlink" title="2.5 在 GitHub 上创建一个仓库, 用于存放配置文件"></a>2.5 在 GitHub 上创建一个仓库, 用于存放配置文件</h3><ol><li>在 GitHub 上创建一个仓库, 仓库名为 <code>spring-cloud-config</code>, 名字随意</li><li>在仓库里面新建了一个文件夹 <code>application-config</code>, 里面新建了三个文件 <code>config-dev.yml</code>, <code>config-test.yml</code>, <code>config-prod.yml</code></li><li>在三个文件里面分别写入对应的配置内容<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># config-dev.yml 配置, config-test.yml, config-prod.yml 配置类似, 改为 my.name 修改为 test/prod 即可</span><span class="token key atrule">my</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> dev</code></pre></li></ol><p>到此, 环境准备基本完成了。</p><h2 id="3-Config-开始使用"><a href="#3-Config-开始使用" class="headerlink" title="3 Config 开始使用"></a>3 Config 开始使用</h2><h3 id="3-1-配置客户端搭建-配置中心"><a href="#3-1-配置客户端搭建-配置中心" class="headerlink" title="3.1 配置客户端搭建 (配置中心)"></a>3.1 配置客户端搭建 (配置中心)</h3><ol><li><p>在配置客户端 <code>config-center</code> 引入对应的依赖</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>在 <code>application.yml</code> 中添加配置</p></li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> spring<span class="token punctuation">-</span>cloud<span class="token punctuation">-</span>config<span class="token punctuation">-</span>server  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>      <span class="token key atrule">server</span><span class="token punctuation">:</span>        <span class="token key atrule">git</span><span class="token punctuation">:</span>          <span class="token key atrule">uri</span><span class="token punctuation">:</span> 你GitHub配置仓库的地址          <span class="token comment"># 指定某个目录</span>          <span class="token key atrule">search-paths</span><span class="token punctuation">:</span> 配置仓库里面哪个文件夹存放着你这个项目需要的配置文件(这里我的就是 /application<span class="token punctuation">-</span>config)          <span class="token key atrule">username</span><span class="token punctuation">:</span> GitHub的用户名          <span class="token key atrule">password</span><span class="token punctuation">:</span> GitHub的登录密码</code></pre><ol start="3"><li>在启动类上加上注解 <code>@EnableConfigServer</code></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableEurekaClient</span><span class="token annotation punctuation">@EnableConfigServer</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigServer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">ConfigServer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li>启动注册中心, 启动配置客户端, 测试一下是否能获取得到配置信息, 访问路径 <a href="http://localhost:服务端的端口/你的配置文件-的前部分/你的配置文件-的后半部分/">http://localhost:服务端的端口/你的配置文件-的前部分/你的配置文件-的后半部分/</a>(这个可选, 取那条分支的内容, 默认是master), 我的访问路径为 <a href="http://localhost:9091/config/dev/master">http://localhost:9091/config/dev/master</a>, 如果成功的话, 可以看到类似下面的内容, 说明你的配置客户端没问题了<pre class="language-log" data-language="log"><code class="language-log"><span class="token operator">&#123;</span>  <span class="token property">name:</span> <span class="token string">"config"</span><span class="token punctuation">,</span> profiles<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"dev"</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span> label<span class="token operator">:</span> <span class="token string">"master"</span><span class="token punctuation">,</span> version<span class="token operator">:</span> <span class="token string">"dcc1f4eb6c3f44c59b28d3699edf39ac4da0e97b"</span><span class="token punctuation">,</span> state<span class="token operator">:</span> <span class="token boolean">null</span><span class="token punctuation">,</span> propertySources<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token operator">&#123;</span>      <span class="token property">name:</span> <span class="token string">"https://github.com/GitHub用户名/你的配置仓库名/配置文件夹名/配置文件名.yml"</span><span class="token punctuation">,</span> source<span class="token operator">:</span> <span class="token operator">&#123;</span>        <span class="token property">my.name:</span> <span class="token string">"dev-update-v1.2"</span>      <span class="token operator">&#125;</span><span class="token punctuation">,</span> <span class="token operator">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&#125;</span></code></pre></li></ol><h3 id="3-2-配置读取客户端搭建-测试配置读取"><a href="#3-2-配置读取客户端搭建-测试配置读取" class="headerlink" title="3.2 配置读取客户端搭建 (测试配置读取)"></a>3.2 配置读取客户端搭建 (测试配置读取)</h3><ol><li><p>在配置客户端 <code>config-client</code> 引入对应的依赖</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>在 src&#x2F;main&#x2F;resources 里面新建一个 <code>bootstrap.yml</code> 的配置文件 (启动配置文件, 他的优先级高于 application.yml), 在里面配置</p></li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>spring.application.name<span class="token punctuation">&#125;</span><span class="token punctuation">:</span>$<span class="token punctuation">&#123;</span>server.port<span class="token punctuation">&#125;</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token comment"># 向服务端的注册地址</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8081.com<span class="token punctuation">:</span>8081/eureka/<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8082.com<span class="token punctuation">:</span>8082/eureka<span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>      <span class="token comment"># 下面三个参数对应登录我们服务端获取配置信息的 url 的三个参数</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> config      <span class="token key atrule">profile</span><span class="token punctuation">:</span> dev      <span class="token key atrule">label</span><span class="token punctuation">:</span> master      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>        <span class="token comment"># Config 服务发现支持</span>        <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>        <span class="token comment"># config server 的应用名</span>        <span class="token key atrule">serviceId</span><span class="token punctuation">:</span> spring<span class="token punctuation">-</span>cloud<span class="token punctuation">-</span>config<span class="token punctuation">-</span>server</code></pre><ol start="3"><li><p>客户端还是需要在 <code>application.yml</code>设置我们客户端的其他信息的, 如端口, 应用名</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9091</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> spring<span class="token punctuation">-</span>cloud<span class="token punctuation">-</span>config<span class="token punctuation">-</span>client</code></pre></li><li><p>修改测试的 Controller </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PropertyController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;my.name&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/property"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> resp <span class="token operator">=</span> <span class="token string">"从远程获取到的配置"</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>        <span class="token keyword">return</span> resp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></li><li><p>启动客户端, 访问 <code>http://localhost:你的端口/property</code> 可以看到 <code>从远程获取到的配置 dev</code></p></li><li><p>这时候你修改了 GitHub 上面 config-dev.yml 的内容, 你会发现你的客户端没法获取到最新的配置, SpringCloud 提供了一个 <code>POST</code> 方法, 请求一下 <code>/refresh</code> 这个接口就行了。但是需要做一下配置</p></li><li><p>在测试客户端引入 <code>actuator</code> 依赖, 他里面有我们需要的的 <code>/refresh</code>的实现</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>在你引用到远程配置的类的上面加上注解 <code>@RefreshScope</code>, 我们这里就是在 Controller 上面加上就行了</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PropertyController</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span></code></pre></li><li><p><code>actuator</code> 默认的 <code>refresh</code> 端点是关闭的, 需要开启 (配置在 <code>application.yml</code> 就行了)</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 暴露所有的端点 management.security.enabled=false 在 spring boot 2.0 版本以上已过期</span><span class="token key atrule">management</span><span class="token punctuation">:</span>  <span class="token key atrule">endpoints</span><span class="token punctuation">:</span>    <span class="token key atrule">web</span><span class="token punctuation">:</span>      <span class="token key atrule">exposure</span><span class="token punctuation">:</span>        <span class="token key atrule">include</span><span class="token punctuation">:</span> <span class="token string">'*'</span></code></pre></li><li><p>当我们的远程仓库的配置继续了修改, 只需要我们手动发起一个 Post 请求到 <code>http://你客户端的地址:端口/actuator/refresh</code>, 你的项目里面的配置就会进行刷新</p></li><li><p>上面的主动请求 <code>/refresh</code>, 可以通过 GitHub 的 Webhooks 进行回调。但是随着系统的客户端的增加, Webhooks 的 url 也会增大, 不好管理。下面看一下, 通过消息总线的方式的解决</p></li></ol><h2 id="4-消息总线"><a href="#4-消息总线" class="headerlink" title="4 消息总线"></a>4 消息总线</h2><p>流程大概是这样的</p><blockquote><ol><li>当我们代码提交了, 通过GitHub的Webhook功能回调我们的服务端(单机集群都可以), 地址 http:&#x2F;&#x2F;你的服务端的地址:端口&#x2F;actuator&#x2F;bus-refresh</li><li>这时候服务端通知消息总线 (也就是 MQ), 消息总线通知所有的客户端</li><li>客户端主动去请求服务端获取最新的配置</li></ol></blockquote><ol><li><p>首先搭建一套 MQ 环境, 这里使用的是 RabbitMQ, 你可以使用其他的, 但是需要修改配置</p></li><li><p>在配置客户端 <code>config-center</code> 引入对应的依赖</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-bus-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-bus<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>在 配置客户端 <code>config-center</code> 的 &#96;application.yml&#96;&#96; 配置文件里面加上配置  </p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">bus</span><span class="token punctuation">:</span>      <span class="token comment"># 开启总线</span>      <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token key atrule">trace</span><span class="token punctuation">:</span>        <span class="token comment"># 追踪链路</span>        <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> RabbitMQ 的地址    <span class="token key atrule">port</span><span class="token punctuation">:</span> RabbitMQ 的端口    <span class="token key atrule">username</span><span class="token punctuation">:</span> RabbitMQ 用户名    <span class="token key atrule">password</span><span class="token punctuation">:</span> RabbitMQ 密码    <span class="token comment"># 暴露端点</span><span class="token key atrule">management</span><span class="token punctuation">:</span>  <span class="token key atrule">endpoints</span><span class="token punctuation">:</span>    <span class="token key atrule">web</span><span class="token punctuation">:</span>      <span class="token key atrule">exposure</span><span class="token punctuation">:</span>        <span class="token key atrule">include</span><span class="token punctuation">:</span> bus<span class="token punctuation">-</span>refresh    </code></pre></li><li><p>配置读取客户端 <code>config-client</code> 移除 <code>actuator</code> 的依赖和配置(这些我们配置在服务端), 同时加上依赖</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-bus-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-bus<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>配置读取客户端在 &#96;bootstrap.yml&#96;&#96; 里面加一下总线的和 RabbitMQ 的配置</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">bus</span><span class="token punctuation">:</span>      <span class="token comment"># 开启总线</span>      <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token key atrule">trace</span><span class="token punctuation">:</span>        <span class="token comment"># 追踪链路</span>        <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> RabbitMQ 的地址    <span class="token key atrule">port</span><span class="token punctuation">:</span> RabbitMQ 的端口    <span class="token key atrule">username</span><span class="token punctuation">:</span> RabbitMQ 用户名    <span class="token key atrule">password</span><span class="token punctuation">:</span> RabbitMQ 密码</code></pre></li><li><p>在 GitHub 的 webhook 配置上我们的配置服务端的请求地址 <code>http://localhost:9091/actuator/bus-refresh</code> (这个地址, Github 是无论都访问不到的, 如果是正式环境需要正确的配置), 在这里我们通过模拟发送 Post 请求到这个地址, 达到测试的效果</p></li><li><p>刷新页面, 可以看到你修改并提交到 GitHub 的内容都能不用重启就取到了</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 框架使用 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Gateway 简单使用</title>
      <link href="/article/2019/2800395431/"/>
      <url>/article/2019/2800395431/</url>
      
        <content type="html"><![CDATA[<h2 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h2><p>因为 SpirngBoot, SpringCloud 的各个版本之间差异还是挺大的, 所以在参照本博客进行学习时, 有可能出现因为版本不一致, 而出现不同的问题。<br>如果可以和本项目使用的环境保持一致, 即使不一致, 也尽可能不要跨大版本。</p><p>环境清单</p><table><thead><tr><th align="center">框架</th><th align="center">版本</th></tr></thead><tbody><tr><td align="center">JDK</td><td align="center">1.8</td></tr><tr><td align="center">Spring Boot</td><td align="center">2.1.4.RELEASE</td></tr><tr><td align="center">Spring Cloud</td><td align="center">Greenwich.SR1</td></tr></tbody></table><h2 id="2-准备"><a href="#2-准备" class="headerlink" title="2 准备"></a>2 准备</h2><h3 id="2-1-Maven-父模块配置"><a href="#2-1-Maven-父模块配置" class="headerlink" title="2.1 Maven 父模块配置"></a>2.1 Maven 父模块配置</h3><ol><li>先建立一个 Maven 的父模块, 也就是整个项目里面只有一个 pom 文件  </li><li>在父 pom 里面添加一些共用的配置, 比如 SpringBoot, SpringCloud 的依赖</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 手动引入 spring boot 版本依赖--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.4.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>lcn29.github.io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-eureka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- 手动引入 spring cloud 对应的配置 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>Greenwich.SR1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 手动 引入 spring cloud 的基础模块--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 省略一些打包相关的配置 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h3 id="2-2-启动-2-个服务端-注册中心"><a href="#2-2-启动-2-个服务端-注册中心" class="headerlink" title="2.2 启动 2 个服务端 (注册中心)"></a>2.2 启动 2 个服务端 (注册中心)</h3><ol><li>在父模块里面新建一个子模块, 模块名 <code>eureka-server</code>  </li><li>在子模块引入 Eureka 服务端需要的依赖</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- eureka 服务端的依赖--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><ol start="3"><li>在启动类上加上注解 <code>@EnableEurekaServer</code></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableEurekaServer</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaServe</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaServe</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li><p>在 src&#x2F;main&#x2F;resources 里面新建 3 个配置文件, 分别是 <code>application.yml</code>, <code>application-8081.yml</code>, <code>application-8081.yml</code></p></li><li><p>在 <code>application.yml</code> 里面加上这 2 个配置</p></li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># eureka 服务端的通用配置</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> server<span class="token punctuation">-</span>eureka<span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>spring.application.name<span class="token punctuation">&#125;</span><span class="token punctuation">:</span>$<span class="token punctuation">&#123;</span>server.port<span class="token punctuation">&#125;</span></code></pre><ol start="6"><li>在 <code>application-8081.yml</code> 里面加上这 2 个配置</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># eureka 服务端 1 的配置</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8081</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>8081.com  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8082.com<span class="token punctuation">:</span>8082/eureka/</code></pre><ol start="7"><li>在 <code>application-8082.yml</code> 里面加上这 2 个配置</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># eureka 服务端 1 的配置</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8082</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>8082.com  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8081.com<span class="token punctuation">:</span>8081/eureka/</code></pre><ol start="8"><li>在电脑的 hosts 文件里面添加这 2 行映射</li></ol><pre class="language-txt" data-language="txt"><code class="language-txt">127.0.0.1 eureka-8081.com127.0.0.1 eureka-8082.com</code></pre><ol start="9"><li>为了让我们的子模块能够启动为 2 个服务端, 需要我们做一下启动的配置</li></ol><blockquote><ol><li>Idea 找到右上角的这个<br><img src="https://pic.imgdb.cn/item/654b5368c458853aef8dfdb7.png" alt="Alt &#39;模块多实例配置&#39;"></li></ol></blockquote><blockquote><ol start="2"><li>点一下左边的 +, 找到 SpringBoot 项, 配置一下下面的三项<br><img src="https://pic.imgdb.cn/item/654b5a28c458853aefa1b906.png" alt="Alt &#39;模块多实例参数配置&#39;"><br>(如果 Program arguments 没有的话, 可以在绿色区域搜索添加)</li></ol></blockquote><blockquote><ol start="3"><li>Program arguments 配置的内容为 <code>--spring.profiles.active=8081</code>, 作用是启动这个 SpringBoot 应用时使用<code>8081</code> 环境, 也就是对应 <code>application-8081.yml</code> 里面的配置</li></ol></blockquote><blockquote><ol start="4"><li>同理, 在配置多一条 <code>8082</code> 环境的启动命令, 这样子模块就能启动 2 个程序了</li></ol></blockquote><h3 id="2-3-搭建-1-个服务提供方"><a href="#2-3-搭建-1-个服务提供方" class="headerlink" title="2.3 搭建 1 个服务提供方"></a>2.3 搭建 1 个服务提供方</h3><ol><li><p>在父模块里面新建一个子模块, 模块名 <code>client-provider</code>  </p></li><li><p>在模块里面添加如下依赖</p></li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- eureka 服务端的依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- web 功能的支持, 没有这个 客户端就会启动完就结束程序 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><ol start="3"><li>然后在启动类上加上注解 <code>@EnableEurekaClient</code></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableEurekaClient</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaClientOne</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaClientOne</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li><p>同样在 src&#x2F;main&#x2F;resources 里面新建 1 个配置文件, <code>application.yml</code></p></li><li><p>在 <code>application.yml</code> 里面加上这 2 个配置</p></li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> client<span class="token punctuation">-</span>provider<span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9091</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>spring.application.name<span class="token punctuation">&#125;</span><span class="token punctuation">:</span>$<span class="token punctuation">&#123;</span>server.port<span class="token punctuation">&#125;</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token comment"># 向服务端的注册地址</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8081.com<span class="token punctuation">:</span>8081/eureka/<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8082.com<span class="token punctuation">:</span>8082/eureka</code></pre><ol start="6"><li>服务提供方新增一个的 Rest Api</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProviderController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/server/&#123;num&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> resp <span class="token operator">=</span> <span class="token string">"服务提供端收到了消息:"</span> <span class="token operator">+</span> num<span class="token punctuation">;</span>        <span class="token keyword">return</span> resp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="7"><li>依次启动服务端 (注册中心), 服务提供方</li></ol><p>至此, 我们的环境就搭好了, 这次没有创建服务调用方。<br>这里直接采用网关调用服务提供方的方式, 也就是说, 我们的网关就是服务调用方。</p><h2 id="3-Gateway-开始使用"><a href="#3-Gateway-开始使用" class="headerlink" title="3 Gateway 开始使用"></a>3 Gateway 开始使用</h2><ol><li><p>在父模块里面新建一个子模块, 模块名 <code>gateway-service</code>  </p></li><li><p>在模块里面添加如下依赖</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 引入 eureka 的客户端, 让其可以被 eureka 服务端, 也就是注册中心进行观察  --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- gateway 是基于 netty + webflux 实现的, 所以本身已经支持 web 功能, 可以不用 web 相关的依赖 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-gateway<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre></li><li><p>在启动类添加注解 <code>@EnableEurekaClient</code> 即可</p><pre class="language-Java" data-language="Java"><code class="language-Java">@EnableEurekaClient@SpringBootApplicationpublic class MonitorDashBoard &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MonitorDashBoard.class, args);    &#125;&#125;</code></pre></li><li><p>在 <code>application.yml</code> 里面如下配置</p></li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> gateway<span class="token punctuation">-</span>service  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>      <span class="token key atrule">gateway</span><span class="token punctuation">:</span>        <span class="token comment"># 配置路由规则, 访问当前网关的 /server/* 会转发请求到 http://localhost:9091/server/*</span>        <span class="token key atrule">routes</span><span class="token punctuation">:</span>        <span class="token comment"># 路由Id, 需要唯一</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> server.route          <span class="token key atrule">uri</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span><span class="token number">9091</span>          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> Path=/server/*<span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10101</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>spring.application.name<span class="token punctuation">&#125;</span><span class="token punctuation">:</span>$<span class="token punctuation">&#123;</span>server.port<span class="token punctuation">&#125;</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token comment"># 向服务端的注册地址</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8081.com<span class="token punctuation">:</span>8081/eureka/<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8082.com<span class="token punctuation">:</span>8082/eureka</code></pre><ol start="5"><li>如果不想通过配置的方式进行配置, 也可以通过代码的方式进行配置, 声明如下的配置类</li></ol><pre class="language-Java" data-language="Java"><code class="language-Java">@Configurationpublic class RouteConfigruation &#123;    @Bean    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) &#123;        &#x2F;&#x2F; 配置了一个 id 为 second_route, 访问 &#x2F;second&#x2F;* 会被重定向到 http:&#x2F;&#x2F;localhost:9091&#x2F;second&#x2F;*        return builder.routes()                .route(&quot;second_route&quot;, r -&gt; r.path(&quot;&#x2F;second&#x2F;*&quot;).uri(&quot;http:&#x2F;&#x2F;localhost:9091&#x2F;second&#x2F;*&quot;))                .build();    &#125;&#125;</code></pre><ol start="6"><li>启动网关服务, 访问 <code>http://localhost:10101/server/123</code>, 可以收到响应: <strong>服务提供端收到了消息:123</strong></li></ol><h2 id="4-Gateway-的路由规则"><a href="#4-Gateway-的路由规则" class="headerlink" title="4 Gateway 的路由规则"></a>4 Gateway 的路由规则</h2><p>上面的例子, 通过配置路径的方式进行路由, 也就是通过配置 Path 的方式进行配置。而 Gateway 还支持很多配置, 进行路由的配置</p><table><thead><tr><th align="left">关键字</th><th align="center">作用</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">Path</td><td align="center">请求路径匹配, 也是一个正则</td><td align="left">- Path&#x3D;&#x2F;server&#x2F;{num}</td></tr><tr><td align="left">After</td><td align="center">请求在指定的时间后</td><td align="left">- After&#x3D;2018-01-20T06:06:06+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td align="left">Before</td><td align="center">请求在指定的时间前</td><td align="left">- Before&#x3D;2018-01-20T06:06:06+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td align="left">Between</td><td align="center">请求在指定的时间内</td><td align="left">- Between&#x3D;2018-01-20T06:06:06+08:00[Asia&#x2F;Shanghai], 2019-01-20T06:06:06+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td align="left">Cookie</td><td align="center">请求必须带某个 key 的 Cookie, value 是一个正则表达式</td><td align="left">- Cookie&#x3D;key, regularExpression</td></tr><tr><td align="left">Header</td><td align="center">请求头必须带某个 key, value 是一个正则表达式</td><td align="left">- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td align="left">Host</td><td align="center">请求来至于对应的主机, 才做处理, 通过正则配置</td><td align="left">- Host&#x3D;**.baidu.com</td></tr><tr><td align="left">Mehtod</td><td align="center">请求的方式限制</td><td align="left">-Method&#x3D;GET</td></tr><tr><td align="left">Query</td><td align="center">请求包括指定的请求参数, 同时支持指定参数(正则设置)的匹配</td><td align="left">- Query&#x3D;arg 或者 - Query&#x3D;key, regularExpression</td></tr><tr><td align="left">RemoteAddr</td><td align="center">请求来自于某个 Ip</td><td align="left">- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr></tbody></table><p>上面的规则不仅可以单独使用, 也可以进行组合使用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架使用 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-Hystrix简单使用</title>
      <link href="/article/2019/2951766549/"/>
      <url>/article/2019/2951766549/</url>
      
        <content type="html"><![CDATA[<h2 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h2><p>因为 SpirngBoot, SpringCloud 的各个版本之间差异还是挺大的, 所以在参照本博客进行学习时, 有可能出现因为版本不一致, 而出现不同的问题。<br>如果可以和本项目使用的环境保持一致, 即使不一致, 也尽可能不要跨大版本。</p><p>环境清单</p><table><thead><tr><th align="center">框架</th><th align="center">版本</th></tr></thead><tbody><tr><td align="center">JDK</td><td align="center">1.8</td></tr><tr><td align="center">Spring Boot</td><td align="center">2.1.4.RELEASE</td></tr><tr><td align="center">Spring Cloud</td><td align="center">Greenwich.SR1</td></tr></tbody></table><h2 id="2-准备"><a href="#2-准备" class="headerlink" title="2 准备"></a>2 准备</h2><h3 id="2-1-Maven-父模块配置"><a href="#2-1-Maven-父模块配置" class="headerlink" title="2.1 Maven 父模块配置"></a>2.1 Maven 父模块配置</h3><ol><li>先建立一个 Maven 的父模块, 也就是整个项目里面只有一个 pom 文件  </li><li>在父 pom 里面添加一些共用的配置, 比如 SpringBoot, SpringCloud 的依赖</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 手动引入 spring boot 版本依赖--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.4.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>lcn29.github.io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-eureka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- 手动引入 spring cloud 对应的配置 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>Greenwich.SR1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 手动 引入 spring cloud 的基础模块--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 省略一些打包相关的配置 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h3 id="2-2-启动-2-个服务端-注册中心"><a href="#2-2-启动-2-个服务端-注册中心" class="headerlink" title="2.2 启动 2 个服务端 (注册中心)"></a>2.2 启动 2 个服务端 (注册中心)</h3><ol><li>在父模块里面新建一个子模块, 模块名 <code>eureka-server</code>  </li><li>在子模块引入 Eureka 服务端需要的依赖</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- eureka 服务端的依赖--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><ol start="3"><li>在启动类上加上注解 <code>@EnableEurekaServer</code></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableEurekaServer</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaServe</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaServe</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li><p>在 src&#x2F;main&#x2F;resources 里面新建 3 个配置文件, 分别是 <code>application.yml</code>, <code>application-8081.yml</code>, <code>application-8081.yml</code></p></li><li><p>在 <code>application.yml</code> 里面加上这 2 个配置</p></li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># eureka 服务端的通用配置</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> server<span class="token punctuation">-</span>eureka<span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>spring.application.name<span class="token punctuation">&#125;</span><span class="token punctuation">:</span>$<span class="token punctuation">&#123;</span>server.port<span class="token punctuation">&#125;</span></code></pre><ol start="6"><li>在 <code>application-8081.yml</code> 里面加上这 2 个配置</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># eureka 服务端 1 的配置</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8081</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>8081.com  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8082.com<span class="token punctuation">:</span>8082/eureka/</code></pre><ol start="7"><li>在 <code>application-8082.yml</code> 里面加上这 2 个配置</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># eureka 服务端 1 的配置</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8082</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>8082.com  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8081.com<span class="token punctuation">:</span>8081/eureka/</code></pre><ol start="8"><li>在电脑的 hosts 文件里面添加这 2 行映射</li></ol><pre class="language-txt" data-language="txt"><code class="language-txt">127.0.0.1 eureka-8081.com127.0.0.1 eureka-8082.com</code></pre><ol start="9"><li>为了让我们的子模块能够启动为 2 个服务端, 需要我们做一下启动的配置</li></ol><blockquote><ol><li>Idea 找到右上角的这个<br><img src="https://pic.imgdb.cn/item/654b5368c458853aef8dfdb7.png" alt="Alt &#39;模块多实例配置&#39;"></li></ol></blockquote><blockquote><ol start="2"><li>点一下左边的 +, 找到 SpringBoot 项, 配置一下下面的三项<br><img src="https://pic.imgdb.cn/item/654b5a28c458853aefa1b906.png" alt="Alt &#39;模块多实例参数配置&#39;"><br>(如果 Program arguments 没有的话, 可以在绿色区域搜索添加)</li></ol></blockquote><blockquote><ol start="3"><li>Program arguments 配置的内容为 <code>--spring.profiles.active=8081</code>, 作用是启动这个 SpringBoot 应用时使用<code>8081</code> 环境, 也就是对应 <code>application-8081.yml</code> 里面的配置</li></ol></blockquote><blockquote><ol start="4"><li>同理, 在配置多一条 <code>8082</code> 环境的启动命令, 这样子模块就能启动 2 个程序了</li></ol></blockquote><h3 id="2-3-搭建-1-个服务提供方"><a href="#2-3-搭建-1-个服务提供方" class="headerlink" title="2.3 搭建 1 个服务提供方"></a>2.3 搭建 1 个服务提供方</h3><ol><li><p>在父模块里面新建一个子模块, 模块名 <code>client-provider</code>  </p></li><li><p>在模块里面添加如下依赖</p></li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- eureka 服务端的依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- web 功能的支持, 没有这个 客户端就会启动完就结束程序 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><ol start="3"><li>然后在启动类上加上注解 <code>@EnableEurekaClient</code></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableEurekaClient</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClientProvider</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaClientOne</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li><p>同样在 src&#x2F;main&#x2F;resources 里面新建 1 个配置文件, <code>application.yml</code></p></li><li><p>在 <code>application.yml</code> 里面加上这 2 个配置</p></li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> client<span class="token punctuation">-</span>provider<span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9091</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>spring.application.name<span class="token punctuation">&#125;</span><span class="token punctuation">:</span>$<span class="token punctuation">&#123;</span>server.port<span class="token punctuation">&#125;</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token comment"># 向服务端的注册地址</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8081.com<span class="token punctuation">:</span>8081/eureka/<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8082.com<span class="token punctuation">:</span>8082/eureka</code></pre><ol start="6"><li>服务提供方新增一个的 Rest Api</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProviderController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hello/&#123;delay&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"delay"</span><span class="token punctuation">)</span><span class="token keyword">int</span> delay<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 传递的参数为1, 让线程睡5s, 让调用方超时</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//打印请求的地址</span>        <span class="token class-name">String</span> resp <span class="token operator">=</span> <span class="token string">"当前响应来自于服务提供方"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> resp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-4-搭建-1-个服务调用方"><a href="#2-4-搭建-1-个服务调用方" class="headerlink" title="2.4 搭建 1 个服务调用方"></a>2.4 搭建 1 个服务调用方</h3><ol><li><p>在父模块里面再建立一个子模块, 模块名<code>client-consumer</code>, 作为服务的调用方</p></li><li><p>在模块里面添加如下依赖</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- eureka 服务端的依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- web 功能的支持, 没有这个 客户端就会启动完就结束程序 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--远程调用--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>然后在启动类上加上注解 <code>@EnableEurekaClient</code></p></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token annotation punctuation">@EnableEurekaClient</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClientConsumer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">ClientConsumer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li>在 <code>application.yml</code> 中添加配置</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> client<span class="token punctuation">-</span>consumer<span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10101</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>spring.application.name<span class="token punctuation">&#125;</span><span class="token punctuation">:</span>$<span class="token punctuation">&#123;</span>server.port<span class="token punctuation">&#125;</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token comment"># 向服务端的注册地址</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8081.com<span class="token punctuation">:</span>8081/eureka/<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8082.com<span class="token punctuation">:</span>8082/eureka</code></pre><ol start="5"><li>创建一个接口, 用于远程调用</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// name 是服务提供方的应用名</span><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"client-provider"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ProviderRemote</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>    <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ol start="6"><li>声明一个 Controller (用于测试), 注入刚声明的接口</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HystrixController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">ProviderRemote</span> providerRemote<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hystrix/&#123;delay&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hystrix</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"delay"</span><span class="token punctuation">)</span><span class="token keyword">int</span> delay<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> resp <span class="token operator">=</span> providerRemote<span class="token punctuation">.</span><span class="token function">hystrix</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> resp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="7"><li>依次启动服务端 (注册中心), 服务提供方, 服务调用方</li></ol><p>至此, 我们的环境就搭好了, 项目如果正常的话, 这时候访问 <code>http://localhost:10101/ribbon</code>, 服务调用方是可以调用到服务提供方的。</p><h2 id="3-Hystrix-开始使用"><a href="#3-Hystrix-开始使用" class="headerlink" title="3 Hystrix 开始使用"></a>3 Hystrix 开始使用</h2><ol><li>在服务调用方的依赖里面加入 Hystrix 的依赖</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 熔断器 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-hystrix<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><ol start="2"><li><p>启动类加上 @EnableCircuitBreaker 注解, 启动熔断功能</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token annotation punctuation">@EnableEurekaClient</span><span class="token annotation punctuation">@EnableCircuitBreaker</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClientConsumer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">ClientConsumer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></li><li><p>为服务调用方的 Feign 接口创建一个实现类, 并注入容器, 同时设置 @FeignClient 的 fallback 选项为我们的实现类</p></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 在原本的 ProviderRemote 接口的 @FeignClient 注解里面加上对应的实现类</span><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"client-provider"</span><span class="token punctuation">,</span> fallback <span class="token operator">=</span> <span class="token class-name">ProviderRemoteImpl</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ProviderRemote</span> <span class="token punctuation">&#123;</span>   <span class="token comment">/**    * 远程接口    * @param delay 是否进入延迟 1：开启    * @return    */</span>   <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hello/&#123;delay&#125;"</span><span class="token punctuation">)</span>   <span class="token class-name">String</span> <span class="token function">hystrix</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"delay"</span><span class="token punctuation">)</span><span class="token keyword">int</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// ProviderRemote 接口实现类</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProviderRemoteImpl</span> <span class="token keyword">implements</span> <span class="token class-name">ProviderRemote</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hystrix</span><span class="token punctuation">(</span><span class="token keyword">int</span> delay<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"服务提供方出现异常, 不进行调用, 直接返回了"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li>在 在 <code>application.yml</code> 里面加上启动 Hystrix 的配置</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">hystrix</span><span class="token punctuation">:</span>    <span class="token comment"># 开启熔断器功能</span>    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p>这时通过请求调用方的提供 HystrixController 声明的接口</p><blockquote><ol><li>入参为 1, 响应结果为: <strong>服务提供方出现异常, 不进行调用, 直接返回了</strong></li><li>入参为非 1 的其他参数, 响应结果为: <strong>当前响应来自于服务提供方</strong></li></ol></blockquote><h2 id="4-通过-Hystrix-dashboard-进行监控"><a href="#4-通过-Hystrix-dashboard-进行监控" class="headerlink" title="4 通过 Hystrix-dashboard 进行监控"></a>4 通过 Hystrix-dashboard 进行监控</h2><p>Hystrix 提供了一套实时监控的工具: HystrixDashboard。<br>通过 HystrixDashboard 我们可以在直观地看到各 Hystrix Command 的请求响应时间, 请求成功率等数据。下面就介绍一下怎么使用。</p><ol><li>我们的 Hystrix 项目需要提供一个注册一个 Servlet, 提供给监控项目使用, 也就是在我们的服务调用方添加下面的逻辑</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 新增一个配置类  * 提供一个 Servlet 供监控项目使用 */</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MetricsStreamServletConfigration</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">ServletRegistrationBean</span> <span class="token function">getServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">HystrixMetricsStreamServlet</span> streamServlet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HystrixMetricsStreamServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ServletRegistrationBean</span> registrationBean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServletRegistrationBean</span><span class="token punctuation">(</span>streamServlet<span class="token punctuation">)</span><span class="token punctuation">;</span>        registrationBean<span class="token punctuation">.</span><span class="token function">setLoadOnStartup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        registrationBean<span class="token punctuation">.</span><span class="token function">addUrlMappings</span><span class="token punctuation">(</span><span class="token string">"/actuator/hystrix.stream"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        registrationBean<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"HystrixMetricsStreamServlet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> registrationBean<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="2"><li><p>在父模块里面新建一个子模块, 模块名 <code>monitor-dashboard</code>  </p></li><li><p>在模块里面添加如下依赖</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-hystrix<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- hystrix 监控 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-hystrix-dashboard<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.4.7.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>在启动类添加注解 @EnableHystrixDashboard</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableHystrixDashboard</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MonitorDashBoard</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">MonitorDashBoard</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></li><li><p>启动项目后, 在浏览器输入 <strong><a href="http://localhost:你设置的端口/hystrix">http://localhost:你设置的端口/hystrix</a></strong>, 链接打开后的样子如下:</p></li></ol><p><img src="https://pic.imgdb.cn/item/6554e0cac458853aef41236e.png" alt="Alt &#39;HystrixDashboard 初始界面&#39;"><br>在第一个空格输入你的要监控的 hystrix 项目, 一般是服务调用者的 <strong>http 地址 + 端口 + &#x2F;actuator&#x2F;hystrix.stream</strong>, 下面的 Title 随意输</p><ol start="6"><li>输入后打开, 可以看到这个界面 (如果界面一直在 loading, 手动调用一次 服务调用者的接口就可以了)</li></ol><p><img src="https://pic.imgdb.cn/item/6554e0dbc458853aef41bfb9.png" alt="Alt &#39;HystrixDashboard 项目监控界面&#39;"></p><ol start="7"><li>Hystrix-dashboard 可以查看每个应用的信息, 但是每次都只能查看一个, 有时我们需要了解这个集群的情况, Hystrix-dashboard 就满足不了了, 这时可以使用 <strong>Turbine</strong>, 这里就不做更多的说明了</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 框架使用 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Ribbon 简单使用</title>
      <link href="/article/2019/3913265623/"/>
      <url>/article/2019/3913265623/</url>
      
        <content type="html"><![CDATA[<h2 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h2><p>因为 SpirngBoot, SpringCloud 的各个版本之间差异还是挺大的, 所以在参照本博客进行学习时, 有可能出现因为版本不一致, 而出现不同的问题。<br>如果可以和本项目使用的环境保持一致, 即使不一致, 也尽可能不要跨大版本。</p><p>环境清单</p><table><thead><tr><th align="center">框架</th><th align="center">版本</th></tr></thead><tbody><tr><td align="center">JDK</td><td align="center">1.8</td></tr><tr><td align="center">Spring Boot</td><td align="center">2.1.4.RELEASE</td></tr><tr><td align="center">Spring Cloud</td><td align="center">Greenwich.SR1</td></tr></tbody></table><h2 id="2-准备"><a href="#2-准备" class="headerlink" title="2 准备"></a>2 准备</h2><h3 id="2-1-Maven-父模块配置"><a href="#2-1-Maven-父模块配置" class="headerlink" title="2.1 Maven 父模块配置"></a>2.1 Maven 父模块配置</h3><ol><li>先建立一个 Maven 的父模块, 也就是整个项目里面只有一个 pom 文件  </li><li>在父 pom 里面添加一些共用的配置, 比如 SpringBoot, SpringCloud 的依赖</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 手动引入 spring boot 版本依赖--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.4.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>lcn29.github.io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-eureka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- 手动引入 spring cloud 对应的配置 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>Greenwich.SR1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 手动 引入 spring cloud 的基础模块--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 省略一些打包相关的配置 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h3 id="2-2-启动-2-个服务端-注册中心"><a href="#2-2-启动-2-个服务端-注册中心" class="headerlink" title="2.2 启动 2 个服务端 (注册中心)"></a>2.2 启动 2 个服务端 (注册中心)</h3><ol><li>在父模块里面新建一个子模块, 模块名 <code>eureka-server</code>  </li><li>在子模块引入 Eureka 服务端需要的依赖</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- eureka 服务端的依赖--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><ol start="3"><li>在启动类上加上注解 <code>@EnableEurekaServer</code></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableEurekaServer</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaServe</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaServe</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li><p>在 src&#x2F;main&#x2F;resources 里面新建 3 个配置文件, 分别是 <code>application.yml</code>, <code>application-8081.yml</code>, <code>application-8081.yml</code></p></li><li><p>在 <code>application.yml</code> 里面加上这 2 个配置</p></li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># eureka 服务端的通用配置</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> server<span class="token punctuation">-</span>eureka<span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>spring.application.name<span class="token punctuation">&#125;</span><span class="token punctuation">:</span>$<span class="token punctuation">&#123;</span>server.port<span class="token punctuation">&#125;</span></code></pre><ol start="6"><li>在 <code>application-8081.yml</code> 里面加上这 2 个配置</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># eureka 服务端 1 的配置</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8081</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>8081.com  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8082.com<span class="token punctuation">:</span>8082/eureka/</code></pre><ol start="7"><li>在 <code>application-8082.yml</code> 里面加上这 2 个配置</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># eureka 服务端 1 的配置</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8082</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>8082.com  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8081.com<span class="token punctuation">:</span>8081/eureka/</code></pre><ol start="8"><li>在电脑的 hosts 文件里面添加这 2 行映射</li></ol><pre class="language-txt" data-language="txt"><code class="language-txt">127.0.0.1 eureka-8081.com127.0.0.1 eureka-8082.com</code></pre><ol start="9"><li>为了让我们的子模块能够启动为 2 个服务端, 需要我们做一下启动的配置</li></ol><blockquote><ol><li>Idea 找到右上角的这个<br><img src="https://pic.imgdb.cn/item/654b5368c458853aef8dfdb7.png" alt="Alt &#39;模块多实例配置&#39;"></li></ol></blockquote><blockquote><ol start="2"><li>点一下左边的 +, 找到 SpringBoot 项, 配置一下下面的三项<br><img src="https://pic.imgdb.cn/item/654b5a28c458853aefa1b906.png" alt="Alt &#39;模块多实例参数配置&#39;"><br>(如果 Program arguments 没有的话, 可以在绿色区域搜索添加)</li></ol></blockquote><blockquote><ol start="3"><li>Program arguments 配置的内容为 <code>--spring.profiles.active=8081</code>, 作用是启动这个 SpringBoot 应用时使用<code>8081</code> 环境, 也就是对应 <code>application-8081.yml</code> 里面的配置</li></ol></blockquote><blockquote><ol start="4"><li>同理, 在配置多一条 <code>8082</code> 环境的启动命令, 这样子模块就能启动 2 个程序了</li></ol></blockquote><h3 id="2-3-搭建-2-个服务提供方"><a href="#2-3-搭建-2-个服务提供方" class="headerlink" title="2.3 搭建 2 个服务提供方"></a>2.3 搭建 2 个服务提供方</h3><ol><li><p>在父模块里面新建一个子模块, 模块名 <code>client-provider</code>  </p></li><li><p>在模块里面添加如下依赖</p></li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- eureka 服务端的依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- web 功能的支持, 没有这个 客户端就会启动完就结束程序 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><ol start="3"><li>然后在启动类上加上注解 <code>@EnableEurekaClient</code></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableEurekaClient</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaClientOne</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaClientOne</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li><p>同样在 src&#x2F;main&#x2F;resources 里面新建 3 个配置文件, 分别是 <code>application.yml</code>, <code>application-9091.yml</code> 和 <code>application-9092.yml</code></p></li><li><p>在 <code>application.yml</code> 里面加上这 2 个配置</p></li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> client<span class="token punctuation">-</span>provider<span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>spring.application.name<span class="token punctuation">&#125;</span><span class="token punctuation">:</span>$<span class="token punctuation">&#123;</span>server.port<span class="token punctuation">&#125;</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token comment"># 向服务端的注册地址</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8081.com<span class="token punctuation">:</span>8081/eureka/<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8082.com<span class="token punctuation">:</span>8082/eureka</code></pre><ol start="6"><li>在 <code>application-9091.yml</code> 里面加上端口配置</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9091</span></code></pre><ol start="7"><li>在 <code>application-9092.yml</code> 里面加上端口配置</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9092</span></code></pre><ol start="8"><li>服务提供方新增一个的 Rest Api</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProviderController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 返回请求的地址</span>        <span class="token keyword">return</span> <span class="token string">"当前响应来自于"</span> <span class="token operator">+</span> request<span class="token punctuation">.</span><span class="token function">getRequestURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-4-搭建-1-个服务调用方"><a href="#2-4-搭建-1-个服务调用方" class="headerlink" title="2.4 搭建 1 个服务调用方"></a>2.4 搭建 1 个服务调用方</h3><ol><li><p>在父模块里面再建立一个子模块, 模块名<code>client-consumer</code>, 作为服务的调用方</p></li><li><p>在模块里面添加如下依赖</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- eureka 服务端的依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- web 功能的支持, 没有这个 客户端就会启动完就结束程序 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--远程调用--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>然后在启动类上加上注解 <code>@EnableEurekaClient</code></p></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token annotation punctuation">@EnableEurekaClient</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClientConsumer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">ClientConsumer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li>在 <code>application.yml</code> 中添加配置</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> client<span class="token punctuation">-</span>consumer<span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10101</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>spring.application.name<span class="token punctuation">&#125;</span><span class="token punctuation">:</span>$<span class="token punctuation">&#123;</span>server.port<span class="token punctuation">&#125;</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token comment"># 向服务端的注册地址</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8081.com<span class="token punctuation">:</span>8081/eureka/<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8082.com<span class="token punctuation">:</span>8082/eureka</code></pre><ol start="5"><li>创建一个接口, 用于远程调用</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// name 是服务提供方的应用名</span><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"client-provider"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ProviderRemote</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>    <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ol start="6"><li>声明一个 Controller (用于测试), 注入刚声明的接口</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RibbonController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">ProviderRemote</span> providerRemote<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/ribbon"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">ribbon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> resp <span class="token operator">=</span> providerRemote<span class="token punctuation">.</span><span class="token function">ribbon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> resp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="7"><li>依次启动服务端 (注册中心), 服务提供方, 服务调用方</li></ol><p>至此, 我们的环境就搭好了, 项目如果正常的话, 这时候访问 <code>http://localhost:10101/ribbon</code>, 服务调用方是可以调用到服务提供方的。</p><h2 id="3-Ribbon-负载均衡"><a href="#3-Ribbon-负载均衡" class="headerlink" title="3 Ribbon 负载均衡"></a>3 Ribbon 负载均衡</h2><h3 id="3-1-Ribbon-集成"><a href="#3-1-Ribbon-集成" class="headerlink" title="3.1 Ribbon 集成"></a>3.1 Ribbon 集成</h3><p>在上面验证环境时, 如果多调用几次接口, 就可以发现服务调用方已经在轮询调用 2 个服务提供方了。<br>其实, Feign 自身就使用了 Ribbon 的轮询负载进行调用服务。所以当你的服务提供方有多个的时候, 使用 Feign 进行远程调用的话, 不做任何的配置, Feign 默认就使用了轮询的负载在调用服务。</p><h3 id="3-2-修改-Ribbon-的负载算法"><a href="#3-2-修改-Ribbon-的负载算法" class="headerlink" title="3.2 修改 Ribbon 的负载算法"></a>3.2 修改 Ribbon 的负载算法</h3><p>可以直接修改 <code>application.yml</code> 配置文件, 添加如下配置</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 这里为服务提供者的应用名</span><span class="token key atrule">client-provider</span><span class="token punctuation">:</span>  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>    <span class="token comment"># 随机算法</span>    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.RandomRule</code></pre><table><thead><tr><th align="left">策略对应的实现类</th><th align="center">策略描述</th></tr></thead><tbody><tr><td align="left">com.netflix.loadbalancer.RoundRobinRule</td><td align="center">轮询选择 server</td></tr><tr><td align="left">com.netflix.loadbalancer.RandomRule</td><td align="center">随机选择一个 server</td></tr><tr><td align="left">com.netflix.loadbalancer.BestAvailableRule</td><td align="center">选择一个最小的并发请求的 server</td></tr><tr><td align="left">com.netflix.loadbalancer.AvailabilityFilteringRule</td><td align="center">过滤掉那些因为一直连接失败的被标记为 circuit tripped 的 server, 并过滤掉那些高并发的的 server (active connections 超过配置的阈值)</td></tr><tr><td align="left">com.netflix.loadbalancer.WeightedResponseTimeRule</td><td align="center">根据响应时间分配一个 weight, 响应时间越长, weight 越小, 被选中的可能性越低</td></tr><tr><td align="left">com.netflix.loadbalancer.RetryRule</td><td align="center">先按照 RoundRobinRule 的策略获取 server, 如果获取失败则在制定时间内进行重试, 直到获取可用的 server</td></tr><tr><td align="left">com.netflix.loadbalancer.ZoneAvoidanceRule</td><td align="center">复合判断 server 所在区域的性能和 server 的可用性选择 server</td></tr></tbody></table><h3 id="3-3-通过代码形式修改-Ribbon-的负载算法"><a href="#3-3-通过代码形式修改-Ribbon-的负载算法" class="headerlink" title="3.3 通过代码形式修改 Ribbon 的负载算法"></a>3.3 通过代码形式修改 Ribbon 的负载算法</h3><ol><li><p>新建一个配置类</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RibbonRuleConfig</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">IRule</span> <span class="token function">ribbonRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 返回我们需要的负载策略</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RandomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></li><li><p>指定调用方在调用哪个应用时, 使用什么策略</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 调用 client-provider 的服务时, 使用  RibbonRuleConfig 配置的策略</span><span class="token annotation punctuation">@RibbonClient</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"client-provider"</span><span class="token punctuation">,</span> configuration <span class="token operator">=</span> <span class="token class-name">RibbonRuleConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRibbonClient</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></code></pre></li></ol><h3 id="3-4-自定义负载策略"><a href="#3-4-自定义负载策略" class="headerlink" title="3.4 自定义负载策略"></a>3.4 自定义负载策略</h3><p>只需要实现 <strong>AbstractLoadBalancerRule</strong> 接口, 重写 <strong>choose</strong> 方法即可</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RibbonRule</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractLoadBalancerRule</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initWithNiwsConfig</span><span class="token punctuation">(</span><span class="token class-name">IClientConfig</span> iClientConfig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Server</span> <span class="token function">choose</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 实现你的逻辑, 最后返回选择的服务实例</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>使用方法和配置方式和系统内置的负载算法一样。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架使用 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Eureka 简单使用</title>
      <link href="/article/2019/2941950923/"/>
      <url>/article/2019/2941950923/</url>
      
        <content type="html"><![CDATA[<h2 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h2><p>因为 SpirngBoot, SpringCloud 的各个版本之间差异还是挺大的, 所以在参照本博客进行学习时, 有可能出现因为版本不一致, 而出现不同的问题。<br>如果可以和本项目使用的环境保持一致, 即使不一致, 也尽可能不要跨大版本。</p><p>环境清单</p><table><thead><tr><th align="center">框架</th><th align="center">版本</th></tr></thead><tbody><tr><td align="center">JDK</td><td align="center">1.8</td></tr><tr><td align="center">Spring Boot</td><td align="center">2.1.4.RELEASE</td></tr><tr><td align="center">Spring Cloud</td><td align="center">Greenwich.SR1</td></tr></tbody></table><h2 id="2-准备"><a href="#2-准备" class="headerlink" title="2 准备"></a>2 准备</h2><ol><li>先建立一个 Maven 的父模块, 也就是整个项目里面只有一个 pom 文件  </li><li>在父 pom 里面添加一些共用的配置, 比如 SpringBoot, SpringCloud 的依赖</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 手动引入 spring boot 版本依赖--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.4.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>lcn29.github.io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-eureka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- 手动引入 spring cloud 对应的配置 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>Greenwich.SR1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 手动 引入 spring cloud 的基础模块--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 省略一些打包相关的配置 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h2 id="3-建立一个单机的-Eureka-服务端-注册中心"><a href="#3-建立一个单机的-Eureka-服务端-注册中心" class="headerlink" title="3 建立一个单机的 Eureka 服务端 (注册中心)"></a>3 建立一个单机的 Eureka 服务端 (注册中心)</h2><ol><li>在父模块里面新建一个子模块, 模块名 <code>eureka-server-one</code>  </li><li>在子模块引入 Eureka 服务端需要的依赖</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- eureka 服务端的依赖--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><ol start="3"><li>在启动类上加上注解 <code>@EnableEurekaServer</code></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableEurekaServer</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaServerOne</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaServerOne</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li>项目这时会一直在报错, 因为当前应用会把自己当做一个服务注册到服务端, 此处需要停止它的这个行为, 在 SpringBoot 的配置文件 <code>application.yml</code> (Maven 模块是没有这个文件的, 需要在 src&#x2F;main&#x2F; 下面建立一个 resources 文件夹, 然后在里面创建这个文件), 加上这 2 个配置</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 应用的名字</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>server<span class="token punctuation">-</span>one<span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token comment"># 禁止把自己注册到 eureka 的服务端</span>    <span class="token key atrule">register-with-eureka</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>    <span class="token comment"># 不从 eureka 服务端拉取节点信息</span>    <span class="token key atrule">fetch-registry</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>    <span class="token comment"># eureka 的服务端的注册地址, 告诉客户端服务的地址（让其知道去哪注册）</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>8080/eureka/</code></pre><ol start="5"><li><p>通过浏览器访问 <code>http://localhost:8080/</code>, 就能看到 eureka 的管理页面  </p></li><li><p>这时候虽然程序运行起来的, 但是如果你查看页面的 General Info 项里面的 unavailable-replicas 会发现我们的 eureka 服务端显示为不可用的, 但实际它是可用的。</p></li></ol><p>自此, 我们的 Eureka 的服务端就可以了。</p><h2 id="4-建立一个-Eureka-客户端"><a href="#4-建立一个-Eureka-客户端" class="headerlink" title="4 建立一个 Eureka 客户端"></a>4 建立一个 Eureka 客户端</h2><ol><li>在父模块里面建立一个子模块, 模块名<code>eureka-client-one</code></li><li>在子模块引入 Eureka 客户端需要的依赖</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- eureka 服务端的依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- web 功能的支持, 没有这个 客户端就会启动完就结束程序 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><ol start="3"><li>然后在启动类上加上注解 <code>@EnableEurekaClient</code></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableEurekaClient</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaClientOne</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaClientOne</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li>在 <code>application.yml</code> 中添加配置</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>client<span class="token punctuation">-</span>one<span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9091</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token comment"># 服务端的注册地址</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>8080/eureka/</code></pre><ol start="5"><li>打开 eureka 的服务端界面, 可以看到 <code>Instances currently registered with Eureka</code> 项里面有刚刚启动的客户端的ApplicationName, 同时状态为 UP, 说明客户端已经注册到服务端了。</li></ol><h2 id="5-Eureka-客户端间服务调用"><a href="#5-Eureka-客户端间服务调用" class="headerlink" title="5 Eureka 客户端间服务调用"></a>5 Eureka 客户端间服务调用</h2><ol><li><p>在父模块里面再建立一个子模块, 模块名<code>eureka-client-two</code>, 作为服务的调用方</p></li><li><p>依赖, 启动类, 配置和 <code>eureka-client-one</code> 一样。 记得把 <code>application.yml</code> 中的 applicationName 修改为 <code>eureka-client-two</code>, 端口修改为另一个没有使用的, 这样我们就有 2 个客户端了</p></li><li><p>让 <code>eureka-client-one</code> 作为服务的提供方, 提供一个 Rest Api 接口</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyServerController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/server/&#123;id&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">server</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"收到请求Id : "</span> <span class="token operator">+</span> id <span class="token operator">+</span> <span class="token string">", 结束"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></li><li><p>服务调用方 <code>eureka-client-two</code> 引入 Feign, 作为服务间调用的方式</p></li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--远程调用--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><ol start="5"><li>服务的调用方 (这里为 eureka-client-two), 创建一个接口</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// name 是服务提供方的应用名</span><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"eureka-client-one"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RemoteServer</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用的 Rest api, 入参, 出参, 请求路径方式和远程的 Rest Api 一样</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/server/&#123;id&#125;"</span><span class="token punctuation">)</span>    <span class="token class-name">String</span> <span class="token function">server</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ol start="6"><li>在调用方 <code>eureka-client-two</code> 的实例中, 注入刚声明的接口</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FeignController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">RemoteServer</span> remoteServer<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/feign/&#123;id&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">feign</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> result <span class="token operator">=</span> remoteServer<span class="token punctuation">.</span><span class="token function">server</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="7"><li>在调用方 <code>eureka-client-two</code> 的启动类上加上注解 <code>@EnableFeignClients</code></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableEurekaClient</span><span class="token annotation punctuation">@EnableFeignClients</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaClientTwo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaClientTwo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="8"><li>依次启动 <code>eureka-server</code>, <code>eureka-client-one</code>, <code>eureka-client-two</code>, 然后在浏览器输入<code>http://localhost:&#123;eureka-client-two设置的端口&#125;/feign/123</code>, 可以看到<code>收到请求Id : 123, 结束</code>就是成功了</li></ol><h2 id="6-Eureka-服务端集群配置"><a href="#6-Eureka-服务端集群配置" class="headerlink" title="6 Eureka 服务端集群配置"></a>6 Eureka 服务端集群配置</h2><p>Eureka 作为注册中心, 一旦挂了, 基本整个系统就可能无法使用了 (如果 Eureka 是在运行过一段时间后才挂的, 同时各个客户端之间都有其他客户端的缓存, 还是能通信的, 就是无法加入新节点), 所以无特殊情况, Eureka 服务端都是以集群的形式部署的。</p><ol><li><p>同样的依照 <code>eureka-server-one</code>, 新建一个 <code>eureka-server-two</code> Maven 模块, 启动类, 配置, 依赖都一样。</p></li><li><p>修改 <code>eureka-server-one</code> 和  <code>eureka-server-two</code> 的配置</p></li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 这个是 eureka-server-one 的配置</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>server<span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8081</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token comment"># 向另外一个服务端注册自己, 如果有多个服务端, 通过逗号分隔就行了</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>8082/eureka/<span class="token comment"># 这个是 eureka-server-two 的配置</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>server<span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8082</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token comment"># 向另外一个服务端注册自己, 如果有多个服务端, 通过逗号分隔就行了</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>8081/eureka/      </code></pre><p>因为是集群配置, 所以 2 个服务端的应用名都是一样的</p><ol start="3"><li><p>启动项目 (第一个启动的会报错, 因为找不到需要的注册中心, 但你把第二个注册中心启动了, 就不会报错了) 依次访问 <code>http://localhost:8081</code> 和 <code>http://localhost:8082</code> 都可以访问, 但是你会发现你的服务端都是 <code>unavailable-replicas</code> 的。 这是因为 <code>eureka.client.serviceUrl.defaultZone 配置项的地址, 不能使用 localhost, 要使用域名</code></p></li><li><p>如果要解决服务端的 <code>unavailable-replicas</code> 状态, 可以临时通过修改 hosts 处理, 在电脑的 hosts 文件里面添加这 2 行</p></li></ol><pre class="language-txt" data-language="txt"><code class="language-txt">127.0.0.1 eureka-8081.com127.0.0.1 eureka-8082.com</code></pre><ol start="5"><li>修改配置文件的 <code>defaultZone</code> 项, 同时增加 <code>Instances</code>的配置, 其他的都不用修改</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 这个是 eureka-server-one 的配置</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token comment"># 当前服务的域名</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>8081.com    <span class="token comment"># 实例的名字, 上面的applicationName可以看出一个组, 而这里是说明当前的服务是组中的哪一个</span>    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>spring.application.name<span class="token punctuation">&#125;</span><span class="token punctuation">:</span>$<span class="token punctuation">&#123;</span>server.port<span class="token punctuation">&#125;</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token comment"># 向另外一个服务端注册自己, 如果有多个服务端, 通过逗号分隔就行了</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8082.com<span class="token punctuation">:</span>8082/eureka/<span class="token comment"># 这个是 eureka-server-two 的配置</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token comment"># 当前服务的域名</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>8082.com    <span class="token comment"># 实例的名字, 上面的applicationName可以看出一个组, 而这里是说明当前的服务是组中的哪一个</span>    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>spring.application.name<span class="token punctuation">&#125;</span><span class="token punctuation">:</span>$<span class="token punctuation">&#123;</span>server.port<span class="token punctuation">&#125;</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token comment"># 向另外一个服务端注册自己, 如果有多个服务端, 通过逗号分隔就行了</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka<span class="token punctuation">-</span>8081.com<span class="token punctuation">:</span>8082/eureka/</code></pre><ol start="6"><li>最终的效果</li></ol><p><img src="https://pic.imgdb.cn/item/654a36d2c458853aef4a9846.png" alt="Alt &#39;Eureka 集群配置结果&#39;"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架使用 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 包装类型</title>
      <link href="/article/2019/3008448428/"/>
      <url>/article/2019/3008448428/</url>
      
        <content type="html"><![CDATA[<h2 id="1-了解包装类型"><a href="#1-了解包装类型" class="headerlink" title="1 了解包装类型"></a>1 了解包装类型</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>在 Java 中, 数据类型总共可以分为2大类 : <code>基础数据类型</code>和<code>引用数据类型</code>。<br>基础数据类型并不支持面向对象编程, 因为基础数据类型不具备 “对象” 的特性 – 携带属性和方法。<br>所以 Java 为 8 种基础数据类型提供了对应的类, 他们就是包装类, 侧面的将基础数据类型变为类, 符合面向对象编程。<br>之所以没有一开始就是提供包装类, 而是使用基础数据类型, 个人认为只是为了迎合人类根深蒂固的习惯, 并的确能简单、有效地进行常规数据处理。<br><code>总的来说：包装类就是基础数据类型在面向对象中的体现。</code></p><h3 id="1-2-包装类型的种类"><a href="#1-2-包装类型的种类" class="headerlink" title="1.2 包装类型的种类"></a>1.2 包装类型的种类</h3><table><thead><tr><th align="center">基本数据类型</th><th align="center">对应的包装类</th></tr></thead><tbody><tr><td align="center">byte (1 字节)</td><td align="center">java.lang.Byte</td></tr><tr><td align="center">short (2 字节)</td><td align="center">java.lang.Short</td></tr><tr><td align="center">int (4 字节)</td><td align="center">java.lang.Integer</td></tr><tr><td align="center">long (8 字节)</td><td align="center">java.lang.Long</td></tr><tr><td align="center">char (2 字节)</td><td align="center">java.lang.Character</td></tr><tr><td align="center">float (4 字节)</td><td align="center">java.lang.Float</td></tr><tr><td align="center">double (8 字节)</td><td align="center">java.lang.Double</td></tr><tr><td align="center">boolean (未定)</td><td align="center">java.lang.Boolean</td></tr></tbody></table><p>在 Java boolean 的大小, 有三种说法 <code>1/8字节</code>, <code>1字节</code>, <code>4个字节</code>。</p><h3 id="1-3-Java-代码中的继承关系"><a href="#1-3-Java-代码中的继承关系" class="headerlink" title="1.3 Java 代码中的继承关系"></a>1.3 Java 代码中的继承关系</h3><p><img src="https://pic.imgdb.cn/item/657d2b32c458853aef83cc0b.png" alt="Alt &#39;包装类的继承关系&#39;"></p><p>可以看出他们都实现了 Comparable 接口, 支持进行比较。<br>同时数字类型的包装类继承了 Number 抽象类, 支持转为其他基础数据类型。</p><h2 id="2-装箱-拆箱"><a href="#2-装箱-拆箱" class="headerlink" title="2 装箱&#x2F;拆箱"></a>2 装箱&#x2F;拆箱</h2><p>在 Java 中, 我们可以无缝的在包装类型和基础数据类型之间切换, 之间是有一个装换过程的, 这个过程就是 装箱&#x2F;拆箱</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// jdk5 之前, 我们如果需要将一个基础数据和包装类型切换, 需要手动处理</span><span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span><span class="token comment">// 手动装箱</span><span class="token class-name">Integer</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 手动拆箱</span><span class="token keyword">int</span> n <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// jdk5 后支持自动装箱和拆箱</span><span class="token comment">// 自动装箱, 实质是调用 对应包装类.valueOf() 方法实现的</span><span class="token class-name">Integer</span> obj <span class="token operator">=</span> m<span class="token punctuation">;</span><span class="token comment">// 自动拆箱, 实质是调用 对应包装类.xxxValue()方法实现的, 其中的xxx 就是对应的数据基础数据类型</span><span class="token keyword">int</span> n <span class="token operator">=</span> obj<span class="token punctuation">;</span></code></pre><h2 id="3-包装类型的缓存问题"><a href="#3-包装类型的缓存问题" class="headerlink" title="3 包装类型的缓存问题"></a>3 包装类型的缓存问题</h2><p>从装箱和拆箱, 我们可以知道, 把一个基础数据类型转为对应的包装类型, 有 2 种方式</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 主动装箱</span><span class="token class-name">Integer</span> num <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 自动装箱</span><span class="token class-name">Integer</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><p>这2种方式, 虽然都能达到将一个基础数据类型转为包装类型, 但是他们内部的实现, 还是有很大的区别, 这个区别很多时候, 能被用到很多面试题上。</p><p><strong>手动装箱</strong>  </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Integer</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 内部还是通过一个基础数据类型存储我们的数据值的</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>从 Integer 的源码我们可以知道, 我们每次手动装箱, 都会创建一个新的 Integer 对象。</p><p><strong>自动装箱</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Integer</span> <span class="token punctuation">&#123;</span>  <span class="token comment">/** 自动装箱 会调用到这个方法 */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 从这3行的 逻辑和 变量名 我们可以推测出</span>      <span class="token comment">// 如果我们 装箱的值  Integer缓存的下限 &lt;= i &lt;= Integer缓存的上限, 那么他会从 Interger的缓存里面取出对应的包装类, // 否则就重新创建一个新的</span>      <span class="token comment">// 那么 Integer的上下限分别是多少呢, 这个就需要看到 IntegerCache的代码了</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high<span class="token punctuation">)</span>          <span class="token keyword">return</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/** Integer 内部的缓存 */</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>      <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>      <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Integer</span> cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>      <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>        <span class="token comment">// 读取启动命令行 里面的 java.lang.Integer.IntegerCache.high 配置的值</span>        <span class="token comment">// 可以通过控制应用启动时, Integer 内部缓存池的大小</span>        <span class="token class-name">String</span> integerCacheHighPropValue <span class="token operator">=</span>  sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span><span class="token constant">VM</span><span class="token punctuation">.</span><span class="token function">getSavedProperty</span><span class="token punctuation">(</span><span class="token string">"java.lang.Integer.IntegerCache.high"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>              <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 从配置的值和127中取大的那一个</span>              i <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 控制 h 的值 小于等于 Integer.MAX_VALUE - 129</span>              <span class="token comment">// 这里说一下, h 和 high 都是 int 声明的, 所以最大值为 Integer.MAX_VALUE</span>              <span class="token comment">// 同时为了避免下面的(high - low) + 1 = high + 128 + 1 经过运算后超过了 int 的最大值, 变为负数, 所以此处才需要控制 h 的最大上限为  Integer.MAX_VALUE - 129</span>              h <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">-</span>low<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span> <span class="token class-name">NumberFormatException</span> nfe<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        high <span class="token operator">=</span> h<span class="token punctuation">;</span>        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>        <span class="token comment">// 创建 一个 缓存数组 存放 -128 到 h</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>            cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">assert</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high <span class="token operator">>=</span> <span class="token number">127</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><blockquote><ol><li>从 Integer 的源码 可以知道, Integer 内部维护了一个Integer的缓存, 这个缓存默认为 -128 到 127 之间, 所以我们通过自动装箱创建的 Integer 并且值在这个区间内, 都是从缓存里面获取到的</li><li>同时我们可以在我们程序启动时, 指定参数 java.lang.Integer.IntegerCache.high &#x3D; 你想要设置的缓存上限, 修改我们的 Integer 缓存池的上限</li><li>几个数值包装类型, 除了有精度的 Float 和 Double 外都有对应的缓存, 都是 [-128, 127] 之间, 但是只要 Integer 支持配置</li></ol></blockquote><h2 id="4-面试题"><a href="#4-面试题" class="headerlink" title="4 面试题"></a>4 面试题</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 第一, 比较的是否为同一个对象</span><span class="token class-name">Integer</span> num01 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> num02 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> num03 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// false  2 个对象 == 比较的是 2 个对象的内存地址是否一样</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num01 <span class="token operator">==</span> num02<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ture  基础数据类型 和 包装类型 比较时, 之间比较数值大小</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num02 <span class="token operator">==</span> num03<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num01 <span class="token operator">==</span> num03<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 第二, 比较的是 缓存, 自动装箱 数值默认在 [-128, 127] 之间都是从缓存取对象, Integer num04 = 2;</span><span class="token class-name">Integer</span> num05 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// true</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num04 <span class="token operator">==</span> num05<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> num06 <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> num07 <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span><span class="token comment">// false</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num06 <span class="token operator">==</span> num07<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 第三, 包装类型进行运算后, 会被转为 基础数据类型</span><span class="token class-name">Integer</span>  num08 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token class-name">Integer</span>  num09 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token class-name">Long</span> num10 <span class="token operator">=</span> <span class="token number">3L</span><span class="token punctuation">;</span><span class="token comment">// true, num08 + num09 变成了数值 3, 此处比较的是数值大小</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num10 <span class="token operator">==</span> <span class="token punctuation">(</span>num08 <span class="token operator">+</span> num09<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// false, equals 比较的是 2 个对象是否一样, 基础数据类型是无法比较的, 所以此处自动装箱了</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num10<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>num08 <span class="token operator">+</span> num09<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 第四：低精度和高精度运算, 低精度换转为高精度, 再进行运算</span><span class="token class-name">Integer</span>  num11 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token class-name">Long</span>  num12 <span class="token operator">=</span> <span class="token number">2L</span><span class="token punctuation">;</span><span class="token class-name">Long</span> num13 <span class="token operator">=</span> <span class="token number">3L</span><span class="token punctuation">;</span><span class="token comment">// 这里运算后 结果为 3L, 自动装箱为 3, 同时有缓存, 所以 2 个一样</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num13<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>num11 <span class="token operator">+</span> num12<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 第五： Double 和 Float 的自动装箱没有缓存</span><span class="token class-name">Double</span> num14 <span class="token operator">=</span> <span class="token number">1D</span><span class="token punctuation">;</span><span class="token class-name">Double</span> num15 <span class="token operator">=</span> <span class="token number">1D</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num14 <span class="token operator">==</span> num15<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>包装类型的知识就这些吧, 在判断 2 个对象是否一样时, 基本可以从下面入手</p><blockquote><ol><li>比较的是数值, 还是对象, 存在自动装箱和自动拆箱</li><li>比较的是包装类型, 是否自动装箱了, 值超过了缓存</li><li>包装类型进行了运算, 默认运算后的结果是基础数据类型</li><li>低精度和高精度运算, 低精度换转为高精度</li><li>Double 和 Float 的自动装箱没有缓存</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 外部类和内部类</title>
      <link href="/article/2019/2743414135/"/>
      <url>/article/2019/2743414135/</url>
      
        <content type="html"><![CDATA[<h2 id="1-外部类"><a href="#1-外部类" class="headerlink" title="1 外部类"></a>1 外部类</h2><p>在 Java 中, 创建的 <code>.java</code> 文件 (源文件) 时, 文件名必须和里面定义的类名一样。<br>而这个我们创建的类, 就是外部类, 也叫顶级类。</p><p>做一点引申: </p><blockquote><ol><li>在一个源文件里面, 可以有很多个顶级类, 但是这些顶级类只有和文件名一样的顶级类才能被 public 修饰, 只有一个, 其他的都只能用默认 (什么都不加) 进行修饰</li><li>同一个源文件里面的多个顶级类, 因为只有一个可以被 public 修饰, 所以导致其他的顶级类, 只能在当前包路径下使用</li><li>《Effective Java, Third Edition》第 25 条建议: 每个源文件只对应一个顶级类</li></ol></blockquote><h2 id="2-内部类"><a href="#2-内部类" class="headerlink" title="2 内部类"></a>2 内部类</h2><p>又称嵌套类, 是在类中在定义另外一个类, 这个类可以在顶级类里面的任意地方定义。</p><h3 id="2-1-静态内部类"><a href="#2-1-静态内部类" class="headerlink" title="2.1 静态内部类"></a>2.1 静态内部类</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OutClass</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">InnerClass</span> <span class="token punctuation">&#123;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>直接在顶级类的内部声明, 通过 static 进行修饰的类</p><p>特点: </p><blockquote><ol><li>所有的权限修饰符都可以进行修饰</li><li>能够在类中定义静态属性和方法</li><li>只能使用外部类的静态属性和方法</li><li>在其他类可以直接声明 (静态内部类与外部类没有关系, 在编译后, 就是 2 个普通的类)</li></ol></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">OutClass<span class="token punctuation">.</span>StaticInnerClass</span> innerClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OutClass<span class="token punctuation">.</span>StaticInnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-2-非静态内部类"><a href="#2-2-非静态内部类" class="headerlink" title="2.2 非静态内部类"></a>2.2 非静态内部类</h3><h4 id="2-2-1-成员内部类"><a href="#2-2-1-成员内部类" class="headerlink" title="2.2.1 成员内部类"></a>2.2.1 成员内部类</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OutClass</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InnerClass</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>定义在顶级类的直接内部, 和类的属性同级</p><p>特点:</p><blockquote><ol><li>所有的权限修饰符都可以进行修饰</li><li>不能够在类内定义静态属性和方法</li><li>能够访问外部类的所有属性和方法, 包括静态的</li><li>需要依靠所在类的外部类才能声明 (成员内部类对象会隐式的引用一个外部类对象, 也就是 2 者之间有联系)</li></ol></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">OutClass</span> outClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OutClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 需要先创建出外部类的实例, 通过实例才能创建内部类</span><span class="token class-name">OutClass<span class="token punctuation">.</span>InnerClass</span> innerClass <span class="token operator">=</span> outClass<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">InnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="2-2-2-局部内部类"><a href="#2-2-2-局部内部类" class="headerlink" title="2.2.2 局部内部类"></a>2.2.2 局部内部类</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OutClass</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">class</span> <span class="token class-name">InnerClass</span> <span class="token punctuation">&#123;</span>       <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>声明在顶级类的某个作用域内(方法体内, if 判断里面等)</p><p>特点：</p><blockquote><ol><li>这个类只能使用默认权限修饰符, 不能被其他的权限修饰符修饰</li><li>不能够在类内定义静态属性和方法</li><li>可以访问到外部类的属性和方法, 包括静态的</li><li>在其他类是无法创建声明的</li><li>局部类只能在对应的作用域起作用, 超出了对应的作用域就没了, 所以无法被其他的类调用</li></ol></blockquote><h4 id="2-2-3-匿名内部类"><a href="#2-2-3-匿名内部类" class="headerlink" title="2.2.3 匿名内部类"></a>2.2.3 匿名内部类</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OutClass</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">/**        *     创建格式:        *     new 父类/接口(参数列表) &#123;        *     &#125;        */</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token annotation punctuation">@Override</span>          <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>在顶级类的某个作用域内, 直接创建使用, 没有进行具体的声明</p><p>特点：</p><blockquote><ol><li>匿名内部类为局部内部类的特例, 具备局部内部类的特点</li></ol></blockquote><h2 id="3-作用"><a href="#3-作用" class="headerlink" title="3 作用"></a>3 作用</h2><h3 id="3-1-封装性-隐藏具体的细节-不让外部类知道"><a href="#3-1-封装性-隐藏具体的细节-不让外部类知道" class="headerlink" title="3.1 封装性, 隐藏具体的细节, 不让外部类知道"></a>3.1 封装性, 隐藏具体的细节, 不让外部类知道</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 加密器接口 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Encrypter</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 对内容进行加密     * @param content 加密的内容     * @return 加密后的内容     */</span>    <span class="token class-name">String</span> <span class="token function">encrypt</span><span class="token punctuation">(</span><span class="token class-name">String</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 外部类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OutClass</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 隐藏起来的加密器     */</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">MyEncrypter</span> <span class="token keyword">implements</span> <span class="token class-name">Encrypter</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">encrypt</span><span class="token punctuation">(</span><span class="token class-name">String</span> content<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 在需要加密的内容后面加上 encrypt</span>            <span class="token keyword">return</span> content <span class="token operator">+</span> <span class="token string">"encrypt"</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 获取加密器     * @return     */</span>    <span class="token keyword">public</span> <span class="token class-name">Encrypter</span> <span class="token function">getEncrypter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyEncrypter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 调用类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"需要加密的内容"</span><span class="token punctuation">;</span>        <span class="token comment">// 取到加密器, 此处我们只知道通过外部类就能获得加密器, 但是加密器的加密过程我们是不知道的</span>        <span class="token class-name">OutClass</span> outClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OutClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Encrypter</span> encrypter <span class="token operator">=</span> outClass<span class="token punctuation">.</span><span class="token function">getEncrypter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 加密内容</span>        <span class="token class-name">String</span> encryptedContent <span class="token operator">=</span> encrypter<span class="token punctuation">.</span><span class="token function">encrypt</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>encryptedContent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-2-间接实现多重继承-声明多个内部类-每个内部类继承一个类"><a href="#3-2-间接实现多重继承-声明多个内部类-每个内部类继承一个类" class="headerlink" title="3.2 间接实现多重继承(声明多个内部类, 每个内部类继承一个类)"></a>3.2 间接实现多重继承(声明多个内部类, 每个内部类继承一个类)</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 加密器 */</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Encrypter</span> <span class="token punctuation">&#123;</span>     <span class="token comment">/**      * 对内容进行加密      * @param content 加密的内容      * @return 加密后的内容      */</span>     <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">encrypt</span><span class="token punctuation">(</span><span class="token class-name">String</span> content<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">// 在需要加密的内容后面加上 encrypt</span>         <span class="token keyword">return</span> content <span class="token operator">+</span> <span class="token string">"encrypt"</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token comment">/** * 解密器 */</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Decrypter</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 对内容进行解密     * @param content 需要解密的内容     * @return 解密后的内容     */</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">decrypt</span><span class="token punctuation">(</span><span class="token class-name">String</span> content<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 在需要加密的内容后面加上 encrypt</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token string">"encrypt"</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 解密的内容不为空, 同时长度需要大于 length</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>content <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token operator">||</span> content<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> content<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> content<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> content<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> length <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 外部类, 此时我们的外部类具备了编码和解码的功能 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OutClass</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">MyEncrypter</span> <span class="token keyword">extends</span> <span class="token class-name">Encrypter</span><span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">MyDecrypter</span> <span class="token keyword">extends</span> <span class="token class-name">Decrypter</span><span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">encrypt</span><span class="token punctuation">(</span><span class="token class-name">String</span> content<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyEncrypter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encrypt</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">decrypt</span><span class="token punctuation">(</span><span class="token class-name">String</span> content<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyDecrypter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decrypt</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-3-方便编写事件驱动程序-如安卓里面的按钮事件等"><a href="#3-3-方便编写事件驱动程序-如安卓里面的按钮事件等" class="headerlink" title="3.3 方便编写事件驱动程序 (如安卓里面的按钮事件等)"></a>3.3 方便编写事件驱动程序 (如安卓里面的按钮事件等)</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">/** 匿名内部类 */</span>myBtn<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">View<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token class-name">View</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">//这里写代码</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="4-补充"><a href="#4-补充" class="headerlink" title="4 补充"></a>4 补充</h2><h3 id="4-1-内部类如何访问外部类的同名方法-属性"><a href="#4-1-内部类如何访问外部类的同名方法-属性" class="headerlink" title="4.1 内部类如何访问外部类的同名方法&#x2F;属性"></a>4.1 内部类如何访问外部类的同名方法&#x2F;属性</h3><p>内部类的属性, 方法和外部类的重名了, 在调用时, 优先使用内部类的, 同时可以通过<code>外部类.this.方法/属性</code>, 访问到外部类的同名方法&#x2F;属性</p><h3 id="4-2-局部内部类访问方法体内入参-变量的条件"><a href="#4-2-局部内部类访问方法体内入参-变量的条件" class="headerlink" title="4.2 局部内部类访问方法体内入参&#x2F;变量的条件"></a>4.2 局部内部类访问方法体内入参&#x2F;变量的条件</h3><blockquote><ol><li>局部内部类可以访问方法内的局部变量和入参, 但是前提是这个变量和入参在这个方法体内是被 final 修饰的</li><li>在 Java 8 中, 可以直接声明后使用, 只要你保证你的入参&#x2F;变量满足 <code>Effectively final</code></li></ol></blockquote><p>注: <code>Effectively final</code> 是 Java 8  新增的一个特性。<br>对于一个变量, 如果没有给它加 final 修饰, 而且没有对它的二次赋值, 那么这个变量就是 effectively final (有效的不会变的)。<br>简单的来说, 我们在方法 fn 里面声明了一个变量 int a &#x3D; 1; 在这个方法体内, 除了第一次声明外, 没有别的地方对其进行了修改, 他就是 effectively final, 而只要做了一次变更, 就会破坏掉这个状态。  </p><p>Effectively final 内部类和 Lambda 时会经常碰到, 一旦在他们内部做外部的一个变量做了变更就会编译失败, 但是单纯的读是支持的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 权限修饰符</title>
      <link href="/article/2019/1491542063/"/>
      <url>/article/2019/1491542063/</url>
      
        <content type="html"><![CDATA[<h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1 作用"></a>1 作用</h2><p>主要用于控制类, 属性, 方法的访问</p><h2 id="2-种类"><a href="#2-种类" class="headerlink" title="2 种类"></a>2 种类</h2><blockquote><ol><li>public</li><li>protected</li><li>什么都不加(默认, 有的地方写作 default)</li><li>private</li></ol></blockquote><h2 id="3-修饰的地方"><a href="#3-修饰的地方" class="headerlink" title="3 修饰的地方"></a>3 修饰的地方</h2><table><thead><tr><th align="center"></th><th align="center">属性</th><th align="center">方法</th><th align="center">外部类</th><th align="center">内部类</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="center">protected</td><td align="center">Y</td><td align="center">Y</td><td align="center">N</td><td align="center">Y</td></tr><tr><td align="center">什么都不加</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="center">private</td><td align="center">Y</td><td align="center">Y</td><td align="center">N</td><td align="center">Y</td></tr></tbody></table><p>从中可知: 4 个修饰符都能修饰: 属性, 方法, 内部类。<br>但是修饰外部类的只有 <code>public</code> 和 <code>什么都不加</code> </p><h2 id="4-可被访问的范围"><a href="#4-可被访问的范围" class="headerlink" title="4 可被访问的范围"></a>4 可被访问的范围</h2><table><thead><tr><th align="center"></th><th align="center">类的内部调用</th><th align="center">子类内部调用</th><th align="center">调用类 (和父类同包) 直接调用</th><th align="center">调用类 (和父类不同包) 直接调用</th><th align="center">调用类通过其子类间接调用 (和父类同包)</th><th align="center">调用类通过其子类间接调用 (和父类不同包)</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="center">protected</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">N</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">什么都不加</td><td align="center">Y</td><td align="center">Y&#x2F;N(特殊说明)</td><td align="center">Y</td><td align="center">N</td><td align="center">Y&#x2F;N(特殊说明)</td><td align="center">N</td></tr><tr><td align="center">private</td><td align="center">Y</td><td align="center">N</td><td align="center">N</td><td align="center">N</td><td align="center">N</td><td align="center">N</td></tr></tbody></table><p>上面的几种情况说明一下:</p><blockquote><ol><li>类的内部调用: 类内部的方法互相调用</li><li>子类内部调用: 子类调用父类的方法</li><li>调用类直接调用: 类 A 调用 类 B 的方法</li><li>调用类通过其子类间接调用: 类 A 是父类, 有方法 fn, 类 B 是 类 A 的子类, 类 C 调用 类 B 的 fn 方法</li></ol></blockquote><p>什么都不加(默认)</p><blockquote><ol><li><code>子类内部调用</code>: 当子类和父类不在同一个包下, 无法调用, 但是在同一个包下, 能调用</li><li><code>调用类通过其子类间接调用(和父类同包)</code>: 调用类, 子类, 父类, 都在同一个包路径下, 能够执行成功, 其他的情况, 都会失败</li></ol></blockquote><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p><strong>public</strong> 强调的是共有的, 所以在所有的地方都能调用</p><p><strong>protected</strong>  强调的是同一个包和子类, 所以可以在</p><blockquote><ol><li>类内部调用</li><li>子类内部调用</li><li>同一包下, 调用类调用, 即使是隔着子类间接的调用都可以, 只要 调用类和父类维持在统一包路径下</li></ol></blockquote><p><strong>什么都不加 (default)</strong> 强调的是同一个包, 所以可以在</p><blockquote><ol><li>类内部调用</li><li>子类和父类在同一个包下, 子类能调用</li><li>子类, 父类, 调用类都在同一个包下, 调用类可以通过子类间接调用到</li></ol></blockquote><p><strong>private</strong> 强调的是私有的, 所以只能在类的内部调用</p><h2 id="6-补充"><a href="#6-补充" class="headerlink" title="6 补充"></a>6 补充</h2><blockquote><ol><li>我们声明接口时, 接口方法 没有修饰符, 默认是 <code>public</code></li><li>4个修饰符的控制访问  private &lt; 什么都不加 &lt; protected &lt; public, 在重写父类的方法的时候, 修饰符必须大于父类的修饰符</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java ArrayList</title>
      <link href="/article/2019/715108250/"/>
      <url>/article/2019/715108250/</url>
      
        <content type="html"><![CDATA[<p>ArrayList 一个动态数组。本身是基于数组进行封装的列表, 提供了自动扩容的功能: 在容量不够的情况下, 自动扩容。<br>同时支持存储包括 null 在内的所有数据类型。</p><h2 id="1-数组-Array"><a href="#1-数组-Array" class="headerlink" title="1 数组 (Array)"></a>1 数组 (Array)</h2><p>了解 ArrayList 之前, 我们需要先了解一下数组的特点</p><blockquote><ol><li>数组的内存是连续的, 不存在相邻元素之间还隔着其他内存</li><li>数组内存储的数据类型都是一样的</li><li>数组具备了查询快, 增删慢的特点</li><li>数组在声明的时候需要知道初始的容量, 一个容量一旦确定了, 就不能再改变了</li></ol></blockquote><p>基于数组实现的 ArrayList, 同理也具备了相同的特性。</p><p>了解完 ArrayList 的特性, 下面进入到源码, 看看 ArrayList 的实现。</p><p>注: 本文是基于 Java 8 进行分析的。</p><h2 id="2-ArrayList-中的几比较重要的属性"><a href="#2-ArrayList-中的几比较重要的属性" class="headerlink" title="2 ArrayList 中的几比较重要的属性"></a>2 ArrayList 中的几比较重要的属性</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">transient</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_CAPACITY</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">EMPTY_ELEMENTDATA</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-1-elementData"><a href="#2-1-elementData" class="headerlink" title="2.1 elementData"></a>2.1 elementData</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">transient</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span> </code></pre><p>ArrayList 是基于 Array 实现的, 对 Array 做的封装。所以其本身还是通过 Array 进行数据的存储的。<br>而 elementData 就是真正存储数据的地方, 存到 ArrayList 的数据实际就是存在这里。</p><h3 id="2-2-DEFAULT-CAPACITY"><a href="#2-2-DEFAULT-CAPACITY" class="headerlink" title="2.2 DEFAULT_CAPACITY"></a>2.2 DEFAULT_CAPACITY</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_CAPACITY</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>一个 int 的整数, 表示 ArrayList 默认的初始容量大小。<br>数组在使用的时候需要<strong>提前声明容量</strong>, 基于数组实现的 ArrayList 也需要遵循这个规则。<br>所以在声明  ArrayList 时, 如果没有指定需要的容量大小, 默认是 10 进行声明容量的。</p><h3 id="2-3-EMPTY-ELEMENTDATA"><a href="#2-3-EMPTY-ELEMENTDATA" class="headerlink" title="2.3 EMPTY_ELEMENTDATA"></a>2.3 EMPTY_ELEMENTDATA</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">EMPTY_ELEMENTDATA</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>一个静态的空数组变量。   </p><p>在声明 ArrayList 时, 支持不显示声明容量大小, 则默认为 10。同样也可以手动声明大小, 声明了多少, 那么容量就是多少。<br>所以用户可以声明容量为 0, 那么 ArrayList 内部需要创建的数组就等于这个 <code>elementData = EMPTY_ELEMENTDATA</code>。<br>作用: 所有容量为 0 的情况, 都是这一个对象, 减少不必要的对象声明。  </p><h3 id="2-4-DEFAULTCAPACITY-EMPTY-ELEMENTDATA"><a href="#2-4-DEFAULTCAPACITY-EMPTY-ELEMENTDATA" class="headerlink" title="2.4 DEFAULTCAPACITY_EMPTY_ELEMENTDATA"></a>2.4 DEFAULTCAPACITY_EMPTY_ELEMENTDATA</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>在声明 ArrayList 时, 不指定容量的声明, 会先将 ArrayList 存储数据的 elementData 先赋值为这个空数组 <code>elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>。<br>在真正进行数据存储时, 再进行扩容。</p><p>同样的, 声明为 static, 可以共用, 节省内存。<br>同时不在声明时, 就按照默认容量创建一个数组。可以防止声明了 ArrayList, 但是没用到的情况, 浪费内存。  </p><h3 id="2-5-size"><a href="#2-5-size" class="headerlink" title="2.5 size"></a>2.5 size</h3><p>当前 ArrayList 真正存储的数据个数。</p><h2 id="3-ArrayList-的构造方法"><a href="#3-ArrayList-的构造方法" class="headerlink" title="3 ArrayList 的构造方法"></a>3 ArrayList 的构造方法</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 构造函数 1: 不指定容量构造</span>    <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 构造函数 2: 指定容量构造</span>    <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 构造函数 3: 给定一个 Collection 的构造</span>    <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-1-不指定容量构造"><a href="#3-1-不指定容量构造" class="headerlink" title="3.1 不指定容量构造"></a>3.1 不指定容量构造</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>很简单, 将空数组的 <strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong> 赋值给存储数据的 elementData。  </p><p>延迟声明有容量的数组, 防止声明了, 但是没有使用的 ArrayList, 浪费空间。<br>同时先赋值为静态的 DEFAULTCAPACITY_EMPTY_ELEMENTDATA, 多个 ArrayList 可以共用这个, 节省内存。  </p><h3 id="3-2-指定容量构造"><a href="#3-2-指定容量构造" class="headerlink" title="3.2 指定容量构造"></a>3.2 指定容量构造</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token constant">EMPTY_ELEMENTDATA</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><blockquote><ol><li>指定的容量小于 0, 抛异常</li><li>指定的容量为 0, 将空数组 <strong>EMPTY_ELEMENTDATA</strong> 赋值给 <strong>elementData</strong></li><li>指定的容量大于 0, 将 <strong>elementData</strong> 声明指定容量的数组</li></ol></blockquote><h3 id="3-3-给定一个-Collection-的构造"><a href="#3-3-给定一个-Collection-的构造" class="headerlink" title="3.3 给定一个 Collection 的构造"></a>3.3 给定一个 Collection 的构造</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用 Collection 的方法, 获取内部存储数据的数组</span>    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">ArrayList</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            elementData <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        elementData <span class="token operator">=</span> <span class="token constant">EMPTY_ELEMENTDATA</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><blockquote><ol><li>传入的 Collection 的长度为 0, 将空数组 <strong>EMPTY_ELEMENTDATA</strong> 赋值给 <strong>elementData</strong></li><li>传入的 Collection 的长度不等于 0, 将传入的 Collection 转为数组</li><li>传入的 Collection 为 ArrayList 类型, 将转换的数组赋值给 <strong>elmentData</strong></li><li>传入的 Collection 不是 ArrayList 类型, 则需要将转换后的数组转换为 Object 数组, 在赋值给 <strong>elementData</strong></li></ol></blockquote><p>上面 3, 4 步存在的原因是: Collection.toArray 方法在不同类的实现上有一些差异, 具体的分析可以看最后面的分析。</p><h2 id="4-ArrayList-几个常用的方法"><a href="#4-ArrayList-几个常用的方法" class="headerlink" title="4 ArrayList 几个常用的方法"></a>4 ArrayList 几个常用的方法</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 直接添加数据</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 指定位置, 添加数据</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 添加一个集合 Collection 数据</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 指定位置, 添加一个集合 Collection 数据</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 删除指定位置的数据</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 删除指定的数据</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取指定位置的数据</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="4-1-直接添加数据"><a href="#4-1-直接添加数据" class="headerlink" title="4.1 直接添加数据"></a>4.1 直接添加数据</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 确保容量足够</span>    <span class="token comment">// 容量够, 不做处理</span>    <span class="token comment">// 容量不够, 动态的扩容</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 放入到数组的最后一位</span>    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 确保容量足够, 容量不够, 进行扩容 * * @minCapacity 当前需要的最小容量 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// calculateCapacity 需要的容量</span>    <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token function">calculateCapacity</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 计算一下当前 ArrayList 需要的容量 */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">calculateCapacity</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">,</span> <span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// DEFAULTCAPACITY_EMPTY_ELEMENTDATA: 前面声明的空数组 &#123;&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// DEFAULT_CAPACITY: 默认值 10</span>        <span class="token comment">// 空数组, 创建时默认容量为 10, 但是上游可以指定它需要的最小容量, 2 者进行比较, 取大的</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 直接返回上游需要的最小容量</span>    <span class="token keyword">return</span> minCapacity<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 确保当然数组的长度比需要的最小的容量大, 不够的话, 自动扩容 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 需要的最少容量比当前的数组的容量大, 说明当前的数组容量不够了, 需要进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 数组容量扩容, 默认是当前容量的 1.5 倍 * 如果当前容量的 1.5 倍比需要的最小容量还小, 直接取最小容量 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 扩容前的容量</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// oldCapacity >> 1  相当于  oldCapacity / (2 的一次方), 也就是  oldCapacity * 0.5</span>    <span class="token comment">// 也就是 数组的扩容 = 原来的容量 * 1.5</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 计算出来的容量比需要的最小的容量还小, 则直接去最小的容量</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>    <span class="token comment">// MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8</span>    <span class="token comment">// 计算出来的新的容量比 Integer 的最大值 - 8 还大</span>    <span class="token comment">// 这一步主要是为了防止计算出来的容量超过了 Integer 的最大值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> <span class="token constant">MAX_ARRAY_SIZE</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 创建一个新的数组, 同时把当前的数组内容转移到新的数组</span>    elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 确保当前的容量不超过 Integer 的最大值 */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 小于 0, 超过了, 直接抛异常</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 容量 >  Integer.MAX_VALUE - 8 的话, 直接返回 Integer 最大值, 否则返回 Integer.MAX_VALUE - 8</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> <span class="token constant">MAX_ARRAY_SIZE</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">:</span> <span class="token constant">MAX_ARRAY_SIZE</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="4-2-指定位置-添加数据"><a href="#4-2-指定位置-添加数据" class="headerlink" title="4.2 指定位置, 添加数据"></a>4.2 指定位置, 添加数据</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 判断一下 index 是否正常, index 不能大于 size, index 不能小于 0</span>    <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 走一遍判断扩容</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 新建一个数组  数组的内容和当前的数据一样, 把 index 后面的数据都往后退一位, 然后 index 位置变为 null</span>    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置 index 的元素为要插入的数据</span>    elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 检测 index 是否符合要求  */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> size <span class="token operator">||</span> index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>指定位置的数据插入会导致数组数据的转移, 影响性能。</p><h3 id="4-3-添加一个集合-Collection-数据"><a href="#4-3-添加一个集合-Collection-数据" class="headerlink" title="4.3 添加一个集合 Collection 数据"></a>4.3 添加一个集合 Collection 数据</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numNew <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// 确保容量足够</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 新建一个新的数组, 拷贝原来数组和需要插入的 Collection 转换的数组到新数组</span>    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>    size <span class="token operator">+=</span> numNew<span class="token punctuation">;</span>    <span class="token keyword">return</span> numNew <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="4-4-指定位置-添加一个集合-Collection-数据"><a href="#4-4-指定位置-添加一个集合-Collection-数据" class="headerlink" title="4.4 指定位置, 添加一个集合 Collection 数据"></a>4.4 指定位置, 添加一个集合 Collection 数据</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 判断一下 index 是否正常, index 不能大于 size, index 不能小于 0</span>    <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numNew <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// 确保容量足够</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 计算需要移动的位置</span>    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment">// 新建一个数组, 将 elementData 从 index 后面的数据移动到 elementData 的 index + numNew 的后面</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> numNew<span class="token punctuation">,</span> numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将 a 移动到新数组的 index 和 index + numNex 之间</span>    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>    size <span class="token operator">+=</span> numNew<span class="token punctuation">;</span>    <span class="token keyword">return</span> numNew <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="4-5-删除指定位置的数据"><a href="#4-5-删除指定位置的数据" class="headerlink" title="4.5 删除指定位置的数据"></a>4.5 删除指定位置的数据</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 判断 index 是否合法</span>    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 取到需要删除的元素</span>    <span class="token class-name">E</span> oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 删除的元素所在的位置后面还有多少个元素</span>    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment">// 将 elementData index + 1 开始到 numMoved 个元素依次放到 elementData 的 index 处的后面</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置 site - 1 处的元素为空</span>    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * index 检查 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rangeCheck</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// index 不能大于 size</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> size<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 获取需要删除的元素 */</span><span class="token class-name">E</span> <span class="token function">elementData</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="4-6-删除指定的元素"><a href="#4-6-删除指定的元素" class="headerlink" title="4.6 删除指定的元素"></a>4.6 删除指定的元素</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// o 为 null, 则将 0 到 size - 1 之间第一个 null 删除</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 调用 Object 的 equals 比较 2 个对象是否为同一个</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 删除元素和 remove(int) 类似 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fastRemove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 将 elementData index + 1 开始到 numMoved 个元素依次放到 elementData 的 index 处的后面</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置 site - 1 处的元素为空</span>    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>ArrayList 内部还提供了其他的删除元素方法</p><blockquote><ol><li>removeAll(Collection&lt;?&gt; c): 删除当前 List 中在 Collection c 中有的元素</li><li>removeRange(int fromIndex, int toIndex):  删除指定范围内的元素</li><li>removeIf(Predicate&lt;? super E&gt; filter):  删除当前 List 中符合过滤条件的元素</li></ol></blockquote><h3 id="4-7-获取数据"><a href="#4-7-获取数据" class="headerlink" title="4.7 获取数据"></a>4.7 获取数据</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 检测 index 是否符合条件</span>    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 通过索引获取元素, 直接就是 elementData[index]</span>    <span class="token keyword">return</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="5-ArrayList-的补充"><a href="#5-ArrayList-的补充" class="headerlink" title="5 ArrayList 的补充"></a>5 ArrayList 的补充</h2><p><strong>1. ArrayList 实现了 Serializable 接口, 那么支持序列化的, 但是数据是存放在 elementData 内, elementData 却被 transient (对象序列化时忽略) 修饰了</strong></p><p>elementData 本质是一个数组, 使用数组是需要先定义长度, 所以可能存在 **elementData 的长度为 10, 存放的数据为 3 个, 7 个空的位置。<br>在序列化时, 将这几个没有的数据序列过去, 浪费了空间和浪费时间, 所以 ArrayList 将 elementData 设置为不用序列化的, 然后自身重写了序列化方法 <code>writeObject</code> 和 反序列化方法 <code>readObject</code>,<br>只把 elementData 内有效的数据序列化过去。</p><p><strong>2. ArrayList 的 add, remove, clear 方法的调用, 可以看到有行代码 modCount++, modCount 的作用</strong></p><p>这个变量是继承与父类 AbstractList 的, 这个变量记录的是: <code>当前 ArrayList 的修改次数</code>。<br>作用: 用于支持 fail-fast 机制 (在遍历中, 发现数据被修改过了, 直接抛出异常) </p><p>ArrayList 内部自己实现了一个 Iterator (代码有省略), 通过 ArrayList.iterator() 获取到的就是这个实现类</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Itr</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>从代码我们可以知道  </p><blockquote><ol><li>Iterator 内部维护了一个 expectedModCount 他的值就是当前 ArrayList 内部数据修改过的次数 modCount</li><li>每次遍历时, 都会判断 expectedModCount 的值是否等于当前 modCount, 不等于直接抛异常, 不进行后续操作了</li><li>上面的场景很大概率出现在多线程上, 一个线程在遍历, 另一个线程对 ArrayList 进行了修改, modCount + 1 了, 从而使得 modCount !&#x3D; expectedModCount, 遍历的线程立即抛出异常</li><li>modCount 在 AbstractList 只是被修饰为 transient 的, 没有用 volatile 修饰, 也就是存在一个线程修改了数据但是 modCount 没有及时写到内存中, 遍历线程还是能够继续执行。 所以 fail-fast 机制, 是一种错误检测机制。它只能被用来检测错误, 因为 JDK 并不保证 fail-fast 机制一定会发生</li></ol></blockquote><p><strong>3. ArrayList 不是一个线程安全的集合</strong></p><p>ArrayList 是线程不安全的, 如果需要保证线程的安全性, 可以考虑使用 CopyOWriteArrayList 或者使用 Collections.synchronizedList(Lise l) 函数返回一个线程安全的 ArrayList 类</p><p><strong>4. ArrayList 实现了 RandomAccess 接口有什么用</strong></p><p>首先 RandomAccess 的定义</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RandomAccess</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></code></pre><p>从定义可以看到 RandomAccess 接口, 没有任何的东西需要我们实现, 它只做一种标识作用。<br>实现这个接口的类, 表示自身是支持 “随机访问” (如果有 10 个元素, 我们需要访问第 5 个, 就能直接跳到第 5 个进行访问, 忽略掉前面的 4 个元素, 还有一个顺序访问, 无论要访问第几个元素, 都需要从第一个元素开始, 一直往下找, 直到找到了需要的位置为止) 策略的 (官网还特意说明了, 如果是实现了这个接口的 List, 使用 for 循环的方式获取数据会优于用迭代器获取数据)。</p><p>官方使用例子: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Collections</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 二分查找     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">></span><span class="token punctuation">></span></span> list<span class="token punctuation">,</span> <span class="token class-name">T</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// list 支持随机访问或者当前的数据量 小于 5000</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token keyword">instanceof</span> <span class="token class-name">RandomAccess</span> <span class="token operator">||</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token constant">BINARYSEARCH_THRESHOLD</span><span class="token punctuation">)</span>            <span class="token comment">// 可以到源码里面看一下这个方法, 内部是通过 white 进行遍历的</span>            <span class="token keyword">return</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">indexedBinarySearch</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// 这个 是使用 迭代器遍历的</span>            <span class="token keyword">return</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">iteratorBinarySearch</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="6-Collection-toArray"><a href="#6-Collection-toArray" class="headerlink" title="6 Collection.toArray()"></a>6 Collection.toArray()</h2><p>可以先查看<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652">这里</a>, 了解一下, Collection.toArray() 的问题。</p><p>下面做一个简单的整理。</p><h3 id="6-1-对象向上转型"><a href="#6-1-对象向上转型" class="headerlink" title="6.1 对象向上转型"></a>6.1 对象向上转型</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span>    <span class="token class-name">Object</span> obj <span class="token operator">=</span> str<span class="token punctuation">;</span>    <span class="token class-name">Object</span> obj2 <span class="token operator">=</span> obj<span class="token punctuation">;</span>    <span class="token comment">// class java.lang.String</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// class java.lang.String</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// class java.lang.String</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Integer</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token class-name">Number</span> obj3 <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token comment">// class java.lang.Integer</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// class java.lang.Integer</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj3<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>从上面的代码, 可以发现通过向上转型, <strong>虽然对象已经是转型后的类型了, 但是还是会保留了实际的类型</strong>。</p><h3 id="6-2-对象为数组时-向上转型"><a href="#6-2-对象为数组时-向上转型" class="headerlink" title="6.2 对象为数组时, 向上转型"></a>6.2 对象为数组时, 向上转型</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    obj<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// class [Ljava.lang.Object;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// class [Ljava.lang.String;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>strObj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// class java.lang.String</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>从上面的代码, 可以发现<strong>声明的数组是什么类型, 那么它的类型就是什么</strong>。<br>但是<strong>放入到内部的对象, 通过转型存到了数组里面, 但是它的实际类型还是没变的</strong>。</p><h3 id="6-3-Collection-toArray"><a href="#6-3-Collection-toArray" class="headerlink" title="6.3 Collection.toArray()"></a>6.3 Collection.toArray()</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objArray <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list2 <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objArray2 <span class="token operator">=</span> list2<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// class [Ljava.lang.Object;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>objArray<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// class [Ljava.lang.String;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>objArray2<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>在上面中通过 Collection.toArray() 方法得到的 2 个 Object[], 一个是类型的 Object 数组, 一个是类型是原来的类型的数组。同样的方法但是返回的 2 种不同的结果。<br>所以才有通过一个 Collection 创建 ArrayList, 才会判断一下 <code>toArray</code> 方法返回的数据的实际类型。  </p><p>至于 <code>Object[] toArray();</code> 返回的 Object[] 是不同的类型, 需要具体到不同的实现。</p><p><strong>ArrayList 的 toArray()</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用到 Arrays.copyOf 方法</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// elementData.getClass 是 Object[] 类型, 所以通过 Array.copyOf 得到的为 Object[] 类型</span>        <span class="token keyword">return</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Arrays</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> original<span class="token punctuation">,</span> <span class="token keyword">int</span> newLength<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">copyOf</span><span class="token punctuation">(</span>original<span class="token punctuation">,</span> newLength<span class="token punctuation">,</span> original<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>通过 Arrays 创建的 ArrayList 的 toArray()</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Arrays</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">asList</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 通过 Arrays.asList 方法返回的是内部自行实现的 ArrayList</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 常用的 ArrayList 的数据是使用一个 Object[] elementData 进行保存的, 这里使用的是泛型数组存储</span>        <span class="token comment">// 区别是 elementData.getClass 返回的是 Object[], 这里 a.getClass 返回的是实际数据的类型</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span>        <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            a <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 自行实现的 ArrayList, 内部不是调用自身的 copyOf 进行转换的, 而是通过 clone 方法</span>        <span class="token comment">// 通过 clone() 返回结果的是 E[], 然后通过向上转型 (Object[])E[], 所以返回了 Object[], 但是保留了原本的类型。</span>        <span class="token keyword">public</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>2 种不同的实现, 最终导致了不同的结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&quot;分布式事务一致性&quot; 看这一篇就够了</title>
      <link href="/article/2018/1551438839/"/>
      <url>/article/2018/1551438839/</url>
      
        <content type="html"><![CDATA[<p>转载信息:<br>作者: <strong>田向阳</strong><br>来源: 知乎<br>原文链接: <a href="https://zhuanlan.zhihu.com/p/36153160">“分布式事务一致性” 看这一篇就够了</a><br>版权声明: 著作权归作者所有。</p><p>注: 原文中很多图片太模糊了, 所以我根据原图重新画了一遍, 同时原文的排版有些问题, 也按照个人习惯做了一些调整。</p><h2 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1 摘要"></a>1 摘要</h2><p>传统应用使用本地事务和分布式事务保证数据一致性。<br>但是在微服务架构中数据都是服务私有的, 需要通过服务提供的 Api 访问, 分布式事务不再适用微服务架构。<br>传统分布式事务不是微服务中数据一致性的最佳选择。微服务架构中应满足数据最终一致性原则。</p><h2 id="2-作者介绍"><a href="#2-作者介绍" class="headerlink" title="2 作者介绍"></a>2 作者介绍</h2><p><img src="https://pic.imgdb.cn/item/655d8bbac458853aef8e14f1.png" alt="Alt &#39;田向阳头像&#39;"></p><p><strong>田向阳</strong>, 普元解决方案中心架构师, 曾就职于神州数码主特研发新一代自主渠道总线、中间业务平台。金融领域技术高手, 操作系统、编译原理爰好者, 喜欢问什么工程师。</p><h2 id="3-内容简介"><a href="#3-内容简介" class="headerlink" title="3 内容简介"></a>3 内容简介</h2><p>大家好, 我是田向阳, 是现任普元解决方案的中心架构师。<br>今天我给大家分享的题目是微服务架构下的事务一致性保证。</p><p>主要内容包括 4 部分: </p><blockquote><ol><li>传统分布式事务不是微服务中一致性的最佳选择</li><li>微服务架构中应满足数据最终一致性原则</li><li>微服务架构实现最终一致性的三种模式</li><li>对账是最后的终极防线</li></ol></blockquote><h2 id="4-传统分布式事务不是微服务中一致性的最佳选择"><a href="#4-传统分布式事务不是微服务中一致性的最佳选择" class="headerlink" title="4 传统分布式事务不是微服务中一致性的最佳选择"></a>4 传统分布式事务不是微服务中一致性的最佳选择</h2><p>我们先来看一下第一部分, 传统使用本地事务和分布式事务保证一致性。</p><p><img src="https://pic.imgdb.cn/item/655b82d4c458853aef0343b6.png" alt="Alt &#39;本地事务&#39;"></p><p>传统单机应用一般都会使用一个关系型数据库, 好处是应用可以使用 ACID transactions。<br>为保证一致性我们只需要: 开始一个事务, 改变 (插入, 删除, 更新) 很多行, 然后提交事务 (如果有异常时回滚事务)。<br>更进一步, 借助开发平台中的数据访问技术和框架 (如 Spring), 我们需要做的事情更少, 只需要关注数据本身的改变。<br>随着组织规模不断扩大, 业务量不断增长, 单机应用和数据库已经不足以支持庞大的业务量和数据量, 这个时候需要对应用和数据库进行拆分, 就出现了一个应用需要同时访问两个或两个以上的数据库情况。  </p><p>开始我们用分布式事务来保证一致性, 也就是我们常说的两阶段提交协议 (2PC)。</p><p><img src="https://pic.imgdb.cn/item/655b82d6c458853aef034c53.png" alt="Alt &#39;分布式事务 - 两阶段提交协议&#39;"></p><p>本地事务和分布式事务现在已经非常成熟, 相关介绍很丰富, 此处不多作讨论。<br>我们下面来讨论以下为什么分布式事务不适用于微服务架构。  </p><p><img src="https://pic.imgdb.cn/item/655d8f62c458853aef9b7bcd.png" alt="Alt &#39;微服务下的困境&#39;"></p><p>首先, 对于微服务架构来说, 数据访问变得更加复杂, 这是因为数据都是微服务私有的, 唯一可访问的方式就是通过 Api。<br>这种打包数据访问方式使得微服务之间松耦合, 并且彼此之间独立非常容易进行性能扩展。</p><p>其次, 不同的微服务经常使用不同的数据库。应用会产生各种不同类型的数据, 关系型数据库并不一定是最佳选择。例如, 某个产生和查询字符串的应用采用 Elasticsearch 的字符搜索引擎; 某个产生社交图片数据的应用可以采用图数据库, 例如, Neo4j;  </p><p>基于微服务的应用一般都使用 SQL 和 NoSQL 结合的模式。但是这些非关系型数据大多数并不支持 2PC。可见在微服务架构中已经不能选择分布式事务了。  </p><h2 id="5-微服务架构中应满足数据最终一致性原则"><a href="#5-微服务架构中应满足数据最终一致性原则" class="headerlink" title="5 微服务架构中应满足数据最终一致性原则"></a>5 微服务架构中应满足数据最终一致性原则</h2><p>依据 CAP 理论, 必须在可用性 (availability) 和一致性(consistency) 之间做出选择。<br>如果选择提供一致性需要付出在满足一致性之前阻塞其他并发访问的代价。<br>这可能持续一个不确定的时间, 尤其是在系统已经表现出高延迟时或者网络故障导致失去连接时。  </p><p>依据目前的成功经验, <strong>可用性</strong>一般是更好的选择, 但是在服务和数据库之间维护数据一致性是非常根本的需求,<br>微服务架构中应选择满足<strong>最终一致性(指系统中的所有数据副本经过一定时间后, 最终能够达到一致的状态)。</strong>  </p><p>当然选择了最终一致性, 就要保证到最终的这段时间要在用户可接受的范围之内。<br>那么我们怎么实现最终一致性呢？</p><h2 id="6-微服务架构实现最终一致性的三种模式"><a href="#6-微服务架构实现最终一致性的三种模式" class="headerlink" title="6 微服务架构实现最终一致性的三种模式"></a>6 微服务架构实现最终一致性的三种模式</h2><p><img src="https://pic.imgdb.cn/item/655b82dac458853aef035b89.png" alt="Alt &#39;一致性的本质&#39;"></p><p>从一致性的本质来看, 是要保证在一个业务逻辑中包含的服务要么都成功, 要么都失败。那我们怎么选择方向呢？<br>保证成功还是保证失败呢？我们说业务模式决定了我们的选择。  </p><p>实现最终一致性有三种模式: </p><blockquote><ol><li>可靠事件模式</li><li>业务补偿模式</li><li>TCC 模式</li></ol></blockquote><h3 id="6-1-可靠事件模式"><a href="#6-1-可靠事件模式" class="headerlink" title="6.1 可靠事件模式"></a>6.1 可靠事件模式</h3><p>可靠事件模式属于事件驱动架构, 当某件重要事情发生时, 例如更新一个业务实体, 微服务会向消息代理发布一个事件。<br>消息代理会向订阅事件的微服务推送事件, 当订阅这些事件的微服务接收此事件时, 就可以完成自己的业务, 也可能会引发更多的事件发布。   </p><p><img src="https://pic.imgdb.cn/item/655b82e0c458853aef037499.png" alt="Alt &#39;可靠性事件模式 - 例子&#39;"></p><ol><li>订单服务创建一个待支付的订单, 发布一个 “创建订单” 的事件</li><li>支付服务消费 “创建订单” 事件, 支付完成后发布一个 “支付完成” 事件</li><li>订单服务消费 “支付完成” 事件, 订单状态更新为待出库</li></ol><p>从而就实现了完成的业务流程。但是这并不是一个完美的流程。</p><p><img src="https://pic.imgdb.cn/item/655b82dfc458853aef036ee9.png" alt="Alt &#39;可靠性事件模式 - 例子异常情况&#39;"></p><p>这个过程可能导致出现不一致的地方在于: </p><blockquote><ol><li>某个微服务在更新了业务实体后发布事件却失败</li><li>虽然微服务发布事件成功, 但是消息代理未能正确推送事件到订阅的微服务</li><li>接受事件的微服务重复消费了事件</li></ol></blockquote><p>可靠事件模式在于保证<strong>可靠事件投递</strong>和<strong>避免重复消费</strong>。  </p><p>可靠事件投递定义为:<br>(a) 每个服务原子性的业务操作和发布事件<br>(b) 消息代理确保事件传递至少一次。避免重复消费要求服务实现幂等性, 如支付服务不能因为重复收到事件而多次支付。</p><p>因为现在流行的消息队列都实现了事件的持久化和 <strong>at least once</strong> 的投递模式, (b) 特性 (消息代理确保事件投递至少一次) 已经满足, 今天不做展开。  </p><p>下面分享的内容主要从可靠事件投递和实现幂等性两方面来讨论, 我们先来看可靠事件投递。</p><h4 id="6-1-1-可靠事件投递"><a href="#6-1-1-可靠事件投递" class="headerlink" title="6.1.1 可靠事件投递"></a>6.1.1 可靠事件投递</h4><p>首先我们来看一个实现的代码片段, 这是从某生产系统上截取下来的。</p><pre class="language-Java" data-language="Java"><code class="language-Java">public void trans() &#123;    try &#123;        &#x2F;&#x2F; 1. 操作数据库        &#x2F;&#x2F; 操作数据库失败, 会抛出异常        boolean result &#x3D; dao.update(model);         if (result) &#123;            &#x2F;&#x2F; 如果 mq.append 方法执行失败 (投递消息失败), 方法内部会抛出异常            mq.append(model);         &#125;    &#125; catch(Eexeption ex)&#123;        &#x2F;&#x2F; 如果发射异常, 则回滚        rollback();    &#125;&#125;</code></pre><p>根据上述代码及注释, 初看可能出现 3 种情况: </p><blockquote><ol><li>操作数据库成功, 向消息代理投递事件也成功</li><li>操作数据库失败, 不会向消息代理中投递事件了</li><li>操作数据库成功, 但是向消息代理中投递事件时失败, 向外抛出了异常, 刚刚执行的更新数据库的操作将被回滚</li></ol></blockquote><p>从上面分析的几种情况来看, 貌似没有问题。但是仔细分析不难发现缺陷所在, 在上面的处理过程中存在一段隐患时间窗口。</p><p><img src="https://pic.imgdb.cn/item/655b82e3c458853aef037ef0.png" alt="Alt &#39;可靠性事件模式 - 代码隐患窗口一&#39;"></p><p>微服务 A 投递事件的时候可能消息代理已经处理成功, 但是返回响应的时候网络异常, 导致 append 操作抛出异常。<br>最终结果是事件被投递, 数据库确被回滚。</p><p><img src="https://pic.imgdb.cn/item/655b82e4c458853aef0386f3.png" alt="Alt &#39;可靠性事件模式 - 代码隐患窗口二&#39;"></p><p>在投递完成后到数据库 commit 操作之间如果微服务 A 宕机也将造成数据库操作因为连接异常关闭而被回滚。<br>最终结果还是事件被投递, 数据库却被回滚。这个实现往往运行很长时间都没有出过问题, 但是一旦出现了将会让人感觉莫名很难发现问题所在。  </p><p>下面给出两种可靠事件投递的实现方式。</p><h5 id="6-1-1-1-本地事件表"><a href="#6-1-1-1-本地事件表" class="headerlink" title="6.1.1.1 本地事件表"></a>6.1.1.1 本地事件表</h5><p>本地事件表方法将事件和业务数据保存在同一个数据库中, 使用一个额外的 “事件恢复” 服务来恢复事件, 由本地事务保证更新业务和发布事件的原子性。<br>考虑到事件恢复可能会有一定的延时, 服务在完成本地事务后可立即向消息代理发布一个事件。  </p><p><img src="https://pic.imgdb.cn/item/655b82e8c458853aef039586.png" alt="Alt &#39;可靠性事件模式 - 本地事件表&#39;"></p><blockquote><ol><li>微服务在同一个本地事务中记录业务数据和事件</li><li>微服务实时发布一个事件立即通知关联的业务服务, 如果事件发布成功立即删除记录的事件</li><li>事件恢复服务定时从事件表中恢复未发布成功的事件, 重新发布, 重新发布成功才删除记录的事件</li></ol></blockquote><p>其中第二条的操作主要是为了增加发布事件的实时性, 由第三条保证事件一定被发布。 </p><p>本地事件表方式业务系统和事件系统耦合比较紧密, 额外的事件数据库操作也会给数据库带来额外的压力, 可能成为瓶颈。  </p><h5 id="6-1-1-2-外部事件表"><a href="#6-1-1-2-外部事件表" class="headerlink" title="6.1.1.2 外部事件表"></a>6.1.1.2 外部事件表</h5><p>外部事件表方法将事件持久化到外部的事件系统, 事件系统需提供实时事件服务以接受微服务发布事件, 同时事件系统还需要提供事件恢复服务来确认和恢复事件。</p><p><img src="https://pic.imgdb.cn/item/655b82ddc458853aef0366a9.png" alt="Alt &#39;可靠性事件模式 - 外部事件表&#39;"></p><blockquote><ol><li>业务服务在事务提交前, 通过实时事件服务向事件系统请求发送事件, 事件系统只记录事件并不真正发送</li><li>业务服务在提交后, 通过实时事件服务向事件系统确认发送, 事件得到确认后事件系统才真正发布事件到消息代理</li><li>业务服务在业务回滚时, 通过实时事件向事件系统取消事件</li></ol></blockquote><p>如果业务服务在发送确认或取消之前停止服务了怎么办呢？<br>事件系统的事件恢复服务会定期找到未确认发送的事件向业务服务查询状态, 根据业务服务返回的状态决定事件是要发布还是取消。  </p><p>该方式将业务系统和事件系统独立解耦, 都可以独立伸缩。<br>但是这种方式需要一次额外的发送操作, 并且需要发布者提供额外的查询接口。</p><h4 id="6-1-2-幂等性"><a href="#6-1-2-幂等性" class="headerlink" title="6.1.2 幂等性"></a>6.1.2 幂等性</h4><p>介绍完了可靠事件投递再来说一说幂等性的实现, 有些事件本身是幂等的, 有些事件却不是。  </p><p>如果事件本身描述的是某个时间点的固定值 (如账户余额为 100), 而不是描述一条转换指令 (如余额增加 10), 那么这个事件是幂等的。<br>我们要意识到事件可能出现的次数和顺序是不可预测的, 需要保证幂等事件的顺序执行, 否则结果往往不是我们想要的。 </p><p>如果我们先后收到两条事件:<br>(1) 账户余额更新为 100<br>(2) 账户余额更新为 120  </p><blockquote><ol><li>微服务收到事件 (1) 后, 将对应的账户余额设置为 100</li><li>微服务收到事件 (2) 后, 将对应的账户余额设置为 120</li><li>这时微服务又收到了一次事件 (1), 又将对应的账户余额设置为 100</li></ol></blockquote><p>显然结果是错误的, 所以我们需要保证事件 (2) 一旦执行事件, (1) 就不能再处理, 否则账户余额仍不是我们想要的结果。</p><p>为保证事件的顺序一个简单的做法是在事件中添加时间戳, 微服务记录每个类型的事件最后处理的时间戳, 如果收到的事件的时间戳早于我们记录的, 丢弃该事件。<br>如果事件不是在同一个服务器上发出的, 那么服务器之间的时间同步是个难题, 更稳妥的做法是使用一个<strong>全局递增序列号</strong>替换时间戳。  </p><p>对于本身不具有幂等性的操作, 主要思想是<strong>为每条事件存储执行结果</strong>, 当收到一条事件时我们需要根据事件的 id 查询该事件是否已经执行过, 如果执行过直接返回上一次的执行结果, 否则调度执行事件。 </p><h5 id="6-1-2-1-重复处理开销大事件使用事件存储过滤重复事件"><a href="#6-1-2-1-重复处理开销大事件使用事件存储过滤重复事件" class="headerlink" title="6.1.2.1 重复处理开销大事件使用事件存储过滤重复事件"></a>6.1.2.1 重复处理开销大事件使用事件存储过滤重复事件</h5><p>在这个思想下我们需要考虑重复执行一条事件和查询存储结果的开销。<br>如果重复处理一条事件开销很小, 或者可预见只有非常少的事件会被重复接收, 可以选择重复处理一次事件, 在将事件数据持久化时由数据库抛出唯一性约束异常。  </p><p>如果重复处理一条事件的开销相比额外一次查询的开销要高很多, 使用一个过滤服务来过滤重复的事件, 过滤服务使用事件存储存储已经处理过的事件和结果。  </p><p>当收到一条事件时, 过滤服务首先查询事件存储, 确定该条事件是否已经被处理过:  </p><blockquote><ol><li>如果事件已经被处理过, 直接返回存储的结果  </li><li>否则调度业务服务执行处理, 并将处理完的结果存储到事件存储中</li></ol></blockquote><p>一般情况下上面的方法能够运行得很好, 如果我们的微服务是 RPC类 的服务我们需要更加小心, 可能出现的问题在于  </p><blockquote><ol><li>过滤服务在业务处理完成后才将事件结果存储到事件存储中, 但是在业务处理完成前有可能就已经收到重复事件, 由于是 RPC 服务也不能依赖数据库的唯一性约束  </li><li>业务服务的处理结果可能出现位置状态, 一般出现在正常提交请求但是没有收到响应的时候</li></ol></blockquote><p>对于问题 (1) 可以按步骤记录事件处理过程, 比如事件的记录事件的处理过程为 “接收”、”发送请求”、”收到应答”、”处理完成”。<br>好处是过滤服务能及时的发现重复事件, 进一步还能根据事件状态作不同的处理。  </p><p>对于问题 (2) 可以通过一次额外的查询请求来确定事件的实际处理状态, 要注意额外的查询会带来更长时间的延时, 更进一步可能某些 RPC 服务根本不提供查询接口。<br>此时只能选择接收暂时的不一致, 时候采用对账和人工接入的方式来保证一致性。  </p><h3 id="6-2-业务补偿模式"><a href="#6-2-业务补偿模式" class="headerlink" title="6.2 业务补偿模式"></a>6.2 业务补偿模式</h3><p>为了描述方便, 这里先定义两个概念<br><strong>业务异常</strong>: 业务逻辑产生错误的情况, 比如账户余额不足、商品库存不足等。<br><strong>技术异常</strong>: 非业务逻辑产生的异常, 如网络连接异常、网络超时等。</p><p>补偿模式使用一个额外的协调服务来协调各个需要保证一致性的微服务, 协调服务按顺序调用各个微服务, 如果某个微服务调用异常 (包括业务异常和技术异常) 就取消之前所有已经调用成功的微服务。  </p><p>补偿模式建议仅用于不能避免出现业务异常的情况, 如果有可能应该优化业务模式, 以避免要求补偿事务。<br>如账户余额不足的业务异常可通过预先冻结金额的方式避免, 商品库存不足可要求商家准备额外的库存等。  </p><p>假设一位客户规划的行程是:<br>(1) 上海 - 北京 6 月 19 日 9 点 的某某航班<br>(2) 某某酒店住宿 3 晚<br>(3) 北京 - 上海 6 月 22 日 17 点火车   </p><p>在客户提交行程后, 旅行公司的预订行程业务按顺序串行的调用航班预订服务、酒店预订服务、火车预订服务。<br>最后的火车预订服务成功后整个预订业务才算完成。</p><p><img src="https://pic.imgdb.cn/item/655b82f3c458853aef03c44c.png" alt="Alt &#39;补偿模式 - 例子&#39;"></p><p>如果火车票预订服务没有调用成功, 那么之前预订的航班、酒店都得取消。 取消之前预订的酒店、航班即为补偿过程。  </p><p><img src="https://pic.imgdb.cn/item/655b82eec458853aef03af02.png" alt="Alt &#39;补偿模式 - 例子取消过程&#39;"></p><p>为了降低开发的复杂性和提高效率, 协调服务实现为一个通用的补偿框架。<br>补偿框架提供服务编排和自动完成补偿的能力。</p><p>要实现补偿过程, 我们需要做到两点:  </p><h4 id="6-2-1-首先要确定失败的步骤和状态-从而确定需要补偿的范围"><a href="#6-2-1-首先要确定失败的步骤和状态-从而确定需要补偿的范围" class="headerlink" title="6.2.1 首先要确定失败的步骤和状态, 从而确定需要补偿的范围"></a>6.2.1 首先要确定失败的步骤和状态, 从而确定需要补偿的范围</h4><p><img src="https://pic.imgdb.cn/item/655b82f1c458853aef03bda7.png" alt="Alt &#39;补偿模式 - 例子补偿范围和异常原因分析&#39;"></p><p>在上面的例子中我们不光要知道第 3 个步骤 (预订火车) 失败, 还要知道失败的原因。<br>如果是因为预订火车服务返回无票, 那么补偿过程只需要取消前两个步骤就可以了。<br>但是如果失败的原因是因为网络超时, 那么补偿过程除前两个步骤之外还需要包括第 3 个步骤。  </p><h4 id="6-2-2-其次要能提供补偿操作使用到的业务数据"><a href="#6-2-2-其次要能提供补偿操作使用到的业务数据" class="headerlink" title="6.2.2 其次要能提供补偿操作使用到的业务数据"></a>6.2.2 其次要能提供补偿操作使用到的业务数据</h4><p>比如一个支付微服务的补偿操作要求参数包括支付时的业务流水 id、账号和金额。<br>理论上说实际完成补偿操作可以根据唯一的业务流水 id 就可以, 但是提供更多的要素有益于微服务的健壮性, 微服务在收到补偿操作的时候可以做业务的检查, 比如检查账户是否相等, 金额是否一致等等。</p><p>做到上面两点的办法是记录完整的业务流水, 可以通过业务流水的状态来确定需要补偿的步骤, 同时业务流水为补偿操作提供需要的业务数据。</p><p><img src="https://pic.imgdb.cn/item/655b82ecc458853aef03a60a.png" alt="Alt &#39;补偿模式 - 业务流水表&#39;"></p><p>当客户的一个预订请求达到时, 协调服务 (补偿框架) 为请求生成一个全局唯一的业务流水号。<br>并在调用各个工作服务的同时记录完整的状态:  </p><blockquote><ol><li>记录调用 bookFlight 的业务流水, 调用 bookFlight 服务, 更新业务流水状态</li><li>记录调用 bookHotel 的业务流水, 调用 bookHotel 服务, 更新业务流水状态</li><li>记录调用 bookTrain 的业务流水, 调用 bookTrain 服务, 更新业务流水状态</li></ol></blockquote><p>当调用某个服务出现异常时, 比如第 3 步骤 (预订火车) 异常。    </p><p><img src="https://pic.imgdb.cn/item/655b82eac458853aef039f0b.png" alt="Alt &#39;补偿模式 - 业务流水表加事件记录表&#39;"></p><p>协调服务 (补偿框架) 同样会记录第 3 步的状态, 同时会另外记录一条事件, 说明业务出现了异常。<br>然后就是执行补偿过程了, 可以从业务流水的状态中知道补偿的范围, 补偿过程中需要的业务数据从记录的业务流水中获取。</p><p>对于一个通用的补偿框架来说, 预先知道微服务需要记录的业务要素是不可能的。<br>那么就需要一种方法来保证业务流水的可扩展性, 这里介绍两种方法: 大表和关联表。</p><p><img src="https://pic.imgdb.cn/item/655b82d1c458853aef0337bd.png" alt="Alt &#39;补偿模式 - 大表 VS 关联表&#39;"></p><h5 id="6-2-2-1-业务流水的可扩展性"><a href="#6-2-2-1-业务流水的可扩展性" class="headerlink" title="6.2.2.1 业务流水的可扩展性"></a>6.2.2.1 业务流水的可扩展性</h5><p>大表顾明思议就是设计时除必须的字段外, 还需要预留大量的备用字段, 框架可以提供辅助工具来帮助将业务数据映射到备用字段中。<br>关联表, 分为框架表和业务表, 技术表中保存为实现补偿操作所需要的技术数据, 业务表保存业务数据, 通过在技术表中增加业务表名和业务表主键来建立和业务数据的关联。  </p><p>大表对于框架层实现起来简单, 但是也有一些难点, 比如预留多少字段合适, 每个字段又需要预留多少长度。另外一个难点是如果向从数据层面来查询数据, 很难看出备用字段的业务含义, 维护过程不友好。<br>关联表在业务要素上更灵活, 能支持不同的业务类型记录不同的业务要素; 但是对于框架实现上难度更高, 另外每次查询都需要复杂的关联动作, 性能方面会受影响。</p><p>有了上面的完整的流水记录, 协调服务就可以根据工作服务的状态在异常时完成补偿过程。<br>但是补偿由于网络等原因, 补偿操作并不一定能保证 100% 成功, 这时候我们还要做更多一点。</p><p>通过重试保证补偿过程的完整。从而满足最终一致性。<br>补偿过程作为一个服务调用过程同样存在调用不成功的情况, 这个时候需要通过重试的机制来保证补偿的成功率。<br>当然这也就要求补偿操作本身具备幂等性。 关于幂等性的实现在前面做过讨论。</p><h5 id="6-2-2-2-重试策略"><a href="#6-2-2-2-重试策略" class="headerlink" title="6.2.2.2 重试策略"></a>6.2.2.2 重试策略</h5><p>如果只是一味的失败就立即重试会给工作服务造成不必要的压力, 我们要根据服务执行失败的原因来选择不同的重试策略。  </p><p><img src="https://pic.imgdb.cn/item/655b82d2c458853aef033c25.png" alt="Alt &#39;补偿模式 - 重试策略&#39;"></p><p>如果失败的原因不是暂时性的, 由于业务因素导致 (如业务要素检查失败) 的业务错误, 这类错误是不会重发就能自动恢复的, 那么应该立即终止重试。<br>如果错误的原因是一些罕见的异常, 比如因为网络传输过程出现数据丢失或者错误, 应该立即再次重试, 因为类似的错误一般很少会再次发生。<br>如果错误的原因是系统繁忙 (比如 http 协议返回的 500 或者另外约定的返回码) 或者超时, 这个时候需要等待一些时间再重试。  </p><p>重试操作一般会指定重试次数上线, 如果重试次数达到了上限就不再进行重试了。这个时候应该通过一种手段通知相关人员进行处理。<br>对于等待重试的策略如果重试时仍然错误, 可逐渐增加等待的时间, 直到达到一个上限后, 以上限作为等待时间。<br>如果某个时刻聚集了大量需要重试的操作, 补偿框架需要控制请求的流量, 以防止对工作服务造成过大的压力。  </p><p>另外关于补偿模式还有几点补充说明：  </p><blockquote><ol><li>微服务实现补偿操作不是简单的回退到业务发生时的状态, 因为可能还有其他的并发的请求同时更改了状态。一般都使用逆操作的方式完成补偿。  </li><li>补偿过程不需要严格按照与业务发生的相反顺序执行, 可以依据工作服务的重用程度优先执行, 甚至是可以并发的执行。  </li><li>有些服务的补偿过程是有依赖关系的, 被依赖服务的补偿操作没有成功就要及时终止补偿过程。  </li><li>如果在一个业务中包含的工作服务不是都提供了补偿操作, 那我们编排服务时应该把提供补偿操作的服务放在前面, 这样当后面的工作服务错误时还有机会补偿。  </li><li>设计工作服务的补偿接口时应该以协调服务请求的业务要素作为条件, 不要以工作服务的应答要素作为条件。因为还存在超时需要补偿的情况, 这时补偿框架就没法提供补偿需要的业务要素。</li></ol></blockquote><p>补偿模式就介绍到这里, 下面介绍第三种模式: TCC 模式 (Try-Confirm-Cancel)</p><h3 id="6-3-TCC-模式"><a href="#6-3-TCC-模式" class="headerlink" title="6.3 TCC 模式"></a>6.3 TCC 模式</h3><p>一个完整的 TCC 业务由一个主业务服务和若干个从业务服务组成, 主业务服务发起并完成整个业务活动, TCC 模式要求从服务提供三个接口: Try、Confirm、Cancel。  </p><p><img src="https://pic.imgdb.cn/item/655b82d0c458853aef03339a.png" alt="Alt &#39;TCC 模式 - 操作说明&#39;"></p><blockquote><ol><li>Try: 完成所有业务检查, 预留必须业务资源 </li><li>Confirm: 真正执行业务, 不作任何业务检查, 只使用 Try 阶段预留的业务资源, Confirm 操作满足幂等性 </li><li>Cancel: 释放 Try 阶段预留的业务资源, Cancel 操作满足幂等性</li></ol></blockquote><p>整个 TCC 业务分成两个阶段完成。</p><p><img src="https://pic.imgdb.cn/item/655b82cfc458853aef032f56.png" alt="Alt &#39;TCC 模式 - 大体流程&#39;"></p><p>第一阶段: 主业务服务分别调用所有从业务的 try 操作, 并在活动管理器中登记所有从业务服务。当所有从业务服务的 try 操作都调用成功或者某个从业务服务的 try 操作失败, 进入第二阶段。</p><p>第二阶段: 活动管理器根据第一阶段的执行结果来执行 confirm 或 cancel 操作。<br>如果第一阶段所有 try 操作都成功, 则活动管理器调用所有从业务活动的 confirm 操作。否则调用所有从业务服务的 cancel 操作。</p><p>需要注意的是第二阶段 confirm 或 cancel 操作本身也是满足最终一致性的过程。<br>在调用 confirm 或 cancel 的时候也可能因为某种原因 (比如网络) 导致调用失败, 所以需要活动管理支持重试的能力, 同时这也就要求 confirm 和 cancel 操作具有幂等性。  </p><p>在补偿模式中一个比较明显的缺陷是, 没有隔离性。从第一个工作服务步骤开始一直到所有工作服务完成 (或者补偿过程完成), 不一致是对其他服务可见的。<br>另外最终一致性的保证还充分的依赖了协调服务的健壮性, 如果协调服务异常, 就没法达到一致性。</p><p>TCC 模式在一定程度上弥补了上述的缺陷, 在 TCC 模式中直到明确的 confirm 动作, 所有的业务操作都是隔离的 (由业务层面保证)。<br>另外工作服务可以通过指定 try 操作的超时时间, 主动的 cancel 预留的业务资源, 从而实现自治的微服务。</p><p>TCC 模式和补偿模式一样需要需要有协调服务和工作服务, 协调服务也可以作为通用服务一般实现为框架。<br>与补偿模式不同的是 TCC 服务框架不需要记录详细的业务流水, 完成 confirm 和 cancel 操作的业务要素由业务服务提供。  </p><p><img src="https://pic.imgdb.cn/item/655b82cec458853aef032a38.png" alt="Alt &#39;TCC 模式 - Confirm&#39;"></p><p>在第 4 步确认预订之前, 订单只是 pending 状态, 只有等到明确的 confirm 之后订单才生效。</p><p><img src="https://pic.imgdb.cn/item/655b82ccc458853aef0323ff.png" alt="Alt &#39;TCC 模式 - Cancel&#39;"></p><p>如果 3 个服务中某个服务 try 操作失败, 那么可以向 TCC 服务框架提交 cancel, 或者什么也不做由工作服务自己超时处理。  </p><p><img src="https://pic.imgdb.cn/item/655b82cbc458853aef031c16.png" alt="Alt &#39;TCC 模式 - heuristic exception&#39;"></p><p>TCC 模式也不能百分百保证一致性, 如果业务服务向 TCC 服务框架提交 confirm 后, TCC 服务框架向某个工作服务提交 confirm 失败 (比如网络故障), 那么就会出现不一致, 一般称为 <strong>heuristic exception</strong>。</p><p>需要说明的是为保证业务成功率, 业务服务向 TCC 服务框架提交 confirm 以及 TCC 服务框架向工作服务提交 confirm&#x2F;cancel 时都要支持重试, 这也就要 confirm&#x2F;cancel 的实现必须具有幂等性。<br>如果业务服务向 TCC 服务框架提交 confirm&#x2F;cancel 失败, 不会导致不一致, 因为服务最后都会超时而取消。</p><p>另外 heuristic exception 是不可杜绝的, 但是可以通过设置合适的超时时间, 以及重试频率和监控措施使得出现这个异常的可能性降低到很小。<br>如果出现了 heuristic exception 是可以通过人工的手段补救的。</p><h2 id="7-对账是最后的终极防线"><a href="#7-对账是最后的终极防线" class="headerlink" title="7 对账是最后的终极防线"></a>7 对账是最后的终极防线</h2><p>如果有些业务由于瞬时的网络故障或调用超时等问题, 通过上文所讲的 3 种模式一般都能得到很好的解决。<br>但是在当今云计算环境下, 很多服务是依赖于外部系统的可用性情况, 在一些重要的业务场景下还需要周期性的对账来保证真实的一致性。<br>比如支付系统和银行之间每天日终是都会有对账过程。</p><p><img src="https://pic.imgdb.cn/item/655b82c7c458853aef030f04.png" alt="Alt &#39;对账&#39;"></p><p>以上就是今天分享的内容, 主要介绍的是微服务架构中需要满足最终一致性原则以及实现最终一致性的 3 种模式。</p><h2 id="8-Q-A"><a href="#8-Q-A" class="headerlink" title="8 Q&amp;A"></a>8 Q&amp;A</h2><p><strong>1. 如果要保证事务, 是不是要开发一套成功的流程外, 还有开发一套失败保障的流程呢 ?</strong></p><p>也不是一套保障流程, 是服务除正常操作外还得提供其他相应的操作  </p><p><strong>2. 请问一下实现后两种模式所需要的内存开支是怎样的, 能否介绍一下 ?</strong></p><p>补偿模式和 TCC 模式对内存没有太多的要求, 中间状态保持一般会持久化到 db 中, 要考虑到业务操作和补偿操作可能会相差的时间比较长, 持久化是更好的选择。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是 Lambda ?</title>
      <link href="/article/2018/1832908961/"/>
      <url>/article/2018/1832908961/</url>
      
        <content type="html"><![CDATA[<p>转载信息:<br>作者: <strong>Mingqi</strong><br>来源: 知乎<br>原文链接: <a href="https://www.zhihu.com/question/20125256/answer/324121308">什么是 Lambda?</a><br>版权声明: 著作权归作者所有。商业转载请联系作者获得授权, 非商业转载请注明出处。</p><h2 id="什么是-Lambda"><a href="#什么是-Lambda" class="headerlink" title="什么是 Lambda?"></a>什么是 Lambda?</h2><p>我们知道, 对于一个 Java 变量, 我们可以赋给其一个<strong>值</strong>。</p><p><img src="https://pic.imgdb.cn/item/65582194c458853aeff56602.png" alt="Alt &#39;Java 变量赋值&#39;"></p><p>如果你想把<strong>一块代码</strong>赋给一个 Java 变量, 应该怎么做呢？<br>比如, 我想把右边那块代码, 赋给一个叫做 aBlockOfCode 的 Java 变量: </p><p><img src="https://pic.imgdb.cn/item/65582176c458853aeff51263.png" alt="Alt &#39;代码块赋值给 Java 变量&#39;"></p><p>在 Java 8 之前, 这个是做不到的。但是 Java 8 问世之后, 利用 Lambda 特性, 就可以做到了。</p><p><img src="https://pic.imgdb.cn/item/655827a1c458853aef08ae07.png" alt="Alt &#39;通过 Lambda 将代码块赋值给 Java 变量&#39;"></p><p>当然, 这个并不是一个很简洁的写法。所以, 为了使这个赋值操作更加 elegant, 我们可以移除一些没用的声明。</p><p><img src="https://pic.imgdb.cn/item/6558217ec458853aeff528dd.png" alt="Alt &#39;Lambda 表达式赋值给 Java 变量简化过程&#39;"></p><p>这样, 我们就成功的非常优雅的把<strong>一块代码</strong>赋给了一个变量。而<strong>这块代码</strong>, 或者说<strong>这个被赋给一个变量的函数</strong>, 就是一个 <strong>Lambda 表达式</strong>。</p><p>但是这里仍然有一个问题, 就是变量 aBlockOfCode 的类型应该是什么？</p><p>在 Java 8 里面, <strong>所有的 Lambda 的类型都是一个接口, 而 Lambda 表达式本身, 也就是那段代码, 需要是这个接口的实现</strong>。<br>这是我认为理解 Lambda 的一个关键所在, 简而言之就是, <strong>Lambda 表达式本身就是一个接口的实现</strong>。<br>直接这样说可能还是有点让人困扰, 我们继续看看例子。我们给上面的 aBlockOfCode 加上一个类型: </p><p><img src="https://pic.imgdb.cn/item/6558218bc458853aeff54e37.png" alt="Alt &#39;初版函数式接口&#39;"></p><p>这种只有<strong>一个接口函数需要被实现的接口类型, 我们叫它”函数式接口”。</strong><br>为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现, 变成”非函数接口”, 我们可以在这个上面加上一个声明<code>@FunctionalInterface</code>, 这样别人就无法在里面添加新的接口函数了: </p><p><img src="https://pic.imgdb.cn/item/6558218dc458853aeff55334.png" alt="Alt &#39;完整版函数式接口&#39;"></p><p>这样, 我们就得到了一个完整的 Lambda 表达式声明: </p><p><img src="https://pic.imgdb.cn/item/65582171c458853aeff502b0.png" alt="Alt &#39;完整版 Lambda 表达式声明&#39;"></p><h2 id="Lambda-表达式有什么作用"><a href="#Lambda-表达式有什么作用" class="headerlink" title="Lambda 表达式有什么作用?"></a>Lambda 表达式有什么作用?</h2><p><strong>最直观的作用就是使得代码变得异常简洁。</strong></p><p>我们可以对比一下 Lambda 表达式和传统的 Java 对同一个接口的实现: </p><p><img src="https://pic.imgdb.cn/item/65582188c458853aeff545b8.png" alt="Alt &#39;Java8 和 Java7 对同一接口实现对比&#39;"></p><p>这两种写法本质上是等价的。但是显然, Java 8 中的写法更加优雅简洁。<br>并且, 由于 Lambda 可以直接赋值给一个变量, <strong>我们就可以直接把 Lambda 作为参数传给函数, 而传统的 Java 必须有明确的接口实现的定义, 初始化才行:</strong></p><p><img src="https://pic.imgdb.cn/item/65582193c458853aeff5626b.png" alt="Alt &#39;Java8 和 Java7 对同一接口实现对比说明&#39;"></p><p>有些情况下, 这个接口实现只需要用到一次。传统的 Java 7 必须要求你定义一个“污染环境”的接口实现 MyInterfaceImpl, 而相较之下 Java 8 的 Lambda, 就显得干净很多。</p><h2 id="Lambda-结合-FunctionalInterface-Lib-forEach-stream-method-reference-等新特性可以使代码变的更加简洁！"><a href="#Lambda-结合-FunctionalInterface-Lib-forEach-stream-method-reference-等新特性可以使代码变的更加简洁！" class="headerlink" title="Lambda 结合 FunctionalInterface Lib, forEach, stream(), method reference 等新特性可以使代码变的更加简洁！"></a>Lambda 结合 FunctionalInterface Lib, forEach, stream(), method reference 等新特性可以使代码变的更加简洁！</h2><p>直接上例子。</p><p>假设 Person  的定义和 List&lt;Person&gt; 的值都给定。</p><p><img src="https://pic.imgdb.cn/item/6558216dc458853aeff4f902.png" alt="Alt &#39;Lambda 使用例子-初始说明&#39;"></p><p>现在需要你打印出 guiltyPersons List 里面所有 LastName 以 “Z” 开头的人的 FirstName。</p><p><strong>原生态 Lambda 写法</strong>: 定义两个函数式接口, 定义一个静态函数, 调用静态函数并给参数赋值 Lambda 表达式。</p><p><img src="https://pic.imgdb.cn/item/65582178c458853aeff516ed.png" alt="Alt &#39;Lambda 使用例子-原生 Lambda 实现&#39;"></p><p>当然可以。在 Java 8 中有一个函数式接口的包, 里面定义了大量可能用到的函数式接口（<a href="https://link.zhihu.com/?target=https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html">java.util.function (Java Platform SE 8 )</a>）。<br>所以, 我们在这里压根都不需要定义 NameChecker 和 Executor 这两个函数式接口, 直接用 Java 8 函数式接口包里的 Predicate&lt;T&gt; 和 Consumer&lt;T&gt; 就可以了 —— 因为他们这一对的接口定义和 NameChecker&#x2F;Executor 其实是一样的。</p><p><img src="https://pic.imgdb.cn/item/65582181c458853aeff532a2.png" alt="Alt &#39;Java8 内置的一些函数式接口举例&#39;"></p><p><strong>第一步简化 - 利用函数式接口包:</strong></p><p><img src="https://pic.imgdb.cn/item/65582187c458853aeff54120.png" alt="Alt &#39;Lambda 使用例子-利用函数式接口&#39;"></p><p>静态函数里面的 for each 循环其实是非常碍眼的。这里可以利用 Iterable 自带的 forEach() 来替代。forEach()本身可以接受一个 Consumer&lt;T&gt;  参数。</p><p><strong>第二步简化 - 用 Iterable.forEach() 取代 foreach loop:</strong></p><p><img src="https://pic.imgdb.cn/item/65582184c458853aeff53b3d.png" alt="Alt &#39;Lambda 使用例子-利用 forEach 代替 for 循环&#39;"></p><p>由于静态函数其实只是对 List 进行了一通操作, 这里我们可以甩掉静态函数, 直接使用 stream() 特性来完成。<br>stream() 的几个方法都是接受 Predicate&lt;T&gt;, Consumer&lt;T&gt; 等参数的（<a href="https://link.zhihu.com/?target=https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html">java.util.stream (Java Platform SE 8 )</a>）。<br>你理解了上面的内容, stream() 这里就非常好理解了, 并不需要多做解释。</p><p><strong>第三步简化 - 利用 stream() 替代静态函数:</strong></p><p><img src="https://pic.imgdb.cn/item/6558217fc458853aeff52b7f.png" alt="Alt &#39;Lambda 使用例子-利用 Stream 替换静态函数&#39;"></p><p>对比最开始的 Lambda 写法, 这里已经非常非常简洁了。<br>但是如果, 我们的要求变一下, 变成 print 这个人的全部信息, 及 <code>p -&amp;gt; System.out.println(p);</code> 那么还可以利用 Method reference 来继续简化。<br>所谓 Method reference, 就是用已经写好的别的 Object&#x2F;Class 的 method 来代替 Lambda expression 。<br>格式如下: </p><p><img src="https://pic.imgdb.cn/item/6558218ac458853aeff54aef.png" alt="Alt &#39;Steam 替换静态函数例子&#39;"></p><p><strong>第四步简化 - 如果是 <code>println(p)</code> , 则可以利用 Method reference 代替 forEach 中的 Lambda 表达式:</strong></p><p><img src="https://pic.imgdb.cn/item/65582180c458853aeff52e58.png" alt="Alt &#39;Lambda 使用例子-方法引用替换 Lambda 表达式&#39;"></p><p>这基本上就是能写的最简洁的版本了。</p><h2 id="Lambda-配合-Optional-可以使-Java-对于-null-的处理变的异常优雅"><a href="#Lambda-配合-Optional-可以使-Java-对于-null-的处理变的异常优雅" class="headerlink" title="Lambda 配合 Optional 可以使 Java 对于 null 的处理变的异常优雅"></a>Lambda 配合 Optional 可以使 Java 对于 null 的处理变的异常优雅</h2><p>这里假设我们有一个 person object, 以及一个 person object 的 Optional wrapper:</p><p><img src="https://pic.imgdb.cn/item/65582185c458853aeff53d60.png" alt="Alt &#39;Optional 使用例子 - 声明&#39;"></p><p>Optional&lt;T&gt; 如果不结合 Lambda 使用的话, 并不能使原来繁琐的 null check 变的简单。</p><p><img src="https://pic.imgdb.cn/item/6558216fc458853aeff4ff19.png" alt="Alt &#39;Optional 使用例子 - 单独使用的场景&#39;"></p><p><strong>只有当 Optional&lt;T&gt; 结合 Lambda 一起使用的时候, 才能发挥出其真正的威力！</strong></p><p>我们现在就来对比一下下面四种常见的 null 处理中, Java 8 的 Lambda + Optional&lt;T&gt; 和传统 Java 两者之间对于 null 的处理差异。</p><p><strong>情况一 - 存在则开干</strong></p><p><img src="https://pic.imgdb.cn/item/65582175c458853aeff50e5c.png" alt="Alt &#39;Optional 使用 - 存在就开干&#39;"></p><p><strong>情况二 - 存在则返回, 无则返回屁</strong></p><p><img src="https://pic.imgdb.cn/item/65582179c458853aeff51c03.png" alt="Alt &#39;Optional 使用 - 存在就返回, 不存在返回默认值&#39;"></p><p><strong>情况三 - 存在则返回, 无则由函数产生</strong><br><img src="https://pic.imgdb.cn/item/65582173c458853aeff5086c.png" alt="Alt &#39;Optional 使用 - 存在就返回, 不存在调用函数返回值&#39;"></p><p><strong>情况四 - 夺命连环null检查</strong></p><p><img src="https://pic.imgdb.cn/item/65582183c458853aeff537ed.png" alt="Alt &#39;Optional 使用 - null 检查优化&#39;"></p><p>由上述四种情况可以清楚地看到, Optional&lt;T&gt; + Lambda 可以让我们少写很多 ifElse 块。<br>尤其是对于情况四那种夺命连环 null 检查, 传统 java 的写法显得冗长难懂, 而新的 Optional&lt;T&gt; + Lambda 则清新脱俗, 清楚简洁。</p><hr><p>关于 Java 的 Lambda, 还有东西需要讨论和学习。比如如何 handle lambda exception, 如何利用 Lambda 的特性来进行 parallel processing 等。<br>总之, 我只是一如既往地介绍个大概, 让你大概知道, 哦！原来是这样子 OK 了。网上关于 Lambda 有很多相关的教程, 多看多练。假以时日, 必定有所精益。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot Starter</title>
      <link href="/article/2017/1551438839/"/>
      <url>/article/2017/1551438839/</url>
      
        <content type="html"><![CDATA[<p>转载信息:<br>作者: <strong>Derobukal</strong><br>来源: 御坂研究所<br>原文链接: <a href="https://www.nosuchfield.com/2017/10/15/Spring-Boot-Starters">Spring Boot Starters</a><br>版权声明: 本博客所有文章均采用 CC BY-NC-SA 4.0 许可协议, 转载请注明出处！</p><p>Spring Boot Starter 是在 SpringBoot 组件中被提出来的一种概念, stackoverflow 上面已经有人概括了这个 starter 是什么东西, 想看完整的回答戳 <a href="https://stackoverflow.com/a/28273660">这里</a></p><p><code>Starter POMs are a set of convenient dependency descriptors that you can include in your application. You get a one-stop-shop for all the Spring and related technology that you need, without having to hunt through sample code and copy paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, just include the spring-boot-starter-data-jpa dependency in your project, and you are good to go.</code></p><p>大概意思就是说 starter 是一种对依赖的 synthesize (合成), 这是什么意思呢？ 我可以举个例子来说明。</p><h2 id="传统的做法"><a href="#传统的做法" class="headerlink" title="传统的做法"></a>传统的做法</h2><p>在没有 starter 之前, 假如我想要在 Spring 中使用 JPA, 那我可能需要做以下操作：</p><blockquote><ol><li>在 Maven 中引入使用的数据库的依赖 (即 JDBC 的 JPA)</li><li>引入 JPA 的依赖</li><li>在 xxx.xml 中配置一些属性信息</li><li>反复的调试直到可以正常运行</li></ol></blockquote><p>需要注意的是, 这里操作在我们<strong>每次新建一个需要用到 JPA 的项目的时候都需要重复的做一次</strong>。<br>也许你在第一次自己建立项目的时候是在 Google 上自己搜索了一番, 花了半天时间解决掉了各种奇怪的问题之后, JPA 终于能正常运行了。<br>有些有经验的人会在 OneNote 上面把这次建立项目的过程给记录下来, 包括操作的步骤以及需要用到的配置文件的内容。<br>在下一次再创建 JPA 项目的时候, 就不需要再次去 Google 了, 只需要照着笔记来, 之后再把所有的配置文件 copy&amp;paste 就可以了。</p><p>像上面这样的操作也不算不行, 事实上我们在没有 starter 之前都是这么干的, 但是这样做有几个问题：</p><blockquote><ol><li>如果过程比较繁琐, 这样一步步操作会增加出错的可能性</li><li>不停地 copy&amp;paste 不符合 <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">Don’t repeat yourself</a> 精神</li><li>在第一次配置的时候 (尤其如果开发者比较小白), 需要花费掉大量的时间</li></ol></blockquote><h2 id="使用-SpringBoot-Starter-提升效率"><a href="#使用-SpringBoot-Starter-提升效率" class="headerlink" title="使用 SpringBoot Starter 提升效率"></a>使用 SpringBoot Starter 提升效率</h2><p>starter 的主要目的就是为了解决上面的这些问题。  </p><p>starter 的理念: starter 会把所有用到的依赖都给包含进来, 避免了开发者自己去引入依赖所带来的麻烦。<br>需要注意的是不同的 starter 是为了解决不同的依赖, 所以它们内部的实现可能会有很大的差异, 例如 JPA 的starter 和 Redis 的 starter 可能实现就不一样, 这是因为 starter 的本质在于 synthesize, 这是一层在逻辑层面的抽象。<br>也许这种理念有点类似于 Docker, 因为它们都是在做一个 “包装” 的操作, 如果你知道 Docker 是为了解决什么问题的, 也许你可以用 Docker 和 starter 做一个类比。</p><p>starter 的实现: 虽然不同的 starter 实现起来各有差异, 但是他们基本上都会使用到两个相同的内容: ConfigurationProperties 和 AutoConfiguration。<br>因为 SpringBoot 坚信 “约定大于配置” 这一理念, 所以我们使用 ConfigurationProperties 来保存我们的配置, 并且这些配置都可以有一个默认值, 即在我们没有主动覆写原始配置的情况下, 默认值就会生效, 这在很多情况下是非常有用的。<br>除此之外, starter 的 ConfigurationProperties 还使得所有的配置属性被聚集到一个文件中 (一般在 resources 目录下的 application.properties), 这样我们就告别了 Spring 项目中 XML 地狱。</p><p>starter 的整体逻辑:<br><img src="https://pic.imgdb.cn/item/6558a1cdc458853aefcc2fb0.png" alt="Alt &#39;SpringBoot Starter 整体逻辑&#39;"></p><p>上面的 starter 依赖的 jar 和我们自己手动配置的时候依赖的 jar 并没有什么不同, 所以<strong>我们可以认为 starter 其实是把这一些繁琐的配置操作交给了自己, 而把简单交给了用户</strong>。<br>除了帮助用户去除了繁琐的构建操作, 在 “约定大于配置” 的理念下, ConfigurationProperties 还帮助用户减少了无谓的配置操作。<br>并且因为 application.properties 文件的存在, 即使需要自定义配置, 所有的配置也只需要在一个文件中进行, 使用起来非常方便。</p><p>了解了 starter 其实就是帮助用户简化了配置的操作之后, 要理解 starter 和被配置了 starter 的组件之间并不是竞争关系, 而是辅助关系, 即我们可以给一个组件创建一个 starter 来让最终用户在使用这个组件的时候更加的简单方便。<br>基于这种理念, 我们可以给任意一个现有的组件创建一个 starter 来让别人在使用这个组件的时候更加的简单方便, 事实上 SpringBoot 团队已经帮助现有大部分的流行的组件创建好了它们的 starter, 你可以在<a href="https://github.com/spring-projects/spring-boot/tree/v1.5.7.RELEASE/spring-boot-starters">这里</a>查看这些 starter 的列表。</p><h2 id="创建自己的-SpringBoot-Starter"><a href="#创建自己的-SpringBoot-Starter" class="headerlink" title="创建自己的 SpringBoot Starter"></a>创建自己的 SpringBoot Starter</h2><p>如果你想要自己创建一个 starter, 那么基本上包含以下几步</p><blockquote><ol><li>创建一个 starter 项目, 关于项目的命名你可以参考<a href="https://docs.spring.io/spring-boot/docs/2.0.0.M5/reference/htmlsingle/#boot-features-custom-starter-naming">这里</a></li><li>创建一个 ConfigurationProperties 用于保存你的配置信息 (如果你的项目不使用配置信息则可以跳过这一步, 不过这种情况非常少见)</li><li>创建一个 AutoConfiguration, 引用定义好的配置信息, 在 AutoConfiguration 中实现所有 starter 应该完成的操作, 并且把这个类加入 spring.factories 配置文件中进行声明</li><li>打包项目, 之后在一个 SpringBoot 项目中引入该项目依赖, 然后就可以使用该 starter 了</li></ol></blockquote><p>我们来看一个例子 (例子的完整代码位于 <a href="https://github.com/RitterHou/learn-spring-boot-starter">https://github.com/RitterHou/learn-spring-boot-starter</a>)</p><ol><li><p>首先新建一个 Maven项目, 设置 pom.xml 文件如下:</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>http-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 自定义starter都应该继承自该依赖 --></span>    <span class="token comment">&lt;!-- 如果自定义starter本身需要继承其它的依赖, 可以参考 https://stackoverflow.com/a/21318359 解决 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starters<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.5.2.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- 自定义starter依赖此jar包 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- lombok用于自动生成get、set方法 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.16.10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre></li><li><p>创建 proterties 类来保存配置信息:</p></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"http"</span><span class="token punctuation">)</span> <span class="token comment">// 自动获取配置文件中前缀为http的属性, 把值传入对象参数</span><span class="token annotation punctuation">@Setter</span><span class="token annotation punctuation">@Getter</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpProperties</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果配置文件中配置了http.url属性, 则该默认属性会被覆盖</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"http://www.baidu.com/"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上面这个类就是定义了一个属性, 其默认值是 <a href="http://www.baidu.com/">http://www.baidu.com/</a>, 我们可以通过在 application.properties 中添加配置 http.url&#x3D;<a href="https://www.zhihu.com/">https://www.zhihu.com</a> 来覆盖参数的值。</p><ol start="3"><li>创建业务类: <pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Setter</span><span class="token annotation punctuation">@Getter</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpClient</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> url<span class="token punctuation">;</span>    <span class="token comment">// 根据 url 获取网页数据</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getHtml</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">URL</span> url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">URLConnection</span> urlConnection <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>urlConnection<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> line <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token string">"error"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></li></ol><p>这个业务类的操作非常简单, 只包含了一个 url 属性和一个 getHtml 方法, 用于获取一个网页的 HTML 数据, 读者看看就懂了。</p><ol start="4"><li>创建 AutoConfiguration<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token class-name">HttpProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpAutoConfiguration</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">HttpProperties</span> properties<span class="token punctuation">;</span> <span class="token comment">// 使用配置</span>    <span class="token comment">// 在Spring上下文中创建一个对象</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span>    <span class="token keyword">public</span> <span class="token class-name">HttpClient</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">HttpClient</span> client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> client<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></li></ol><p>在上面的 AutoConfiguration 中我们实现了自己要求: 在 Spring 的上下文中创建了一个 HttpClient 类的 bean, 并且我们把 properties 中的一个参数赋给了该 bean。<br>关于 @ConditionalOnMissingBean 这个注解, 它的意思是在该 bean 不存在的情况下此方法才会执行, 这个相当于开关的角色, 更多关于开关系列的注解可以参考<a href="https://docs.spring.io/spring-boot/docs/2.0.0.M5/reference/htmlsingle/#boot-features-condition-annotations">这里</a>。</p><p>最后, 我们在 resources 文件夹下新建目录 META-INF, 在目录中新建 spring.factories 文件, 并且在 spring.factories 中配置 AutoConfiguration：</p><pre class="language-none"><code class="language-none">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\com.nosuchfield.httpstarter.HttpAutoConfiguration</code></pre><p>到此, 我们的 starter 已经创建完毕了, 使用 Maven 打包该项目。<br>之后创建一个 SpringBoot 项目, 在项目中添加我们之前打包的 starter 作为依赖, 然后使用 SringBoot 来运行我们的 starter, 代码如下：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RunIt</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">HttpClient</span> httpClient<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>httpClient<span class="token punctuation">.</span><span class="token function">getHtml</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>正常情况下此方法的执行会打印出 url <a href="http://www.baidu.com/">http://www.baidu.com/</a> 的 HTML 内容, 之后我们在 application.properties 中加入配置: </p><pre class="language-none"><code class="language-none">http.url&#x3D;https:&#x2F;&#x2F;www.zhihu.com&#x2F;</code></pre><p>再次运行程序, 此时打印的结果应该是知乎首页的 HTML 了, 证明 properties 中的数据确实被覆盖了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
