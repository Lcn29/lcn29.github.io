<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Redis 内存回收和内存淘汰机制, Lcn29">
    <meta name="description" content="1 概念Redis 所有的数据都是存储在内存中的, 如果不进行任何的内存回收, 那么很容易出现内存爆满的情况。因此，在某些情况下需要对占用的内存空间进行释放。
Redis 中内存的释放主要分为两类Redis 中内存的释放主要分为两类: 

">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Redis 内存回收和内存淘汰机制 | Lcn29</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Lcn29" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.svg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Lcn29</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友链</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.svg" class="logo-img circle responsive-img">
        
        <div class="logo-name">Lcn29</div>
        <div class="logo-desc">
            
            Technical System
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友链
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/lcn29" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #121317;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/lcn29" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/21.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Redis 内存回收和内存淘汰机制</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Redis/">
                                <span class="chip bg-color">Redis</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-06-05
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2024-10-10
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    10.5k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    44 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>Redis 所有的数据都是存储在内存中的, 如果不进行任何的内存回收, 那么很容易出现内存爆满的情况。因此，在某些情况下需要对占用的内存空间进行释放。</p>
<p>Redis 中内存的释放主要分为两类<br>Redis 中内存的释放主要分为两类: </p>
<blockquote>
<ol>
<li>内存回收: 将过期的 key 清除，以减少内存占用</li>
<li>内存淘汰: 在内存使用达到上限(max_memory), 按照一定的策略删除一些键，以释放内存空间</li>
</ol>
</blockquote>
<p>两者都是通过删除 key (及其对应的 value) 来达到释放空间的效果。<br>区别在于前者清除的是用户明确不需要的 key, 而后者清除的则是用户可能仍然需要的 key。</p>
<h2 id="2-内存回收"><a href="#2-内存回收" class="headerlink" title="2 内存回收"></a>2 内存回收</h2><h3 id="2-1-过期策略"><a href="#2-1-过期策略" class="headerlink" title="2.1 过期策略"></a>2.1 过期策略</h3><p>在内存中的大量 key 中, 如何清除其中已经过期的 key 呢?</p>
<p>常用的方式有 3 种</p>
<blockquote>
<ol>
<li>定时过期 </li>
<li>惰性过期 </li>
<li>定期过期</li>
</ol>
</blockquote>
<p><strong>定时过期</strong></p>
<p>为每个 key 都创建一个定时器, 时间到了, 就将这个 key 清除。<br>该策略可以立即清除过期的数据, 对内存很友好。但是会占用大量的 CPU 资源去处理过期的数据, 从而影响缓存的响应时间和吞吐量。</p>
<p><strong>惰性过期</strong></p>
<p>key 过期了, 不进行处理。当后续访问到这个 key 时, 才会判断该 key 是否已过期, 过期则清除。<br>该策略可以最大化地节省 CPU 资源, 却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问, 从而不会被清除, 占用大量内存。</p>
<p><strong>定期过期</strong></p>
<p>将所有的 key 维护在一起, 每隔一段时间就从中扫描一定的数量的 key(采样), 并清除其中已经过期的 key。<br>通过调整定时扫描的时间间隔和每次扫描的耗时, 可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。</p>
<p>在 Reids 的实现中是通过 <strong>惰性过期</strong> + <strong>定期过期</strong> 2 种策略配合, 达到内存回收的效果。</p>
<h3 id="2-2-惰性过期-在-Redis-中的实现"><a href="#2-2-惰性过期-在-Redis-中的实现" class="headerlink" title="2.2 惰性过期 在 Redis 中的实现"></a>2.2 惰性过期 在 Redis 中的实现</h3><p>前提: Redis 中一个对象的过期时间存放在 dictEntry 的 v.s64 中, 至于 dictEntry 的设计可以看一下后面的<strong>附录</strong>。</p>
<p>Redis 大部分读写对象的命令, 在执行前都会调用 <strong>expireIfNeeded</strong> 函数做一个过期检查</p>
<blockquote>
<ol>
<li>如果 key 已经过期了, 将其删除</li>
<li>如果 key 未过期, 不做任何处理</li>
</ol>
</blockquote>
<p>expireIfNeeded 函数的定义如下</p>
<pre class="language-C" data-language="C"><code class="language-C">int expireIfNeeded(redisDb *db, robj *key) &#123;

    &#x2F;&#x2F; key 未过期返回 0
    if (!keyIsExpired(db,key)) return 0;

    &#x2F;&#x2F; 下面的逻辑都是 Key 过期的逻辑处理

    &#x2F;&#x2F; 当前的节点是从节点, 返回 1, 然后结束
    &#x2F;&#x2F; 为了保持主从数据的一致, 从节点不会主动清除数据, 都是主节点同步消息在删除
    if (server.masterhost !&#x3D; NULL) return 1;

    &#x2F;&#x2F; 已经删除过期键个数 + 1
    server.stat_expiredkeys++;
    &#x2F;&#x2F; 向从节点和 AOF 文件传播 key 过期信息, 清除过期 key
    propagateExpire(db,key,server.lazyfree_lazy_expire);
    &#x2F;&#x2F; 发送事件通知
    notifyKeyspaceEvent(NOTIFY_EXPIRED,&quot;expired&quot;,key,db-&gt;id);

    &#x2F;&#x2F; lazyfree-lazy-expire 配置参数 (版本 4.0 以上支持), 默认为 0
    &#x2F;&#x2F; 根据配置, 同步或异步删除 key (异步删除: 先将 key 逻辑删除, 然后在通过后台的线程池进行真正的空间释放)
    return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : dbSyncDelete(db,key);
&#125;

int keyIsExpired(redisDb *db, robj *key) &#123;
    &#x2F;&#x2F; 从过期字典中获取 key 对应的过期时间, 实际就是获取 dictEntity 的 v 中的 s64 值 (dictEntity.v.s64)
    mstime_t when &#x3D; getExpire(db,key);
    mstime_t now;

    &#x2F;&#x2F; 没有过期时间
    if (when &lt; 0) return 0;

    &#x2F;&#x2F; redis 在加载数据中
    if (server.loading) return 0;
    
    &#x2F;&#x2F; 获取当前的事件
    if (server.lua_caller) &#123;
        &#x2F;&#x2F; 有 lua 脚本在执行中, 当前时间等于脚本开始执行前的时间
        now &#x3D; server.lua_time_start;
    &#125; else if (server.fixed_time_expire &gt; 0) &#123;
        &#x2F;&#x2F; 有缓存时间, 线使用缓存时间
        &#x2F;&#x2F; server.mstime 这个时间会在调用执行命令函数的 call() 前进行更新
        &#x2F;&#x2F; 这样可以避免一些批量操作的命令, 比如 RPOPLPUSH 等命令, 这些命令会执行过程中可能多次访问这个 key
        &#x2F;&#x2F; 而在多次的访问过程中, 可能出现上一次访问未过期, 下次访问已经过期了, 通过这个缓冲时间可以解决这个问题
        now &#x3D; server.mstime;
    &#125; else &#123;
        &#x2F;&#x2F; 其他情况, 直接获取当前时间
        now &#x3D; mstime();
    &#125;

    &#x2F;&#x2F; 当前时间是否大于 key 的过期时间
    return now &gt; when;
&#125;</code></pre>

<p>expireIfNeeded 的调用时机, 基本都是在各个命令内部。 以 String 的 get 命令为例, 大体的流程如下</p>
<pre class="language-C" data-language="C"><code class="language-C">&#x2F;**
 * get 命令对应的执行函数
 * 需要的参数都封装在 client 对象中
 *&#x2F;
void getCommand(client *c) &#123;

    &#x2F;&#x2F; getGenericCommand -&gt; lookupKeyReadOrReply -&gt; lookupKeyRead -&gt; lookupKeyReadWithFlags
    &#x2F;&#x2F; getGenericCommand 经过几个函数最终调用到 lookupKeyReadWithFlags
    getGenericCommand(c);
&#125;

robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) &#123;

    robj *val;
    &#x2F;&#x2F; expireIfNeeded 返回 &gt; 0, 过期了
    if (expireIfNeeded(db,key) &#x3D;&#x3D; 1) &#123;
        &#x2F;&#x2F; 省略过期处理
        &#x2F;&#x2F; 过期的处理, 然后 return null
    &#125;

    &#x2F;&#x2F; 非过期处理, 查找然后返回
    val &#x3D; lookupKey(db,key,flags);
    if (val &#x3D;&#x3D; NULL)
        server.stat_keyspace_misses++;
    else
        server.stat_keyspace_hits++;
    return val;
&#125;</code></pre>

<p>上面就是 get 指令的中的惰性过期的过程, 其他命令的逻辑差不多, 核心就是一个 expireIfNeeded 函数。</p>
<h3 id="2-3-定期过期在-Redis-中的实现"><a href="#2-3-定期过期在-Redis-中的实现" class="headerlink" title="2.3 定期过期在 Redis 中的实现"></a>2.3 定期过期在 Redis 中的实现</h3><p>Redis 默认是 16 个数据库, 每个数据库会将设置了过期时间的 key 放到各自的一个独立的字典中, 称为过期字典 (redisDb 对象的 dict *expires 属性)。</p>
<p>然后 Redis 默认会按照每秒 10 次的频率（可以通过 redis.conf 中的 hz 配置）进行过期扫描。<br>扫描的过程不会遍历整个过期字典，而是按照以下策略进行</p>
<blockquote>
<ol>
<li>从过期字典中随机选择 20 个 key </li>
<li>删除其中已经过期的键</li>
<li>如果超过 25% 的键被删除, 则重复步骤 1, 2, 3, 没有超过, 就结束这次扫描</li>
<li>同时为防止重复循环, 导致线程卡死, 增加了每 16 次抽样, 就做一次扫描时间的上限的检查 (默认是慢模式下, 上限是 25 毫秒, 如果是快模式，扫描上限是 1 毫秒), 超过就结束循环</li>
</ol>
</blockquote>
<p>定期过期删除的实现主要在 <strong>&#x2F;activeExpireCycle</strong> 函数, 大体的逻辑如下</p>
<pre class="language-C" data-language="C"><code class="language-C">&#x2F;**
 * 过期循环清除
 * 为了便于理解, 这里对函数的逻辑做了一点小调整和删除一些非必要的逻辑, 但是整体的逻辑不变

 * @type 模式, 取值有 2 个 ACTIVE_EXPIRE_CYCLE_SLOW (0, 慢模式), ACTIVE_EXPIRE_CYCLE_FAST (1, 快模式)
 *&#x2F;
void activeExpireCycle(int type) &#123;

    &#x2F;&#x2F; 静态变量, 当前处理的数据库索引
    &#x2F;&#x2F; 静态的效果, 这个变量执行后的值不会被清空, 每次调用这个方法, 是上一次执行的值
    &#x2F;&#x2F; 这样就可以保证 16 个数据库, 每次方法执行完, 下次进来可以执行到下一个数据库, 循环起来，而不是每次进来都从第 0 个开始
    static unsigned int current_db &#x3D; 0;

    &#x2F;&#x2F; 上一次清理是否是因为时间超时结束循环的, 同样是静态变量
    static int timelimit_exit &#x3D; 0;    
    &#x2F;&#x2F; 上一次快速循环循环的时间, 同样是静态变量
    static long long last_fast_cycle &#x3D; 0;

    &#x2F;&#x2F; 当前时间
    long long start &#x3D; ustime(),

    &#x2F;&#x2F; 本次循环清除是快速循环, 上一次是时间超时获取 2 次快速循环的时间差在 2 毫秒内, 不执行
    if (type &#x3D;&#x3D; ACTIVE_EXPIRE_CYCLE_FAST) &#123;
        &#x2F;&#x2F; 上一次循环是因为时间超时结束的, 本次快速循环不进行
        if (!timelimit_exit) return;
        &#x2F;&#x2F; 上次快速循环距离当前时间在 1000 * 2 &#x3D; 2 毫秒内, 也不进行快速循环
        if (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) return;
        last_fast_cycle &#x3D; start;
    &#125;

    &#x2F;&#x2F; 计算循环的上限毫秒限制 
    &#x2F;&#x2F; server.hz 默认等于 10, ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC 等于 25
    &#x2F;&#x2F; 1000000 * 25 &#x2F; 10 &#x2F; 100 &#x3D; 25000 单位: 微秒, 即 25 毫秒
    long long timelimit &#x3D; 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC&#x2F;server.hz&#x2F;100;

    &#x2F;&#x2F; ACTIVE_EXPIRE_CYCLE_FAST_DURATION &#x3D; 1000
    &#x2F;&#x2F; 如果是快模式, 修改为 1000 微秒, 即 1 毫秒超时
    if (type &#x3D;&#x3D; ACTIVE_EXPIRE_CYCLE_FAST)
        timelimit &#x3D; ACTIVE_EXPIRE_CYCLE_FAST_DURATION;


    &#x2F;&#x2F; CRON_DBS_PER_CALL &#x3D; 16, 每次循环处理的数据库数量
    int dbs_per_call &#x3D; CRON_DBS_PER_CALL;

    &#x2F;&#x2F; 遍历当前数据库的次数
    int iteration &#x3D; 0;

    &#x2F;&#x2F; 遍历循环 16 个数据库
    for (int j &#x3D; 0; j &lt; dbs_per_call &amp;&amp; timelimit_exit &#x3D;&#x3D; 0; j++) &#123;

        &#x2F;&#x2F; 清理过期的 key 个数
        int expired;

        &#x2F;&#x2F; 计算本次处理的数据库
        redisDb *db &#x3D; server.db+(current_db % server.dbnum);
        current_db++;

        do &#123;
            &#x2F;&#x2F; 开始循环清除当前数据库中过期的 key

            &#x2F;&#x2F; 遍历次数 + 1
            iteration++;

            &#x2F;&#x2F; dictSize 获取整个过期字典的已经使用大小
            unsigned long num &#x3D; dictSize(db-&gt;expires);

            &#x2F;&#x2F; num &#x3D;&#x3D; 0 表示整个字典没有数据, 跳出循环，处理下一个数据库
            if (num &#x3D;&#x3D; 0) &#123;
                break;
            &#125;

            &#x2F;&#x2F; 计算整个过期字典的总大小
            unsigned long slots &#x3D; dictSlots(db-&gt;expires);

            &#x2F;&#x2F; DICT_HT_INITIAL_SIZE &#x3D; 4, 每个字典初始化时的默认值
            &#x2F;&#x2F; num &gt; 0, 字典中有数据了, slots 大于 4, 表示当前的字典扩容过了
            &#x2F;&#x2F; num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE, 当前的字典扩容过同时里面有数据
            &#x2F;&#x2F; num * 100 &#x2F; slots &lt; 1 计算当前使用的数据占整个字典的百分比是否小于 1%

            &#x2F;&#x2F; Redis 认为, 如果一个字典中的使用率小于 1%, 花时间去进行清理是一个昂贵的操作
            &#x2F;&#x2F; 应该停下来，等待更好的时间再进行调整
            &#x2F;&#x2F; 所以简单理解: 当这个字典中使用的空间小于 1%, 这里跳过了这个数据的处理
            if (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp; (num * 100 &#x2F; slots &lt; 1)) 
                break;

            expired &#x3D; 0;

            &#x2F;&#x2F; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP &#x3D; 20 
            &#x2F;&#x2F; 本次从过期字典中获取多少个 key, 如果字典中的已经使用的 key 大于 20, 则只取 20 个, 否则有多少取多少
            if (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)
                num &#x3D; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;
            
            &#x2F;&#x2F; 循环 num 次从字典中获取 key 
            while (num--) &#123;

                dictEntry *de;
                &#x2F;&#x2F; 从过期字典中随机获取一个 key, 获取不到, 就停止本次循环
                if ((de &#x3D; dictGetRandomKey(db-&gt;expires)) &#x3D;&#x3D; NULL) break;

                &#x2F;&#x2F; 尝试释放这个 key, 如果 key 释放成功, 过期次数 + 1
                if (activeExpireCycleTryExpire(db,de,now)) expired++;

            &#125;

            &#x2F;&#x2F; 0xf &#x3D; 15, iteration 表示遍历了 15 次
            if ((iteration &amp; 0xf) &#x3D;&#x3D; 0) &#123;
                &#x2F;&#x2F; 计算消耗时间
                int elapsed &#x3D; ustime()-start;
                &#x2F;&#x2F; 消耗时间超过了限制时间, 结束本次循环
                if (elapsed &gt; timelimit) &#123;
                    &#x2F;&#x2F; 超过时间限制标识设置为 true, 本次循环清除超时了, 结束本次循环清除
                    timelimit_exit &#x3D; 1;
                    break;
                &#125;
            &#125;

            &#x2F;&#x2F; 本次清理的过期 key 超过了 25%, 继续, 否则结束
            &#x2F;&#x2F; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP &#x3D; 20
            &#x2F;&#x2F; 每次抽取的个数最大为 20 个, 控制 25%, 20 * 25% &#x3D; 5 个
            &#x2F;&#x2F; 也就是过期的个数大于 5 就是大于 25%, (ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP&#x2F;4 &#x3D; 5)
        &#125; while (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP&#x2F;4);
    &#125;

    &#x2F;&#x2F; 省略各种分析数据的记录
&#125;</code></pre>

<p>调用 activeExpireCycle 的入口有 2 个</p>
<ol>
<li>Redis 定时事件触发</li>
</ol>
<pre class="language-C" data-language="C"><code class="language-C">&#x2F;**
 * Reids 启动时, 向事件轮询中注册的唯一一个定时事件(默认 100 毫秒执行一次), 执行的函数
 *&#x2F;
int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) &#123;
    ...
    &#x2F;&#x2F; 数据库扫描
    databasesCron();
    ...
&#125;

void databasesCron(void) &#123;

    &#x2F;&#x2F; 过期功能开启中, 默认为开启
    if (server.active_expire_enabled) &#123;
        &#x2F;&#x2F; 主节点
        if (server.masterhost &#x3D;&#x3D; NULL) &#123;
            &#x2F;&#x2F; 慢模式循环清除
            activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);
        &#125; else &#123;
            &#x2F;&#x2F; 从节点处理
            expireSlaveKeys();
        &#125;
    &#125;

    ...
&#125;</code></pre>

<ol start="2">
<li>事件轮询中, 进入阻塞前的调用函数</li>
</ol>
<pre class="language-C" data-language="C"><code class="language-C">void beforeSleep(struct aeEventLoop *eventLoop) &#123;

    ...

    &#x2F;&#x2F; 过期功能开启中同时为主节点
    if (server.active_expire_enabled &amp;&amp; server.masterhost &#x3D;&#x3D; NULL)
        &#x2F;&#x2F; 快模式循环清除
        activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);

    ...
&#125;</code></pre>

<h2 id="3-内存淘汰"><a href="#3-内存淘汰" class="headerlink" title="3 内存淘汰"></a>3 内存淘汰</h2><h3 id="3-1-淘汰算法"><a href="#3-1-淘汰算法" class="headerlink" title="3.1 淘汰算法"></a>3.1 淘汰算法</h3><p>为了能够腾出内存空间, 需要在一大群对象中选择某一些进行淘汰, 哪么应该基于什么标准进行选择呢?<br>比较常见的算法有 2 个: LRU 和 LFU。</p>
<p>LRU (Least Recently Used): 最近最少使用算法, 根据数据的历史访问记录进行淘汰数据，优先移除<strong>最近最少使用</strong>的数据。<br>简单理解就是根据对象的访问时间, 优先淘汰访问时间最早的对象。</p>
<p>LFU (Least Frequently Used): 最少频率使用算法, 根据数据的访问频率频率进行淘汰数据, 优先移除<strong>最近使用频率最少</strong>的数据。<br>简单理解就是根据对象的访问次数, 优先淘汰访问次数最少的对象。</p>
<h3 id="3-2-Redis-内存淘汰策略"><a href="#3-2-Redis-内存淘汰策略" class="headerlink" title="3.2 Redis 内存淘汰策略"></a>3.2 Redis 内存淘汰策略</h3><p>在 LFU 和 LRU 的基础上, Redis 提供了 8 种淘汰策略</p>
<table>
<thead>
<tr>
<th align="center">策略</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">noeviction</td>
<td align="center">默认策略, 不会删除任何数据, 但是拒绝所有写入操作并返回客户端错误信息 (error)OOM command not allow when used memory。此时 Redis 只响应读操作。</td>
</tr>
<tr>
<td align="center">volatile-lru</td>
<td align="center">Least Recently Used, 最近最少使用。在所有设置了 expire 的 key 中删除最近最少使用的键值对, 即距离上次访问时间最久的。</td>
</tr>
<tr>
<td align="center">allkeys-lru</td>
<td align="center">Least Recently Used, 最近最少使用。在所有的 key 中删除最近最少使用的键值对, 即距离上次访问时间最久的。</td>
</tr>
<tr>
<td align="center">volatile-lfu</td>
<td align="center">Least Frequently Used, 最不经常使用。在所有设置了 expire 的 key 中删除最不经常使用的键值对, 即访问次数最少的。</td>
</tr>
<tr>
<td align="center">allkeys-lfu</td>
<td align="center">Least Frequently Used, 最不经常使用。在所有的 key 中删除最不经常使用的键值对, 即访问次数最少的。</td>
</tr>
<tr>
<td align="center">volatile-random</td>
<td align="center">在所有设置了 expire 的 key 中随机选择删除</td>
</tr>
<tr>
<td align="center">allkeys-random</td>
<td align="center">在所有的 key 中随机选择删除。</td>
</tr>
<tr>
<td align="center">volatile-ttl</td>
<td align="center">Time To Live, 存活时间。 在所有设置了 expire 的 key 中删除 ttl 值最多的。</td>
</tr>
</tbody></table>
<p>volatile-lru, volatile-random, volatile-ttl, 在没有符合条件的 key 的情况下, 会按照 noeviction 的策略进行处理。</p>
<h3 id="3-3-Redis-对象淘汰判断标准设计"><a href="#3-3-Redis-对象淘汰判断标准设计" class="headerlink" title="3.3 Redis 对象淘汰判断标准设计"></a>3.3 Redis 对象淘汰判断标准设计</h3><p>在上面介绍的几种策略可以知道, 要判断一个对象是否可以被淘汰, 需要对象自身存放使用策略对应的数据, 以便于判断<br>比如: </p>
<blockquote>
<ol>
<li>2 个 lru 策略, 需要对象自身保存好上次访问的时间</li>
<li>2 个 lfu 策略, 需要对象自身保存好访问次数</li>
<li>ttl 策略, 需要对象自身保存好过期时间</li>
<li>2 个 random 策略, 不需要保存额外的数据, 通过随机一个数, 根据这个数从字典中获取数据即可</li>
</ol>
</blockquote>
<h5 id="3-3-1-Redis-对象的设计"><a href="#3-3-1-Redis-对象的设计" class="headerlink" title="3.3.1 Redis 对象的设计"></a>3.3.1 Redis 对象的设计</h5><p>正常情况下, 当我们向 Redis 中存入一对键值对, 实际可以拆分为 2 个对象, 一个 key, 一个 value。<br>其中 key 可以明确为是一个字符串, 所以存入到 Redis 的键值对的 key 会被封装为 sds 对象。<br>但是 value 可以类型可以很多, 为了行为的统一等, 需要对 value 做一个封装, 落实到源码中就是一个 <strong>redisObject</strong> 对象, 其定义如下</p>
<pre class="language-C" data-language="C"><code class="language-C">typedef struct redisObject &#123;
    
    &#x2F;** 
     * 标识这个对象的数据类型, 常说的 String, Hash, List 等
     *&#x2F;
    unsigned type:4;

    &#x2F;**
     * 可以理解为数据类型的具体实现类型
     * 比如数据类型为 List, 在具体的实现中可以是 ArrayList LinkedList 等
     *&#x2F;
    unsigned encoding:4;

    &#x2F;** 
     * LRU_BITS &#x3D; 24,
     * 一个 24 位的变量, 表示对象最后一次被程序访问的时间或者访问的次数, 与内存回收有关
     * 暂时知道有这个对象即可, 后面有分析
     *&#x2F;
    unsigned lru:LRU_BITS;

    &#x2F;**
     * 被引用的次数, 当 refcount 为 0 的时候, 表示该对象已经不被任何对象引用, 则可以进行垃圾回收了
     *&#x2F;
    int refcount;

    &#x2F;**
     * 一个指针, 指向具体的数据
     *&#x2F;
    void *ptr;

&#125; robj;</code></pre>

<p>一个对象的 lru 和 lfu 计算后的值, 都是存放在这个对象的 lru 字段中的, 但是 lru 和 lfu 的计算方式是不一样的。</p>
<h5 id="3-3-2-lru-策略-对象的访问时间设计"><a href="#3-3-2-lru-策略-对象的访问时间设计" class="headerlink" title="3.3.2 lru 策略, 对象的访问时间设计"></a>3.3.2 lru 策略, 对象的访问时间设计</h5><h6 id="3-3-2-1-全局时间-lruclock"><a href="#3-3-2-1-全局时间-lruclock" class="headerlink" title="3.3.2.1 全局时间 lruclock"></a>3.3.2.1 全局时间 lruclock</h6><p>在 Redis 的中维护了一个全局的变量 lruclock, 表示当前时间的一个相对值。</p>
<pre class="language-C" data-language="C"><code class="language-C">&#x2F;**
 * redisServer 可以看做整个 Redis 运行时的上下文, 保存的数据, 配置等都在这个结构体中
 *&#x2F;
struct redisServer &#123;
    unsigned int lruclock &#x3D; getLRUClock();
&#125;

unsigned int getLRUClock(void) &#123;
    &#x2F;&#x2F; LRU_CLOCK_RESOLUTION &#x3D; 1000
    &#x2F;&#x2F; mstime() 当前时间毫秒, 当前时间的毫秒&#x2F;LRU_CLOCK_RESOLUTION &#x3D; 当前时间的毫秒&#x2F;1000 &#x3D; 变为单位秒
    &#x2F;&#x2F; LRU_CLOCK_MAX &#x3D; ((1&lt;&lt;LRU_BITS)-1) &#x3D; 1&lt;&lt;24-1 &#x3D; redisObject lru 字段的最大值
    &#x2F;&#x2F; (当前的时间 &#x2F; 1000) &amp; (1&lt;&lt;24-1) 确保时间的精度是秒, 同时不会超过 24 位的整数的最多值
    &#x2F;&#x2F; 整个全局时间的进度为秒, 2 个对象的访问时间差如果在秒内, 得到的是他们的访问时间是一样的
    
    &#x2F;&#x2F; 得到一个当前时间的相对值
    return (mstime()&#x2F;LRU_CLOCK_RESOLUTION) &amp; LRU_CLOCK_MAX;
&#125;</code></pre>

<p>同时这个时间会在 Redis 的定时任务 serverCron 中定时的更新为最新的值</p>
<pre class="language-C" data-language="C"><code class="language-C">int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) &#123;
    &#x2F;&#x2F; serverCron 默认是 100 毫秒执行一次
    unsigned int lruclock &#x3D; getLRUClock();
    atomicSet(server.lruclock,lruclock);
&#125;</code></pre>

<h6 id="3-3-2-2-对象的访问时间设计"><a href="#3-3-2-2-对象的访问时间设计" class="headerlink" title="3.3.2.2 对象的访问时间设计"></a>3.3.2.2 对象的访问时间设计</h6><p>Redis 每次通过 key 在数据库中查询对应的 value 时, 在找到时, 就会进行 lru 字段的更新</p>
<pre class="language-C" data-language="C"><code class="language-C">robj *lookupKey(redisDb *db, robj *key, int flags) &#123;
    &#x2F;&#x2F; 从字典中获取 key 对应的 dictEntry (字典的设计可以看一下后面的附录)
    dictEntry *de &#x3D; dictFind(db-&gt;dict,key-&gt;ptr);
    if (de) &#123;
        &#x2F;&#x2F; 获取 key 对应的 dictEntry 的存在
        &#x2F;&#x2F; 获取 dictEntry 的 value 也就是 redisObject 对象
        robj *val &#x3D; dictGetVal(de);

        if (server.rdb_child_pid &#x3D;&#x3D; -1 &amp;&amp; server.aof_child_pid &#x3D;&#x3D; -1 &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH)) &#123;
            &#x2F;&#x2F; 没有在进行 RDB 或 AOF 操作, 并且 flags 没有设置 LOOKUP_NOTOUCH

            &#x2F;&#x2F; 淘汰策略设置的的 LFU 策略
            if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;
                updateLFU(val);
            &#125; else &#123;
                &#x2F;&#x2F; 其他策略, 更新 lru 为全局的 lruclock
                val-&gt;lru &#x3D; LRU_CLOCK();
            &#125;
        &#125;
    &#125; else &#123;
        &#x2F;&#x2F; key 不存在, 返回 null
        return NULL;
    &#125;
&#125;

unsigned int LRU_CLOCK(void) &#123;
    unsigned int lruclock;
    &#x2F;&#x2F; LRU_CLOCK_RESOLUTION &#x3D; 1000
    &#x2F;&#x2F; 1000&#x2F;server.hz 就是上面定时任务 serverCron 的执行时间
    &#x2F;&#x2F; &lt;&#x3D; 1000 说明 serverCron 的执行时间小于 1 秒, 直接获取 server.lruclock 的值
    &#x2F;&#x2F; 如果大于 1000, 就调用 getLRUClock() 实时获取当前的时间, 因为频率太低了, 会造成更多的对象的访问时间一样
    if (1000&#x2F;server.hz &lt;&#x3D; LRU_CLOCK_RESOLUTION) &#123;
        atomicGet(server.lruclock,lruclock);
    &#125; else &#123;
        lruclock &#x3D; getLRUClock();
    &#125;
    return lruclock;
&#125;</code></pre>

<h5 id="3-3-3-lfu-策略-对象的访问频率设计"><a href="#3-3-3-lfu-策略-对象的访问频率设计" class="headerlink" title="3.3.3 lfu 策略, 对象的访问频率设计"></a>3.3.3 lfu 策略, 对象的访问频率设计</h5><p>对象的 lfu 同样是存放在 redisObject 的 <strong>lru:LRU_BITS</strong> 字段。 这个 24 bits 字段, 被分为两部分</p>
<blockquote>
<ol>
<li>高 16 位用来记录访问时间 (单位为分钟，ldt, last decrement time)</li>
<li>低 8 位用来记录相对的访问次数, 简称 counter (logc, logistic counter)</li>
</ol>
</blockquote>
<p>Redis 中对 LFU 的实现比较特殊, 通过时间衰减的方式近似达到了 LFU 的效果。<br>大体的思路如下:</p>
<blockquote>
<ol>
<li>对象创建时, 初始访问次数为 5 (避免刚创建出来, 对象就被回收), 同时记录下当前时间, 单位分钟</li>
<li>对象被访问时, 获取当前时间, 单位分钟, 当前时间 - 对象本身记录的时间, 得到相差多少分钟, 访问次数就减少多少</li>
<li>然后对象的访问次数 + 1, 再次记录下当前时间</li>
</ol>
</blockquote>
<p>这样对象在单位分钟内, 访问越频繁, 访问次数越大, 同时随着时间的推移, 没有进行访问, 访问次数会逐渐减少, 从而达到了 LFU 的效果。</p>
<p>ldt 记录的是最近一次访问的时间, 16 位, 所以最大值为 65535, 单位是分钟, 差不多 45 天左右。<br>也就是一个对象如果一直被访问, 到了第 45 天后, 这个值又会重新回到 0 开始计算。</p>
<p>ldt 的计算</p>
<pre class="language-C" data-language="C"><code class="language-C">unsigned long LFUGetTimeInMinutes(void) &#123;
  &#x2F;&#x2F; &amp; 65535 保证时间的范围在 0 ~ 65535 之间, 不会超过 16 数值的大小   
  return (server.unixtime&#x2F;60) &amp; 65535;
&#125;</code></pre>

<p>同 lru 一样, lruclock 的计算, 后面的时间比前面的时间小,<br>说明后面的时间到了下一轮的重新开始了, 这时只需要后面的时间 + 65535 - 前面的时间, 就能得到 2 个时间的差值了。</p>
<p>logc 记录的是一个相对的访问次数。<br>本身只有 8 位, 也就是最大值为 255, 也就是一个对象只能保存 255 次访问次数, 这个基本不同满足日常的使用。<br>所以 Redis 内部设计了一个随机公式, 控制访问次数的增长, 即每次访问, 访问次数加不加一, 通过随机判断。</p>
<pre class="language-C" data-language="C"><code class="language-C">uint8_t LFULogIncr(uint8_t counter) &#123;
    &#x2F;&#x2F; 当前的访问次数已经达到了最大值了
    if (counter &#x3D;&#x3D; 255) 
        return 255;

    &#x2F;&#x2F; 产生一个随机数
    double r &#x3D; (double)rand()&#x2F;RAND_MAX;
    &#x2F;&#x2F; 获取一个基础值, 当前的次数 - 对象初始化的默认次数 (LFU_INIT_VAL &#x3D; 5)
    double baseval &#x3D; counter - LFU_INIT_VAL;
    if (baseval &lt; 0) baseval &#x3D; 0;
    &#x2F;&#x2F; 1.0 &#x2F; 基础值 * server.lfu_log_factor (默认值, 10, 可配置) + 1, 得到一个数
    double p &#x3D; 1.0&#x2F;(baseval*server.lfu_log_factor+1);
    &#x2F;&#x2F; 得到的数大于随机出来的数, 访问次数 + 1
    if (r &lt; p) counter++;
    return counter;
&#125;</code></pre>
<p>官方的测试数据 (可以简单看成, counter &#x3D; 5, 在 100 - 1000w 次的调用, lfu_log_factor 不同取值下, 最终的 counter 的值)</p>
<table>
<thead>
<tr>
<th align="center">lfu_log_factor 取值</th>
<th align="center">100 次</th>
<th align="center">1000 次</th>
<th align="center">10w 次</th>
<th align="center">100w 次</th>
<th align="center">1000w 次</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">104</td>
<td align="center">255</td>
<td align="center">255</td>
<td align="center">255</td>
<td align="center">255</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">18</td>
<td align="center">49</td>
<td align="center">255</td>
<td align="center">255</td>
<td align="center">255</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">18</td>
<td align="center">142</td>
<td align="center">255</td>
<td align="center">255</td>
</tr>
<tr>
<td align="center">100</td>
<td align="center">8</td>
<td align="center">11</td>
<td align="center">49</td>
<td align="center">143</td>
<td align="center">255</td>
</tr>
</tbody></table>
<p>lfu_log_factor 设置为 10 的情况下, 在 100w 次的访问中, 访问次数才达到为 255, 也就是最大值。<br>基本可以满足 10w 次的使用</p>
<h6 id="3-3-3-1-counter-衰减机制"><a href="#3-3-3-1-counter-衰减机制" class="headerlink" title="3.3.3.1 counter 衰减机制"></a>3.3.3.1 counter 衰减机制</h6><p>每个对象被返回时, counter 都会先进行一个衰减操作, 然后再通过上面的随机公式进行判断次数是否需要增加。</p>
<p>衰减的过程如下</p>
<pre class="language-C" data-language="C"><code class="language-C">unsigned long LFUDecrAndReturn(robj *o) &#123;

    &#x2F;&#x2F; 右移 8 为, 也就是得的了高位的 16 位, 即 ldt, 得到上次记录的时间
    unsigned long ldt &#x3D; o-&gt;lru &gt;&gt; 8;
    &#x2F;&#x2F; 得到当前保存的次数
    unsigned long counter &#x3D; o-&gt;lru &amp; 255;

    &#x2F;&#x2F; lfu_decay_time 衰减时间, 默认 1, 单位分钟
    &#x2F;&#x2F; 如果没有配置 lfu_decay_time, 则默认不进行衰减, counter 当前是多少就是多少
    &#x2F;&#x2F; 获取 2 次访问的时间差 &#x2F; lfu_decay_time, 得到经过了多少个时间段   
    unsigned long num_periods &#x3D; server.lfu_decay_time ? LFUTimeElapsed(ldt) &#x2F; server.lfu_decay_time : 0;
    if (num_periods)
        &#x2F;&#x2F; 最新的次数 &#x3D; 当前的次数 - 经过了多少个时间段, 小于 0 时, 设置为 0 
        counter &#x3D; (num_periods &gt; counter) ? 0 : counter - num_periods;
    return counter;
&#125;

&#x2F;&#x2F; 距离上次访问相差多少分钟
unsigned long LFUTimeElapsed(unsigned long ldt) &#123;
    unsigned long now &#x3D; LFUGetTimeInMinutes();
    if (now &gt;&#x3D; ldt) return now-ldt;
    return 65535-ldt+now;
&#125;</code></pre>

<h6 id="3-3-3-2-对象的访问频率设计"><a href="#3-3-3-2-对象的访问频率设计" class="headerlink" title="3.3.3.2 对象的访问频率设计"></a>3.3.3.2 对象的访问频率设计</h6><p>Redis 每次通过 key 在数据库中查询对应的 value 时, 在找到时, 就会进行 lru 字段的更新</p>
<pre class="language-C" data-language="C"><code class="language-C">robj *lookupKey(redisDb *db, robj *key, int flags) &#123;
    
    dictEntry *de &#x3D; dictFind(db-&gt;dict,key-&gt;ptr);
    if (de) &#123;
        robj *val &#x3D; dictGetVal(de);

        if (server.rdb_child_pid &#x3D;&#x3D; -1 &amp;&amp; server.aof_child_pid &#x3D;&#x3D; -1 &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH)) &#123;
            &#x2F;&#x2F; 淘汰策略设置的的 LFU 策略
            if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;
                updateLFU(val);
            &#125; else &#123;
                val-&gt;lru &#x3D; LRU_CLOCK();
            &#125;
        &#125;
    &#125; else &#123;
        return NULL;
    &#125;
&#125;

void updateLFU(robj *val) &#123;
    &#x2F;&#x2F; 通过衰减机制, 得到最新的 counter
    unsigned long counter &#x3D; LFUDecrAndReturn(val);
    &#x2F;&#x2F; 通过随机公式, 得到最新的 counter
    counter &#x3D; LFULogIncr(counter);
    &#x2F;&#x2F; 将最新的 counter 和 当前时间保存到 lru 字段中
    val-&gt;lru &#x3D; (LFUGetTimeInMinutes()&lt;&lt;8) | counter;
&#125;</code></pre>



<h3 id="3-4-Redis-内存淘汰策略的实现"><a href="#3-4-Redis-内存淘汰策略的实现" class="headerlink" title="3.4 Redis 内存淘汰策略的实现"></a>3.4 Redis 内存淘汰策略的实现</h3><p>Redis 的内存的实现方式都是通过<strong>随机采样 + 比较 lru 值决定是否淘汰</strong>的方式实现的。</p>
<p>大体过程如下:</p>
<blockquote>
<ol>
<li>Redis 启动时, 会初始一个默认容量为 16 的待淘汰数据池 <strong>evictionPoolEntry (本质就是一个数组)</strong></li>
<li>每个存入到 Redis 的对象 (redisObject) 都会在初始其 24 位的 lru 字段 (lru: 一个相对的访问时间, lfu: 一个相对的访问次数)</li>
<li>后面每次访问 Redis 的对象时, 更新其 lru 字段的值</li>
<li>同时每次执行一个 Redis 命令时, 就会判断一下当前的内存是否足够, 如果不够, 就计算出需要释放多少内存, 然后进行内存淘汰</li>
</ol>
</blockquote>
<p>内存淘汰的过程如下: </p>
<p><strong>4.1 首次淘汰</strong><br>从数据字典或过期字典 (由配置的淘汰策略决定) 中随机抽样选出<strong>最多 N 个数据</strong>放入到一个<strong>样例池</strong>。<br>数据量 N: 由 redis.conf 配置的 maxmemory-samples 决定, 默认值是 5。 配置为 10 将非常接近真实 LRU 效果。<br>采样参数 maxmemory-samples 配置的数值越大, 就越能精确的查找到待淘汰的缓存数据, 但是也消耗更多的 CPU 计算, 执行效率降低。<br>同时为了避免长时间找不到足够的数据填充<strong>样例池</strong>, 强制写死了单次寻找数据的最大次数是 maxsteps &#x3D; N*10。  </p>
<p><strong>4.2 再次淘汰</strong><br>遍历整个<strong>样例池</strong>, 遍历的对象通过 lru 计算处理的值, 只要比<strong>待淘汰数据池</strong>中的<strong>任意一条</strong>数据的小, 就将该数据填充至<strong>待淘汰数据池</strong>。<br>第一次淘汰时, <strong>待淘汰数据池</strong>为空, 所以第一次淘汰时, 会将所有的样例数据填充到<strong>待淘汰数据池</strong>中, 这个池子后面就都会有数据, 一直存在着。<br>后续的淘汰时, <strong>样例池</strong> 中的数据就有可能进入到<strong>待淘汰数据池</strong>中, 也有可能不进入。</p>
<p><strong>4.3 执行淘汰</strong><br>从<strong>待淘汰数据池</strong>的尾部向前找到第一个可以删除的 key (此时找到的 key 就是值最小&#x2F;大的, 既空闲时间最大&#x2F;访问次数最小&#x2F;存活时间最小), 对其进行淘汰</p>
<p><strong>4.4 继续淘汰</strong><br>计算删除了一个 key 后内存释放了多少, 如果没达到要求的释放量, 就回到步骤 <strong>4.1</strong> 继续淘汰</p>
<h4 id="3-4-1-Redis-内存淘汰策略的代码实现"><a href="#3-4-1-Redis-内存淘汰策略的代码实现" class="headerlink" title="3.4.1 Redis 内存淘汰策略的代码实现"></a>3.4.1 Redis 内存淘汰策略的代码实现</h4><p>入口: 每个命令的执行处</p>
<pre class="language-C" data-language="C"><code class="language-C">int processCommand(client *c) &#123;
    ...

    &#x2F;&#x2F; 有设置最大内存 同时当前没有 lua 脚本超时的情况
    if (server.maxmemory &amp;&amp; !server.lua_timedout) &#123;
        &#x2F;&#x2F; 有必要时, 尝试释放内存
        int out_of_memory &#x3D; freeMemoryIfNeededAndSafe() &#x3D;&#x3D; C_ERR;

        &#x2F;&#x2F; 内存不够 同时执行的命令是变更命令 或者 当前的客户端开启了事务, 同时执行的命令不是 exec 
        if (out_of_memory &amp;&amp; (c-&gt;cmd-&gt;flags &amp; CMD_DENYOOM || (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp; c-&gt;cmd-&gt;proc !&#x3D; execCommand))) &#123;
            flagTransaction(c);
            &#x2F;&#x2F; 响应 -OOM command not allowed when used memory &gt; &#39;maxmemory’
            addReply(c, shared.oomerr);
            return C_OK;
        &#125;
    &#125;

    ...
&#125;

int freeMemoryIfNeededAndSafe(void) &#123;
    &#x2F;&#x2F; 当前有 lua 脚本执行超时或者真正加载数据, 返回成功
    if (server.lua_timedout || server.loading) return C_OK;
    &#x2F;&#x2F; 是否内存如果有必要的话
    return freeMemoryIfNeeded();
&#125;</code></pre>

<p>释放内存的核心函数</p>
<pre class="language-C" data-language="C"><code class="language-C">int freeMemoryIfNeeded(void) &#123;

    &#x2F;&#x2F; 如果是从节点同时配置了从节点忽略内存配置, 直接返回
    if (server.masterhost &amp;&amp; server.repl_slave_ignore_maxmemory) return C_OK;

    &#x2F;&#x2F; mem_reported 保存了整个 Redis 已经使用的内存
    &#x2F;&#x2F; mem_tofree 经过计算本次应该释放的内存, 等于当前已经使用的内存 - 用于主从复制的复制缓冲区大小 - 配置的 maxmemory
    &#x2F;&#x2F; mem_freed 已经释放了多少内存
    size_t mem_reported, mem_tofree, mem_freed;

    long long delta;

    &#x2F;&#x2F; 从节点个数
    int slaves &#x3D; listLength(server.slaves);

    &#x2F;&#x2F; 判断当前的内存状态, 如果足够, 直接返回
    if (getMaxmemoryState(&amp;mem_reported,NULL,&amp;mem_tofree,NULL) &#x3D;&#x3D; C_OK)
        return C_OK;

    &#x2F;&#x2F; 如果配置的策略为  noeviction
    if (server.maxmemory_policy &#x3D;&#x3D; MAXMEMORY_NO_EVICTION)
        goto cant_free;

    mem_freed &#x3D; 0;

    &#x2F;&#x2F; 没有达到需要的内存大小, 继续循环
    while (mem_freed &lt; mem_tofree) &#123;

        static unsigned int next_db &#x3D; 0;
        sds bestkey &#x3D; NULL;
        int bestdbid;
        redisDb *db;
        dict *dict;
        dictEntry *de;

        
        if (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) || server.maxmemory_policy &#x3D;&#x3D; MAXMEMORY_VOLATILE_TTL) &#123;
            &#x2F;&#x2F; LRU + LFU + TTL 策略

            &#x2F;&#x2F; 淘汰池
            struct evictionPoolEntry *pool &#x3D; EvictionPoolLRU;

            while(bestkey &#x3D;&#x3D; NULL) &#123;
                
                &#x2F;&#x2F; 遍历 16 个数据库
                for (i &#x3D; 0; i &lt; server.dbnum; i++) &#123;
                    db &#x3D; server.db+i;
                    &#x2F;&#x2F; 根据 volatile 或 all 选择对应的数据字典
                    dict &#x3D; (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ? db-&gt;dict : db-&gt;expires;
                    &#x2F;&#x2F; 获取字典的数据大小, keys 为当前数据库的 key 的数量
                    if ((keys &#x3D; dictSize(dict)) !&#x3D; 0) &#123;
                        evictionPoolPopulate(i, dict, db-&gt;dict, pool);
                        total_keys +&#x3D; keys;
                    &#125;
                &#125;

                &#x2F;&#x2F; 没有可以处理的 keys
                if (!total_keys) break;

                &#x2F;&#x2F; EVPOOL_SIZE &#x3D;  16
                for (k &#x3D; EVPOOL_SIZE-1; k &gt;&#x3D; 0; k--) &#123;
                    if (pool[k].key &#x3D;&#x3D; NULL) continue;
                    bestdbid &#x3D; pool[k].dbid;

                    &#x2F;&#x2F; 从数据库中获取对应的节点
                    if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) &#123;
                        de &#x3D; dictFind(server.db[pool[k].dbid].dict, pool[k].key);
                    &#125; else &#123;
                        de &#x3D; dictFind(server.db[pool[k].dbid].expires, pool[k].key);
                    &#125;

                    &#x2F;&#x2F; 释放缓存
                    if (pool[k].key !&#x3D; pool[k].cached)
                        sdsfree(pool[k].key);
                    pool[k].key &#x3D; NULL;
                    pool[k].idle &#x3D; 0;

                    &#x2F;&#x2F; 找到的释放对象存在, 先跳出这次循环
                    if (de) &#123;
                        bestkey &#x3D; dictGetKey(de);
                        break;
                    &#125; else &#123;
                        &#x2F;&#x2F; 不存在, 进行循环查找
                    &#125;
                &#125;
            &#125;

        &#125; else if (server.maxmemory_policy &#x3D;&#x3D; MAXMEMORY_ALLKEYS_RANDOM || server.maxmemory_policy &#x3D;&#x3D; MAXMEMORY_VOLATILE_RANDOM) &#123;
            &#x2F;&#x2F; random 策略
        &#125;

        &#x2F;&#x2F; 删除找到的 key
        if (bestkey) &#123;
            
            db &#x3D; server.db+bestdbid;

            &#x2F;&#x2F; 将 key 封装为 redisObject 对象
            robj *keyobj &#x3D; createStringObject(bestkey,sdslen(bestkey));

            &#x2F;&#x2F; 传播 key 过期信息到主从复制和 AOF 文件
            propagateExpire(db,keyobj,server.lazyfree_lazy_eviction);

            &#x2F;&#x2F; 获取当前的内存大小
            delta &#x3D; (long long) zmalloc_used_memory();
            &#x2F;&#x2F; 同步删除或异步删除 key
            if (server.lazyfree_lazy_eviction) &#123;
                dbAsyncDelete(db,keyobj);
            else
                dbSyncDelete(db,keyobj);
            &#125;

            &#x2F;&#x2F; 计算本次释放的内存
            delta -&#x3D; (long long) zmalloc_used_memory();
            mem_freed +&#x3D; delta;
            &#x2F;&#x2F; 释放创建的 key redisObject 对象
            decrRefCount(keyobj);
            keys_freed++;

            &#x2F;&#x2F; 如果有从节点, 推送缓冲区的数据
            if (slaves) flushSlavesOutputBuffers();

            &#x2F;&#x2F; 支持异步清除 同时 清除了 16 个 key
            if (server.lazyfree_lazy_eviction &amp;&amp; !(keys_freed % 16)) &#123;
                &#x2F;&#x2F; 再次判断内存情况, 如果内存足够了
                if (getMaxmemoryState(NULL,NULL,NULL,NULL) &#x3D;&#x3D; C_OK) &#123;
                    &#x2F;&#x2F; 更新已经释放的缓存大小 &#x3D; 需要释放的缓存大小
                    mem_freed &#x3D; mem_tofree;
                &#125;
            &#125;

        &#125;

        &#x2F;&#x2F; 本次释放没有处理成功任何一个 key
        if (!keys_freed) &#123;
            goto cant_free; 
        &#125;
    &#125;

    return C_OK;


cant_free:
    &#x2F;&#x2F; 没有内存可以分配了, 做唯一可以做的一件事: 检查是否有 lazyfree 线程在执行释放内存任务, 有进行等待
    &#x2F;&#x2F; 知道没有任务或者已有的内存达到了需要释放的内存
    while(bioPendingJobsOfType(BIO_LAZY_FREE)) &#123;
        &#x2F;&#x2F; 当前的内存达到了现在需要的释放的内存, 结束检查
        if (((mem_reported - zmalloc_used_memory()) + mem_freed) &gt;&#x3D; mem_tofree)
            break;
        usleep(1000);
    &#125;
    return C_ERR;  </code></pre>


<p>淘汰池的填充</p>
<pre class="language-C" data-language="C"><code class="language-C">void evictionPoolPopulate(int dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool) &#123;

    int j, k, count;
    &#x2F;&#x2F; 采样结果数组, 最大容量为 mamemory_samples 的大小
    dictEntry *samples[server.maxmemory_samples];

    &#x2F;&#x2F; 从 sampledict 字典中采样 server.maxmemory_samples 个 key 存放到 samples, 同时返回总共采样的多少个
    count &#x3D; dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);

    for (j &#x3D; 0; j &lt; count; j++) &#123;

        unsigned long long idle;
        sds key;
        robj *o;
        dictEntry *de;

        de &#x3D; samples[j];
        key &#x3D; dictGetKey(de);       

        if (server.maxmemory_policy !&#x3D; MAXMEMORY_VOLATILE_TTL) &#123;
            if (sampledict !&#x3D; keydict) de &#x3D; dictFind(keydict, key);
            o &#x3D; dictGetVal(de);
        &#125;

        if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU) &#123;
            &#x2F;&#x2F; LRU 算法
            idle &#x3D; estimateObjectIdleTime(o);
        &#125; else if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;
            &#x2F;&#x2F; LRU 算法
            idle &#x3D; 255 - LFUDecrAndReturn(o);
        &#125; else if (server.maxmemory_policy &#x3D;&#x3D; MAXMEMORY_VOLATILE_TTL) &#123;
            &#x2F;&#x2F; TTL 算法
            idle &#x3D; ULLONG_MAX - (long)dictGetVal(de);
        &#125; else &#123;
            serverPanic(&quot;Unknown eviction policy in evictionPoolPopulate()&quot;);
        &#125;

        k &#x3D; 0;
        &#x2F;&#x2F; 从 evictionPoolEntry 淘汰池中找到第一个闲置时间比当前淘汰 key 大的
        while (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key &amp;&amp; pool[k].idle &lt; idle) 
            k++;
        
        if (k &#x3D;&#x3D; 0 &amp;&amp; pool[EVPOOL_SIZE-1].key !&#x3D; NULL) &#123;
            &#x2F;&#x2F; 如果找到的 key 比淘汰池中闲置时间最小的 key 还小, 同时淘汰池没有空间了, 则跳过这个 key
            continue;
        &#125; else if (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key &#x3D;&#x3D; NULL) &#123;
            &#x2F;&#x2F; 插入的位置为空, 直接进入到下面的赋值节点
        &#125; else &#123;
            &#x2F;&#x2F; 核心就是将找到的位置 k 空出来

            &#x2F;&#x2F; 最后的位置为空
            if (pool[EVPOOL_SIZE-1].key &#x3D;&#x3D; NULL) &#123;
                &#x2F;&#x2F; 将原本 k 位置和后面的数据向后移动 1 位 
                sds cached &#x3D; pool[EVPOOL_SIZE-1].cached;
                memmove(pool+k+1, pool+k, sizeof(pool[0])*(EVPOOL_SIZE-k-1));
                pool[k].cached &#x3D; cached;
            &#125; else &#123;
                &#x2F;&#x2F; 插入的位置不为空 
                &#x2F;&#x2F; 将原本 k 位置前面的数据往前移动 1 位, 原本的第一位丢弃
                k--;
                sds cached &#x3D; pool[0].cached;
                if (pool[0].key !&#x3D; pool[0].cached) sdsfree(pool[0].key);
                memmove(pool,pool+1,sizeof(pool[0])*k);
                pool[k].cached &#x3D; cached;
            &#125;
        &#125;

        &#x2F;&#x2F; 把找到的 key 放到 k 的位置
        int klen &#x3D; sdslen(key);
        &#x2F;&#x2F; EVPOOL_CACHED_SDS_SIZE &#x3D; 255
        if (klen &gt; EVPOOL_CACHED_SDS_SIZE) &#123;
            &#x2F;&#x2F; 创建一个新的 key 赋值给 pool[k].key
            pool[k].key &#x3D; sdsdup(key);
        &#125; else &#123;
            &#x2F;&#x2F; 从 key 中拷贝 klen + 1 的长度到 pool[k].cached
            memcpy(pool[k].cached,key,klen+1);

            sdssetlen(pool[k].cached,klen);
            pool[k].key &#x3D; pool[k].cached;
        &#125;
        pool[k].idle &#x3D; idle;
        pool[k].dbid &#x3D; dbid;
    &#125;
&#125;

unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count) &#123;
    unsigned long j; 
    unsigned long tables;
    unsigned long stored &#x3D; 0, maxsizemask;
    unsigned long maxsteps;

    &#x2F;&#x2F; 字典中的数据量小于需要的个数, 取的个数变为字典的数据大小
    if (dictSize(d) &lt; count) count &#x3D; dictSize(d);

    &#x2F;&#x2F; 最大次数 &#x3D; 次数 * 10
    maxsteps &#x3D; count*10;

    &#x2F;* 如果字典在 rehash 中, 尝试 count 一样次数的 rehash *&#x2F;
    for (j &#x3D; 0; j &lt; count; j++) &#123;
        if (dictIsRehashing(d))
            _dictRehashStep(d);
        else
            break;
    &#125;

    &#x2F;&#x2F; 获取总的 HashTable 个数, 如果在 rehash 中就是 2 个, 否则 1 个
    tables &#x3D; dictIsRehashing(d) ? 2 : 1;
    &#x2F;&#x2F; 获取数组大小的掩码, 用于计算索引值
    maxsizemask &#x3D; d-&gt;ht[0].sizemask;
    if (tables &gt; 1 &amp;&amp; maxsizemask &lt; d-&gt;ht[1].sizemask)
        maxsizemask &#x3D; d-&gt;ht[1].sizemask;

    &#x2F;&#x2F; 随机获取一个位置
    unsigned long i &#x3D; random() &amp; maxsizemask;
    unsigned long emptylen &#x3D; 0;

    &#x2F;&#x2F; 获取到的个数没达到需要的个数 或者尝试的次数还没达到 0 
    while(stored &lt; count &amp;&amp; maxsteps--) &#123;
        for (j &#x3D; 0; j &lt; tables; j++) &#123;
    
            &#x2F;&#x2F; 如果字典在 rehash 中, 同时当前处理的是第一个字典, 处理的位置小于 rehash 下次处理的位置, 
            &#x2F;&#x2F; 则跳过这个位置, 直接到 rehash 下次处理的位置
            &#x2F;&#x2F; 因为第一个字典 rehash 下次处理的位置前的数据都迁移到第二个字典中了
            if (tables &#x3D;&#x3D; 2 &amp;&amp; j &#x3D;&#x3D; 0 &amp;&amp; i &lt; (unsigned long) d-&gt;rehashidx) &#123;
                &#x2F;&#x2F; 防止获取数据的位置 i 超过第二个字典的大小
                if (i &gt;&#x3D; d-&gt;ht[1].size)
                    i &#x3D; d-&gt;rehashidx;
                else
                    continue;
            &#125;

            &#x2F;&#x2F; 超过了数组的长度
            if (i &gt;&#x3D; d-&gt;ht[j].size) continue;
            &#x2F;&#x2F; 获取对应位置的数据
            dictEntry *he &#x3D; d-&gt;ht[j].table[i];

            &#x2F;&#x2F; 对应的位置为 null
            if (he &#x3D;&#x3D; NULL) &#123;
                emptylen++;
                &#x2F;&#x2F; 获取 null 数据的次数大于 5 次 同时 大于需要的过期 key 的个数
                if (emptylen &gt;&#x3D; 5 &amp;&amp; emptylen &gt; count) &#123;
                    &#x2F;&#x2F; 重新计算获取的位置 i, 重新获取
                    i &#x3D; random() &amp; maxsizemask;
                    emptylen &#x3D; 0;
                &#125;
            &#125; else &#123;
                emptylen &#x3D; 0;
                while (he) &#123;
                    &#x2F;&#x2F; he 本身是链表, 计算从链表中获取到的个数, 够了结束, 不够就 i+1, 从字典的下一个位置继续获取
                    *des &#x3D; he;
                    des++;
                    he &#x3D; he-&gt;next;
                    stored++;
                    if (stored &#x3D;&#x3D; count) return stored;
                &#125;
            &#125;
        &#125;
        i &#x3D; (i+1) &amp; maxsizemask;
    &#125;
    return stored;
&#125;</code></pre>

<p>dictGetSomeKeys 函数简单理解就是, 通过 random() 得到一个随机数, 这个随机数 &amp; 数组大小的掩码, 得到一个位置, 从这个位置向后获取 count 个过期 key。<br>这个处理的过程中</p>
<blockquote>
<ol>
<li>有可能字典在 rehash 中, 数据分布在 2 个字典中, 所以有时第一个字典获取不到需要到第二个字典获取</li>
<li>需要的过期 key 的个数小于等于 5 个, 通过计算得到的位置获取到的数据连续都为 null, 则重新通过 random() 计算一个新的位置</li>
<li>为了防止长时间的需要, 在外面还计算了最大的循环次数</li>
</ol>
</blockquote>
<p>从上面的代码实现可以看出, Redis 内部对 LRU + LFU 的实现都是不是很正式的实现, 带有一定的误差和随机性。</p>
<p>其本身考虑主用是从性能上做的折中。比如传统的 LRU 算法, 需要将所有的数据维护一个双向链表</p>
<blockquote>
<ol>
<li>访问节点, 如果节点存在, 则将该节点移动到链表的头节点, 并返回节点值, 不存在就返回 null</li>
<li>新增节点, 节点不存在, 就在链表的头部新增节点, 如果节点存在, 则更新节点数据, 然后将节点移动到链表的头节点</li>
</ol>
</blockquote>
<p>需要消耗的内存在维护链表的 + 节点的挑战, 对于一个大规模的数据, 这个消耗是非常大的。<br>所以 Redis 采用了其思想, 通过另外的方式达到类似的效果。</p>
<h2 id="4-附录-Redis-几个对象的介绍"><a href="#4-附录-Redis-几个对象的介绍" class="headerlink" title="4 附录: Redis 几个对象的介绍"></a>4 附录: Redis 几个对象的介绍</h2><h3 id="4-1-Redis-中的字典"><a href="#4-1-Redis-中的字典" class="headerlink" title="4.1 Redis 中的字典"></a>4.1 Redis 中的字典</h3><h4 id="4-2-1-HashTable"><a href="#4-2-1-HashTable" class="headerlink" title="4.2.1 HashTable"></a>4.2.1 HashTable</h4><p>存储在 Redis 中的基本都是键值对, 而这种键值对存储, 同时可以通过 key 快速查询到对应的 value, 最合适的实现就是 HashTable 了。<br>而实现 HashTable 的底层结构，基本就是一个数组或者链表, 同时为了解决 hash 冲突, 数组或链表的每个节点定义为一个链表。</p>
<p>Redis 中对 HashTable 的实现也是如此, 大体如下</p>
<p><img src="https://pic.imgdb.cn/item/66714d06d9c307b7e93742a9.png" alt="Alt &#39;dictht 设计&#39;"></p>
<p>Redis 中实现的 HastTable 叫做 dictht (Dictionary Hash Table)</p>
<p>对应的定义如下:</p>
<pre class="language-C" data-language="C"><code class="language-C">typedef struct dictht &#123;
    &#x2F;&#x2F; 存放节点的数组
    dictEntry **table;
    &#x2F;&#x2F; HashTable 的大小, 2 的幂次方
    unsigned long size;
    &#x2F;&#x2F; HashTable 的大小掩码, 用于计算索引值
    unsigned long sizemask;
    &#x2F;&#x2F; HashTable 中已经使用的节点个数
    unsigned long used;
&#125; dictht;</code></pre>

<p>真实存储数据的链表节点的定义如下:  </p>
<pre class="language-C" data-language="C"><code class="language-C">typedef struct dictEntry &#123;
    &#x2F;&#x2F; 存储的键值对的 key
    void *key;
    &#x2F;&#x2F; 存储的键值对的 value
    union &#123;
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    &#125; v;
    &#x2F;&#x2F; 指向下一个节点
    struct dictEntry *next;
&#125; dictEntry;</code></pre>

<p>key + v(value) + next 一个简单的链表定义。<br>有点特殊的就是对应着 value 属性的 v 的定义是一个联合体, 会在不同场景下使用不同的字段,<br>比如一个键值对的过期时间就存放在 <strong>s64</strong> 中, 这个 value 存放的值就放在 <strong>val</strong> 中。</p>
<p>一个 dictEntry 的字段存放内容大体如下:</p>
<p><img src="https://pic.imgdb.cn/item/66714a82d9c307b7e93175bd.png" alt="Alt &#39;dictEntry 内容&#39;"></p>
<h4 id="4-2-2-字典"><a href="#4-2-2-字典" class="headerlink" title="4.2.2 字典"></a>4.2.2 字典</h4><p>在使用 HashTable 时, 都需要提前声明好容量, 而随着程序的运行, 存放到 HashTable 的数据会越来越多, 最终达到上限, 这时就需要进行扩容了。<br>在 Java 的 HashMap 的扩容过程</p>
<blockquote>
<ol>
<li>创建一个更大容量的数组</li>
<li>将 HashMap 中旧数组一次性迁移到新的数组中</li>
<li>清除掉旧数组</li>
</ol>
</blockquote>
<p>这个扩容没多大问题, 但是放到 Redis 中合适吗?</p>
<blockquote>
<ol>
<li>Redis 是一个存内存的数据库, 所有的数据都存放在内存中, 基本是 GB 级别的数据量, 每次扩容迁移的数据量很多</li>
<li>Redis 是一个单线程的数据库, 一次只能处理一个事情, 如果全力在做扩容, 那么其他的请求将无法处理</li>
</ol>
</blockquote>
<p>所以 Redis 采用了一种 <strong>渐进式 rehash</strong> 的方法解决扩容缩容的问题, 过程如下</p>
<blockquote>
<ol>
<li>维护 2 个 dictht, 一个是真实存储数据的 HashTable A, 一个是扩容后存储数据的 TableTable B + 一个 rehash 位置的索引, 初始值为 0</li>
<li>在 rehash &gt;&#x3D;0 期间, 每次对 HashTable 进行操作, 除了正常的操作外, 还会将 A rehash 位置的数据都迁移到 B, 然后 rehash + 1</li>
<li>随着对 HashTable 的不断操作, 最终 A 中的数据都会迁移到 B, 这时将 rehash 设置为 -1</li>
</ol>
</blockquote>
<p>基于上面的渐进式 rehash 分析, 实际是需要 2 个 dictht, 所以 Redis 在此至上多封装了一层</p>
<pre class="language-C" data-language="C"><code class="language-C">typedef struct dict &#123;
    dictType *type;
    void *privdata;
    dictht ht[2];   &#x2F;&#x2F; 2 个 HashTable
    long rehashidx; &#x2F;&#x2F; rehash 的索引
    unsigned long iterators;
&#125; dict;</code></pre>

<p>这个就是 Redis 中的字典, 用于存储键值对的结构。</p>
<p>在将这个结构放到一个 redisDb 就是我们常见的 Redis 数据库了</p>
<pre class="language-C" data-language="C"><code class="language-C">typedef struct redisDb &#123;
    dict *dict; 
    dict *expires;
    ....
&#125; redisDb;</code></pre>

<p>redisDb 就是我们常说的 Redis 16 个数据库的定义了。 每个数据库中都有 2 个字典</p>
<blockquote>
<ol>
<li>dict 正常的字典, 存储没有设置过期时间的键值对</li>
<li>expires 过期字典, 存储设置了过期时间的键值对</li>
</ol>
</blockquote>
<h3 id="4-2-Redis-的内存待淘汰池"><a href="#4-2-Redis-的内存待淘汰池" class="headerlink" title="4.2 Redis 的内存待淘汰池"></a>4.2 Redis 的内存待淘汰池</h3><pre class="language-C" data-language="C"><code class="language-C">struct evictionPoolEntry &#123;
    unsigned long long idle;    &#x2F;&#x2F; 对象空闲时间 (使用的算法是 LFU 则是逆频率)
    sds key;                    &#x2F;&#x2F; 待淘汰的键值对的 key
    sds cached;                 &#x2F;&#x2F; 缓存的 key 名称 SDS 对象
    int dbid;                   &#x2F;&#x2F; 待淘汰键值对的 key 所在的数据库 ID
&#125;;</code></pre>

<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ltaodream/p/16299107.html">Redis源码解析-LRU</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/reim/p/17422410.html#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">Redis内存兜底策略——内存淘汰及回收机制</a></p>

                
            </div>
            <hr/>
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/article/2024/277668067/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="记一次 SQL 优化">
                        
                        <span class="card-title">记一次 SQL 优化</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-06-26
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Lcn29
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/MySQL/">
                        <span class="chip bg-color">MySQL</span>
                    </a>
                    
                    <a href="/tags/%E7%94%9F%E4%BA%A7%E8%AE%B0%E5%BD%95/">
                        <span class="chip bg-color">生产记录</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/article/2023/608272343/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="一次 CPU 占用率过高的问题排查 (不断创建线程和线程上下文频繁切换)">
                        
                        <span class="card-title">一次 CPU 占用率过高的问题排查 (不断创建线程和线程上下文频繁切换)</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-12-07
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Lcn29
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%94%9F%E4%BA%A7%E8%AE%B0%E5%BD%95/">
                        <span class="chip bg-color">生产记录</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2024</span>
            
            <br/>

            Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            &nbsp; | &nbsp;&nbsp;Theme <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>

            
            <br>
            
            
                <span id="busuanzi_container_site_pv">
                    总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
            
            
                <span id="busuanzi_container_site_uv">
                    &nbsp; | &nbsp;&nbsp;总访问人数:&nbsp; <span id="busuanzi_value_site_uv" class="white-color"></span>
                </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
