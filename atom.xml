<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lcn29</title>
  
  <subtitle>Technical System</subtitle>
  <link href="https://github.com/Lcn29/atom.xml" rel="self"/>
  
  <link href="https://github.com/Lcn29/"/>
  <updated>2024-10-10T11:58:04.056Z</updated>
  <id>https://github.com/Lcn29/</id>
  
  <author>
    <name>Lcn29</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis Cluster 简单介绍</title>
    <link href="https://github.com/Lcn29/article/2024/3024014473/"/>
    <id>https://github.com/Lcn29/article/2024/3024014473/</id>
    <published>2024-09-25T02:40:14.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<p>Redis Cluster 是 Redis 3.0 提供的一种分布式解决方案, 允许数据在多个节点之间分散存储, 从而实现高可用性和可扩展性。</p><p>特点:</p><ol><li>分片: Redis Cluster 将数据分散到多个节点, 通过哈希槽 (hash slots) 机制将键映射到不同的节点上。总共有 16384 个哈希槽, 每个节点负责一部分槽。</li><li>高可用性: Redis Cluster 支持主从复制, 每个主节点可以有多个从节点, 从节点可以在主节点故障时自动提升为主节点。</li><li>自动故障转移: 当主节点宕机时, Cluster 会自动检测并选择从节点提升为新的主节点, 保持服务的可用性。</li><li>无中心化: Redis Cluster 是去中心化的, 没有单点故障。所有节点都可以处理请求, 提升了系统的健壮性。</li></ol><p>解决的问题:</p><ol><li>数据存储限制: 单个 Redis 实例的内存限制使其在处理大规模数据时受到约束, Redis Cluster 通过分片技术克服了这一限制, 支持更大规模的数据存储。</li><li>高可用性需求: 在传统的 Redis 配置中, 主节点故障会导致服务不可用。Redis Cluster 通过主从复制和自动故障转移确保服务的连续性, 满足高可用性的需求。</li><li>负载均衡: 随着数据量和访问量的增加, Redis Cluster 可以通过增加节点和分配哈希槽实现负载均衡, 避免某一节点过载。</li></ol><h2 id="1-Redis-Cluster-的搭建"><a href="#1-Redis-Cluster-的搭建" class="headerlink" title="1 Redis Cluster 的搭建"></a>1 Redis Cluster 的搭建</h2><p>Redis Cluster 可以看成是由多个 Redis 实例组成的数据集合。<br>客户端不需要关注数据的子集到底存储在哪个节点, 只需要关注这个集合整体。</p><p>那么如何搭建一个这样的集群呢?<br>注: 这里用一台集群搭建集群, Ip 地址为 192.169.10.10, 7000&#x2F;7001&#x2F;7002 为主节点的端口, 8000&#x2F;8001&#x2F;8002 为对应的从节点的端口。</p><h3 id="1-1-修改配置"><a href="#1-1-修改配置" class="headerlink" title="1.1 修改配置"></a>1.1 修改配置</h3><p>修改 redis.conf 配置文件中的 3 个参数</p><blockquote><ol><li>cluster-enabled yes</li><li>cluster-config-file “node-7000.conf”</li><li>cluster-node-timeout 5000</li></ol></blockquote><p>其他的参数和单个 Redis 实例的一样。</p><p><code>cluster-enabled yes</code>: Redis 实例可以分为单机模式 (standalone) 和集群模式 (cluster)。 yes 开启为集群模式。 </p><p><code>cluster-config-file</code>: 该参数指定了集群配置文件的位置。每个节点在运行过程中, 会维护一份集群配置文件; 每当集群信息发生变化时 (如增减节点), 集群内所有节点会将最新信息更新到自己维护的配置文件。<br>当节点重启后, 会重新读取该配置文件, 获取集群信息, 可以方便的重新加入到集群中。<br>也就是说当 Redis 节点以集群模式启动时, 会首先寻找是否有集群配置文件, 如果有则使用文件中的配置启动, 如果没有, 则初始化配置并将配置保存到文件中。 集群配置文件由 Redis 节点维护, 不需要人工修改。</p><p><code>cluster-node-timeout</code>: 节点之间心跳超时时间</p><p><code>cluster-require-full-coverage</code>: 默认值为 yes, 将其修改为 no, 表示 Redis 节点的槽没有完全分配时，集群仍可以上线。</p><h3 id="1-2-启动节点"><a href="#1-2-启动节点" class="headerlink" title="1.2 启动节点"></a>1.2 启动节点</h3><p>通过 <code>redis-server redis.conf</code> 配置文件启动 Redis。<br>可以通过 <strong>cluster nodes</strong> 查看当前的节点集群信息。</p><h3 id="1-3-节点握手"><a href="#1-3-节点握手" class="headerlink" title="1.3 节点握手"></a>1.3 节点握手</h3><p><strong>执行 redis-cli –cluster create 命令</strong></p><p>节点启动以后是相互独立的，并不知道其他节点存在, 需要进行节点握手。<br>将独立的节点组成一个网络。<strong>注下面的操作, 不能使用 localhost 和 127.0.0.1, 需要使用局域网 Ip 或 公网 Ip</strong>。</p><pre class="language-bash" data-language="bash"><code class="language-bash">redis-cli <span class="token parameter variable">--cluster</span> create <span class="token number">192.169</span>.10.10:7000 <span class="token number">192.169</span>.10.10:7001 <span class="token number">192.169</span>.10.10:7002 <span class="token number">192.169</span>.10.10:8000 <span class="token number">192.169</span>.10.10:8001 <span class="token number">192.169</span>.10.10:8002 --cluster-replicas <span class="token number">1</span></code></pre><p>–cluster-replicas 1 表示每个主节点有 1 个从节点, 后面的多个 {ip:port} 表示节点地址。(默认: 所有节点平均分成 2 组, 前面一组为主节点, 后面一组为从节点)</p><p>执行创建命令后, Redis 会给出一个预计的方案, 对 6 个节点分配 3 主 3 从, 如果认为没有问题，输入 yes 确认</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> Performing <span class="token builtin class-name">hash</span> slots allocation on <span class="token number">6</span> nodes<span class="token punctuation">..</span>.Master<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> -<span class="token operator">></span> Slots <span class="token number">0</span> - <span class="token number">5460</span>Master<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> -<span class="token operator">></span> Slots <span class="token number">5461</span> - <span class="token number">10922</span>Master<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> -<span class="token operator">></span> Slots <span class="token number">10923</span> - <span class="token number">16383</span>Adding replica <span class="token number">192.169</span>.10.10:8000 to <span class="token number">192.169</span>.10.10:7000Adding replica <span class="token number">192.169</span>.10.10:8001 to <span class="token number">192.169</span>.10.10:7001Adding replica <span class="token number">192.169</span>.10.10:8002 to <span class="token number">192.169</span>.10.10:7002<span class="token operator">>></span><span class="token operator">></span> Trying to optimize slaves allocation <span class="token keyword">for</span> anti-affinity<span class="token punctuation">[</span>WARNING<span class="token punctuation">]</span> Some slaves are <span class="token keyword">in</span> the same <span class="token function">host</span> as their masterM: dfdc9c0589219f727e4fd0ad8dafaf7e0cfb4f1c <span class="token number">192.169</span>.10.10:7000   slots:<span class="token punctuation">[</span><span class="token number">0</span>-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> masterM: 8c878b45905bba3d7366c89ec51bd0cd7ce959f8 <span class="token number">192.169</span>.10.10:7001   slots:<span class="token punctuation">[</span><span class="token number">5461</span>-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5462</span> slots<span class="token punctuation">)</span> masterM: aeeb7d7076d9b25a7805ac6f508497b43887e599 <span class="token number">192.169</span>.10.10:7002   slots:<span class="token punctuation">[</span><span class="token number">10923</span>-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> masterS: ebc479e609ff8f6ca9283947530919c559a08f80 <span class="token number">192.169</span>.10.10:8000   replicates aeeb7d7076d9b25a7805ac6f508497b43887e599S: 49385ed6e58469ef900ec48e5912e5f7b7505f6e <span class="token number">192.169</span>.10.10:8001   replicates dfdc9c0589219f727e4fd0ad8dafaf7e0cfb4f1cS: 8d6227aefc4830065624ff6c1dd795d2d5ad094a <span class="token number">192.169</span>.10.10:8002   replicates 8c878b45905bba3d7366c89ec51bd0cd7ce959f8Can I <span class="token builtin class-name">set</span> the above configuration? <span class="token punctuation">(</span>type <span class="token string">'yes'</span> to accept<span class="token punctuation">)</span>: </code></pre><p>输入 yes 后</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> Nodes configuration updated<span class="token operator">>></span><span class="token operator">></span> Assign a different config epoch to each <span class="token function">node</span><span class="token operator">>></span><span class="token operator">></span> Sending CLUSTER MEET messages to <span class="token function">join</span> the clusterWaiting <span class="token keyword">for</span> the cluster to <span class="token function">join</span><span class="token punctuation">..</span><span class="token operator">>></span><span class="token operator">></span> Performing Cluster Check <span class="token punctuation">(</span>using <span class="token function">node</span> <span class="token number">192.169</span>.10.10:7000<span class="token punctuation">)</span>M: dfdc9c0589219f727e4fd0ad8dafaf7e0cfb4f1c <span class="token number">192.169</span>.10.10:7000   slots:<span class="token punctuation">[</span><span class="token number">0</span>-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> master   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>M: 8c878b45905bba3d7366c89ec51bd0cd7ce959f8 <span class="token number">192.169</span>.10.10:7001   slots:<span class="token punctuation">[</span><span class="token number">5461</span>-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5462</span> slots<span class="token punctuation">)</span> master   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>S: ebc479e609ff8f6ca9283947530919c559a08f80 <span class="token number">192.169</span>.10.10:8002   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave   replicates aeeb7d7076d9b25a7805ac6f508497b43887e599S: 49385ed6e58469ef900ec48e5912e5f7b7505f6e <span class="token number">192.169</span>.10.10:8000   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave   replicates dfdc9c0589219f727e4fd0ad8dafaf7e0cfb4f1cM: aeeb7d7076d9b25a7805ac6f508497b43887e599 <span class="token number">192.169</span>.10.10:7002   slots:<span class="token punctuation">[</span><span class="token number">10923</span>-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> master   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>S: 8d6227aefc4830065624ff6c1dd795d2d5ad094a <span class="token number">192.169</span>.10.10:8001   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave   replicates 8c878b45905bba3d7366c89ec51bd0cd7ce959f8<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All nodes agree about slots configuration.<span class="token operator">>></span><span class="token operator">></span> Check <span class="token keyword">for</span> <span class="token function">open</span> slots<span class="token punctuation">..</span>.<span class="token operator">>></span><span class="token operator">></span> Check slots coverage<span class="token punctuation">..</span>.<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All <span class="token number">16384</span> slots covered.</code></pre><p>上面的操作是 Redis 提供的脚步式搭建, 隐藏了一些细节。如果想要体验完整的搭建过程, 可以参考 <a href="https://www.cnblogs.com/Yunya-Cnblogs/p/14608937.html">Redis 超详细的手动搭建Cluster集群步骤</a>, 完全的通过命令的方式搭建集群。</p><h3 id="1-4-Redis-Cluster-相关的命令"><a href="#1-4-Redis-Cluster-相关的命令" class="headerlink" title="1.4 Redis Cluster 相关的命令"></a>1.4 Redis Cluster 相关的命令</h3><p>集群命令</p><table><thead><tr><th align="center">命令</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">cluster info</td><td align="center">打印集群的信息</td></tr><tr><td align="center">cluster nodes</td><td align="center">列出集群当前已知的所有节点 (node), 以及这些节点的相关信息</td></tr><tr><td align="center">cluster meet <ip> <port></td><td align="center">将 ip 和 port 所指定的节点添加到集群当中, 让它成为集群的一份子, 这时候没有主从关系</td></tr><tr><td align="center">cluster forget <node_id></td><td align="center">从集群中移除 node_id 指定的节点 (保证空槽道)</td></tr><tr><td align="center">cluster replicate <node_id></td><td align="center">将当前节点设置为 node_id 指定的节点的从节点</td></tr><tr><td align="center">cluster saveconfig</td><td align="center">将节点的配置文件保存到硬盘里面</td></tr></tbody></table><p>槽slot命令</p><table><thead><tr><th align="center">命令</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">cluster addslots [slot …]</td><td align="center">将一个或多个槽 (slot) 指派 (assign) 给当前节点</td></tr><tr><td align="center">cluster delslots [slot …]</td><td align="center">移除一个或多个槽对当前节点的指派</td></tr><tr><td align="center">cluster flushslots</td><td align="center">移除指派给当前节点的所有槽, 让当前节点变成一个没有指派任何槽的节点</td></tr><tr><td align="center">cluster setslot node <node_id></td><td align="center">将槽 slot 指派给 node_id 指定的节点, 如果槽已经指派给另一个节点, 那么先让另一个节点删除该槽, 然后再进行指派</td></tr><tr><td align="center">cluster setslot migrating <node_id></td><td align="center">将本节点的槽 slot 迁移到 node_id 指定的节点中</td></tr><tr><td align="center">cluster setslot importing <node_id></td><td align="center">从 node_id 指定的节点中导入槽 slot 到本节点</td></tr><tr><td align="center">cluster setslot stable</td><td align="center">取消对槽 slot 的导入 (imort) 或者迁移 (migrate)</td></tr></tbody></table><p>键命令</p><table><thead><tr><th align="center">命令</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">cluster keyslot <key></td><td align="center">计算键 key 应该被放置在哪个槽上</td></tr><tr><td align="center">cluster countkeysinslot <slot></td><td align="center">返回槽 slot 目前包含的键值对数量</td></tr><tr><td align="center">cluster getkeysinslot <slot> <count></td><td align="center">返回 count 个 slot 槽中的键</td></tr></tbody></table><h2 id="2-故障转移"><a href="#2-故障转移" class="headerlink" title="2 故障转移"></a>2 故障转移</h2><p>集群的实现与哨兵思路类似: 通过定时任务发送 PING 消息检测其他节点状态。节点下线分为主观下线和客观下线, 客观下线后选取从节点进行故障转移。  </p><p>与哨兵一样, 集群只实现了主节点的故障转移, 从节点故障时只会被下线, 不会进行故障转移。因此, 使用集群时, 应谨慎使用读写分离技术, 因为从节点故障会导致读服务不可用, 可用性变差。</p><p>大体是:</p><blockquote><ol><li>slave 发现自己的 maste 变为 Fail 状态, 偏尝试进行 Failover, 以期成为新的 master</li><li>slave 将自己记录的集群 currentEpoch + 1, 然后广播 FAILOVER_AUTH_REQUEST 信息</li><li>其他节点收到改消息后, 只有 master 节点会进行响应, 判断请求这的合法性, 并发送 FAILOVER_AUTH_ACK, 对每一个 epoch 只发送一次 ack</li><li>尝试 Failover 的 slave 收集 FAILOVER_AUTH_ACK</li><li>超过半数后变成新的 master</li><li>广播 Pong 通知其他集群节点</li></ol></blockquote><p>节点数量: 在故障转移阶段, 需要由主节点投票选出哪个从节点成为新的主节点, 从节点选举胜出需要的票数为 N&#x2F;2+1, 其中 N 为主节点数量 (包括故障主节点), 但故障主节点实际上不能投票。<br>因此为了能够在故障发生时顺利选出从节点, 集群中至少需要3个主节点 (且部署在不同的物理机上)。</p><p>故障转移时间: 从主节点故障发生到完成转移, 所需要的时间主要消耗在主观下线识别、主观下线传播、选举延迟等几个环节。具体时间与参数 cluster-node-timeout 有关, 一般来说：<br>故障转移时间(毫秒) ≤ 1.5 * cluster-node-timeout + 1000<br>cluster-node-timeout 的默认值为 15000ms (15s), 因此故障转移时间会在 20s 量级</p><h2 id="3-Hash-Tag"><a href="#3-Hash-Tag" class="headerlink" title="3 Hash Tag"></a>3 Hash Tag</h2><p>有些 multi key 操作是不能跨阶段的, 如果要让某些数据统一分配到同一个节点上, 可以借助 Hast Tag 功能。</p><p>Hash Tag 原理是: 当一个 key 包含 {} 的时候, 不对整个 key 做 hash, 而仅对 {} 包括的字符串做 hash。<br>Hash Tag 可以让不同的 key 拥有相同的 hash 值, 从而分配在同一个槽里, 这样针对不同 key 的批量操作 (mget&#x2F;mset等), 以及事务、Lua 脚本等都可以支持。  </p><p>Hash Tag 可能会带来数据分配不均的问题, 这时可以</p><blockquote><ol><li>调整不同节点中槽的数量，使数据分布尽量均匀</li><li>避免对热点数据使用 Hash Tag, 导致请求分布不均</li></ol></blockquote><h2 id="4-Redis-Cluster-的不足"><a href="#4-Redis-Cluster-的不足" class="headerlink" title="4 Redis Cluster 的不足"></a>4 Redis Cluster 的不足</h2><blockquote><ol><li>Client 实现复杂, 驱动要求实现 Smart Client, 缓存 slots mapping 信息并及时更新, 提高了开发难度, 客户端的不成熟影响业务的稳定性</li><li>节点会因为某些原因发生阻塞 (阻塞时间大于 cluster-node-timeout), 被判断下线, 这种 failover 是没必要的</li><li>数据通过异步复制, 不保证数据的强一致性</li><li>多个业务使用同一套集群时, 无法根据统计区分冷热数据, 资源隔离性较差, 容易出现相互影响的情况</li></ol></blockquote><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><a href="https://www.cnblogs.com/kismetv/p/9853040.html">深入学习Redis（5）：集群</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Redis Cluster 是 Redis 3.0 提供的一种分布式解决方案, 允许数据在多个节点之间分散存储, 从而实现高可用性和可扩展性。&lt;/p&gt;
&lt;p&gt;特点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分片: Redis Cluster 将数据分散到多个节点, 通过哈希槽</summary>
        
      
    
    
    
    
    <category term="Redis" scheme="https://github.com/Lcn29/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 集群槽设计原理</title>
    <link href="https://github.com/Lcn29/article/2024/2904586595/"/>
    <id>https://github.com/Lcn29/article/2024/2904586595/</id>
    <published>2024-09-09T13:58:40.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<p>在 Redis 中, 为了支持高可用, 官方提供了 3 种方式</p><blockquote><ol><li>主从复制</li><li>哨兵模式</li><li>集群模式 (Cluster)</li></ol></blockquote><p>但是主从复制和哨兵模式都有一个问题: 无法水平扩缩容, 而这个问题在集群模式中得到了解决。</p><p>假设有 3 个 Redis 节点, 所有的数据均匀的分散在 3 个节点中。<br>如果现在需要往里面加入一个新的节点或移出一个已有的节点, 那么就需要对已有的数据做迁移。<br>这个迁移可以说是涉及到所有数据, 这是一个大成本的操作。</p><p>Redis 为了避免全数据量的迁移, 在集群中引入了一个槽的概念。<br>在 Redis 的集群模式 (Cluster) 中, Redis 内置了 16384 个哈希槽, 将以前数据存储在 Redis 节点的转为数据层存储在哈希槽 (实际最终还是在具体的节点中)。<br>当我们向 Redis 中存入一个 key-value, 会先通过 crc16 算法对 key 计算出一个值, 再通过这个值对 16384 取余数, 得到其存储到哪个哈希槽中。</p><p>这里面有个问题: 为什么引入槽设计后, 可以避免全量的数据迁移, 同时还有其他什么好处吗, 下面简单的做一个分析。</p><h2 id="1-数据分区"><a href="#1-数据分区" class="headerlink" title="1 数据分区"></a>1 数据分区</h2><p>Redis 集群如果需要支持水平的扩缩容, 就需要先解决一个问题: 数据分区, 即如何将大型数据集按一定的规则或策略进行分割或划分, 以便更有效地管理、存储和处理数据。</p><p>常见的数据分区有</p><blockquote><p>顺序分区<br>范围分区<br>哈希分区<br>…</p></blockquote><p>其中哈希分区由于其天然的随机性, 使用广泛。集群的分区方案便是哈希分区的一种。</p><p>哈希分区的基本思路是: 对数据的特征值 (如 Key) 进行哈希, 然后根据哈希值决定数据落在哪个节点。<br>常见的哈希分区包括: 哈希取余分区, 一致性哈希分区, 带虚拟节点的一致性哈希分区等。</p><p>衡量数据分区方法好坏的标准有很多, 其中比较重要的两个因素是 <strong>数据分布是否均匀</strong>, <strong>增加或删减节点对数据分布的影响</strong>。<br>由于哈希的随机性, 哈希分区基本可以保证数据分布均匀。 因此在比较哈希分区方案时, 重点要看增减节点对数据分布的影响。</p><h2 id="2-哈希取余分区"><a href="#2-哈希取余分区" class="headerlink" title="2 哈希取余分区"></a>2 哈希取余分区</h2><p>哈希取余分区, 对特征值进行哈希, 得到一个需要的哈希值, 然后通过这个哈希值取余已有的分区数, 得到另外一个值, 这个值就是当前数据后续所在的分区位置。<br>比如当前 Redis 集群中有 3 个节点, 往这个集群中存入一个 key-value, 假设对 key 哈希后得到的值为 15, 15 % 3 &#x3D; 0, 那么 key-value 这对键值对就存在 0 号节点。</p><p>该方案最大的问题是: 当新增或删减节点时, 节点数量发生变化, 系统中几乎所有的数据都需要重新计算映射关系, 引发大规模数据迁移。<br>比如当前有 3 个节点, 其中 (假设 hash 函数为 hash(数字) &#x3D; 数字)<br>节点 A 已有数据 (0, 3, 6, 9)<br>节点 B 已有数据 (1, 4, 7, 10, 13)<br>节点 C 已有数据 (2, 5, 8, 11)</p><p>现在向里面加入多一个节点, 变成了 4 个节点, 原本 hash(3) &#x3D; 3 % 3 (个节点)&#x3D; 0, 变为 hash(3) &#x3D; 3 % 4 &#x3D; 3。<br>因为多加了一个节点, 计算后 3 由原本的 A 节点变为了 D 节点, 所以需要将 3 从 A 迁移到 D 节点, 最终整个集群数据变为<br>节点 A (0, 4, 8)<br>节点 B (1, 5, 9, 13)<br>节点 C (2, 6, 10)<br>节点 D (3, 7, 11)</p><p>可以看到集群中的数据变动还是挺大的, 如果这个发生在 Redis 那种几百 G 的数据中, 需要迁移多久。</p><h2 id="3-一致性哈希分区"><a href="#3-一致性哈希分区" class="headerlink" title="3 一致性哈希分区"></a>3 一致性哈希分区</h2><p>为了解决哈希取余分区, 节点的变更, 带来大数据量迁移的问题, 就有了一致性哈希分区。</p><p>一致性哈希分区原理</p><ol><li>设定有 0 - 2^32-1 个整数, 将这些整数按照一个圆环的形式排列起来, 然后 0 和 2^32-1 相连, 这样就形成一个哈希环<br><img src="https://pic.imgdb.cn/item/66e1a371d9c307b7e9480908.png" alt="Alt &#39;哈希环&#39;"></li><li>将已有的几个 Redis 节点通过计算得到一个在 0 - 2^32-1 中的某个值, 这个值就是当前节点在哈希环上的位置</li><li>当有数据需要存储时, 先计算数据的哈希值, 得到一个在 0 - 2^32-1 中的某个值, 也就是在哈希环上某个位置<blockquote><p>3.1 如果这个位置有节点, 则这个位置就是数据的存储的节点<br>3.2 如果这个位置没有节点, 则在哈希环上的这个位置开始, 顺时针的方向向前找到第一个节点, 将数据存储到这个节点中<br><img src="https://pic.imgdb.cn/item/66e1a374d9c307b7e94813c6.png" alt="Alt &#39;一致性哈希分区&#39;"></p></blockquote></li></ol><p>与<strong>哈希取余分区</strong>相比, 一致性哈希分区将增减节点的影响限制在下一个节点。</p><ol><li>当新增一个节点时(设前一个节点到新增节点的区间为 A, 设新增节点到后一个节点区间为 B), 那么只需要将区间 A 的数据从后一个节点迁移到新增节点中即可</li></ol><p>如图: 新增一个节点 node-4, 此时只需要将数据 data 从原本的 node-1 迁移到 node-4 中即可<br><img src="https://pic.imgdb.cn/item/66e1a377d9c307b7e9481909.png" alt="Alt &#39;一致性哈希分区-新增节点&#39;"></p><ol start="2"><li>当减少一个节点时, 只需要将这个节点的数据存储到其顺时针方向的下一个节点即可</li></ol><p>如图: 新增一个节点 node-1, 此时只需要将数据 data 从原本的 node-1 迁移到 node-2 中即可<br><img src="https://pic.imgdb.cn/item/66e1a37dd9c307b7e9482333.png" alt="Alt &#39;一致性哈希分区-删除节点&#39;"></p><p>如图中, 在一致哈希算法中，如果增加或者移除一个节点，仅影响该节点的下一个节点。<br>但是一致性哈希算法不能保证节点能够在哈希环上分布均匀，这样就会带来一个问题: 数据倾斜, 可能存在某些节点的数据比其他节点多&#x2F;少的情况。<br>如果某个节点的数据量过大, 会导致这个节点的负载过高, 从而影响整个集群的性能, 如果这个节点挂掉, 会导致整个集群的大量的数据无法访问等问题。</p><h2 id="4-带虚拟节点的一致性哈希分区"><a href="#4-带虚拟节点的一致性哈希分区" class="headerlink" title="4 带虚拟节点的一致性哈希分区"></a>4 带虚拟节点的一致性哈希分区</h2><p>一致性哈希分区的问题在于节点不能在哈希环上分布均匀, 但是如果有大量的节点, 节点的分布就会更加均匀, 极端点, 环上的每个位置都有一个节点, 这样就可以保证节点的分布均匀。</p><p>但是实际中, 节点的数量是有限的, 为了解决这个问题, 引入了虚拟节点的概念,  **Redis 集群使用的便是该方案, 其中的虚拟节点称为槽 (slot)**。  </p><p>具体做法是，不再将真实节点映射到哈希环上, 而是将虚拟节点映射到哈希环上, 并将虚拟节点映射到实际节点, 形成 2 层的映射关系。<br>即数据的映射关系由数据 hash -&gt; 实际节点, 变成了数据 hash -&gt; 槽 -&gt; 实际节点。</p><p>假设现在有 3 个节点, 有 9 个虚拟节点, 那么每个节点就包含 3 个虚拟节点</p><ol><li>节点 A 保存 0-2 槽</li><li>节点 B 保存 3-5 槽</li><li>节点 C 保存 6-8 槽</li></ol><p>那么原本的哈希环, 就变成了这样,<br><img src="https://pic.imgdb.cn/item/66e1a386d9c307b7e9482fb4.png" alt="Alt &#39;带虚拟节点的一致性哈希分区&#39;"></p><p>可以看出: 虚拟节点越多，哈希环上的节点就越多，数据分布就越均匀，从而避免了数据倾斜的问题, (现实中, 虚拟节点会很多, 比如 Redis 就设置了 16384 个槽)。</p><p>另外, 虚拟节点除了提高节点的平衡, 还可以提高系统的稳定性, 比如: 当有节点数量变化时, 可能有不同的节点分担系统的变化, 提高了稳定性。<br>比如有一个哈希环, 上面的虚拟节点如下: A-1, B-1, C-1, A-2, C-2, B-2, A-3, C-3, B-3。<br>现在因为 A 节点挂掉, 那么 A-1, A-2, A-3 的数据就需要迁移到下一个节点中, A-1 &#x3D;&#x3D;&gt; B-1,  A-2 &#x3D;&#x3D;&gt; C-2, A-3 &#x3D;&#x3D;&gt; C-3。<br>迁移的压力就分担到的 B, C 节点, 而不是由某个节点进行处理。</p><p>同时, 因为有虚拟节点的存在, 还可以动态地调整每个节点分担的虚拟节点的数量, 比如: 高性能的机器可以分配更多的虚拟节点, 从而提高性能。</p><p>可以看出<strong>带虚拟节点的一致性哈希分区</strong></p><blockquote><ol><li>保证了节点的数据分布均匀</li><li>提高了系统的稳定性</li><li>提高了系统的灵活性</li></ol></blockquote><p>因为这些优点, Redis 集群采用了带虚拟节点的一致性哈希分区的方案。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><a href="https://github.com/xiaolincoder/CS-Base/blob/main/os/8_network_system/hash.md">9.4 什么是一致性哈希？</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在 Redis 中, 为了支持高可用, 官方提供了 3 种方式&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;主从复制&lt;/li&gt;
&lt;li&gt;哨兵模式&lt;/li&gt;
&lt;li&gt;集群模式</summary>
        
      
    
    
    
    
    <category term="Redis" scheme="https://github.com/Lcn29/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 主从复制 - relication 源码分析</title>
    <link href="https://github.com/Lcn29/article/2024/3467330524/"/>
    <id>https://github.com/Lcn29/article/2024/3467330524/</id>
    <published>2024-08-26T14:18:00.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-replicationUnsetMaster-断开主从关系"><a href="#1-replicationUnsetMaster-断开主从关系" class="headerlink" title="1 replicationUnsetMaster  -  断开主从关系"></a>1 replicationUnsetMaster  -  断开主从关系</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 断开主从关系 */</span> <span class="token keyword">void</span> <span class="token function">replicationUnsetMaster</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 没有设置主节点的, 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 释放主节点的 host 配置</span>    <span class="token function">sdsfree</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost<span class="token punctuation">)</span><span class="token punctuation">;</span>f    server<span class="token punctuation">.</span>masterhost <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">// 把当前的 replid 复制到 replid2</span>    <span class="token comment">// 重新生成一个新的 40 位随机 id 并赋值到 replid</span>    <span class="token function">shiftReplicationId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 释放代表主节点的 client 对象</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span>         <span class="token function">freeClient</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将 server.cached_server 设置为空, 同时设置释放对应的内存</span>    <span class="token function">replicationDiscardCachedMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 取消主从复制的握手</span>    <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 关闭所有的从节点客户端</span>    <span class="token function">disconnectSlaves</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 当前节点的主从复制状态设置为 REPL_STATE_NONE</span>    server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_NONE<span class="token punctuation">;</span>    <span class="token comment">// 从节点选中的数据库为 - 1</span>    server<span class="token punctuation">.</span>slaveseldb <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_no_slaves_since <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span></code></pre><h3 id="1-1-shiftReplicationId-切换第一组-replid-和-offset-到第二组"><a href="#1-1-shiftReplicationId-切换第一组-replid-和-offset-到第二组" class="headerlink" title="1.1 shiftReplicationId - 切换第一组 replid 和 offset 到第二组"></a>1.1 shiftReplicationId - 切换第一组 replid 和 offset 到第二组</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">shiftReplicationId</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 将 replid 复制到 replid2</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid2<span class="token punctuation">,</span> server<span class="token punctuation">.</span>replid<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将原本的复制积压缓冲区的偏移量 master_repl_offset + 1 放到第二组的  second_replid_offset </span>    server<span class="token punctuation">.</span>second_replid_offset <span class="token operator">=</span> server<span class="token punctuation">.</span>master_repl_offset<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 重新生成一个 replid, 并赋值到 server.replid</span>    <span class="token function">changeReplicationId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="1-2-changeReplicationId-重新生成一个-replid"><a href="#1-2-changeReplicationId-重新生成一个-replid" class="headerlink" title="1.2 changeReplicationId - 重新生成一个 replid"></a>1.2 changeReplicationId - 重新生成一个 replid</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">changeReplicationId</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// CONFIG_RUN_ID_SIZE = 40, 重新随机生成一个 40 位的 id 并赋值到 replid</span>    <span class="token function">getRandomHexChars</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">,</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>replid<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="1-3-replicationDiscardCachedMaster-清空缓存的-cached-master"><a href="#1-3-replicationDiscardCachedMaster-清空缓存的-cached-master" class="headerlink" title="1.3 replicationDiscardCachedMaster - 清空缓存的 cached_master"></a>1.3 replicationDiscardCachedMaster - 清空缓存的 cached_master</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationDiscardCachedMaster</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>cached_master <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// CLIENT_MASTER = 1&lt;&lt;1 = 1</span>    <span class="token comment">// 先设置为 cashed_master 的 flags = flag &amp; (~CLIENT_MASTER), 简单理解就是把主节点的标识去掉</span>    server<span class="token punctuation">.</span>cached_master<span class="token operator">-></span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>CLIENT_MASTER<span class="token punctuation">;</span>    <span class="token comment">// 然后再释放 cached_master</span>    <span class="token function">freeClient</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>cached_master<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>cached_master <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="1-4-cancelReplicationHandshake-取消主从复制的握手"><a href="#1-4-cancelReplicationHandshake-取消主从复制的握手" class="headerlink" title="1.4 cancelReplicationHandshake -  取消主从复制的握手"></a>1.4 cancelReplicationHandshake -  取消主从复制的握手</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_TRANSFER<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 当前从节点的状态为 REPL_STATE_TRANSFER (正在接收从主节点发送过来的 RDB 文件)</span>        <span class="token comment">// 停止同步传输</span>        <span class="token comment">// 关闭从节点同步主节点的 socket 和临时文件描述符 repl_transfer_tmpfile</span>        <span class="token function">replicationAbortSyncTransfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新状态为 REPL_STATE_CONNECT (未连接上主节点)</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECT<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_CONNECTING <span class="token operator">||</span> <span class="token function">slaveIsInHandshakeState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 当前的状态为 REPL_STATE_CONNECTING (正在建立连接) 或者处于握手阶段</span>        <span class="token comment">// 关闭从节点同步主节点信息的 Socket, 对应的 Socket 文件描述符为 repl_transfer_s</span>        <span class="token function">undoConnectWithMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新状态为 REPL_STATE_CONNECT (未连接上主节点)</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECT<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 3. 其他的情况 </span>        <span class="token comment">// 其他状态返回 0</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="1-5-replicationAbortSyncTransfer-停止文件同步传输"><a href="#1-5-replicationAbortSyncTransfer-停止文件同步传输" class="headerlink" title="1.5 replicationAbortSyncTransfer - 停止文件同步传输"></a>1.5 replicationAbortSyncTransfer - 停止文件同步传输</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationAbortSyncTransfer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">serverAssert</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_TRANSFER<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 关闭从节点同步主节点信息的 Socket repl_transfer_s 和对应的文件描述符 repl_transfer_tmpfile</span>    <span class="token function">undoConnectWithMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unlink</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">zfree</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="1-6-undoConnectWithMaster-断开和主节点的连接"><a href="#1-6-undoConnectWithMaster-断开和主节点的连接" class="headerlink" title="1.6 undoConnectWithMaster - 断开和主节点的连接"></a>1.6 undoConnectWithMaster - 断开和主节点的连接</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">undoConnectWithMaster</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd <span class="token operator">=</span> server<span class="token punctuation">.</span>repl_transfer_s<span class="token punctuation">;</span>    <span class="token comment">// 删除 repl_transfer_s 这个文件描述符的事件</span>    <span class="token function">aeDeleteFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>AE_READABLE<span class="token operator">|</span>AE_WRITABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 关闭这个文件描述符</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 重置为 - 1 </span>    server<span class="token punctuation">.</span>repl_transfer_s <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="1-7-slaveIsInHandshakeState-判断当前从节点是否处于握手阶段"><a href="#1-7-slaveIsInHandshakeState-判断当前从节点是否处于握手阶段" class="headerlink" title="1.7 slaveIsInHandshakeState - 判断当前从节点是否处于握手阶段"></a>1.7 slaveIsInHandshakeState - 判断当前从节点是否处于握手阶段</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">slaveIsInHandshakeState</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 3 &lt;= server.repl_state &lt;= 13 </span>    <span class="token keyword">return</span> server<span class="token punctuation">.</span>repl_state <span class="token operator">>=</span> REPL_STATE_RECEIVE_PONG <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>repl_state <span class="token operator">&lt;=</span> REPL_STATE_RECEIVE_PSYNC<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="1-8-disconnectSlaves-关闭所有的从节点"><a href="#1-8-disconnectSlaves-关闭所有的从节点" class="headerlink" title="1.8 disconnectSlaves - 关闭所有的从节点"></a>1.8 disconnectSlaves - 关闭所有的从节点</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">disconnectSlaves</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 遍历自身所有的从节点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        listNode <span class="token operator">*</span>ln <span class="token operator">=</span> <span class="token function">listFirst</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">freeClient</span><span class="token punctuation">(</span><span class="token punctuation">(</span>client<span class="token operator">*</span><span class="token punctuation">)</span>ln<span class="token operator">-></span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="2-replicationSetMaster-保存主节点信息并进入待连接状态"><a href="#2-replicationSetMaster-保存主节点信息并进入待连接状态" class="headerlink" title="2 replicationSetMaster - 保存主节点信息并进入待连接状态"></a>2 replicationSetMaster - 保存主节点信息并进入待连接状态</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationSetMaster</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>ip<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">/</span> was_master <span class="token operator">=</span> 当前从节点的原本的主节点为 null    <span class="token keyword">int</span> was_master <span class="token operator">=</span> server<span class="token punctuation">.</span>masterhost <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">// 将入参的 IP 和 端口赋值给对应的字段</span>    <span class="token function">sdsfree</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>masterhost <span class="token operator">=</span> <span class="token function">sdsnew</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>masterport <span class="token operator">=</span> port<span class="token punctuation">;</span>    <span class="token comment">// 旧的主节点客户端存在, 进行释放</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">freeClient</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 解除所有阻塞状态的客户端</span>    <span class="token function">disconnectAllBlockedClients</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 释放所有的从节点信息 </span>    <span class="token function">disconnectSlaves</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 取消主从复制的握手</span>    <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// was_master = true, 也就是当前的从节点是第一次被设置为从节点</span>    <span class="token comment">// 创建出一个 cache_server, 用于后续数据复制</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>was_master<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 将 server.cached_server 设置为空, 同时设置释放对应的内存</span>        <span class="token function">replicationDiscardCachedMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 根据当前参数合成出一个 client, 同时将其放到 cached_master</span>        <span class="token function">replicationCacheMasterUsingMyself</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 设置当前的主从复制状态为待连接上主节点 (REPL_STATE_CONNECT)</span>    server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECT<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-1-disconnectAllBlockedClients-释放所有阻塞状态的客户端"><a href="#2-1-disconnectAllBlockedClients-释放所有阻塞状态的客户端" class="headerlink" title="2.1 disconnectAllBlockedClients - 释放所有阻塞状态的客户端"></a>2.1 disconnectAllBlockedClients - 释放所有阻塞状态的客户端</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">disconnectAllBlockedClients</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>    listIter li<span class="token punctuation">;</span>    <span class="token comment">// 将 server.clients 的信息转移到 li 上</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 遍历 li</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 客户端为阻塞状态</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_BLOCKED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token function">addReplySds</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token function">sdsnew</span><span class="token punctuation">(</span><span class="token string">"-UNBLOCKED force unblock from blocking operation, instance state changed (master -> replica?)\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 解除所有阻塞状态的客户端</span>            <span class="token function">unblockClient</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            c<span class="token operator">-></span>flags <span class="token operator">|=</span> CLIENT_CLOSE_AFTER_REPLY<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-2-replicationCacheMasterUsingMyself-为-server-cached-master-赋值一个默认合成的客户端"><a href="#2-2-replicationCacheMasterUsingMyself-为-server-cached-master-赋值一个默认合成的客户端" class="headerlink" title="2.2 replicationCacheMasterUsingMyself - 为 server.cached_master 赋值一个默认合成的客户端"></a>2.2 replicationCacheMasterUsingMyself - 为 server.cached_master 赋值一个默认合成的客户端</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationCacheMasterUsingMyself</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 设置当前的 master_initial_offset 等于 master_repl_offset</span>    server<span class="token punctuation">.</span>master_initial_offset <span class="token operator">=</span> server<span class="token punctuation">.</span>master_repl_offset<span class="token punctuation">;</span>    <span class="token comment">// 创建一个新的主节点客户端, 并存放发到 server.master 中</span>    <span class="token function">replicationCreateMasterClient</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将 server.replid 拷贝到创建出来的节点的 replid</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token operator">-></span>replid<span class="token punctuation">,</span> server<span class="token punctuation">.</span>replid<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 通过 replicationCreateMasterClient 创建出来的客户端, unlinkClient 里面的逻辑都不符合条件, 直接结束了</span>    <span class="token comment">// 可以看成是没有这个方法的逻辑</span>    <span class="token function">unlinkClient</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置 cached_master = master, 同时置空 master </span>    server<span class="token punctuation">.</span>cached_master <span class="token operator">=</span> server<span class="token punctuation">.</span>master<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>master <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-3-replicationCreateMasterClient-创建主节点客户端"><a href="#2-3-replicationCreateMasterClient-创建主节点客户端" class="headerlink" title="2.3 replicationCreateMasterClient - 创建主节点客户端"></a>2.3 replicationCreateMasterClient - 创建主节点客户端</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** *  创建主节点客户端 */</span><span class="token keyword">void</span> <span class="token function">replicationCreateMasterClient</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> dbid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 创建新的客户端, 赋值到 master, createClient 创建出来的 flag 默认为 0 </span>    <span class="token comment">// 具体的创建逻辑可以查看 networking.c 中的 createClient 函数</span>    server<span class="token punctuation">.</span>master <span class="token operator">=</span> <span class="token function">createClient</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 此时 flag = CLIENT_MASTER = 1, 主节点</span>    server<span class="token punctuation">.</span>master<span class="token operator">-></span>flags <span class="token operator">|=</span> CLIENT_MASTER<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>master<span class="token operator">-></span>authenticated <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>master<span class="token operator">-></span>reploff <span class="token operator">=</span> server<span class="token punctuation">.</span>master_initial_offset<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>master<span class="token operator">-></span>read_reploff <span class="token operator">=</span> server<span class="token punctuation">.</span>master<span class="token operator">-></span>reploff<span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token operator">-></span>replid<span class="token punctuation">,</span> server<span class="token punctuation">.</span>master_replid<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master_replid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果一个主节点的偏移量为 -1, 那么这个主节点是旧的, 并且是无法进行 psync 的, 所以将其设置为 CLIENT_PRE_PSYNC (1 &lt;&lt; 16, 65536)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token operator">-></span>reploff <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">// | CLIENT_PRE_PSYNC 后, flags 等于 65537</span>        server<span class="token punctuation">.</span>master<span class="token operator">-></span>flags <span class="token operator">|=</span> CLIENT_PRE_PSYNC<span class="token punctuation">;</span>    <span class="token comment">// 指定当前的数据库 (0 - 16 个数据库)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dbid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token function">selectDb</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">,</span> dbid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="3-connectWithMaster-尝试和主节点建立-TCP-连接"><a href="#3-connectWithMaster-尝试和主节点建立-TCP-连接" class="headerlink" title="3 connectWithMaster -  尝试和主节点建立 TCP 连接"></a>3 connectWithMaster -  尝试和主节点建立 TCP 连接</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">connectWithMaster</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    <span class="token comment">// 建立非阻塞的 Tcp 连接</span>    fd <span class="token operator">=</span> <span class="token function">anetTcpNonBlockBestEffortBindConnect</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>masterhost<span class="token punctuation">,</span> server<span class="token punctuation">.</span>masterport<span class="token punctuation">,</span> NET_FIRST_BIND_ADDR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 文件描述符为 -1, 建立连接失败</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 为 Tcp 连接的文件描述符注册一个的可读可写的事件, 处理的逻辑函数为 syncWithMaster</span>    <span class="token comment">// 注意这里注册的类型为 AE_READABLE|AE_WRITABLE, 在 epoll 中, 底层注册的是 EPOLLIN | EPOLLOUT</span>    <span class="token comment">// epoll 有个机制, 同时注册 EPOLLIN | EPOLLOUT 事件, 会立即触发一次 EPOLLOUT 事件, 也就是 AE_WRITABLE 事件</span>    <span class="token comment">// 也就是在下次事件轮询中会执行一次 syncWithMaster 函数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> fd<span class="token punctuation">,</span>AE_READABLE<span class="token operator">|</span>AE_WRITABLE<span class="token punctuation">,</span> syncWithMaster<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> AE_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 更新从节点和主节点最近一次进行数据同步的时间, 默认为当前时间</span>    server<span class="token punctuation">.</span>repl_transfer_lastio <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_transfer_s <span class="token operator">=</span> fd<span class="token punctuation">;</span>    <span class="token comment">// 当前从节点的主从复制的状态为 REPL_STATE_CONNECTING (正在连接主节点)</span>    server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECTING<span class="token punctuation">;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="4-sendSynchronousCommand-发送命令到主节点"><a href="#4-sendSynchronousCommand-发送命令到主节点" class="headerlink" title="4 sendSynchronousCommand - 发送命令到主节点"></a>4 sendSynchronousCommand - 发送命令到主节点</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span><span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 发送写命令</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> SYNC_CMD_WRITE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 发送 ping 命令时, 入参为 (SYNC_CMD_WRITE,fd,"PING",NULL)</span>        <span class="token comment">// flags = SYNC_CMD_WRITE</span>                <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">;</span>        <span class="token comment">// 下面的 va_ 开头的函数, 都是用来处理动态入参的</span>        va_list ap<span class="token punctuation">;</span>        sds cmd <span class="token operator">=</span> <span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sds cmdargs <span class="token operator">=</span> <span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">size_t</span> argslen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">va_start</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            arg <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arg <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>                 <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment">// 拼接 cmd 命令的参数</span>            cmdargs <span class="token operator">=</span> <span class="token function">sdscatprintf</span><span class="token punctuation">(</span>cmdargs<span class="token punctuation">,</span><span class="token string">"$%zu\r\n%s\r\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">,</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>            argslen<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">va_end</span><span class="token punctuation">(</span>ap<span class="token punctuation">)</span><span class="token punctuation">;</span>        cmd <span class="token operator">=</span> <span class="token function">sdscatprintf</span><span class="token punctuation">(</span>cmd<span class="token punctuation">,</span><span class="token string">"*%zu\r\n"</span><span class="token punctuation">,</span>argslen<span class="token punctuation">)</span><span class="token punctuation">;</span>        cmd <span class="token operator">=</span> <span class="token function">sdscatsds</span><span class="token punctuation">(</span>cmd<span class="token punctuation">,</span>cmdargs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>cmdargs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 发送给对应的文件描述符, 这里的 fd 是 Socket 通道</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">syncWrite</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> cmd<span class="token punctuation">,</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>repl_syncio_timeout<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">sdsfree</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">sdscatprintf</span><span class="token punctuation">(</span><span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"-Writing to master: %s"</span><span class="token punctuation">,</span><span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 接受读操作</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> SYNC_CMD_READ<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 读取数据到 buf 中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">syncReadLine</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span>server<span class="token punctuation">.</span>repl_syncio_timeout<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">sdscatprintf</span><span class="token punctuation">(</span><span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"-Reading from master: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        server<span class="token punctuation">.</span>repl_transfer_lastio <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">sdsnew</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="5-slaveTryPartialResynchronization-根据条件判断是发送部分同步复制还是全量同步复制-同时支持读取主节点发送信息"><a href="#5-slaveTryPartialResynchronization-根据条件判断是发送部分同步复制还是全量同步复制-同时支持读取主节点发送信息" class="headerlink" title="5 slaveTryPartialResynchronization - 根据条件判断是发送部分同步复制还是全量同步复制, 同时支持读取主节点发送信息"></a>5 slaveTryPartialResynchronization - 根据条件判断是发送部分同步复制还是全量同步复制, 同时支持读取主节点发送信息</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">slaveTryPartialResynchronization</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> read_reply<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 入参的 read_reply 0: 表示向主节点写读取 1: 表示读取主节点的数据</span>    <span class="token keyword">char</span> <span class="token operator">*</span>psync_replid<span class="token punctuation">;</span>    <span class="token keyword">char</span> psync_offset<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    sds reply<span class="token punctuation">;</span>    <span class="token comment">// 写操作</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>read_reply<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 设置初始的偏移量为 -1</span>        <span class="token comment">// -1 表示示主节点的 replid 和全局复制偏移量是无效的</span>        server<span class="token punctuation">.</span>master_initial_offset <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 主节点的缓存不为空，可以尝试进行部分重同步</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>cached_master<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// psync_replid 为缓存的主节点的 replid</span>            psync_replid <span class="token operator">=</span> server<span class="token punctuation">.</span>cached_master<span class="token operator">-></span>replid<span class="token punctuation">;</span>            <span class="token comment">// 获取部分同步的开始位置 , 赋值给 psync_offset</span>            <span class="token function">snprintf</span><span class="token punctuation">(</span>psync_offset<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>psync_offset<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"%lld"</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>cached_master<span class="token operator">-></span>reploff<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 没有主节点缓存, 进行全量同步</span>            psync_replid <span class="token operator">=</span> <span class="token string">"?"</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>psync_offset<span class="token punctuation">,</span><span class="token string">"-1"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 部分复制, 最终发送的命令 psync replid repl_offset</span>        <span class="token comment">// 全量复制, 最终发送的命令 psync ? -1</span>        reply <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_WRITE<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token string">"PSYNC"</span><span class="token punctuation">,</span>psync_replid<span class="token punctuation">,</span>psync_offset<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 写失败, 删除对应的文件描述符的读监听</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>reply <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">sdsfree</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">aeDeleteFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>AE_READABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> PSYNC_WRITE_ERROR<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> PSYNC_WAIT_REPLY<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 下面的读操作可以等待下面的 psync 命令应答在回来看, 现在下面不影响整个的流程</span>    <span class="token comment">// 读操作</span>    reply <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_READ<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sdslen</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 没有响应数据</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> PSYNC_WAIT_REPLY<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// strncmp 比较字符串是否一样, 一样返回 0, 不一样, 返回值为非 0 </span>    <span class="token comment">// 比较 reply 前 11 个字符是否为 +FULLRESYNC</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strncmp</span><span class="token punctuation">(</span>reply<span class="token punctuation">,</span><span class="token string">"+FULLRESYNC"</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 响应的数据前面的内容为 +FULLRESYNC</span>        <span class="token keyword">char</span> <span class="token operator">*</span>replid <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">*</span>offset <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token comment">// 这个是 psync 命令, 全量复制的响应 </span>        <span class="token comment">// 定位到第一个空格的位置</span>        replid <span class="token operator">=</span> <span class="token function">strchr</span><span class="token punctuation">(</span>reply<span class="token punctuation">,</span><span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取响应的 replid</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>replid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 定位到 replid 的位置</span>            replid<span class="token operator">++</span><span class="token punctuation">;</span>            offset <span class="token operator">=</span> <span class="token function">strchr</span><span class="token punctuation">(</span>replid<span class="token punctuation">,</span><span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>offset<span class="token punctuation">)</span>                 <span class="token comment">// 定位到 offset 的位置</span>                offset<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// replid 为  0 || offset 为 0 || offset - replid - 1 不等于 40 (replid 的长度为 40)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>replid <span class="token operator">||</span> <span class="token operator">!</span>offset <span class="token operator">||</span> <span class="token punctuation">(</span>offset<span class="token operator">-</span>replid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 设置 replid 为 0</span>            <span class="token function">memset</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master_replid<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>CONFIG_RUN_ID_SIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 将 replid 复制给 server.master_replid </span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master_replid<span class="token punctuation">,</span> replid<span class="token punctuation">,</span> offset<span class="token operator">-</span>replid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            server<span class="token punctuation">.</span>master_replid<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>            <span class="token comment">// server.master_initial_offset = 获取到的 offset</span>            server<span class="token punctuation">.</span>master_initial_offset <span class="token operator">=</span> <span class="token function">strtoll</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 全量复制了, 缓存的主节点没有意义, 清空了</span>        <span class="token comment">// 将 server.cached_server 设置为空, 同时设置释放对应的内存</span>        <span class="token function">replicationDiscardCachedMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> PSYNC_FULLRESYNC<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 响应的前面的数据为 +CONTINUE</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strncmp</span><span class="token punctuation">(</span>reply<span class="token punctuation">,</span><span class="token string">"+CONTINUE"</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> <span class="token operator">*</span>start <span class="token operator">=</span> reply<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>end <span class="token operator">=</span> reply<span class="token operator">+</span><span class="token number">9</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>end<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\r'</span> <span class="token operator">&amp;&amp;</span> end<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\n'</span> <span class="token operator">&amp;&amp;</span> end<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>             end<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token comment">// 结束的位置 - 开始的位置 = 40 </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">==</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 新的 replid </span>            <span class="token keyword">char</span> new<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span>start<span class="token punctuation">,</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            new<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>            <span class="token comment">// replid 和当前的缓存主节点 cached_master 的 replid 不一致</span>            <span class="token comment">// 只能进行全量复制</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span> server<span class="token punctuation">.</span>cached_master<span class="token operator">-></span>replid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 缓存的主节点的 replid 和参数的 replid 不一致</span>                <span class="token comment">// 将当前的 cached_master 的 replid 赋值给 replid2</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid2<span class="token punctuation">,</span> server<span class="token punctuation">.</span>cached_master<span class="token operator">-></span>replid<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                server<span class="token punctuation">.</span>second_replid_offset <span class="token operator">=</span> server<span class="token punctuation">.</span>master_repl_offset<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// 新的 replid 赋值到 server.replid</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">,</span> new<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 设置缓存的客户端的 cached_master 的 replid = server.replid</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>cached_master<span class="token operator">-></span>replid<span class="token punctuation">,</span> new<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 释放从节点</span>                <span class="token function">disconnectSlaves</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                 <span class="token function">sdsfree</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 重新将 cached_master 作为主节点使用</span>        <span class="token function">replicationResurrectCachedMaster</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>             <span class="token comment">// 没有复制积压缓冲区, 进行创建</span>            <span class="token function">createReplicationBacklog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> PSYNC_CONTINUE<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>        <span class="token comment">// 主节点无法响应 psync 命令</span>    <span class="token comment">// 主节点处于一个特殊的状态, 无法处理对应的请求</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strncmp</span><span class="token punctuation">(</span>reply<span class="token punctuation">,</span><span class="token string">"-NOMASTERLINK"</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">strncmp</span><span class="token punctuation">(</span>reply<span class="token punctuation">,</span><span class="token string">"-LOADING"</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> PSYNC_TRY_LATER<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 响应了异常</span>    <span class="token function">sdsfree</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将 server.cached_server 设置为空, 同时设置释放对应的内存</span>    <span class="token function">replicationDiscardCachedMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> PSYNC_NOT_SUPPORTED<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre><h3 id="5-1-replicationResurrectCachedMaster-重新将-cached-master-作为主节点使用"><a href="#5-1-replicationResurrectCachedMaster-重新将-cached-master-作为主节点使用" class="headerlink" title="5.1 replicationResurrectCachedMaster - 重新将 cached_master 作为主节点使用"></a>5.1 replicationResurrectCachedMaster - 重新将 cached_master 作为主节点使用</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationResurrectCachedMaster</span><span class="token punctuation">(</span><span class="token keyword">int</span> newfd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    server<span class="token punctuation">.</span>master <span class="token operator">=</span> server<span class="token punctuation">.</span>cached_master<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>cached_master <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>master<span class="token operator">-></span>fd <span class="token operator">=</span> newfd<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>master<span class="token operator">-></span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span>CLIENT_CLOSE_AFTER_REPLY<span class="token operator">|</span>CLIENT_CLOSE_ASAP<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>master<span class="token operator">-></span>authenticated <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>master<span class="token operator">-></span>lastinteraction <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    <span class="token comment">// 修改状态为 REPL_STATE_CONNECTED (已连接上主节点)</span>    server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECTED<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_down_since <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">linkClient</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 添加事件</span>    <span class="token comment">// 为当前的主节点添加一个读事件, 触发逻辑为 readQueryFromClient</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> newfd<span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">,</span> readQueryFromClient<span class="token punctuation">,</span> server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 当前的主节点有数据需要发送 </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 添加一个写事件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> newfd<span class="token punctuation">,</span> AE_WRITABLE<span class="token punctuation">,</span> sendReplyToClient<span class="token punctuation">,</span> server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="5-2-clientHasPendingReplies-判断当前的入参的客户端是否有数据需要发送"><a href="#5-2-clientHasPendingReplies-判断当前的入参的客户端是否有数据需要发送" class="headerlink" title="5.2 clientHasPendingReplies - 判断当前的入参的客户端是否有数据需要发送"></a>5.2 clientHasPendingReplies - 判断当前的入参的客户端是否有数据需要发送</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 固定缓存区有数据 或者 回复列表有数据</span>    <span class="token keyword">return</span> c<span class="token operator">-></span>bufpos <span class="token operator">||</span> <span class="token function">listLength</span><span class="token punctuation">(</span>c<span class="token operator">-></span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="5-3-createReplicationBacklog-创建复制积压缓冲区"><a href="#5-3-createReplicationBacklog-创建复制积压缓冲区" class="headerlink" title="5.3 createReplicationBacklog - 创建复制积压缓冲区"></a>5.3 createReplicationBacklog - 创建复制积压缓冲区</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">createReplicationBacklog</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">serverAssert</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_backlog <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_backlog_histlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_backlog_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 虽然没有任何数据, 但是第一个字节是数据写入的位置</span>    server<span class="token punctuation">.</span>repl_backlog_off <span class="token operator">=</span> server<span class="token punctuation">.</span>master_repl_offset<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="6-clearReplicationId2-清除-replid2-和-second-replid-offset"><a href="#6-clearReplicationId2-清除-replid2-和-second-replid-offset" class="headerlink" title="6 clearReplicationId2 - 清除 replid2 和 second_replid_offset"></a>6 clearReplicationId2 - 清除 replid2 和 second_replid_offset</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 清除 replid2 和 second_replid_offset */</span><span class="token keyword">void</span> <span class="token function">clearReplicationId2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid2<span class="token punctuation">,</span><span class="token char">'0'</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>replid2<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>second_replid_offset <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="7-masterTryPartialResynchronization-尝试和从节点进行部分同步复制"><a href="#7-masterTryPartialResynchronization-尝试和从节点进行部分同步复制" class="headerlink" title="7 masterTryPartialResynchronization - 尝试和从节点进行部分同步复制"></a>7 masterTryPartialResynchronization - 尝试和从节点进行部分同步复制</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">masterTryPartialResynchronization</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// client 进到这里面执行的命令为 psync ? -1 或 psync master_repl_id repl_offset</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> psync_offset<span class="token punctuation">,</span> psync_len<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>master_replid <span class="token operator">=</span> c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> buflen<span class="token punctuation">;</span>    <span class="token comment">// 读取入参的第 3 个参数到 psync_offset</span>    <span class="token comment">// 读取失败, 直接全量同步</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getLongLongFromObjectOrReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>psync_offset<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span>         <span class="token keyword">goto</span> need_full_resync<span class="token punctuation">;</span>    <span class="token comment">// 在入参的 repl_id 和当前主节点的 replid 不一样的条件下</span>    <span class="token comment">// 1. 入参的 repl_id 和当前主节点一样的 replid2 不一样</span>    <span class="token comment">// 2. 请求的偏移量 大于 second_replid_offset (也就是 replid2)</span>    <span class="token comment">// replid2 可以看出当前节点同步了旧主节点数据的位置, second_replid_offset 可以看出是从节点同步了旧节点数据的位置</span>    <span class="token comment">// 如果 second_replid_offset > replid2, 表示从节点同步的数据快于当前节点的, 从节点的数据比主节点多, 不合理, 直接全量同步</span>    <span class="token comment">// 满足其中一种情况, 直接进入全量赋值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>master_replid<span class="token punctuation">,</span> server<span class="token punctuation">.</span>replid<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>master_replid<span class="token punctuation">,</span> server<span class="token punctuation">.</span>replid2<span class="token punctuation">)</span> <span class="token operator">||</span> psync_offset <span class="token operator">></span> server<span class="token punctuation">.</span>second_replid_offset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 这 2 种请求都不能进行部分同步, 直接进入全量同步</span>        <span class="token keyword">goto</span> need_full_resync<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// psync_offset 可以看做是从复制积压缓冲区的哪个位置开始复制</span>    <span class="token comment">// 当前复制积压缓冲区没有数据</span>    <span class="token comment">// 请求的偏移量小于 repl_backlog_off (复制积压缓冲区 backlog 的第一个字节的逻辑位置是下次复制的开始位置), 说明 backlog 所备份的数据的已经太新了, 有一些数据被覆盖，则需要进行全量复制</span>    <span class="token comment">// 请求的偏移量大于 repl_backlog_off + repl_backlog_histlen (backlog 的实际数据大小) 表示当前 backlog 的数据不够全，则需要进行全量复制</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>server<span class="token punctuation">.</span>repl_backlog <span class="token operator">||</span> psync_offset <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>repl_backlog_off <span class="token operator">||</span> psync_offset <span class="token operator">></span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_off <span class="token operator">+</span> server<span class="token punctuation">.</span>repl_backlog_histlen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> need_full_resync<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 部分复制</span>    <span class="token comment">// 设置为从节点标识 </span>    c<span class="token operator">-></span>flags <span class="token operator">|=</span> CLIENT_SLAVE<span class="token punctuation">;</span>    <span class="token comment">// 设置状态为 在线状态</span>    c<span class="token operator">-></span>replstate <span class="token operator">=</span> SLAVE_STATE_ONLINE<span class="token punctuation">;</span>    <span class="token comment">// 设置当前客户端, 也就是从节点的 应答时间为当前时间</span>    c<span class="token operator">-></span>repl_ack_time <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    <span class="token comment">// 设置当前客户端, 也就是从节点需要向主节点发送 ack 的标志 为 0, 没有 ack</span>    c<span class="token operator">-></span>repl_put_online_on_ack <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 当前节点的从节点列表添加当前的节点</span>    <span class="token function">listAddNodeTail</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 从节点的复制能力支持 psync2</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>slave_capa <span class="token operator">&amp;</span> SLAVE_CAPA_PSYNC2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 发送内容 +CONTINUE 主节点当前的 repl_id \r\n</span>        buflen <span class="token operator">=</span> <span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"+CONTINUE %s\r\n"</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>replid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 不支持</span>        <span class="token comment">// 发送内容 +CONTINUE\r\n</span>        buflen <span class="token operator">=</span> <span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"+CONTINUE\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 发送数据给从节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">write</span><span class="token punctuation">(</span>c<span class="token operator">-></span>fd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>buflen<span class="token punctuation">)</span> <span class="token operator">!=</span> buflen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    psync_len <span class="token operator">=</span> <span class="token function">addReplyReplicationBacklog</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>psync_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 计算延迟值小于 min-slaves-max-lag 的从节点的个数</span>    <span class="token function">refreshGoodSlavesCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>              need_full_resync<span class="token operator">:</span>    <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="7-1-addReplyReplicationBacklog-进行部分同步复制"><a href="#7-1-addReplyReplicationBacklog-进行部分同步复制" class="headerlink" title="7.1 addReplyReplicationBacklog - 进行部分同步复制"></a>7.1 addReplyReplicationBacklog - 进行部分同步复制</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">addReplyReplicationBacklog</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> offset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> j<span class="token punctuation">,</span> skip<span class="token punctuation">,</span> len<span class="token punctuation">;</span>    <span class="token comment">// 复制积压缓冲区没有数据实际没有数据, 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_histlen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* Compute the amount of bytes we need to discard. */</span>    <span class="token comment">// 跳过初始位置多少个字节</span>    skip <span class="token operator">=</span> offset <span class="token operator">-</span> server<span class="token punctuation">.</span>repl_backlog_off<span class="token punctuation">;</span>    <span class="token comment">// 因为复用着这一个复制积压缓冲区 repl_backlog, 写满了, 新的数据又重开始位置进行写</span>    <span class="token comment">// repl_backlog 的容量 repl_backlog_size 和当前容量 repl_backlog_histlen 基本不会大于 repl_backlog 的容量大小</span>    <span class="token comment">// 但是几个代表位置的字段 repl_backlog_idx repl_backlog_off 会大于 repl_backlog_size</span>    <span class="token comment">// 所以下面位置的计算才那么复杂</span>    <span class="token comment">// 计算出我们的复制积压缓冲区中数据实际最旧的位置, 在复制积压缓冲区的位置</span>    <span class="token comment">// （下一个字节写入的位置 + 复制积压缓冲区的大小 - 复制积压缓冲区当前实际的容量）% 复制积压缓冲区的大小</span>    j <span class="token operator">=</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_idx <span class="token operator">+</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_size <span class="token operator">-</span> server<span class="token punctuation">.</span>repl_backlog_histlen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> server<span class="token punctuation">.</span>repl_backlog_size<span class="token punctuation">;</span>     <span class="token comment">// 计算当前复制的开始位置</span>    j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> skip<span class="token punctuation">)</span> <span class="token operator">%</span> server<span class="token punctuation">.</span>repl_backlog_size<span class="token punctuation">;</span>    <span class="token comment">// 需要发送发送的数据长度</span>    len <span class="token operator">=</span> server<span class="token punctuation">.</span>repl_backlog_histlen <span class="token operator">-</span> skip<span class="token punctuation">;</span>    <span class="token comment">// 不为空</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// (复制积压缓冲区的容量 - 开始发送的位置) &lt; 需要发送的数据的长度 的话, 表示当前可以发送的数据有部分在复制积压缓冲区的开头</span>        <span class="token comment">// 计算这次发送的数据长度</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> thislen <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_size <span class="token operator">-</span> j<span class="token punctuation">)</span> <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_size <span class="token operator">-</span> j<span class="token punctuation">)</span> <span class="token operator">:</span> len<span class="token punctuation">;</span>        <span class="token comment">// 发送数据</span>        <span class="token function">addReplySds</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token function">sdsnewlen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog <span class="token operator">+</span> j<span class="token punctuation">,</span> thislen<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 重新计算下次需要发送的数据长度</span>        len <span class="token operator">-=</span> thislen<span class="token punctuation">;</span>        <span class="token comment">// 开始的位置重新从 0 开始</span>        j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 返回写入的长度</span>    <span class="token keyword">return</span> server<span class="token punctuation">.</span>repl_backlog_histlen <span class="token operator">-</span> skip<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="8-replicationSetupSlaveForFullResync-将最新的-repl-id-和-repl-offset-发送给从节点"><a href="#8-replicationSetupSlaveForFullResync-将最新的-repl-id-和-repl-offset-发送给从节点" class="headerlink" title="8 replicationSetupSlaveForFullResync - 将最新的 repl_id 和 repl_offset 发送给从节点"></a>8 replicationSetupSlaveForFullResync - 将最新的 repl_id 和 repl_offset 发送给从节点</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">replicationSetupSlaveForFullResync</span><span class="token punctuation">(</span>client <span class="token operator">*</span>slave<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> offset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> buflen<span class="token punctuation">;</span>    <span class="token comment">// 更新入参的客户端的 psync 偏移量为 offset </span>    slave<span class="token operator">-></span>psync_initial_offset <span class="token operator">=</span> offset<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> buflen<span class="token punctuation">;</span>    <span class="token comment">// 更新入参的客户端的 psync 偏移量为 offset </span>    slave<span class="token operator">-></span>psync_initial_offset <span class="token operator">=</span> offset<span class="token punctuation">;</span>    <span class="token comment">// 更新状态为 SLAVE_STATE_WAIT_BGSAVE_END (等待 bgsave 结束)</span>    slave<span class="token operator">-></span>replstate <span class="token operator">=</span> SLAVE_STATE_WAIT_BGSAVE_END<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>slaveseldb <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// 如果从节点的状态是 CLIENT_PRE_PSYNC，则表示是 Redis 是 2.8 之前的版本，则不将这些信息发送给从节点</span>    <span class="token comment">// 在 2.8 之前只支持 SYNC 的全量复制同步，而在之后的版本提供了部分的重同步</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>slave<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_PRE_PSYNC<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 发送全量复制的消息给从节点</span>        <span class="token comment">// 发送 +FULLRESYNC replid offset\r\n 给从节点 </span>        buflen <span class="token operator">=</span> <span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"+FULLRESYNC %s %lld\r\n"</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>replid<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">write</span><span class="token punctuation">(</span>slave<span class="token operator">-></span>fd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>buflen<span class="token punctuation">)</span> <span class="token operator">!=</span> buflen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>slave<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="9-startBgsaveForReplication-通过执行-Bgsave-进行全量同步"><a href="#9-startBgsaveForReplication-通过执行-Bgsave-进行全量同步" class="headerlink" title="9 startBgsaveForReplication - 通过执行 Bgsave 进行全量同步"></a>9 startBgsaveForReplication - 通过执行 Bgsave 进行全量同步</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">startBgsaveForReplication</span><span class="token punctuation">(</span><span class="token keyword">int</span> mincapa<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> retval<span class="token punctuation">;</span>    <span class="token comment">// 是否支持 socket 同步, 支持无盘同步同时同步复制能力支持 EOF</span>    <span class="token keyword">int</span> socket_target <span class="token operator">=</span> server<span class="token punctuation">.</span>repl_diskless_sync <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>mincapa <span class="token operator">&amp;</span> SLAVE_CAPA_EOF<span class="token punctuation">)</span><span class="token punctuation">;</span>    listIter li<span class="token punctuation">;</span>    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>    rdbSaveInfo rsi<span class="token punctuation">,</span> <span class="token operator">*</span>rsiptr<span class="token punctuation">;</span>    <span class="token comment">// 创建出一个初始的 rdbSaveInfo</span>    rsiptr <span class="token operator">=</span> <span class="token function">rdbPopulateSaveInfo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rsi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rsiptr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 创建处理的 rdbSaveInfo 不为空</span>                <span class="token comment">// 支持 socket </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>socket_target<span class="token punctuation">)</span>            <span class="token comment">// 大体的流程和正常的 RDB 相关, 就不张开了, 太长了, 可以查看 rdb.c 这个文件进行了解</span>            <span class="token comment">// 1. 在节点客户端列表中找到所有状态为 SLAVE_STATE_WAIT_BGSAVE_START (等待 bgsave 开始, 也就是开始创建 RDB 文件) 并且支持 psync 命令的客户端, 向他们发送 +FULLRESYNC replid offset\r\n, 并修改状态为 SLAVE_STATE_WAIT_BGSAVE_END (等待 RDB 创建文件结束), 同时设置他们的 Socket 为阻塞模式 (可以理解为数据先堆积在 Socket 中, 后序一起发送)</span>            <span class="token comment">// 2. 创建出一个子进程, 将当前主节点的数据以 EOF 要求的格式写入到满足上一步的所有从节点的 Socket 中</span>            <span class="token comment">// EOF 格式</span>            <span class="token comment">// 开头 $EOF: + 长度 40 的 16 位字符串 + \r\n</span>            <span class="token comment">// 中间 RDB 内容</span>            <span class="token comment">// 结尾 一开始的 长度 40 的 16 位字符串 </span>            <span class="token comment">// 3. 全部写完后, 发送给对应的从节点</span>            retval <span class="token operator">=</span> <span class="token function">rdbSaveToSlavesSockets</span><span class="token punctuation">(</span>rsiptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// 正常的 RDB 持久化, 将数据写入到一个文件中, rdb 类型为 RDB_CHILD_TYPE_DISK</span>            retval <span class="token operator">=</span> <span class="token function">rdbSaveBackground</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_filename<span class="token punctuation">,</span>rsiptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 为空, 直接返回失败</span>        retval <span class="token operator">=</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 执行同步失败</span>        <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            client <span class="token operator">*</span>slave <span class="token operator">=</span> ln<span class="token operator">-></span>value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slave<span class="token operator">-></span>replstate <span class="token operator">==</span> SLAVE_STATE_WAIT_BGSAVE_START<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 删除对应的从节点</span>                slave<span class="token operator">-></span>replstate <span class="token operator">=</span> REPL_STATE_NONE<span class="token punctuation">;</span>                slave<span class="token operator">-></span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>CLIENT_SLAVE<span class="token punctuation">;</span>                <span class="token function">listDelNode</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 响应一个失败的提示</span>                <span class="token function">addReplyError</span><span class="token punctuation">(</span>slave<span class="token punctuation">,</span><span class="token string">"BGSAVE failed, replication can't continue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                slave<span class="token operator">-></span>flags <span class="token operator">|=</span> CLIENT_CLOSE_AFTER_REPLY<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> retval<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 磁盘同步类型处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>socket_target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 无盘同步, 已经在 rdbSaveToSlavesSockets 中已更新从节点的信息</span>        <span class="token comment">// 有盘同步, 在这一步处理</span>        <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            client <span class="token operator">*</span>slave <span class="token operator">=</span> ln<span class="token operator">-></span>value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slave<span class="token operator">-></span>replstate <span class="token operator">==</span> SLAVE_STATE_WAIT_BGSAVE_START<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>、                <span class="token comment">// 更新从节点客户端的偏移量, 状态和发送全量复制的消息给从节点</span>                <span class="token comment">// 当前的从节点的状态将会变为 SLAVE_STATE_WAIT_BGSAVE_END</span>                <span class="token function">replicationSetupSlaveForFullResync</span><span class="token punctuation">(</span>slave<span class="token punctuation">,</span> <span class="token function">getPsyncInitialOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 同步成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">==</span> C_OK<span class="token punctuation">)</span>         <span class="token comment">// 清除脚本缓存</span>        <span class="token function">replicationScriptCacheFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> retval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="9-1-replicationScriptCacheFlush-清除-Lua-脚本的缓存"><a href="#9-1-replicationScriptCacheFlush-清除-Lua-脚本的缓存" class="headerlink" title="9.1 replicationScriptCacheFlush - 清除 Lua 脚本的缓存"></a>9.1 replicationScriptCacheFlush - 清除 Lua 脚本的缓存</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationScriptCacheFlush</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">dictEmpty</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_scriptcache_dict<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listRelease</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_scriptcache_fifo<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_scriptcache_fifo <span class="token operator">=</span> <span class="token function">listCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="10-freeReplicationBacklog-清空复制积压缓冲区"><a href="#10-freeReplicationBacklog-清空复制积压缓冲区" class="headerlink" title="10 freeReplicationBacklog - 清空复制积压缓冲区"></a>10 freeReplicationBacklog - 清空复制积压缓冲区</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">freeReplicationBacklog</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">serverAssert</span><span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">zfree</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_backlog <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="11-putSlaveOnline-更新从节点的状态"><a href="#11-putSlaveOnline-更新从节点的状态" class="headerlink" title="11 putSlaveOnline - 更新从节点的状态"></a>11 putSlaveOnline - 更新从节点的状态</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">putSlaveOnline</span><span class="token punctuation">(</span>client <span class="token operator">*</span>slave<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 更新从节点的状态为 SLAVE_STATE_ONLINE (在线状态)</span>    slave<span class="token operator">-></span>replstate <span class="token operator">=</span> SLAVE_STATE_ONLINE<span class="token punctuation">;</span>    <span class="token comment">// 未 ack 应答</span>    slave<span class="token operator">-></span>repl_put_online_on_ack <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 更新 ack 为未应答</span>    slave<span class="token operator">-></span>repl_ack_time <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>     <span class="token comment">// 新增写事件, 将当前客户端的输出缓冲区数据发生给从节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> slave<span class="token operator">-></span>fd<span class="token punctuation">,</span> AE_WRITABLE<span class="token punctuation">,</span> sendReplyToClient<span class="token punctuation">,</span> slave<span class="token punctuation">)</span> <span class="token operator">==</span> AE_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">freeClient</span><span class="token punctuation">(</span>slave<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 更新当前从节点中延迟值小于配置的</span>    <span class="token function">refreshGoodSlavesCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="11-1-refreshGoodSlavesCount-刷新在线从节点且超时时间小于配置的从节点数量"><a href="#11-1-refreshGoodSlavesCount-刷新在线从节点且超时时间小于配置的从节点数量" class="headerlink" title="11.1 refreshGoodSlavesCount - 刷新在线从节点且超时时间小于配置的从节点数量"></a>11.1 refreshGoodSlavesCount - 刷新在线从节点且超时时间小于配置的从节点数量</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">refreshGoodSlavesCount</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    listIter li<span class="token punctuation">;</span>    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>    <span class="token keyword">int</span> good <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 没有配置这 2 个配置, 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>server<span class="token punctuation">.</span>repl_min_slaves_to_write <span class="token operator">||</span> <span class="token operator">!</span>server<span class="token punctuation">.</span>repl_min_slaves_max_lag<span class="token punctuation">)</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 遍历当前所有的从节点, 找出状态为 SLAVE_STATE_ONLINE 和 超时时间小于配置的 repl_min_slaves_max_lag 的节点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        client <span class="token operator">*</span>slave <span class="token operator">=</span> ln<span class="token operator">-></span>value<span class="token punctuation">;</span>        <span class="token class-name">time_t</span> lag <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime <span class="token operator">-</span> slave<span class="token operator">-></span>repl_ack_time<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>slave<span class="token operator">-></span>replstate <span class="token operator">==</span> SLAVE_STATE_ONLINE <span class="token operator">&amp;&amp;</span> lag <span class="token operator">&lt;=</span> server<span class="token punctuation">.</span>repl_min_slaves_max_lag<span class="token punctuation">)</span>             good<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 更新个数</span>    server<span class="token punctuation">.</span>repl_good_slaves_count <span class="token operator">=</span> good<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="12-cancelReplicationHandshake-从节点取消和主节点的握手"><a href="#12-cancelReplicationHandshake-从节点取消和主节点的握手" class="headerlink" title="12 cancelReplicationHandshake - 从节点取消和主节点的握手"></a>12 cancelReplicationHandshake - 从节点取消和主节点的握手</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_TRANSFER<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">replicationAbortSyncTransfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECT<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_CONNECTING <span class="token operator">||</span> <span class="token function">slaveIsInHandshakeState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">undoConnectWithMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECT<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="13-feedReplicationBacklogWithObject-向复制积压缓冲区-backlog-写数据"><a href="#13-feedReplicationBacklogWithObject-向复制积压缓冲区-backlog-写数据" class="headerlink" title="13 feedReplicationBacklogWithObject - 向复制积压缓冲区 backlog 写数据"></a>13 feedReplicationBacklogWithObject - 向复制积压缓冲区 backlog 写数据</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">feedReplicationBacklogWithObject</span><span class="token punctuation">(</span>robj <span class="token operator">*</span>o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> llstr<span class="token punctuation">[</span>LONG_STR_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> len<span class="token punctuation">;</span>    <span class="token comment">// 写入的对象为 int 整数, 转为字符串处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>encoding <span class="token operator">==</span> OBJ_ENCODING_INT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        len <span class="token operator">=</span> <span class="token function">ll2string</span><span class="token punctuation">(</span>llstr<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>llstr<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>o<span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> llstr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        len <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>o<span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> o<span class="token operator">-></span>ptr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">feedReplicationBacklog</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="13-1-feedReplicationBacklog-更新复制积压缓冲区-backlog"><a href="#13-1-feedReplicationBacklog-更新复制积压缓冲区-backlog" class="headerlink" title="13.1 feedReplicationBacklog - 更新复制积压缓冲区 backlog"></a>13.1 feedReplicationBacklog - 更新复制积压缓冲区 backlog</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">feedReplicationBacklog</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> ptr<span class="token punctuation">;</span>    <span class="token comment">// 更新全局复制的偏移量</span>    server<span class="token punctuation">.</span>master_repl_offset <span class="token operator">+=</span> len<span class="token punctuation">;</span>    <span class="token comment">// 复制积压缓冲区, 随着是一个字符串数组, 但是可以看成是一个环形的, 写的尾部</span>    <span class="token comment">// 会重新回到头部继续写, 所以每次写入时, 都需要更新写入位置的索引 repl_backlog_idx</span>    <span class="token comment">// 写入的对象的长度不为 0, 就一直写 </span>    <span class="token keyword">while</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 计算环形缓冲区还有多少空间</span>        <span class="token class-name">size_t</span> thislen <span class="token operator">=</span> server<span class="token punctuation">.</span>repl_backlog_size <span class="token operator">-</span> server<span class="token punctuation">.</span>repl_backlog_idx<span class="token punctuation">;</span>        <span class="token comment">// 如果空间足够，设置 thislen 写的长度为 len</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>thislen <span class="token operator">></span> len<span class="token punctuation">)</span>             thislen <span class="token operator">=</span> len<span class="token punctuation">;</span>        <span class="token comment">// 空间不足够或着刚刚好，那么只写入剩余的空间数，等待下次循环时写入</span>        <span class="token comment">// 将数据拷贝到复制积压缓冲区中    </span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog<span class="token operator">+</span>server<span class="token punctuation">.</span>repl_backlog_idx<span class="token punctuation">,</span>p<span class="token punctuation">,</span>thislen<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新下次写的下标</span>        server<span class="token punctuation">.</span>repl_backlog_idx <span class="token operator">+=</span> thislen<span class="token punctuation">;</span>        <span class="token comment">// 如果 repl_backlog_idx 已经到达缓冲区的尾部，那么重置它</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_idx <span class="token operator">==</span> server<span class="token punctuation">.</span>repl_backlog_size<span class="token punctuation">)</span>            server<span class="token punctuation">.</span>repl_backlog_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 更新未写入的数据长度    </span>        len <span class="token operator">-=</span> thislen<span class="token punctuation">;</span>        <span class="token comment">// 更新未写入数据的地址</span>        p <span class="token operator">+=</span> thislen<span class="token punctuation">;</span>        <span class="token comment">// 更新实际数据的长度</span>        server<span class="token punctuation">.</span>repl_backlog_histlen <span class="token operator">+=</span> thislen<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 实际数据的长度最大只能为复制缓冲区的大小，因为之后环形写入时会覆盖开头位置的数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog_histlen <span class="token operator">></span> server<span class="token punctuation">.</span>repl_backlog_size<span class="token punctuation">)</span>        server<span class="token punctuation">.</span>repl_backlog_histlen <span class="token operator">=</span> server<span class="token punctuation">.</span>repl_backlog_size<span class="token punctuation">;</span>    <span class="token comment">// 设置 backlog 所备份已复制的数据的偏移量，用于处理复制时的断线</span>    server<span class="token punctuation">.</span>repl_backlog_off <span class="token operator">=</span> server<span class="token punctuation">.</span>master_repl_offset <span class="token operator">-</span> server<span class="token punctuation">.</span>repl_backlog_histlen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="14-replicationSendAck-从节点发送心跳-ack-给主节点"><a href="#14-replicationSendAck-从节点发送心跳-ack-给主节点" class="headerlink" title="14 replicationSendAck - 从节点发送心跳 ack 给主节点"></a>14 replicationSendAck - 从节点发送心跳 ack 给主节点</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationSendAck</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    client <span class="token operator">*</span>c <span class="token operator">=</span> server<span class="token punctuation">.</span>master<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        c<span class="token operator">-></span>flags <span class="token operator">|=</span> CLIENT_MASTER_FORCE_REPLY<span class="token punctuation">;</span>        <span class="token function">addReplyMultiBulkLen</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 内容: REPLCONF ACK repl_offset</span>        <span class="token function">addReplyBulkCString</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"REPLCONF"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addReplyBulkCString</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"ACK"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addReplyBulkLongLong</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>c<span class="token operator">-></span>reploff<span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token operator">-></span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>CLIENT_MASTER_FORCE_REPLY<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;1-replicationUnsetMaster-断开主从关系&quot;&gt;&lt;a href=&quot;#1-replicationUnsetMaster-断开主从关系&quot; class=&quot;headerlink&quot; title=&quot;1 replicationUnsetMaster  - </summary>
        
      
    
    
    
    
    <category term="Redis" scheme="https://github.com/Lcn29/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 主从复制 - 源码</title>
    <link href="https://github.com/Lcn29/article/2024/3467330528/"/>
    <id>https://github.com/Lcn29/article/2024/3467330528/</id>
    <published>2024-08-26T14:18:00.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<p>因为主从复制的过程很复杂, 同时核心逻辑主要集中在 <strong>replication.c</strong> 这个文件中, 避免篇幅过大, 所以将主从复制中涉及这个文件的代码集中到了另一篇文章。<br>在当前文章主要分析主从复制的大体代码逻辑, 如果需要了解整体的过程, 可以配合 <a href="https://lcn29.github.io/article/2024/3467330524/">Redis 主从复制 - relication 源码分析</a> 这篇文章。</p><h2 id="1-主从节点建立连接准备"><a href="#1-主从节点建立连接准备" class="headerlink" title="1 主从节点建立连接准备"></a>1 主从节点建立连接准备</h2><p>Redis 主从节点建立连接的 3 种方式, 本质都是从节点执行 <strong>slaveof</strong> 命令, 和父节点建立初步的关联关系。<br>这个命令执行的方法为 <strong>replicaofCommand</strong> (高版本的 Redis 可以通过 replicaof 达到 slaveof 的效果)。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicaofCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 开启了集群功能, 直接返回, 集群模式不允许执行 slaveof </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster_enabled<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReplyError</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"REPLICAOF not allowed in cluster mode."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 第一参数为 no, 第二个参数为 one</span>    <span class="token comment">// slaveof no one, 可以让从节点和主节点断开连接, 停止主从复制 </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"no"</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 取消复制操作, 同时设置当前节点为主节点</span>            <span class="token comment">// 具体代码逻辑, 可以查看 replication 文章的 replicationUnsetMaster 方法解析</span>            <span class="token comment">// 1. 置空 server.masterhost </span>            <span class="token comment">// 2. 将第一组 replid 和 offset 赋值到第二组, 重试生成一个 replid</span>            <span class="token comment">// 3. 置空 server.cached_server</span>            <span class="token comment">// 4. 如果在传输 RDB 文件中或者处于握手阶段, 进行取消, 同时取消和主节点的连接</span>            <span class="token comment">// 5. 如果有从节点, 释放所有的从节点客户端, 也就是断开从节点的连接</span>            <span class="token comment">// 6. 当前节点的状态变为 REPL_STATE_NONE (普通状态, 无主从复制状态)</span>            <span class="token function">replicationUnsetMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 获取 client 的每种信息, 并以 sds 形式返回, 并打印到日志中</span>            sds client <span class="token operator">=</span> <span class="token function">catClientInfoString</span><span class="token punctuation">(</span><span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sdsfree</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 本身是一个从节点了, 无法在执行 salveof ip 端口</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_SLAVE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">addReplyError</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token string">"Command is not valid when client is a replica."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 从入参中获取端口</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">getLongFromObjectOrReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>port<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment">// 已经有主节点了, 同时主节点的的 host 和 ip 和入参的相同</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost<span class="token punctuation">,</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>masterport <span class="token operator">==</span> port<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              <span class="token function">addReplySds</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token function">sdsnew</span><span class="token punctuation">(</span><span class="token string">"+OK Already connected to specified master\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 保存主节点信息并进入待连接状态</span>        <span class="token comment">// 具体代码逻辑, 可以查看 replication 文章的 replicationSetMaster 方法解析</span>        <span class="token comment">// 1. 保存主节点的 IP 和 端口到 server.masterhost 和 server.masterport</span>        <span class="token comment">// 2. 解除所有阻塞状态的客户端</span>        <span class="token comment">// 3. 释放所有的从节点信息</span>        <span class="token comment">// 4. 取消主从复制的握手操作</span>        <span class="token comment">// 5. 当前节点如果没有主节点, 为 server.cached_server 赋值一个默认生成的 client</span>        <span class="token comment">// 6. 设置当前的节点的状态为 REPL_STATE_CONNECT (待连接上主节点)</span>        <span class="token function">replicationSetMaster</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 响应客户端 ok</span>    <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>ok<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/66de83f8d9c307b7e9880337.png" alt="Alt &#39;主从节点建立连接准备&#39;"></p><p>主从复制的第一步逻辑</p><ol><li>将入参的主节点的 ip 和 port 保存在 server </li><li>创建出一个代表主节点的客户端 client, 赋值给 server.cached_server (如果是一开始是从节点, 重启了, 这一步未必会有)</li><li>当前从节点的节点状态变更为 REPL_STATE_CONNECT (开启了主从复制, 但是还没连接上主节点)</li></ol><p>执行完上的逻辑后, salveof (replicaof) 就结束的, 但是整个的主从复制还没有开始, 可以得出 salveof 是一个异步的命令。<br>接下来的步骤则是由定时函数 serverCron 定时的调用。</p><h2 id="2-主从节点建立-TCP-连接"><a href="#2-主从节点建立-TCP-连接" class="headerlink" title="2 主从节点建立 TCP 连接"></a>2 主从节点建立 TCP 连接</h2><p>在第一步中, 只是将主节点的信息保存到从节点中就结束了, 之间还是没有建立起相关的网络连接的, 第二步就是完成这个网络连接的操作。<br>而这个网络连接建立的触发是通过定时函数执行的</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 定时 1 秒执行一次</span>    <span class="token function">run_with_period</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token function">replicationCron</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span></code></pre><p>replicationCron 里面涉及到了大量的逻辑, 基本整个复制运行阶段的状态判断等都是在里面判断的, 这里只截取了涉及到当前步骤相关的逻辑。<br>在第一步操作完成后, 可以知道从节点当前的状态为 <strong>REPL_STATE_CONNECT</strong>。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationCron</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 当前的状态为 REPL_STATE_CONNECT (开启了主从复制, 但是还没连接上主节点)</span>    <span class="token comment">// 顺利执行了 salveof 后, 从节点的默认状态</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_CONNECT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 尝试连接主节点, 连接成功后, 从节点的状态会变为 REPL_STATE_CONNECTING (正在连接主节点)</span>        <span class="token comment">// 具体代码逻辑, 可以查看 replication 文章的 connectWithMaster 方法解析</span>        <span class="token comment">// 1. 通过保存的 ip 和 port 和主节点建立一个 TCP 连接</span>        <span class="token comment">// 2. 向事件轮询添加对应的 TCP 通道的读写事件, 执行的函数为 syncWithMaster</span>        <span class="token comment">// 3. 更新当前节点的状态为 REPL_STATE_CONNECTING (正在连接主节点)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connectWithMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/66de83f6d9c307b7e987fa57.png" alt="Alt &#39;主从节点建立 TCP 连接&#39;"></p><p>主从复制的第二步逻辑 </p><ol><li>和主节点建立起了 TCP 连接</li><li>向事件轮询注册一个读写事件, 触发的函数为 connectWithMaster, 同时这个函数会在下次事件轮询时自动执行一次</li><li>将当前节点的状态更新为 REPL_STATE_CONNECTING (从节点开始连接主节点)</li></ol><h2 id="3-发送-PING-命令"><a href="#3-发送-PING-命令" class="headerlink" title="3 发送 PING 命令"></a>3 发送 PING 命令</h2><h3 id="3-1-从节点发送-PING-命令给主节点"><a href="#3-1-从节点发送-PING-命令给主节点" class="headerlink" title="3.1 从节点发送 PING 命令给主节点"></a>3.1 从节点发送 PING 命令给主节点</h3><p>在第二步的步骤中, 通过保存的主节点 ip 和 port 建立起 TCP 连接后, 会向事件轮询中注册一个 AE_READABLE|AE_WRITABLE 的事件。<br>读写同时注册时, 会自动触发一次, 也就是在下次事件轮询中会执行到其注册的函数 syncWithMaster 函数, 所以第三步的入口就是这个函数了。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 入参中的 fd 就是和主节点建立的 Socket 连接的文件描述符</span><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sockerr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">socklen_t</span> errlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sockerr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">UNUSED</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>privdata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 状态为 REPL_STATE_NONE, 关闭对应的文件描述符</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_NONE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 检查当前的 Socket 通道的状态</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getsockopt</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_ERROR<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sockerr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>errlen<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">// 获取异常信息</span>        sockerr <span class="token operator">=</span> errno<span class="token punctuation">;</span>    <span class="token comment">// 有异常信息</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sockerr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> error<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 从节点和父节点建立了 Socket 后的第一个状态为 REPL_STATE_CONNECTING</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_CONNECTING<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 删除当前这个 Socket 的可写事件, 不关心写事件</span>        <span class="token function">aeDeleteFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>AE_WRITABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 状态修改为 REPL_STATE_RECEIVE_PONG (发送 pong, 等待 ping 回答)</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_RECEIVE_PONG<span class="token punctuation">;</span>                <span class="token comment">// 发送同步命令, 也就是 ping 到主节点, SYNC_CMD_WRITE = 1</span>        <span class="token comment">// 具体代码逻辑, 可以查看 replication 文章的 sendSynchronousCommand 方法解析</span>        err <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_WRITE<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token string">"PING"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>             <span class="token keyword">goto</span> write_error<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>error<span class="token operator">:</span>    <span class="token function">aeDeleteFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>AE_READABLE<span class="token operator">|</span>AE_WRITABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dfd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">close</span><span class="token punctuation">(</span>dfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_transfer_s <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECT<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>write_error<span class="token operator">:</span>     <span class="token comment">// 从节点向父节点发送 SYNC_CMD_WRITE 失败时的处理逻辑</span>    <span class="token function">sdsfree</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">goto</span> error<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-2-主节点发送-Pong-响应从节点的-Ping-命令"><a href="#3-2-主节点发送-Pong-响应从节点的-Ping-命令" class="headerlink" title="3.2 主节点发送 Pong 响应从节点的 Ping 命令"></a>3.2 主节点发送 Pong 响应从节点的 Ping 命令</h3><p>主节点收到了从节点的 Ping 命令后, 处理正常后, 会响应一个 Pong 的命令。</p><p><strong>主节点</strong> 执行的 Ping 命令的逻辑如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">pingCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ping 命令的参数只能是 1 个或者 0 个</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>argc <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReplyErrorFormat</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"wrong number of arguments for '%s' command"</span><span class="token punctuation">,</span> c<span class="token operator">-></span>cmd<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 对应的客户端处于 Pub/Sub 模式</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_PUBSUB<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>mbulkhdr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addReplyBulkCBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"pong"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>argc <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token function">addReplyBulkCBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">addReplyBulk</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 其他模式</span>        <span class="token comment">// 参数是 1 个, 响应一个 pong</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>argc <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>pong<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// 响应入参的第 2 个参数</span>            <span class="token function">addReplyBulk</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-3-从节点收到主节点的响应的-Pong-命令"><a href="#3-3-从节点收到主节点的响应的-Pong-命令" class="headerlink" title="3.3 从节点收到主节点的响应的 Pong 命令"></a>3.3 从节点收到主节点的响应的 Pong 命令</h3><p><strong>从节点</strong> 收到了主节点发送过来的 Pone 响应命令, 这时会触发在上面第 2 步对 Socket 连接建立的可读事件。<br>当事件轮询循环中找到了可读事件, 又执行到 <strong>syncWithMaster</strong> 函数</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>        <span class="token comment">// 当前从节点处于 REPL_STATE_RECEIVE_PONG 状态 (发送 ping, 等待 pong  应答)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_PONG<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 读取主节点响应的信息</span>        err <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_READ<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 异常情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'+'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">strncmp</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span><span class="token string">"-NOAUTH"</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">strncmp</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span><span class="token string">"-ERR operation not permitted"</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">sdsfree</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">goto</span> error<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 响应的是 Pong, 能继续处理</span>        <span class="token punctuation">&#125;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 状态切换到 REPL_STATE_SEND_AUTH, 等待认证结果应答</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_AUTH<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/66dee096d9c307b7e923fa2d.png" alt="Alt &#39;发送 PING 命令&#39;"></p><p>主从复制的第三步逻辑</p><ol><li>从节点向主节点发送了一个 Ping 命令, 自身状态由 REPL_STATE_CONNECTING (从节点开始连接主节点) 变为 REPL_STATE_RECEIVE_PONG (等待主节点响应 Pong 命令)</li><li>主节点收到从节点发送的 Ping 命令, 向其响应了一个 Pong 命令</li><li>从节点收到主节点响应的 Pong 命令, 会将其自身的状态从 REPL_STATE_RECEIVE_PONG (等待主节点响应 Pong 命令) 变为 REPL_STATE_SEND_AUTH (准备发送认证)</li></ol><p>主要是通过发送 Ping 命令和接受主节点响应的 Pong 命令, 初步确定双方网络的正常</p><h2 id="4-密码认证"><a href="#4-密码认证" class="headerlink" title="4 密码认证"></a>4 密码认证</h2><p>在从节点发送 Ping, 主节点响应 Pong , 从节点收到 Pong 响应后, 进入处理时 (syncWithMaster 函数),<br>状态修改为 <strong>REPL_STATE_SEND_AUTH</strong> 后, 方法继续执行下去, 立即进入密码认证的过程。</p><h3 id="4-1-从节点发送认证密码"><a href="#4-1-从节点发送认证密码" class="headerlink" title="4.1 从节点发送认证密码"></a>4.1 从节点发送认证密码</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 当前从节点处于 REPL_STATE_RECEIVE_PONG 状态 (发送 ping, 等待 pong  应答)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_PONG<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>        <span class="token comment">// 状态切换到 REPL_STATE_SEND_AUTH, 准备发送认证</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_AUTH<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 进入认证, 如果需要的话</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_SEND_AUTH<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 配置了主节点的密码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterauth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 发送认证请求和密码到主节点</span>            <span class="token comment">// auth 密码</span>            err <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_WRITE<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token string">"AUTH"</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>masterauth<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>                 <span class="token keyword">goto</span> write_error<span class="token punctuation">;</span>            <span class="token comment">// 状态切换为 REPL_STATE_RECEIVE_AUTH (等待认证结果响应)</span>            server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_RECEIVE_AUTH<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 不需要认证, 状态之间切换为 REPL_STATE_SEND_PORT 准备发送端口</span>            server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_PORT<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>从节点</strong>根据是否配置了主节点认证密码, 走不同的逻辑</p><ol><li>配置了认证密码, 发送<strong>auth 密码</strong>给主节点, 同时状态变为 REPL_STATE_RECEIVE_AUTH (等待主节点响应认证结果应答)</li><li>没有配置认证密码, 直接将状态变为 REPL_STATE_SEND_PORT (准备发送从节点的监听的端口)</li></ol><h3 id="4-2-主节点响应-Auth-命令"><a href="#4-2-主节点响应-Auth-命令" class="headerlink" title="4.2 主节点响应 Auth 命令"></a>4.2 主节点响应 Auth 命令</h3><p><strong>主节点</strong>收到从节点的认证请求 auth, 就会进入到权限认证的过程,  执行的逻辑如下:</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">authCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 主节点不需要密码认证</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>server<span class="token punctuation">.</span>requirepass<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReplyError</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"Client sent AUTH, but no password is set"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">time_independent_strcmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span> server<span class="token punctuation">.</span>requirepass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 密码认证成功  </span>        c<span class="token operator">-></span>authenticated <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>ok<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 密码认证失败  </span>        c<span class="token operator">-></span>authenticated <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">addReplyError</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"invalid password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>主节点</strong>收到从节点的 auth 命令后</p><ol><li>本身没有设置密码, 直接返回错误</li><li>收到的密码和自身配置的密码一样, 返回成功</li><li>收到的密码和自身配置的密码不一样, 返回错误</li></ol><h3 id="4-3-从节点收到-Auth-命令的响应结果"><a href="#4-3-从节点收到-Auth-命令的响应结果" class="headerlink" title="4.3 从节点收到 Auth 命令的响应结果"></a>4.3 从节点收到 Auth 命令的响应结果</h3><p>同 <strong>Ping Pong</strong> 的处理逻辑一样, 这时<strong>从节点</strong>读取到主节点的响应, 事件轮询触发 <strong>syncWithMaster</strong> 函数</p><pre class="language-C" data-language="C"><code class="language-C">void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) &#123;    &#x2F;&#x2F; 当前从节点处于 REPL_STATE_RECEIVE_PONG 状态 (发送 ping, 等待 pong  应答)    if (server.repl_state &#x3D;&#x3D; REPL_STATE_RECEIVE_PONG) &#123;        &#x2F;&#x2F; 省略         &#x2F;&#x2F; 状态切换为 REPL_STATE_RECEIVE_AUTH (等待认证结果响应)        server.repl_state &#x3D; REPL_STATE_RECEIVE_AUTH;        return;    &#125;    &#x2F;&#x2F; 接收到请求认证的响应    if (server.repl_state &#x3D;&#x3D; REPL_STATE_RECEIVE_AUTH) &#123;        &#x2F;&#x2F; 读取响应信息        err &#x3D; sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);                &#x2F;&#x2F; 认证失败        if (err[0] &#x3D;&#x3D; &#39;-&#39;) &#123;            sdsfree(err);            goto error;        &#125;        &#x2F;&#x2F; 认证成功        sdsfree(err);        &#x2F;&#x2F; 状态变为 REPL_STATE_SEND_PORT (准备发送从节点的监听的端口)        server.repl_state &#x3D; REPL_STATE_SEND_PORT;    &#125;&#125;</code></pre><p><img src="https://pic.imgdb.cn/item/66dee099d9c307b7e923fd75.png" alt="Alt &#39;密码认证&#39;"></p><p>主从复制的第四步逻辑</p><ol><li>如果从节点没有配置 masterauth, 则直接进入下一个阶段, 状态从 REPL_STATE_SEND_AUTH (准备发送认证) 直接变为 REPL_STATE_SEND_PORT (准备发送从节点的监听的端口)</li><li>如果有配置 masterauth, 则会<blockquote><p>1 从节点向主节点发送了 Auth 密码 的命令给主节点, 自身状态由 REPL_STATE_SEND_AUTH (准备发送认证) 变为 REPL_STATE_RECEIVE_AUTH (等待认证结果响应)<br>2 主节点收到从节点发送的 Auth 密码, 在确定没错后, 向其响应了一个 ok 的字符串<br>3 从节点收到主节点响应的 ok, 会将其自身的状态从 REPL_STATE_RECEIVE_AUTH (等待认证结果响应) 变为 REPL_STATE_SEND_PORT (准备发送从节点的监听的端口)</p></blockquote></li></ol><p>第四步, 通过配置的密码和主节点进行认证(如果需要的话), 在认证成功或无需认证后, 进入到 REPL_STATE_SEND_PORT (准备发送从节点的监听的端口)</p><h2 id="5-发送端口号"><a href="#5-发送端口号" class="headerlink" title="5 发送端口号"></a>5 发送端口号</h2><p>在不需要权限认证或者从节点收到主节点的权限认证成功后, 此时从节点的状态为 <strong>REPL_STATE_SEND_PORT</strong>, 顺着上一步的处理逻辑中, 继续处理</p><h3 id="5-1-发送从节点主从复制的端口"><a href="#5-1-发送从节点主从复制的端口" class="headerlink" title="5.1 发送从节点主从复制的端口"></a>5.1 发送从节点主从复制的端口</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 收到权限认证的响应</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_AUTH<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 配置了主节点的密码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterauth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 不需要认证, 状态之间切换为 REPL_STATE_SEND_PORT 准备发送端口</span>            server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_PORT<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 接收到请求认证的响应</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_AUTH<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>        <span class="token comment">// 状态变为 REPL_STATE_SEND_PORT (准备发送从节点的监听的端口)</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_PORT<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 进入发送端口阶段</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_SEND_PORT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果有配置一个专门复制的端口的话, 使用配置的端口, 没有使用当前服务器的端口</span>        sds port <span class="token operator">=</span> <span class="token function">sdsfromlonglong</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slave_announce_port <span class="token operator">?</span> server<span class="token punctuation">.</span>slave_announce_port <span class="token operator">:</span> server<span class="token punctuation">.</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 发送端口信息给主节点 命令: replconf listening-port 端口</span>        err <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_WRITE<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token string">"REPLCONF"</span><span class="token punctuation">,</span> <span class="token string">"listening-port"</span><span class="token punctuation">,</span> port<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>             <span class="token keyword">goto</span> write_error<span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 切换状态为 REPL_STATE_RECEIVE_PORT (等待主节点响应收到从节点端口)</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_RECEIVE_PORT<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>向主节点发送自己的主从复制的端口</p><h3 id="5-2-主节点响应从节点的发送端口命令"><a href="#5-2-主节点响应从节点的发送端口命令" class="headerlink" title="5.2 主节点响应从节点的发送端口命令"></a>5.2 主节点响应从节点的发送端口命令</h3><p><strong>主节点</strong>收到从节点的发送端口请求 replconf listening-port 端口, 执行的逻辑如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replconfCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token comment">// 参数需要是 2 的倍数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argc <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>syntaxerr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> c<span class="token operator">-></span>argc<span class="token punctuation">;</span> j<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 每个循环使用 2 个参数</span>        <span class="token comment">// replconf listening-port port</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"listening-port"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">long</span> port<span class="token punctuation">;</span>            <span class="token comment">// 获取下一个项, 也就是端口号</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">getLongFromObjectOrReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>port<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token comment">// 保存到对应的客户端的 slave_listening_port     </span>            c<span class="token operator">-></span>slave_listening_port <span class="token operator">=</span> port<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"ip-address"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"capa"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"ack"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"getack"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 响应错误</span>            <span class="token function">addReplyErrorFormat</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"Unrecognized REPLCONF option: %s"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 响应 OK </span>    <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>ok<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到主节点收到从节点发送过来的端口</p><ol><li>会保存到从节点客户端 client 的 slave_listening_port 字段</li><li>响应一个 ok 字符串</li></ol><h3 id="5-3-从节点收到主节点对自己发送端口命令的响应"><a href="#5-3-从节点收到主节点对自己发送端口命令的响应" class="headerlink" title="5.3 从节点收到主节点对自己发送端口命令的响应"></a>5.3 从节点收到主节点对自己发送端口命令的响应</h3><p>收到主节点的响应后, 从节点同样是事件轮询触发 <strong>syncWithMaster</strong> 函数</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 进入发送端口阶段</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_SEND_PORT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>        <span class="token comment">// 切换状态为 REPL_STATE_RECEIVE_PORT (等待主节点响应收到从节点端口)</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_RECEIVE_PORT<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// REPL_STATE_RECEIVE_PORT 等待主节点响应发送端口请求的响应</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_PORT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        err <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_READ<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 状态变为 REPL_STATE_SEND_IP, 准备发送 IP 到主节点</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_IP<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/66dee09bd9c307b7e923ff2c.png" alt="Alt &#39;发送端口号&#39;"></p><p>主从复制的第五步逻辑</p><ol><li>从节点向主节点发送 replconf listening-port 自身的端口给主节点, 同时进入到 REPL_STATE_RECEIVE_PORT (等待主节点响应收到从节点端口请求)</li><li>主节点收到 replconf listening-port 从节点的端口 命令后, 将其存到自身维护的客户端对象的 slave_listening_port 字段, 向其响应了一个 ok 的字符串</li><li>从节点收到主节点响应的 ok, 会将其自身的状态从 REPL_STATE_RECEIVE_PORT 变为 REPL_STATE_SEND_IP (发送主从复制配置的监听的 IP 地址)</li></ol><h2 id="6-发送-IP-地址"><a href="#6-发送-IP-地址" class="headerlink" title="6 发送 IP 地址"></a>6 发送 IP 地址</h2><p>从节点收到主节点对 <strong>replconf listening-port 端口</strong> 的响应后, 从节点会将状态修改为 <strong>REPL_STATE_SEND_IP</strong>, 然后顺着逻辑走下去</p><h3 id="6-1-发送从节点主从复制的-Ip"><a href="#6-1-发送从节点主从复制的-Ip" class="headerlink" title="6.1 发送从节点主从复制的 Ip"></a>6.1 发送从节点主从复制的 Ip</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// REPL_STATE_RECEIVE_PORT 等待主节点响应发送 IP 请求的响应</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_PORT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>        <span class="token comment">// 状态变为 REPL_STATE_SEND_IP, 准备发送 IP 到主节点</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_IP<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// slave_announce_ip 为空 (没有配置指定的 IP), 直接跳过发送 IP 的阶段</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_SEND_IP <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>slave_announce_ip <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 进入下一个节点 准备发送从节点的发送能力</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_CAPA<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_SEND_IP<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 发送 replconf ip-address ip</span>        err <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_WRITE<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token string">"REPLCONF"</span><span class="token punctuation">,</span> <span class="token string">"ip-address"</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>slave_announce_ip<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>             <span class="token keyword">goto</span> write_error<span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 状态变为 REPL_STATE_RECEIVE_IP (等待主节点响应收到从节点的 IP 地址)</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_RECEIVE_IP<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>从节点进入发送 IP 地址阶段时, 除了状态需要为 REPL_STATE_SEND_IP (准备发送 IP 地址阶段), 还必须有指定 slave_announce_ip, 从节点的 IP (对应配置文件的 slave-announce-ip),<br>2 个条件都满足的情况下, 才会真正的进入发送 Ip 地址, 否则直接进入下一阶段 REPL_STATE_SEND_CAPA (准备发送从节点支持的复制能力)。</p><h3 id="6-2-主节点响应从节点的发送-Ip-命令"><a href="#6-2-主节点响应从节点的发送-Ip-命令" class="headerlink" title="6.2 主节点响应从节点的发送 Ip 命令"></a>6.2 主节点响应从节点的发送 Ip 命令</h3><p><strong>主节点</strong>收到从节点的发送的 <strong>replconf ip-address Ip</strong> 请求, 执行的逻辑如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replconfCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token comment">// 参数需要是 2 的倍数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argc <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>syntaxerr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> c<span class="token operator">-></span>argc<span class="token punctuation">;</span> j<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 每个循环使用 2 个参数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"listening-port"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"ip-address"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// replconf ip-address Ip</span>            <span class="token comment">// 获取对应的从节点发送的 Ip </span>            sds ip <span class="token operator">=</span> c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">;</span>            <span class="token comment">// Ip 的长度判断</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sdslen</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>c<span class="token operator">-></span>slave_ip<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 保存到客户端的 client 的 slave_ip 属性</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>c<span class="token operator">-></span>slave_ip<span class="token punctuation">,</span>ip<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 错误提示</span>                <span class="token function">addReplyErrorFormat</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"REPLCONF ip-address provided by replica instance is too long: %zd bytes"</span><span class="token punctuation">,</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"capa"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"ack"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"getack"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 响应错误</span>            <span class="token function">addReplyErrorFormat</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"Unrecognized REPLCONF option: %s"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 响应 OK </span>    <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>ok<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到主节点收到从节点发送过来的 Ip</p><ol><li>会保存到从节点客户端 client 的 slave_ip 字段</li><li>响应一个 ok 字符串</li></ol><h3 id="6-3-从节点收到主节点对自己发送-Ip-命令的响应"><a href="#6-3-从节点收到主节点对自己发送-Ip-命令的响应" class="headerlink" title="6.3 从节点收到主节点对自己发送 Ip 命令的响应"></a>6.3 从节点收到主节点对自己发送 Ip 命令的响应</h3><p><strong>从节点</strong>收到主节点的响应后, 同样是由事件轮询触发 <strong>syncWithMaster</strong> 函数</p><pre class="language-C" data-language="C"><code class="language-C">void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) &#123;    &#x2F;&#x2F; 省略    &#x2F;&#x2F; 收到主节点对发送 IP 请求的响应    if (server.repl_state &#x3D;&#x3D; REPL_STATE_RECEIVE_IP) &#123;        err &#x3D; sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);        sdsfree(err);        &#x2F;&#x2F; 状态变为等待发送发送能力状态        server.repl_state &#x3D; REPL_STATE_SEND_CAPA;    &#125;&#125;</code></pre><p><img src="https://pic.imgdb.cn/item/66dee09dd9c307b7e924025a.png" alt="Alt &#39;发送 IP 地址&#39;"></p><p>主从复制的第六步逻辑</p><ol><li>如果没有配置从节点用于主从复制的专门 Ip, 则直接进入到 REPL_STATE_SEND_CAPA (准备发送从节点支持的同步能力)</li><li>如果配置了专门的主从复制 Ip<blockquote><p>1 从节点向主节点发送 replconf ip-address Ip, 同时进入到 REPL_STATE_RECEIVE_IP (等待主节点响应收到从节点的 IP 地址)<br>2 主节点收到 replconf ip-address Ip 命令后, 将其存到自身维护的客户端对象的 slave_ip 字段, 向其响应了一个 ok 的字符串<br>3 从节点收到主节点对自身的 replconf 命令的响应后, 将自身从 REPL_STATE_RECEIVE_PORT 切换到 REPL_STATE_SEND_CAPA (准备发送从节点支持的同步能力)</p></blockquote></li></ol><h2 id="7-发送支持的同步能力"><a href="#7-发送支持的同步能力" class="headerlink" title="7 发送支持的同步能力"></a>7 发送支持的同步能力</h2><p>收到主节点响应的 Ip 请求, 从节点的状态切换为了 REPL_STATE_SEND_CAPA (准备发送从节点支持的复制能力),<br>如果从节点没有配置  slave-announce-ip, 也就不会有发送 IP 相关的操作, 也会直接过度到 REPL_STATE_SEND_CAPA。<br>这一步主要是兼容不同版本的 Redis, 主节点需要知道当前从节点支持的复制能力, 才可以决定如何和从节点进行数据复制。</p><p>状态切换到 REPL_STATE_SEND_CAPA 后, 会继续下面的逻辑, 同样在 <strong>syncWithMaster</strong> 函数。</p><h3 id="7-1-发送从节点支持的复制能力"><a href="#7-1-发送从节点支持的复制能力" class="headerlink" title="7.1 发送从节点支持的复制能力"></a>7.1 发送从节点支持的复制能力</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 没有配置宣布的 IP, slave_announce_ip 为空, 直接跳过发送 IP 的阶段</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_SEND_IP <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>slave_announce_ip <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 进入下一个节点 准备发送从节点的发送能力</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_CAPA<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 省略</span>    <span class="token comment">// 收到主节点对发送 IP 请求的响应</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_IP<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 状态变为等待发送发送能力状态</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_CAPA<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_SEND_CAPA<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 发送从节点支持的复制能力到主节点 </span>        <span class="token comment">// replconf capa eof capa psync2</span>        err <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_WRITE<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token string">"REPLCONF"</span><span class="token punctuation">,</span> <span class="token string">"capa"</span><span class="token punctuation">,</span> <span class="token string">"eof"</span><span class="token punctuation">,</span> <span class="token string">"capa"</span><span class="token punctuation">,</span> <span class="token string">"psync2"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">goto</span> write_error<span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 状态修改为 REPL_STATE_RECEIVE_CAPA, 等待主节点响应发送能力的应答</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_RECEIVE_CAPA<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>从节点发送过去的支持的 2 种复制能力</p><blockquote><ol><li>eof: 全量复制, 正常 全量复制时, 主节点将数据持久化为一个文件, 然后将文件发送给从节点, EOF 则表示直接将数据通过 Socket 直接发送给从节点</li><li>psync2: 部分复制, 利用复制积压缓冲区等实现部分复制</li></ol></blockquote><h3 id="7-2-主节点响应从节点的复制能力请求"><a href="#7-2-主节点响应从节点的复制能力请求" class="headerlink" title="7.2 主节点响应从节点的复制能力请求"></a>7.2 主节点响应从节点的复制能力请求</h3><p><strong>主节点</strong>收到从节点的 <strong>replconf capa eof capa psync2</strong> 请求后, 执行的逻辑如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replconfCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token comment">// 参数需要是 2 的倍数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argc <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>syntaxerr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> c<span class="token operator">-></span>argc<span class="token punctuation">;</span> j<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 每个循环使用 2 个参数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"listening-port"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"ip-address"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"capa"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"eof"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment">// SLAVE_CAPA_EOF = 1</span>                c<span class="token operator">-></span>slave_capa <span class="token operator">|=</span> SLAVE_CAPA_EOF<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"psync2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment">// SLAVE_CAPA_PSYNC2 = 2 </span>                c<span class="token operator">-></span>slave_capa <span class="token operator">|=</span> SLAVE_CAPA_PSYNC2<span class="token punctuation">;</span>                            <span class="token comment">// 如果不支持的能力, 不做处理</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"ack"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"getack"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 响应错误</span>            <span class="token function">addReplyErrorFormat</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"Unrecognized REPLCONF option: %s"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 响应 OK </span>    <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>ok<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>主节点收到从节点发送的复制能力</p><ol><li>会保存到从节点客户端 client 的 slave_capa 字段</li><li>响应一个 ok 字符串</li></ol><h3 id="7-3-从节点收到主节点对自己发送支持的复制能力-命令的响应"><a href="#7-3-从节点收到主节点对自己发送支持的复制能力-命令的响应" class="headerlink" title="7.3 从节点收到主节点对自己发送支持的复制能力 命令的响应"></a>7.3 从节点收到主节点对自己发送支持的复制能力 命令的响应</h3><p><strong>从节点</strong>收到主节点的响应后, 从节点同样是事件轮询触发 <strong>syncWithMaster</strong> 函数</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>    <span class="token comment">// 读取主节点发送过来的信息</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_CAPA<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        err <span class="token operator">=</span> <span class="token function">sendSynchronousCommand</span><span class="token punctuation">(</span>SYNC_CMD_READ<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 变更状态为 REPL_STATE_SEND_PSYNC (向主节点发送 psync 命令, 请求同步复制)</span>        <span class="token comment">// 向主节点发送 psync 命令, 请求全量复制</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_PSYNC<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/66dee09fd9c307b7e924055f.png" alt="Alt &#39;发送支持的同步能力&#39;"></p><p>主从复制的第七步逻辑</p><ol><li>从节点向主节点发送 replconf capa eof capa psync2, 同时进入到 REPL_STATE_RECEIVE_CAPA (等待主节点响应收到支持的复制能力的应答)</li><li>主节点收到 replconf capa eof capa psync2 命令后, 将其存到自身维护的客户端对象的 slave_capa 字段</li><li>从节点收到主节点对自身的 replconf 命令的响应后, 将自身从 REPL_STATE_RECEIVE_CAPA 切换到 REPL_STATE_SEND_PSYNC (向主节点发送 psync 命令, 请求同步复制)</li></ol><h2 id="8-发送-PSYNC-命令"><a href="#8-发送-PSYNC-命令" class="headerlink" title="8 发送 PSYNC 命令"></a>8 发送 PSYNC 命令</h2><p>上面 7 步只是主从复制前的准备, 而到了 psync 这步, 就是真正的复制开始了。而且这个过程涉及到全量复制 + 部分复制等情况, 有的绕。</p><h3 id="8-1-从节点发送-psync-命令-通知主节点开始复制"><a href="#8-1-从节点发送-psync-命令-通知主节点开始复制" class="headerlink" title="8.1 从节点发送 psync 命令, 通知主节点开始复制"></a>8.1 从节点发送 psync 命令, 通知主节点开始复制</h3><p><strong>从节点</strong>收到了主节点对其同步能力的响应后, 接着会发送一个 psync 的命令给主节点, 这个请求就是同步复制的真正开始了</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 读取主节点发送过来的信息</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_RECEIVE_CAPA<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>        <span class="token comment">// 向主节点发送 psync 命令, 请求全量复制</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_SEND_PSYNC<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 发送 psync 命令</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">==</span> REPL_STATE_SEND_PSYNC<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 入参的 0 表示写消息给主节点, 1 表示从主节点读取数据</span>        <span class="token comment">// 入参 0 的逻辑, 根据当前是否缓存了主节点 (cached_master 是否为空), 来发送 psync 命令, 为空, 发送全量复制请求, 不为空, 发送部分复制请求</span>        <span class="token comment">// 部分复制, 最终发送的命令 psync replid repl_offset (主节点还是会判断这 2 个的值, 最终决定是全量还是部分)</span>        <span class="token comment">// 全量复制, 最终发送的命令 psync ? -1</span>        <span class="token comment">// 具体代码逻辑, 可以查看 replication 文章的 slaveTryPartialResynchronization 方法解析</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">slaveTryPartialResynchronization</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> PSYNC_WRITE_ERROR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            err <span class="token operator">=</span> <span class="token function">sdsnew</span><span class="token punctuation">(</span><span class="token string">"Write error sending the PSYNC command."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">goto</span> write_error<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 切换状态为 REPL_STATE_RECEIVE_PSYNC (等待 psync 应答)</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_RECEIVE_PSYNC<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>slaveTryPartialResynchronization 函数可以根据入参进行写消息给主节点和读取主节点消息, 因为上面只涉及到写的操作，下面梳理的是写部分的逻辑</p><blockquote><ol><li>声明了 2 个变量 psync_replid 和 psync_offset, 前者用来存储缓存主节点的 replid, 后者存储的是当前从节点同步复制积压缓冲区的位置</li><li>首先根据自身保存的 server.cached_master 是否为空, 得出 2 个变量的值</li><li>如果 server.cached_master 不为空, psync_replid 等于 cached_master.replid, psync_offset 等于 cached_master.reploff + 1</li><li>如果 server.cached_master 为空, psync_replid 等于 ?, psync_offset 等于 -1</li><li>server.cached_master 不为空, 表示从节点上次是有主节点的, 当前可能是重启等情况, 导致从节点重新走了一次复制的流程, 可以尝试进行部分复制, 不进行全量复制</li><li>向主节点发送 psync <psync_replid> <psync_offset>, 也就是 psync ? -1 或者 psync replid offset, 后者主节点收到后会直接判定为全量复制, 后者主节点会判断是否可进行部分复制</li></ol></blockquote><p>上面就是 slaveTryPartialResynchronization 写操作的逻辑, 也是从节点向主节点发送 psync 的过程</p><h3 id="8-2-主节点收到-psync-命令-为开始复制做准备"><a href="#8-2-主节点收到-psync-命令-为开始复制做准备" class="headerlink" title="8.2 主节点收到 psync 命令, 为开始复制做准备"></a>8.2 主节点收到 psync 命令, 为开始复制做准备</h3><p><strong>主节点</strong>收到从节点的发送过来的同步请求命令 psync, 执行的逻辑如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 客户端不是从节点, 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_SLAVE<span class="token punctuation">)</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 当前节点是另一个节点的从节点, 同时节点的状态不是 REPL_STATE_CONNECTED (已经连接状态), 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>repl_state <span class="token operator">!=</span> REPL_STATE_CONNECTED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReplySds</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token function">sdsnew</span><span class="token punctuation">(</span><span class="token string">"-NOMASTERLINK Can't SYNC while not connected with my master\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 判断 client c 的 bufpos != 0 || reply 有数据</span>    <span class="token comment">// 也就是判断当前节点有数据准备发送给从节点, 是的话, 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReplyError</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"SYNC and PSYNC are invalid with pending output"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 执行的命令为 psync</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span> <span class="token string">"psync"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// psync repl_id repl_offset</span>        <span class="token comment">// 主节点尝试进行部分同步复制 </span>        <span class="token comment">// 可以部分复制 stat_sync_partial_ok 部分复制次数 + 1, 然后直接结束</span>        <span class="token comment">// 这段代码的核心, 尝试进行部分复制, 不行返回内会返回 C_ERR, 走到下面全量复制的逻辑</span>        <span class="token comment">// 可以结合下面的说明继续分析</span>        <span class="token comment">// 具体代码逻辑, 可以查看 replication 文章的 masterTryPartialResynchronization 方法解析</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">masterTryPartialResynchronization</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            server<span class="token punctuation">.</span>stat_sync_partial_ok<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">char</span> <span class="token operator">*</span>master_replid <span class="token operator">=</span> c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">;</span>                <span class="token comment">// 从节点指定了 replid, 但是现在部分复制失败了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>master_replid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'?'</span><span class="token punctuation">)</span>             <span class="token comment">// 部分同步复制失败次数 + 1</span>            server<span class="token punctuation">.</span>stat_sync_partial_err<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 执行的命令不是 psync, 按照 sync 命令处理</span>        c<span class="token operator">-></span>flags <span class="token operator">|=</span> CLIENT_PRE_PSYNC<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 全量复制 --> 可以结合下面的 8.2.1 一起使用 </span>    <span class="token comment">// 全量复制次数 + 1</span>    server<span class="token punctuation">.</span>stat_sync_full<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 修改从节点的状态为 SLAVE_STATE_WAIT_BGSAVE_START (等待 bgsave 的开始, 也就是 RDB 文件的创建)</span>    c<span class="token operator">-></span>replstate <span class="token operator">=</span> SLAVE_STATE_WAIT_BGSAVE_START<span class="token punctuation">;</span>        <span class="token comment">// 关闭了 TCP_NODELAY 功能</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_disable_tcp_nodelay<span class="token punctuation">)</span>        <span class="token comment">// 启用 nagle 算法</span>        <span class="token function">anetDisableTcpNoDelay</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> c<span class="token operator">-></span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>      c<span class="token operator">-></span>repldbfd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 客户端设置从节点标识</span>    c<span class="token operator">-></span>flags <span class="token operator">|=</span> CLIENT_SLAVE<span class="token punctuation">;</span>    <span class="token comment">// 把当前的客户端添加到从节点列表</span>    <span class="token function">listAddNodeTail</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果有需要, 创建复制积压缓冲区</span>    <span class="token comment">// 条件: 从节点只有 1 个, 复制积压缓冲区为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>repl_backlog <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 生成 replid, 存放到 server.replid 中</span>        <span class="token function">changeReplicationId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 清除 replid2 和 second_replid_offset</span>        <span class="token comment">// 具体逻辑可以查看 replication 文章的 clearReplicationId2 方法解析</span>        <span class="token function">clearReplicationId2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 创建复制积压缓冲区</span>        <span class="token function">createReplicationBacklog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>rdb_child_type <span class="token operator">==</span> RDB_CHILD_TYPE_DISK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 正在执行 RDB, 同时类型是写入磁盘</span>        client <span class="token operator">*</span>slave<span class="token punctuation">;</span>        listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>        listIter li<span class="token punctuation">;</span>                <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 遍历所有的从节点, 找到第一个节点的状态为 SLAVE_STATE_WAIT_BGSAVE_END (等待 bgsave 的结束, 即等待 RDB 文件的创建结束)</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            slave <span class="token operator">=</span> ln<span class="token operator">-></span>value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slave<span class="token operator">-></span>replstate <span class="token operator">==</span> SLAVE_STATE_WAIT_BGSAVE_END<span class="token punctuation">)</span>                 <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 有找到对应的节点, 当前客户端的节点的复制能力和找到的节点的复制能力一样</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ln <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">-></span>slave_capa <span class="token operator">&amp;</span> slave<span class="token operator">-></span>slave_capa<span class="token punctuation">)</span> <span class="token operator">==</span> slave<span class="token operator">-></span>slave_capa<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 把找到的节点的输出缓存复制到当前的客户端</span>            <span class="token comment">// 将 slave 的 buf 拷贝到 c 的 buf</span>            <span class="token comment">// 将 slave 的 reply_bytes 拷贝到 c 的 reply_bytes, 响应缓冲区</span>            <span class="token comment">// 将 slave 的 bufpos 设置等于 c 的 bufpos</span>            <span class="token function">copyClientOutputBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>slave<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 更新从节点客户端的偏移量, 状态和发送全量复制消息给从节点</span>            <span class="token comment">// 这个命令会发送 FULLRESYNC replid offset\r\n 的响应给从节点, 可以看做是对 psync 命令的响应</span>            <span class="token comment">// 具体逻辑可以查看 replication 文章的 replicationSetupSlaveForFullResync 方法解析</span>            <span class="token function">replicationSetupSlaveForFullResync</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>slave<span class="token operator">-></span>psync_initial_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>rdb_child_type <span class="token operator">==</span> RDB_CHILD_TYPE_SOCKET<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 正在执行将主节点的数据写入到 Socket, 直接结束</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>             <span class="token comment">// 没有在执行 RDB </span>        <span class="token comment">// 复制类型为无盘同步 同时 当前的客户端支持 EOF 的同步方式</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_diskless_sync <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>slave_capa <span class="token operator">&amp;</span> SLAVE_CAPA_EOF<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 支持延迟无盘同步, 打印日志后结束</span>            <span class="token comment">// 后续在定时器执行的 replicationCron 函数时, 会创建出子进程进行同步</span>            <span class="token comment">// 延迟一段时间, 可以等待几个从节点, 后面同步处理</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 没有子进程正在执行 BGSAVE, 且没有进行写 AOF 文件, 则开始为复制执行 BGSAVE, 并且是将 RDB 文件写到磁盘上</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 内部和 RDB 的操作类似, 分为主子进程, fork 出子进程后, 子进程进行 RDB 的生成</span>                <span class="token comment">// 主进程也会通过 replicationSetupSlaveForFullResync 函数进行 psync 的应答</span>                <span class="token comment">// 具体逻辑可以查看 replication 文章的 startBgsaveForReplication 方法解析</span>                <span class="token function">startBgsaveForReplication</span><span class="token punctuation">(</span>c<span class="token operator">-></span>slave_capa<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>这段代码的核心 <strong>masterTryPartialResynchronization</strong>,<br>内部会根据 psync 的 2 个参数 repl_id + repl_offset 和自身的 replid 和 replid2 和复制积压缓冲区的情况, 判断是否走部分复制</p><blockquote><p>1 入参的 repl_id 和当前主节点的 replid 和 replid2 (自己保存的主节点的 id) 不一样<br>2 入参的 repl_id 和当前主节点的 repl_id2 一样, 但是 repl_offset 和当前主节点的 second_replid_offset 大 (以前同步于同一个主节点, 但是现在的从节点比自己同步的快)<br>3 请求的偏移量 repl_offset 小于 repl_backlog_off (复制积压缓冲区最老的位置) , 说明 backlog 所备份的数据的已经太新了, 需要的已经不在复制积压缓冲区中<br>4 请求的偏移量 repl_offset 大于 repl_backlog_off + repl_backlog_histlen (复制积压缓冲区的容量大小) , 表示当前 backlog 的数据不够全，从节点超过了复制积压缓冲区的最新数据了, 需要进行全量复制</p></blockquote><p>出现上面 4 种情况的其中一种, 就会进入到全量复制</p><h4 id="8-2-1-masterTryPartialResynchronization-判断需要全量复制"><a href="#8-2-1-masterTryPartialResynchronization-判断需要全量复制" class="headerlink" title="8.2.1 masterTryPartialResynchronization 判断需要全量复制"></a>8.2.1 masterTryPartialResynchronization 判断需要全量复制</h4><ol><li>设置当前的客户端为 SLAVE_STATE_WAIT_BGSAVE_START (等待 bgsave 开始, 也就是 RDB 文件的创建)</li><li>把当前的客户端加入维护的<strong>从节点客户端列表</strong>中</li><li>如果从节点客户端列表只有 1 个节点同时复制积压缓冲区为空, 创建复制积压缓冲区</li><li>如果当前主节点在执行自身的持久化 RDB, 并且从<strong>节点客户端列表</strong>中找到第一个状态为 SLAVE_STATE_WAIT_BGSAVE_END (等待 RDB 创建文件结束) 同时复制能力和自己一样的<blockquote><p>4.1 将这个节点的响应缓冲区的数据拷贝一份到自己的输出缓冲区 (自身不需要在去触发一次 RDB 了, 复用它已有的输出数据)<br>4.2 修改状态为自身的状态为 SLAVE_STATE_WAIT_BGSAVE_END (等待 RDB 创建文件结束)<br>4.3 同时向从节点发送 +FULLRESYNC replid offset\r\n (避免从节点发一次全量复制就触发一次 RDB, 复用已有的)<br>4.4 发送 +FULLRESYNC replid offset\r\n 给从节点 </p></blockquote></li><li>如果当前主节点在执行主从复制的 RDB, 直接结束方法, 避免大量的子进程写文件, 拖垮主节点</li><li>当前的主节点支持<strong>无盘延迟同步</strong>同时当前从节点支持 <strong>EOF 也就是网络同步</strong>, 那么先结束, 后续由定时任务触发 replicationCron 函数, 创建 RDB 文件, 这样可以延迟同步, 延迟的这段时间可能等到其他需要全量复制和同配置的从节点, 到时可以 bgsave 出一个文件, 共用 (replicationCron 1s 触发一次, 每次会检查所有的从节点和当前主节点的上次交流的时间差, 有一个超过了配置的 repl_diskless_sync_delay 时间, 就立即主从复制)</li><li>当前主节点在 AOF 持久化中, 提前结束</li><li>如果当前的从节点支持 EOF 复制能力同时主节点设置了支持无盘同步<blockquote><p>8.1 在<strong>节点客户端列表</strong>中找到所有状态为 SLAVE_STATE_WAIT_BGSAVE_START (等待 bgsave 开始, 也就是开始创建 RDB 文件) 并且支持 psync 命令的客户端, 发送 +FULLRESYNC replid offset\r\n, 并修改状态为 SLAVE_STATE_WAIT_BGSAVE_END (等待 RDB 创建文件结束)<br>8.2 fork 出一个子进程, 将当前主节点的数据以 EOF 要求的格式写入到满足上一步的所有从节点的 Socket 中, 并阻塞住, 全部写完后一次性全部发送过期</p></blockquote></li><li>如果当前的从节点不支持 EOF 复制能力<blockquote><blockquote><p>9.1 fork 出一个子进程, 将当前主节点的数据按照 RDB 的方式保存到文件中<br>9.1 在<strong>节点客户端列表</strong> 中找到所有状态为 SLAVE_STATE_WAIT_BGSAVE_START (等待 bgsave 开始, 也就是开始创建 RDB 文件) 并且支持 psync 命令的客户端, 发送 +FULLRESYNC replid offset\r\n, 并修改状态为 SLAVE_STATE_WAIT_BGSAVE_END (等待 RDB 创建文件结束)</p></blockquote></blockquote></li></ol><h4 id="8-2-2-masterTryPartialResynchronization-判断可以部分复制"><a href="#8-2-2-masterTryPartialResynchronization-判断可以部分复制" class="headerlink" title="8.2.2 masterTryPartialResynchronization 判断可以部分复制"></a>8.2.2 masterTryPartialResynchronization 判断可以部分复制</h4><ol><li>设置当前的从节点 repl_put_online_on_ack 为 0, 也就是还未 ack </li><li>把当前的从节点加入动节点客户端列表</li><li>如果当前的从节点支持 psync2 则向其发送 +CONTINUE 主节点当前的 repl_id \r\n, 否则发送 +CONTINUE\r\n</li><li>根据入参的 repl_offset 从复制积压缓冲区获取对应的数据, 写入到客户端的输出缓冲区中</li></ol><p>上面就是主节点收到从节点 psync 命令, 为开始复制做准备, 虽然全量复制和部分部分复制有些不同, 但是都可以简单的看为, 将复制的数据写入到从节点的输出缓冲区中, 等待发送。</p><h3 id="8-3-从节点收到主节点对-psync-命令的响应"><a href="#8-3-从节点收到主节点对-psync-命令的响应" class="headerlink" title="8.3 从节点收到主节点对 psync 命令的响应"></a>8.3 从节点收到主节点对 psync 命令的响应</h3><p><strong>从节点</strong>收到主节点的响应后, 从节点同样是事件轮询触发 <strong>syncWithMaster</strong> 函数。</p><p>在从节点发送出 <strong>psync</strong> 命令后, 状态为 <strong>REPL_STATE_RECEIVE_PSYNC (等待 psync 应答)</strong>, 继续从这个状态走下去</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 状态不是 REPL_STATE_RECEIVE_PSYNC 直接失败</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_state <span class="token operator">!=</span> REPL_STATE_RECEIVE_PSYNC<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> error<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 读取主节点的响应, 如果是全量复制, 响应为 PSYNC_FULLRESYNC, 部分复制, 响应为 PSYNC_CONTINUE</span>    <span class="token comment">// 具体逻辑可以查看 replication 文章的 slaveTryPartialResynchronization 方法读的部分逻辑</span>    psync_result <span class="token operator">=</span> <span class="token function">slaveTryPartialResynchronization</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 等待重新执行</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>psync_result <span class="token operator">==</span> PSYNC_WAIT_REPLY<span class="token punctuation">)</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>     <span class="token comment">// 主节点正处于暂时性错误状态</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>psync_result <span class="token operator">==</span> PSYNC_TRY_LATER<span class="token punctuation">)</span>         <span class="token keyword">goto</span> error<span class="token punctuation">;</span>    <span class="token comment">// psync 命令主节点完成, 判断可以部分复制, 从节点可以继续执行其他的, 到这步直接结束</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>psync_result <span class="token operator">==</span> PSYNC_CONTINUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 释放所有的从节点连接</span>    <span class="token function">disconnectSlaves</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 清空已有的复制积压缓冲区</span>    <span class="token comment">// 具体逻辑可以查看 replication 文章的 freeReplicationBacklog 方法解析</span>    <span class="token function">freeReplicationBacklog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 主节点无法识别 psync, 需要尝试执行 sync </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>psync_result <span class="token operator">==</span> PSYNC_NOT_SUPPORTED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 不支持 psync, 则发送 sync</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">syncWrite</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token string">"SYNC\r\n"</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span>server<span class="token punctuation">.</span>repl_syncio_timeout<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">goto</span> error<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>            <span class="token keyword">char</span> tmpfile<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>err <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dfd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> maxtries <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment">// 尝试创建一个临时文件, 失败的话, 进行重试, 可以重试 5 次</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>maxtries<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 创建一个临时文件</span>        <span class="token function">snprintf</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token string">"temp-%d.%ld.rdb"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span>unixtime<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dfd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span>O_CREAT<span class="token operator">|</span>O_WRONLY<span class="token operator">|</span>O_EXCL<span class="token punctuation">,</span><span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dfd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 创建文件失败</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dfd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> error<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 为创建的文件描述符 添加可读事件, 用来下载监听到的数据, 也就是父级发送过来的 RDB, 处理函数为 readSyncBulkPayload</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">,</span> readSyncBulkPayload<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> AE_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> error<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 修改状态为 REPL_STATE_TRANSFER (开始接收 RDB 文件)</span>    server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_TRANSFER<span class="token punctuation">;</span>    <span class="token comment">// 更新复制相关变量的值</span>    server<span class="token punctuation">.</span>repl_transfer_size <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_transfer_read <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_transfer_last_fsync_off <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_transfer_fd <span class="token operator">=</span> dfd<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_transfer_lastio <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>repl_transfer_tmpfile <span class="token operator">=</span> <span class="token function">zstrdup</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>slaveTryPartialResynchronization 函数可以根据入参进行写消息给主节点和读取主节点消息, 这里需要读取主节点的响应数据, 所以下面梳理的是读部分的逻辑</p><ol><li>读取到的内容为 +FULLRESYNC<blockquote><p>1.1 将当前的从节点的 server 的 master_replid 和 master_initial_offset 设置为 +FULLRESYNC 后面的 replId 和 replId_offset<br>1.2 释放到 server.cached_master 的缓存主节点<br>1.3 返回 PSYNC_FULLRESYNC</p></blockquote></li><li>读取到的内容为 +CONTINUE<blockquote><p>2.1 获取 +CONTINUE 后面的 replId, 如果和已有的 server.cached_master 的 replId 不一致, 则将 server.cached_master 的 replId 和 offset 变为 replId2 和 offset2, 参数的 replId 变为 server.cached_master 的 replId, 同时断开所有自己所有从节点的连接<br>2.2 将原本的 server.cached_master 晋升为 server.master, server.cached_master 变为 null<br>2.3 将当前的从节点状态变为 REPL_STATE_CONNECTED (已连接上主节点)<br>2.4 为当前的主节点注册一个可读的事件, 执行函数为 readQueryFromClient<br>2.5 返回 PSYNC_CONTINUE</p></blockquote></li></ol><p>上面就是 slaveTryPartialResynchronization 读操作的逻辑, 整合 syncWithMaster 的 REPL_STATE_RECEIVE_PSYNC 状态的核心逻辑如下</p><ol><li>收到了 +FULLRESYNC<blockquote><p>1.1 创建一个临时的 RDB 文件, 向事件轮询注册一个可读的事件, 执行函数 readSyncBulkPayload, 用于将主节点发送的数据写入到临时文件中和其他的逻辑<br>1.2 自身状态变更为 REPL_STATE_TRANSFER (开始接收 RDB 文件)<br>1.3 更新自身的主从复制相关的信息</p></blockquote></li></ol><p>全量复制整个过程串起来如下:<br><img src="https://pic.imgdb.cn/item/66def5fad9c307b7e94f1d76.png" alt="Alt &#39;psync 命令, 判断为全量复制&#39;"></p><ol start="2"><li>收到了 +CONTINUE<blockquote><p>2.1 将当前的从节点状态变为 REPL_STATE_CONNECTED (已连接上主节点)<br>2.2 向事件轮询注册一个可读的事件, 执行函数 readQueryFromClient, 用于读取并处理主节点发送过来的命令</p></blockquote></li></ol><p>部分复制整个过程串起来如下:<br><img src="https://pic.imgdb.cn/item/66def5fdd9c307b7e94f250a.png" alt="Alt &#39;psync命令, 判断为部分复制&#39;"></p><h2 id="9-主节点向从节点推送数据"><a href="#9-主节点向从节点推送数据" class="headerlink" title="9 主节点向从节点推送数据"></a>9 主节点向从节点推送数据</h2><p>上面的步骤基本就是主从节点为数据同步做的前期准备, 主从节点只是做好了发送同步数据的准备, 实际此时还是没有数据的复制的 (无盘同步先写入到 Socket, 写完直接全部发送, 因为有不确定暂时认为未复制)。  </p><p>从第 8 位可以知道, 在主节点将自身的数据发送给从节点的方式有 2 种</p><blockquote><p>1 只能全量复制, 主节点所有数据的以 RDB 数据发送给从节点, 这里又细分为 2 种, 无盘同步, 直接将数据通过 Socket 发送过去, 非无盘同步, 先将数据保存为 rdb 文件, 再发送文件<br>2 可以部分复制, 从主节点复制积压缓冲区中获取的数据</p></blockquote><p>对于这 2 种数据, 主节点有 2 种方式发送数据给从节点。</p><h3 id="9-1-主节点和从节点全量复制的数据"><a href="#9-1-主节点和从节点全量复制的数据" class="headerlink" title="9.1 主节点和从节点全量复制的数据"></a>9.1 主节点和从节点全量复制的数据</h3><h4 id="9-1-1-主节点向推送节点全量复制的数据"><a href="#9-1-1-主节点向推送节点全量复制的数据" class="headerlink" title="9.1.1 主节点向推送节点全量复制的数据"></a>9.1.1 主节点向推送节点全量复制的数据</h4><p>前期的准备完成后, 主节点会尝试发送数据到从节点, 触发发送的链路如下:</p><ol><li>定时函数 serverCron, 判断出当前的 RDB 子进程不为空, 同时子进行已经完成, 触发 backgroundSaveDoneHandler 函数</li><li>backgroundSaveDoneHandler 中无论什么类型的 RDB (Socket&#x2F;磁盘), 都会走到 updateSlavesWaitingBgsave 函数</li><li>updateSlavesWaitingBgsave 中, 遍历所有的从节点<blockquote><p>4.1 所有从节点中任意有一个的状态为 SLAVE_STATE_WAIT_BGSAVE_START (等待 bgsave 开始, 也就是开始创建 RDB 文件), 触发第 8.2.1 中第 8 步的逻辑<br>4.2 遍历的从节点状态等于 SLAVE_STATE_WAIT_BGSAVE_END 并且同步类型为 Socket 同步, 则当前的从节点的状态变为 SLAVE_STATE_ONLINE (在线), 同时 repl_put_online_on_ack &#x3D; 1, 从节点已 ack<br>4.3 遍历的从节点状态等于 SLAVE_STATE_WAIT_BGSAVE_END 并且同步类型不是 Socket 同步, 向事件轮询注册发送数据事件 sendBulkToSlave, 从节点的状态变为 SLAVE_STATE_SEND_BULK (批量发送数据中)</p></blockquote></li></ol><pre class="language-C" data-language="C"><code class="language-C">void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) &#123;    client *slave &#x3D; privdata;    UNUSED(el);    UNUSED(mask);    char buf[PROTO_IOBUF_LEN];    ssize_t nwritten, buflen;        &#x2F;&#x2F; 发送序言, 这里只是简单发送出了文件的大小, 格式 $&lt;length&gt;\r\n&quot;    if (slave-&gt;replpreamble) &#123;        nwritten &#x3D; write(fd,slave-&gt;replpreamble,sdslen(slave-&gt;replpreamble));        if (nwritten &#x3D;&#x3D; -1) &#123;            freeClient(slave);            return;        &#125;        &#x2F;&#x2F; 更新已经写到网络的字节数        server.stat_net_output_bytes +&#x3D; nwritten;        &#x2F;&#x2F; 保留未写的字节, 删除已写的字节        sdsrange(slave-&gt;replpreamble,nwritten,-1);        &#x2F;&#x2F; 如果已经写完了, 则释放 replpreamble        if (sdslen(slave-&gt;replpreamble) &#x3D;&#x3D; 0) &#123;            sdsfree(slave-&gt;replpreamble);            &#x2F;&#x2F; 设置为 null, 下次进来不会再触发            slave-&gt;replpreamble &#x3D; NULL;        &#125; else &#123;            return;        &#125;    &#125;        &#x2F;&#x2F; slave-&gt;repldbfd 代表 RDB 文件    &#x2F;&#x2F; 将文件指针移动到 slave-&gt;repldboff 位置, 准备读操作    lseek(slave-&gt;repldbfd, slave-&gt;repldboff, SEEK_SET);    &#x2F;&#x2F; PROTO_IOBUF_LEN &#x3D; 1024 * 16, 16kb    &#x2F;&#x2F; 从 RDB 文件的 slave-&gt;repldboff 位置读取 16k 数据的内容保存在 buf 中    buflen &#x3D; read(slave-&gt;repldbfd, buf, PROTO_IOBUF_LEN);        &#x2F;&#x2F; 读取不到数据, 结束    if (buflen &lt;&#x3D; 0) &#123;        freeClient(slave);        return;    &#125;        &#x2F;&#x2F; 将读取到的 16k 数据写到从节点    if ((nwritten &#x3D; write(fd, buf, buflen)) &#x3D;&#x3D; -1) &#123;        &#x2F;&#x2F; 写入失败        if (errno !&#x3D; EAGAIN) &#123;            freeClient(slave);        &#125;        return;    &#125;        &#x2F;&#x2F; 到了这里, 大概可以理解这个发送 RDB 文件的过程不是一次性的    &#x2F;&#x2F; 每次发送 16k, 下次事件轮询触发, 再触发发送 16k, 知道全部写完    &#x2F;&#x2F; 更新主节点已经向从节点同步的字节数    slave-&gt;repldboff +&#x3D; nwritten;    &#x2F;&#x2F; 更新服务器已经写到网络的字节数    server.stat_net_output_bytes +&#x3D; nwritten;    &#x2F;&#x2F; 如果写入完成, 即从网络读到的大小等于文件大小, 写完了    if (slave-&gt;repldboff &#x3D;&#x3D; slave-&gt;repldbsize) &#123;        &#x2F;&#x2F; 关闭 RDB 文件流        close(slave-&gt;repldbfd);        slave-&gt;repldbfd &#x3D; -1;        &#x2F;&#x2F; 删除等待从节点的文件可写事件        aeDeleteFileEvent(server.el, slave-&gt;fd, AE_WRITABLE);        &#x2F;&#x2F; 更新从节点的状态为 SLAVE_STATE_ONLINE (在线状态) 和 repl_put_online_on_ack &#x3D; 0 (ack 为未应答)        &#x2F;&#x2F; 为当前的从节点注册一个写事件, 触发函数为 sendReplyToClient, 将输出缓冲区中的数据发送给从节点, 也就是后续有新数据写给从节点, 就由 sendReplyToClient 触发发送        &#x2F;&#x2F; 具体逻辑可以查看 replication 文章的 putSlaveOnline 方法解析        putSlaveOnline(slave);    &#125;&#125; </code></pre><p>主节点的事件轮询触发 sendBulkToSlave 函数, 逻辑大体如下</p><ol><li>先向从节点发送了当前 RDB 文件的大小</li><li>间断地将 RDB 文件的数据按照 16k 的大小发送给从节点</li><li>RDB 文件全部写给从节点后, 修改从节点的状态为 SLAVE_STATE_ONLINE (在线), 但是 repl_put_online_on_ack &#x3D; 0, 从节点未来 ack</li></ol><h4 id="9-1-2-从节点接收主节点推送的全量复制的数据"><a href="#9-1-2-从节点接收主节点推送的全量复制的数据" class="headerlink" title="9.1.2 从节点接收主节点推送的全量复制的数据"></a>9.1.2 从节点接收主节点推送的全量复制的数据</h4><p>在 8.3 中从节点收到主节点对 psync 命令的响应, 判断到只能全量复制, 就注册了一个 readSyncBulkPayload 函数, 用来读取主节点发送过来的 RDB 数据</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">readSyncBulkPayload</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">4096</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">ssize_t</span> nread<span class="token punctuation">,</span> readlen<span class="token punctuation">,</span> nwritten<span class="token punctuation">;</span>    <span class="token class-name">off_t</span> left<span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>privdata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">char</span> eofmark<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">char</span> lastbytes<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> usemark <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 没有传输过任何数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_size <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 读取 1024 个字节的数据到 buf 中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">syncReadLine</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>repl_syncio_timeout<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">goto</span> error<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'-'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 主节点返回错误信息</span>            <span class="token keyword">goto</span> error<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 回复了一个空行, 只是为了像 ping 一样让连接存活, 只是简单的刷新了一些最新的传输时间</span>            server<span class="token punctuation">.</span>repl_transfer_lastio <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'$'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 协议格式错误</span>            <span class="token keyword">goto</span> error<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// CONFIG_RUN_ID_SIZE 40 </span>        <span class="token comment">// 响应的内容为 EOF: 同时 buf 第 5 位后的字符串长度大于 40 (replid 的最大长度)</span>        <span class="token comment">// Socket 方式发送过来的数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strncmp</span><span class="token punctuation">(</span>buf<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"EOF:"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">>=</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 使用 EOF 标记模式</span>            usemark <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">// 2 个静态变量, 主要是保存 EOF 的中的 replid</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>eofmark<span class="token punctuation">,</span> buf<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">,</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">memset</span><span class="token punctuation">(</span>lastbytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 修改为 0, 防止下次调用又跑到这段逻辑里面</span>            server<span class="token punctuation">.</span>repl_transfer_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 使用固定长度模式 (RDB 文件的方式, 主节点默认每次发送 16k 数据)</span>            usemark <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment">// 读取长度大小</span>            server<span class="token punctuation">.</span>repl_transfer_size <span class="token operator">=</span> <span class="token function">strtol</span><span class="token punctuation">(</span>buf<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 根据模式, 计算这次读多少数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>usemark<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 每次读取缓冲区大小的数据</span>        readlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 读取剩余数据与缓冲区大小的较小值</span>        left <span class="token operator">=</span> server<span class="token punctuation">.</span>repl_transfer_size <span class="token operator">-</span> server<span class="token punctuation">.</span>repl_transfer_read<span class="token punctuation">;</span>        readlen <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">signed</span><span class="token punctuation">)</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> left <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">signed</span><span class="token punctuation">)</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 读取数据到 buf 中</span>    nread <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nread <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 读取失败, 取消握手</span>        <span class="token comment">// 具体逻辑可以查看 replication 文章的 cancelReplicationHandshake 方法解析  </span>        <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    server<span class="token punctuation">.</span>stat_net_input_bytes <span class="token operator">+=</span> nread<span class="token punctuation">;</span>    <span class="token keyword">int</span> eof_reached <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>usemark<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 当使用 EOF 标记模式时，需要检测是否已经到达数据结尾</span>        <span class="token comment">// 更新 lastbytes 并检查是否匹配 EOF 标记</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nread <span class="token operator">>=</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>lastbytes<span class="token punctuation">,</span> buf<span class="token operator">+</span>nread<span class="token operator">-</span>CONFIG_RUN_ID_SIZE<span class="token punctuation">,</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> rem <span class="token operator">=</span> CONFIG_RUN_ID_SIZE <span class="token operator">-</span> nread<span class="token punctuation">;</span>            <span class="token function">memmove</span><span class="token punctuation">(</span>lastbytes<span class="token punctuation">,</span>lastbytes<span class="token operator">+</span>nread<span class="token punctuation">,</span>rem<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>lastbytes<span class="token operator">+</span>rem<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>nread<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 通过维护一个 lastbytes 数组，存储最近接收到的字节，与 eofmark 进行比较</span>        <span class="token comment">// 如果匹配，表示已经接收到完整的数据，设置 eof_reached 标志</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">memcmp</span><span class="token punctuation">(</span>lastbytes<span class="token punctuation">,</span> eofmark<span class="token punctuation">,</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>           eof_reached <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将读取到的数据写入到 repl_transfer_fd 临时文件中</span>    server<span class="token punctuation">.</span>repl_transfer_lastio <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> nread<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> nread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> error<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 更新同步的字节数</span>    server<span class="token punctuation">.</span>repl_transfer_read <span class="token operator">+=</span> nread<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>usemark <span class="token operator">&amp;&amp;</span> eof_reached<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// EOF 模式, 同时读取到末尾了</span>        <span class="token comment">// 计算文件 repl_transfer_read 的大小, 也就是把末尾的 40 个字节去掉</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ftruncate</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_fd<span class="token punctuation">,</span> server<span class="token punctuation">.</span>repl_transfer_read <span class="token operator">-</span> CONFIG_RUN_ID_SIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">goto</span> error<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 当前读取到的数据大于上次刷盘数据的 REPL_MAX_WRITTEN_BEFORE_FSYNC 8M, 进行刷盘</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_read <span class="token operator">>=</span> server<span class="token punctuation">.</span>repl_transfer_last_fsync_off <span class="token operator">+</span> REPL_MAX_WRITTEN_BEFORE_FSYNC<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">off_t</span> sync_size <span class="token operator">=</span> server<span class="token punctuation">.</span>repl_transfer_read <span class="token operator">-</span> server<span class="token punctuation">.</span>repl_transfer_last_fsync_off<span class="token punctuation">;</span>        <span class="token function">rdb_fsync_range</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_fd<span class="token punctuation">,</span> server<span class="token punctuation">.</span>repl_transfer_last_fsync_off<span class="token punctuation">,</span> sync_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>repl_transfer_last_fsync_off <span class="token operator">+=</span> sync_size<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 在固定长度模式下, 检查已读取的字节数是否等于预期的总长度, 确定传输是否完成</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>usemark<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_read <span class="token operator">==</span> server<span class="token punctuation">.</span>repl_transfer_size<span class="token punctuation">)</span>            eof_reached <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>eof_reached<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// aof 是否启用状态</span>        <span class="token keyword">int</span> aof_is_enabled <span class="token operator">=</span> server<span class="token punctuation">.</span>aof_state <span class="token operator">!=</span> AOF_OFF<span class="token punctuation">;</span>        <span class="token comment">// 当前节点在 RDB 中, 则结束掉这个 RDB 过程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">kill</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid<span class="token punctuation">,</span>SIGUSR1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rdbRemoveTempFile</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 最后一次刷盘</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fsync</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_fd<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 把从主节点同步的 RDB 文件重命名为真实的 RDB 文件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rename</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_tmpfile<span class="token punctuation">,</span>server<span class="token punctuation">.</span>rdb_filename<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 停止 AOF 写入, 防止在清空和加载数据时出现写时复制（COW）问题，导致内存占用过高</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>aof_is_enabled<span class="token punctuation">)</span> <span class="token function">stopAppendOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">signalFlushedDb</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">emptyDb</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>repl_slave_lazy_flush <span class="token operator">?</span> EMPTYDB_ASYNC <span class="token operator">:</span> EMPTYDB_NO_FLAGS<span class="token punctuation">,</span> replicationEmptyDbCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 删除文件事件，避免再次调用</span>        <span class="token function">aeDeleteFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> server<span class="token punctuation">.</span>repl_transfer_s<span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>        rdbSaveInfo rsi <span class="token operator">=</span> RDB_SAVE_INFO_INIT<span class="token punctuation">;</span>        <span class="token comment">// 将新的 RDB 文件数据加载到内存中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbLoad</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_filename<span class="token punctuation">,</span><span class="token operator">&amp;</span>rsi<span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 加载失败</span>            <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 重写开始 AOF 同步</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>aof_is_enabled<span class="token punctuation">)</span> <span class="token function">restartAOFAfterSYNC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 释放临时文件名的内存</span>        <span class="token function">zfree</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 关闭文件描述符</span>        <span class="token function">close</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 创建与主节点的新客户端连接, 同时指定数据库</span>        <span class="token function">replicationCreateMasterClient</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_transfer_s<span class="token punctuation">,</span> rsi<span class="token punctuation">.</span>repl_stream_db<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新复制状态为已连接, 重置下线时间</span>        server<span class="token punctuation">.</span>repl_state <span class="token operator">=</span> REPL_STATE_CONNECTED<span class="token punctuation">;</span>        server<span class="token punctuation">.</span>repl_down_since <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">,</span>server<span class="token punctuation">.</span>master<span class="token operator">-></span>replid<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>replid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>master_repl_offset <span class="token operator">=</span> server<span class="token punctuation">.</span>master<span class="token operator">-></span>reploff<span class="token punctuation">;</span>        <span class="token function">clearReplicationId2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token function">createReplicationBacklog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 有停掉的 AOF, 重新启动</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>aof_is_enabled<span class="token punctuation">)</span> <span class="token function">restartAOFAfterSYNC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>error<span class="token operator">:</span>    <span class="token function">cancelReplicationHandshake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/66def601d9c307b7e94f2d7c.png" alt="Alt &#39;全量复制, 主从节点推送数据&#39;"></p><p>readSyncBulkPayload 的逻辑算是比较清晰的, 主节点每次发送数据给从节点, 就触发一次 readSyncBulkPayload</p><ol><li>计算结束表示, EOF 方式 (Socket 同步) 数据以 EOF:40位的 replId 开始, 以 replId 结束, 而正常的 RDB 文件同步, 则会在以开始就发送数据的长度 </li><li>将读取到的数据写入到临时的 RDB 文件中</li><li>通过判断读取到的数据是否等于一开始读取到的 prelId 或者读取到的长度等于一开始读取到的长度, 确定是否已经读取完成了</li><li>读取到了末尾了, 将临时的 RDB 文件重命名为真实的 RDB 文件, 清空数据库, 删除注册的 readSyncBulkPayload 函数, 将 RDB 中的数据加载到内存中, 更新从节点的状态为 REPL_STATE_CONNECTED (主从节点连接中)</li></ol><p>到此, 从节点和主节点开始的全量复制完成了</p><h3 id="9-2-主节点向从节点推送部分复制的数据"><a href="#9-2-主节点向从节点推送部分复制的数据" class="headerlink" title="9.2 主节点向从节点推送部分复制的数据"></a>9.2 主节点向从节点推送部分复制的数据</h3><p>主节点向从节点推送部分复制的数据这个, 只需要了解赋值积压缓冲区存储的内容是 Redis 执行的请求命令, 就很容易了。</p><p>复制积压缓冲区是一个大小为 1M 的循环队列。主节点在命令传播时, 不仅会将命令发送给所有的从节点, 还会将命令写入复制积压缓冲区中。<br>复制积压缓冲区最多可以备份 1M 大小的数据, 主节点会不断往里面写新的数据, 同时淘汰旧的。如果主从节点断线时间过长, 复制积压缓冲区的数据被新数据覆盖, 旧节点需要的数据已经不在里面, 就只能走全量复制, 否则可以从断开的位置继续同步复制积压缓冲区中的数据。</p><p>在 8.2.2 中判断可以部分复制时, 主节点的逻辑就是将复制积压缓冲区中将从节点指定的 repl_offset 后面的请求命令发送给从节点<br>从节点收到对应的命令重新执行一遍, 同时更新一下自己维护的 repl_offset 就行了</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">processCommand</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 执行命令成功, 更新主从复制同步的偏移量</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_MASTER <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_MULTI<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            c<span class="token operator">-></span>reploff <span class="token operator">=</span> c<span class="token operator">-></span>read_reploff <span class="token operator">-</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-></span>querybuf<span class="token punctuation">)</span> <span class="token operator">+</span> c<span class="token operator">-></span>qb_pos<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/66def604d9c307b7e94f338b.png" alt="Alt &#39;部分复制, 主从节点推送数据&#39;"></p><p>到此, 从节点和主节点开始的部分复制完成了</p><h2 id="10-运行中的数据同步-命令传播"><a href="#10-运行中的数据同步-命令传播" class="headerlink" title="10 运行中的数据同步 - 命令传播"></a>10 运行中的数据同步 - 命令传播</h2><p>经过 psync 命令后, 也就是第一次复制后, 主从节点之间数据都同步了, 但是后续如果主节点继续数据的变更, 又会不一致。<br>为了数据的一致, 主节点应该有种方式将自身的变更同步到从节点, 这个实现的步骤就是命令传播。</p><p>在执行 Redis 命令的函数 call 中, 里面会根据执行的命令和客户端的类型等元素, 判断是否需要执行 propagate 函数, propagate 函数就是命令传播的方法。<br>propagate 函数很简单根据入参的标识判断是否需要进行复制传播, 如果判断为是, 会执行 replicationFeedSlaves 方法</p><p>replicationFeedSlaves 方法的执行逻辑如下:</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replicationFeedSlaves</span><span class="token punctuation">(</span>list <span class="token operator">*</span>slaves<span class="token punctuation">,</span> <span class="token keyword">int</span> dictid<span class="token punctuation">,</span> robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">int</span> argc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>    listIter li<span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token punctuation">,</span> len<span class="token punctuation">;</span>    <span class="token keyword">char</span> llstr<span class="token punctuation">[</span>LONG_STR_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 有配置主节点, 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 没有复制积压缓冲区 backlog 且没有从节点, 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> <span class="token function">listLength</span><span class="token punctuation">(</span>slaves<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaveseldb <span class="token operator">!=</span> dictid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果当前从节点使用的数据库不是目标的数据库, 则要生成一个 select 命令</span>        robj <span class="token operator">*</span>selectcmd<span class="token punctuation">;</span>        <span class="token comment">// 0 &lt;= id &lt; 10, 可以使用共享的 select 命令对象</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dictid <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dictid <span class="token operator">&lt;</span> PROTO_SHARED_SELECT_CMDS<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            selectcmd <span class="token operator">=</span> shared<span class="token punctuation">.</span>select<span class="token punctuation">[</span>dictid<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 按照协议格式构建 select 命令对象</span>            <span class="token keyword">int</span> dictid_len<span class="token punctuation">;</span>            dictid_len <span class="token operator">=</span> <span class="token function">ll2string</span><span class="token punctuation">(</span>llstr<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>llstr<span class="token punctuation">)</span><span class="token punctuation">,</span>dictid<span class="token punctuation">)</span><span class="token punctuation">;</span>            selectcmd <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span>OBJ_STRING<span class="token punctuation">,</span> <span class="token function">sdscatprintf</span><span class="token punctuation">(</span><span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n"</span><span class="token punctuation">,</span> dictid_len<span class="token punctuation">,</span> llstr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 把当前的 select 命令写入到复制积压缓冲区</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog<span class="token punctuation">)</span>             <span class="token comment">// 具体逻辑可以查看 replication 文章的 feedReplicationBacklogWithObject 方法解析</span>            <span class="token function">feedReplicationBacklogWithObject</span><span class="token punctuation">(</span>selectcmd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">listRewind</span><span class="token punctuation">(</span>slaves<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 遍历所有的从节点</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            client <span class="token operator">*</span>slave <span class="token operator">=</span> ln<span class="token operator">-></span>value<span class="token punctuation">;</span>            <span class="token comment">// 从节点服务器状态为等待 bgsave 的开始, 因此跳过回复, 遍历下一个节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slave<span class="token operator">-></span>replstate <span class="token operator">==</span> SLAVE_STATE_WAIT_BGSAVE_START<span class="token punctuation">)</span>                 <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment">// 添加 select 命令到当前从节点的回复中    </span>            <span class="token function">addReply</span><span class="token punctuation">(</span>slave<span class="token punctuation">,</span>selectcmd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 释放临时对象</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dictid <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> dictid <span class="token operator">>=</span> PROTO_SHARED_SELECT_CMDS<span class="token punctuation">)</span>            <span class="token function">decrRefCount</span><span class="token punctuation">(</span>selectcmd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 设置当前从节点使用的数据库 ID</span>    server<span class="token punctuation">.</span>slaveseldb <span class="token operator">=</span> dictid<span class="token punctuation">;</span>    <span class="token comment">// 将命令写入一份 backlog, 也就是复制积压缓冲区</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>repl_backlog<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> aux<span class="token punctuation">[</span>LONG_STR_SIZE<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 拼写命令 *&lt;argc>\r\n</span>        aux<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'*'</span><span class="token punctuation">;</span>        len <span class="token operator">=</span> <span class="token function">ll2string</span><span class="token punctuation">(</span>aux<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aux<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>argc<span class="token punctuation">)</span><span class="token punctuation">;</span>        aux<span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\r'</span><span class="token punctuation">;</span>        aux<span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>        <span class="token comment">// 写入复制积压缓冲区</span>        <span class="token function">feedReplicationBacklog</span><span class="token punctuation">(</span>aux<span class="token punctuation">,</span>len<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 遍历所有的参数个数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 参数对象的长度</span>            <span class="token keyword">long</span> objlen <span class="token operator">=</span> <span class="token function">stringObjectLen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 构建成协议标准的字符串, 并添加到 backlog 中</span>            <span class="token comment">// $&lt;len>\r\n&lt;argv>\r\n </span>            aux<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'$'</span><span class="token punctuation">;</span>            len <span class="token operator">=</span> <span class="token function">ll2string</span><span class="token punctuation">(</span>aux<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aux<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>objlen<span class="token punctuation">)</span><span class="token punctuation">;</span>            aux<span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\r'</span><span class="token punctuation">;</span>            aux<span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>            <span class="token comment">// 添加 $&lt;len>\r\n</span>            <span class="token function">feedReplicationBacklog</span><span class="token punctuation">(</span>aux<span class="token punctuation">,</span>len<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 添加参数对象 &lt;argv></span>            <span class="token function">feedReplicationBacklogWithObject</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 添加\r\n</span>            <span class="token function">feedReplicationBacklog</span><span class="token punctuation">(</span>aux<span class="token operator">+</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>slaves<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        client <span class="token operator">*</span>slave <span class="token operator">=</span> ln<span class="token operator">-></span>value<span class="token punctuation">;</span>        <span class="token comment">// 从节点的状态为等待 bgsave 开始跳过</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>slave<span class="token operator">-></span>replstate <span class="token operator">==</span> SLAVE_STATE_WAIT_BGSAVE_START<span class="token punctuation">)</span>             <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">// 将命令写给正在等待初次 SYNC 的从节点 (所以这些命令在输出缓冲区中排队, 直到初始 SYNC 完成), 或已经与主节点同步</span>        <span class="token comment">// 添加回复的长度</span>        <span class="token function">addReplyMultiBulkLen</span><span class="token punctuation">(</span>slave<span class="token punctuation">,</span>argc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将所有的参数列表添加到从节点的输出缓冲区, 发送给从节点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token function">addReplyBulk</span><span class="token punctuation">(</span>slave<span class="token punctuation">,</span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>和 AOF 持久化一样, 再给从节点 client 写命令时, 会将 SELECT 命令强制写入, 以保证命令正确读到数据库中。<br>同时不仅写入了从节点 client 的输出缓冲区, 而且还会将命令记录到主节点服务器的复制积压缓冲区 server.repl_backlog 中, 这是为了网络闪断后进行部分复制做准备。</p><p><img src="https://pic.imgdb.cn/item/66def608d9c307b7e94f3ace.png" alt="Alt &#39;运行中，数据同步&#39;"></p><h2 id="11-心跳机制"><a href="#11-心跳机制" class="headerlink" title="11 心跳机制"></a>11 心跳机制</h2><p>如果有留意的话, 可以发现上面有一行代码 <strong>slave-&gt;repl_put_online_on_ack &#x3D; 0</strong>, 可以简单的猜到主从节点之间是有一个应答 (心跳) 的机制的。</p><p>在主从节点建立连接后, 他们之间都维护着长连接并彼此发送心跳命令。<br>主从节点彼此都有心跳机制, 各自模拟成对方的客户端进行通信。</p><p>主节点默认每隔 10 秒发送 PING 命令, 判断从节点的连接状态, 可以通过 <strong>repl-ping-salve-period</strong> 进行时间的配置, 默认为 10 秒</p><p>在定时函数 serverCron 中</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 如果当前节点是某个节点的主节点, 那么发送 PING 给从节点</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>replication_cron_loops <span class="token operator">%</span> server<span class="token punctuation">.</span>repl_ping_slave_period<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 创建 PING 命令对象</span>    ping_argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">createStringObject</span><span class="token punctuation">(</span><span class="token string">"PING"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将 PING 发送给从服务器</span>    <span class="token function">replicationFeedSlaves</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span> server<span class="token punctuation">.</span>slaveseldb<span class="token punctuation">,</span> ping_argv<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 对象的引用次数 - 1</span>    <span class="token function">decrRefCount</span><span class="token punctuation">(</span>ping_argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>从节点在主线程中每隔 1 秒发送 <strong>REPLCONF ACK <offset></strong> 命令, 给主节点报告自己当前复制偏移量</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 定期发送 ack 给主节点, 旧版本的 Redis 除外</span><span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>master <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>master<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_PRE_PSYNC<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// 发送一个 replconf ack 命令给主节点 报告自身的 repl_offset</span>    <span class="token comment">// 具体逻辑可以查看 replication 文章的 replicationSendAck 方法解析</span>    <span class="token function">replicationSendAck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>主节点</strong> 收到后, 同样是在 replconfCommand 中处理</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">replconfCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argc <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>syntaxerr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> c<span class="token operator">-></span>argc<span class="token punctuation">;</span> j<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"listening-port"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"ip-address"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"capa"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"ack"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">long</span> <span class="token keyword">long</span> offset<span class="token punctuation">;</span>            <span class="token comment">// 不是从节点不做处理</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_SLAVE<span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token comment">// 获取第二个参数 repl_offset</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">getLongLongFromObject</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>offset<span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token comment">// 更新客户端对应的偏移量</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">></span> c<span class="token operator">-></span>repl_ack_off<span class="token punctuation">)</span>                c<span class="token operator">-></span>repl_ack_off <span class="token operator">=</span> offset<span class="token punctuation">;</span>                            <span class="token comment">// 更新收到 ack 的时间为当前时间</span>            c<span class="token operator">-></span>repl_ack_time <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>            <span class="token comment">// 客户端设置了收到 ack 时需要变更为在线状态 同时当前客户端的状态为 SLAVE_STATE_ONLINE</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>repl_put_online_on_ack <span class="token operator">&amp;&amp;</span> c<span class="token operator">-></span>replstate <span class="token operator">==</span> SLAVE_STATE_ONLINE<span class="token punctuation">)</span>                <span class="token function">putSlaveOnline</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 结束, 这个命令不需要响应任何信息</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token string">"getack"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 省略</span>        <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token function">addReplyErrorFormat</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"Unrecognized REPLCONF option: %s"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>shared<span class="token punctuation">.</span>ok<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>从节点</strong>还会在周期性函数 replicationCron() 中, 每次都要检查和主节点处于连接状态的从节点和主节点的交互时间是否超时,<br>如果超时则会调用 cancelReplicationHandshake() 函数, 取消和主节点的连接。 等到下一个周期在和主节点重新建立连接, 进行复制。</p><h2 id="12-参考"><a href="#12-参考" class="headerlink" title="12 参考"></a>12 参考</h2><p><a href="https://blog.csdn.net/men_wen/article/details/72628439">Redis 复制(replicate)实现</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;因为主从复制的过程很复杂, 同时核心逻辑主要集中在 &lt;strong&gt;replication.c&lt;/strong&gt; 这个文件中, 避免篇幅过大, 所以将主从复制中涉及这个文件的代码集中到了另一篇文章。&lt;br&gt;在当前文章主要分析主从复制的大体代码逻辑,</summary>
        
      
    
    
    
    
    <category term="Redis" scheme="https://github.com/Lcn29/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 主从复制分析 - 基础</title>
    <link href="https://github.com/Lcn29/article/2024/1622708120/"/>
    <id>https://github.com/Lcn29/article/2024/1622708120/</id>
    <published>2024-07-22T07:46:23.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-主从节点运行数据的存储"><a href="#1-主从节点运行数据的存储" class="headerlink" title="1 主从节点运行数据的存储"></a>1 主从节点运行数据的存储</h2><p>在主从复制中, 对于主节点, 从节点就是自身的一个客户端, 所以和普通的客户端一样, 会被组织为一个 client 的结构体。 </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span> client<span class="token punctuation">;</span></code></pre><p>同时无论是从节点, 还是主节点, 在运行中的数据都存放在一个 redisServer 的结构体中, 定义如下:</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>在主从复制中的 client 和 redisServer 都是用来存储运行中的一些数据。<br>具体里面存储的数据是什么, 在后面的源码分析中, 逐渐了解。</p><h2 id="2-主从节点复制中的状态枚举"><a href="#2-主从节点复制中的状态枚举" class="headerlink" title="2 主从节点复制中的状态枚举"></a>2 主从节点复制中的状态枚举</h2><h3 id="2-1-从节点自身状态的状态枚举"><a href="#2-1-从节点自身状态的状态枚举" class="headerlink" title="2.1 从节点自身状态的状态枚举"></a>2.1 从节点自身状态的状态枚举</h3><p>整个主从复制是一个复杂的过程, 所以在从节点中, 维护了一套状态, 通过状态来判断下一步的流程 (有点像状态模式)</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 没有开启主从复制功能, 默认的状态</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_NONE</span> <span class="token expression"><span class="token number">0</span></span></span><span class="token comment">// 开启了主从复制, 但是还没连接上主节点</span><span class="token comment">// 执行了 slaveof/replicaof 命令时, 从节点的切换成的状态 </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_CONNECT</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token comment">// 正在连接主节点, 从节点开始连接主节点</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_CONNECTING</span> <span class="token expression"><span class="token number">2</span></span></span><span class="token comment">/* --- 握手阶段的状态开始, 整个握手过程必须按照下面的顺序进行 --- */</span><span class="token comment">// 从节点发送了 ping, 等待主节点 pong  应答 (正常情况, 主节点会回复一个 pong)</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_RECEIVE_PONG</span> <span class="token expression"><span class="token number">3</span></span></span><span class="token comment">// 准备发送认证密码给主节点</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_SEND_AUTH</span> <span class="token expression"><span class="token number">4</span></span></span><span class="token comment">// 等待主节点响应认证结果应答</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_RECEIVE_AUTH</span> <span class="token expression"><span class="token number">5</span></span></span><span class="token comment">// 准备发送从节点的监听的端口</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_SEND_PORT</span> <span class="token expression"><span class="token number">6</span> </span></span><span class="token comment">// 等待主节点响应收到从节点端口</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_RECEIVE_PORT</span> <span class="token expression"><span class="token number">7</span></span></span><span class="token comment">// 发送主从复制配置的监听的 IP 地址</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_SEND_IP</span> <span class="token expression"><span class="token number">8</span> </span></span><span class="token comment">// 等待主节点响应收到从节点的 IP 地址</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_RECEIVE_IP</span> <span class="token expression"><span class="token number">9</span></span></span><span class="token comment">// 准备发送从节点支持的同步能力 </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_SEND_CAPA</span> <span class="token expression"><span class="token number">10</span> </span></span><span class="token comment">// 等待主节点响应收到支持的同步能力的应答</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_RECEIVE_CAPA</span> <span class="token expression"><span class="token number">11</span></span></span><span class="token comment">// 向主节点发送 psync 命令, 请求同步复制</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_SEND_PSYNC</span> <span class="token expression"><span class="token number">12</span> </span></span><span class="token comment">// 等待 psync 应答</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_RECEIVE_PSYNC</span> <span class="token expression"><span class="token number">13</span></span></span><span class="token comment">/* --- 握手阶段的状态结束 --- */</span><span class="token comment">// 正在接收从主节点发送过来的 RDB 文件</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_TRANSFER</span> <span class="token expression"><span class="token number">14</span> </span></span><span class="token comment">// 已经连接状态</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPL_STATE_CONNECTED</span> <span class="token expression"><span class="token number">15</span> </span></span></code></pre><h3 id="2-2-主节点保存从节点的状态枚举"><a href="#2-2-主节点保存从节点的状态枚举" class="headerlink" title="2.2 主节点保存从节点的状态枚举"></a>2.2 主节点保存从节点的状态枚举</h3><p>对于主节点而言, 需要知道从节点当前的状态的, 好进行对应的操作, 但是不需要那么详细, 主节点也维护了一套从节点运行时的状态</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 等待 bgsave (生成 RDB 文件的函数) 的开始</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLAVE_STATE_WAIT_BGSAVE_START</span> <span class="token expression"><span class="token number">6</span></span></span><span class="token comment">// 等待 bgsave 的结束, 也就是 RDB 文件的创建结束</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLAVE_STATE_WAIT_BGSAVE_END</span> <span class="token expression"><span class="token number">7</span></span></span><span class="token comment">// 发送一个 RDB 文件到从节点</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLAVE_STATE_SEND_BULK</span> <span class="token expression"><span class="token number">8</span></span></span><span class="token comment">// 从节点在线</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLAVE_STATE_ONLINE</span> <span class="token expression"><span class="token number">9</span></span></span></code></pre><h2 id="3-从节点复制能力"><a href="#3-从节点复制能力" class="headerlink" title="3 从节点复制能力"></a>3 从节点复制能力</h2><h3 id="3-1-全量复制和部分复制"><a href="#3-1-全量复制和部分复制" class="headerlink" title="3.1 全量复制和部分复制"></a>3.1 全量复制和部分复制</h3><p>整个主从复制, 大体可以概括为 3 种情况</p><blockquote><ol><li>一开始, 主从节点建立连接, 这时候主节点需要将自身所有的数据全部同步给从节点</li><li>运行中, 主节点需要将自己处理的命令, 发送一份给从节点, 这样才能保证主从的一致</li><li>运行中, 出现了网络波动, 服务重启等情况, 重新恢复正常时, 主从需要重新通过<strong>复制</strong>, 让彼此的数据重新保持一致</li></ol></blockquote><p><strong>第一步</strong><br>主从建立了连接, 主节点会将自身所有的数据生成为一个 RDB 的文件, 然后以 <strong>EOF</strong> 的流格式发送给从节点。<br>当然, Redis 在 2.8.18 版本开始支持<strong>无盘复制</strong>, 子进程直接将 RDB 通过网络发送给从服务器, 不使用磁盘作为中间存储。<br>主要是防止比较低速的磁盘, 写入缓慢, 影响到整个应用。<br>这个主节点将所有数据发送给从节点的操作, 叫做<strong>全量复制</strong>。  </p><p><strong>第二步</strong><br>在运行中, 主节点处理完了命令, 会遍历自身维护的所有的从节点, 将自身执行的命令发送给所有状态符合的从节点, 保证数据的一致。<br>可以看出来, 第一, 二步的操作是一个比较简单的过程, 而第三步, 在兼容性能的情况下, 将会是一个复杂的过程。</p><p><strong>第三步</strong><br>主从节点之间出现网络波动, 从节点重启等行为后, 主从之间就可能出现数据不一致。<br>在 Reids 2.8 版本之前, Reids 的操作就是通过在来一次<strong>全量复制</strong>, 保证了主从节点数据的一致性。</p><p><strong>全量复制</strong> 我们可以很容易就想到这是一个耗时, 耗资源的过程, 比如 fork 子进程, RDB 文件生成, 数据发送。<br>所以为了尽量避免<strong>全量复制</strong>的出现, 在 Redis 2.8 版本, 引入了一个<strong>复制积压缓冲区</strong>的缓存区, 主节点执行的命令, 会先保存一份到这个缓存区<br>(这个缓存区是一个环形的数组, 从头写到尾, 写满了, 重新回到头, 继续写, 新的数据覆盖掉旧的, 同时所有的从节点共用一个缓冲区)。</p><p><img src="https://pic.imgdb.cn/item/669e267fd9c307b7e9c9b2dc.png" alt="Alt &#39;复制积压缓冲区&#39;"></p><p>大体的实现如下</p><blockquote><ol><li>主节点启动的时候, 会生成一个 run_id (用来确保复制的主节点的唯一性)</li><li>同时生成一个复制积压缓冲区, 并且有一个变量, 记录着缓冲区中当前最旧的数据的位置, 假设为 min, 假设复制积压缓冲区的容量为 len</li><li>从节点保存着主节点生成的 run_id, 同时维持着一个变量, 当前自身最新的数据在复制积压缓冲区的哪个位置, 也就是复制偏移量, 假设为 offset</li><li>当前主从复制出现问题时, 主从重新建立连接后, 从节点会将 run_id 和 offset 发送给主节点</li><li>主节点收到后, 如果 run_id 和自身的一致, 同时 min &lt;&#x3D; offset &lt;&#x3D; min + len, 也就是需要开始复制的位置的数据, 可以在缓存区中找到, 那么从这个位置进行<strong>部分复制</strong></li><li>主节点如果收到的 run_id 不一致, 或者 offset &lt; min 或者 offset &gt; min + len, 也就是需要开始复制的位置不在缓冲区中, 直接进行<strong>全量复制</strong></li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/669e26a5d9c307b7e9c9d3de.png" alt="Alt &#39;部分复制过程&#39;"></p><p>这个的功能叫做 <strong>psync</strong>, 可以理解为 <strong>部分复制</strong>, 这个功能可以减少<strong>全量复制</strong>的发生。<br>但是这个功能有些问题, 就是从节点需要维护好 run_id, run_id 需要和从节点的一致, 同时 offset 需要在复制积压缓存中, 这其中</p><blockquote><ol><li>slave 维护性重启, run_id 和 offset 会丢失</li><li>主节点故障转移, run_id 会改变<br>都会导致从节点直接<strong>全量复制</strong></li></ol></blockquote><p>所以在 Redis 4.0 针对上面的 2 种情况进行了优化, 使其在上面说的情况下, 可以进行使用<strong>部分复制</strong>, 这个升级的功能也被叫做 <strong>psync2</strong>。<br>涉及的几个名词</p><blockquote><ol><li>replid1, 每个 Redis 实例启动就会自动产生的一个 id, 这个实例变成从节点, 会被替换为主节点的 replid1</li><li>replid2, 默认初始为 0, 用于存储上次主节点的 replid1</li></ol></blockquote><p>当然还要其他的情况, 会导致<strong>部分复制</strong>的失效, 比如: 直接重启主节点, 这是复制积压缓冲区的数据丢了, 没法<strong>部分复制</strong></p><p>所以 <strong>psync2</strong> 只是针对上面的 2 种情况进行了优化, 其他的情况, 还是会直接进入到<strong>全量复制</strong></p><h4 id="3-2-从节点重启的部分复制"><a href="#3-2-从节点重启的部分复制" class="headerlink" title="3.2 从节点重启的部分复制"></a>3.2 从节点重启的部分复制</h4><p>在 Redis 4.0 中</p><blockquote><ol><li>Redis 关闭时, 会把复制相关的信息 replid1 和 offset 作为辅助信息保存到 RDB 文件</li><li>Redis 重启时, 会将从 RDB 文件中重新加载对应的复制信息到对应的字段</li><li>在进行同步时, 将 replid 和 offset 发送给主节点, 尝试进行部分复制</li></ol></blockquote><h4 id="3-3-主节点故障转移的部分复制"><a href="#3-3-主节点故障转移的部分复制" class="headerlink" title="3.3 主节点故障转移的部分复制"></a>3.3 主节点故障转移的部分复制</h4><p>当前的场景主要是在 Redis Cluster 中的故障转移情景的分析, 在单纯的主从复制中, 主节点重启, 挂了等, 都无法避免<strong>全量复制</strong>(单纯的主从复制不会触发故障转移)。</p><p>在 Redis 4.0 中</p><blockquote><ol><li>使用了 2 组 replid 和 offset</li><li>从节点也会开启复制积压缓冲区功能, 以便从节点故障切换变化为主节点后, 其他落后的从节点可以进行同步</li><li>第一组 replid 和 offset, 如果是主节点, 表示的是自己的 replid 和复制偏移量 offset, 从节点表示的是主节点的 replid (确保级联时, replid 都是一致的) 和自身同步主节点的赋值偏移量</li><li>第二组 replid 和 offset, 无论是主从, 都表示自己的上次主节点的 replid 和 offset, 没有则默认为 0 和 -1</li></ol></blockquote><p>故障转移时</p><blockquote><ol><li>从节点中被选举为主节点的节点, 先将自身的 replid1 和 offset1 复制给 replid2 和 offset2, 给自己重新生成另一组 replid 和 offset</li><li>原主节点这时会变为从节点, 也会将自身的 replid1 和 offset1 复制给 replid2 和 offset2, 更新 replid1 和 offset1 为新的主节点的 replid1 和 offset1</li><li>原主节点其他没有被选为主节点的从节点, 同样会将当前的 replid1 和 offest1 复制给 replid2 和 offset2, 更新 replid1 和 offset1 为新的主节点的 replid1 和 offset1</li><li>原主节点和其他从节点和新主节点进行同步时, 会先发送自身的 replid2 和 offset2, 主节点会根据这个信息, 判断是否可以进行部分复制</li></ol></blockquote><p>上面说的 3 个版本的复制能力, 在代码中分别叫做 <strong>EOF</strong>, <strong>psync</strong>, <strong>psync2</strong>。</p><p>复制能力的定义如下:  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 什么能力都不支持</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLAVE_CAPA_NONE</span> <span class="token expression"><span class="token number">0</span></span></span><span class="token comment">// 支持 EOF, 支持全量复制, 可以解析 RDB EOF 流式处理格式</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLAVE_CAPA_EOF</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> </span></span><span class="token comment">// 支持 psync2, 支持部分复制</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLAVE_CAPA_PSYNC2</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span></span></span></code></pre><p>对于 Redis 从节点, 可能因为版本问题, 存在着复制能力不一致的情况, 所以在主从复制开始的阶段, 从节点需要将自身支持的复制能力发送给主节点,<br>主节点才能以正确的方式同步数据给从节点。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><a href="https://blog.csdn.net/qq_42409788/article/details/104246731">redis psync1和psync2 同步详解</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;1-主从节点运行数据的存储&quot;&gt;&lt;a href=&quot;#1-主从节点运行数据的存储&quot; class=&quot;headerlink&quot; title=&quot;1 主从节点运行数据的存储&quot;&gt;&lt;/a&gt;1 主从节点运行数据的存储&lt;/h2&gt;&lt;p&gt;在主从复制中, 对于主节点,</summary>
        
      
    
    
    
    
    <category term="Redis" scheme="https://github.com/Lcn29/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 主从复制分析 - 使用</title>
    <link href="https://github.com/Lcn29/article/2024/3467330523/"/>
    <id>https://github.com/Lcn29/article/2024/3467330523/</id>
    <published>2024-07-05T03:46:00.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<p>Reids 主从复制:<br>将一台 Redis 服务器的数据, 复制到其他的 Redis 服务器。前者称为主节点 (master), 后者称为从节点 (slave)。<br>数据的复制是单向的, 只能由主节点到从节点, 同时主节点以写为主 (可写也可以读), 从节点只能读不可写入。</p><h2 id="1-主从复制的建立"><a href="#1-主从复制的建立" class="headerlink" title="1 主从复制的建立"></a>1 主从复制的建立</h2><p>本文简单的介绍一下如何配置一个 一主两从的 Redis 主从复制集群。</p><p><strong>假设</strong><br>主节点        192.168.0.1, 端口为 6379<br>从节点 1      192.168.0.2, 端口为 6379<br>从节点 2      192.168.0.3, 端口为 6379  </p><h3 id="1-1-方式一-过配置文件进行配置"><a href="#1-1-方式一-过配置文件进行配置" class="headerlink" title="1.1 方式一: 过配置文件进行配置"></a>1.1 方式一: 过配置文件进行配置</h3><blockquote><ol><li>在 2 个从节点的 redis.conf 文件中追加 <strong>slaveof 192.168.0.1(主节点的 IP) 6379(主节点的端口)</strong>    </li><li>启动主节点, 再依次启动从节点, 这样一主两从的配置就完成了</li></ol></blockquote><h3 id="1-2-方式二-Redis-启动时指定主节点"><a href="#1-2-方式二-Redis-启动时指定主节点" class="headerlink" title="1.2 方式二: Redis 启动时指定主节点"></a>1.2 方式二: Redis 启动时指定主节点</h3><blockquote><ol><li>启动主节点</li><li>再启动 2 个从节点, 在启动的参数追加: <strong>–slaveof 192.168.0.1(主节点的 IP) 6379(主节点的端口)</strong>, 即 <strong>.&#x2F;redis-server –slaveof 192.168.0.1 6379</strong></li></ol></blockquote><h3 id="1-3-方式三-Redis-运行中指定主节点"><a href="#1-3-方式三-Redis-运行中指定主节点" class="headerlink" title="1.3 方式三: Redis 运行中指定主节点"></a>1.3 方式三: Redis 运行中指定主节点</h3><blockquote><ol><li>主从节点都正常的启动</li><li>在 2 个从节点都执行命令 <strong>slaveof 192.168.0.1(主节点的 IP) 6379(主节点的端口)</strong></li></ol></blockquote><p>上面就是 3 种建立主从复制的方式。<br>建立了连接后, 从节点可以通过 <strong>slaveof no one</strong> 断开连接, 断开了连接后, 从节点会自动变为主节点。</p><h2 id="2-主从复制节点信息查看"><a href="#2-主从复制节点信息查看" class="headerlink" title="2 主从复制节点信息查看"></a>2 主从复制节点信息查看</h2><p>主节点连接上<strong>从节点</strong>, 执行 <strong>info replication</strong> 就能查看到当前从节点的信息, 大体如下 (截取了主从复制相关的)</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Replication</span><span class="token comment"># 节点角色: 从节点</span>role:slave<span class="token comment"># 主节点的 IP</span>master_host:192.168.0.1<span class="token comment"># 主节点的端口</span>master_port:8888<span class="token comment"># 主节点的连接状态</span>master_link_status:up<span class="token comment"># 主节点最后与从节点的通信时间间隔, 单位秒</span>master_last_io_seconds_ago:0<span class="token comment"># 从节点是否正在全量同步主节点的 RDB 文件</span>master_sync_in_progress:0       <span class="token comment"># 复制偏移量</span>slave_repl_offset:407<span class="token comment"># 从节点的优先级</span>slave_priority:100<span class="token comment"># 从节点是否只读, 一般情况从节点都是只读的, 但是也可以通过在配置文件中配置 slave-read-only 或者 config set 强制修改为可写可读</span>slave_read_only:1 <span class="token comment"># 连接从节点的个数, Redis 支持从节点后面继续配置从节点</span>connected_slaves:0<span class="token comment"># 当前从节点作为其他从节点的主节点时的复制偏移量</span>master_repl_offset:0<span class="token comment"># 以下四种信息为主从节点通用的配置</span><span class="token comment"># 复制缓冲区的状态</span>repl_backlog_active:0 <span class="token comment"># 复制缓冲区的大小</span>repl_backlog_size:1048576<span class="token comment"># 复制缓冲区起始偏移量, 标识当前缓冲区可用的范围</span>repl_backlog_first_byte_offset:0<span class="token comment"># 标识复制缓冲区已存在的有效数据长度</span>repl_backlog_histlen:0 </code></pre><p>同样的, 从节点连上<strong>主节点</strong>后, 也可以通过 <strong>info replication</strong> 查看到当前主节点的信息</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 节点角色: 主节点</span>role:master  <span class="token comment"># 连接从节点的个数</span>connected_slaves:2<span class="token comment"># 连接从节点的信息</span>slave0:ip<span class="token operator">=</span><span class="token number">192.168</span>.0.2,port<span class="token operator">=</span><span class="token number">6379</span>,state<span class="token operator">=</span>online,offset<span class="token operator">=</span><span class="token number">631</span>,lag<span class="token operator">=</span><span class="token number">0</span>slave1:ip<span class="token operator">=</span><span class="token number">192.168</span>.0.3,port<span class="token operator">=</span><span class="token number">6379</span>,state<span class="token operator">=</span>online,offset<span class="token operator">=</span><span class="token number">631</span>,lag<span class="token operator">=</span><span class="token number">0</span> <span class="token comment"># 主节点的偏移量</span>master_repl_offset:631 <span class="token comment"># 以下四种信息为主从节点通用的配置</span><span class="token comment"># 复制缓冲区的状态</span>repl_backlog_active:1 <span class="token comment"># 复制缓冲区的大小</span>repl_backlog_size:1048576<span class="token comment"># 复制缓冲区起始偏移量, 标识当前缓冲区可用的范围</span>repl_backlog_first_byte_offset:2<span class="token comment"># 标识复制缓冲区已存在的有效数据长度</span>repl_backlog_histlen:630                                        </code></pre><h2 id="3-主从复制的其他配置"><a href="#3-主从复制的其他配置" class="headerlink" title="3 主从复制的其他配置"></a>3 主从复制的其他配置</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 从节点是否只读，默认为 true</span>slave-read-only <span class="token boolean">true</span><span class="token comment"># 无盘复制, 默认为 no</span><span class="token comment"># 在全量复制时, 主节点会将自身所有的数据生成为 1 个 RDB 文件, 然后发送给从节点</span><span class="token comment"># 这种发送的方式有 2 种</span><span class="token comment"># 1. 有盘复制: 主节点将 RDB 文件先写入到自己的磁盘, 再发送给从节点</span><span class="token comment"># 2. 无盘复制：主节点直接将 RDB 文件通过 Socket 发送给从节点</span><span class="token comment"># 无盘复制, 在主节点开始传输时, 新进来从节点会先排成队列，等待一段可以配置的时间, 竟可能的等待多个从节点到达, 进行并行传输</span>repl-diskless-sync no<span class="token comment"># 无盘复制, 从节点延迟等待的时间, 默认为 5 秒</span>repl-diskless-sync-deplay <span class="token number">5</span><span class="token comment"># 从节点向主节点发送心跳的时间间隔, 默认 10 秒</span>repl-ping-slave-period <span class="token number">10</span> <span class="token comment"># yes 主节点将使用更小 tcp 包和更少宽带向从节点发送数据, 但是这个会造成延迟</span><span class="token comment"># no  反过来, 延迟会减少, 但会使用更多的宽带</span><span class="token comment"># 默认为 no</span>repl-disable-tcp-nodelay no<span class="token comment"># 复制的超时时间, 默认为 60 秒</span><span class="token comment"># 使用到的场景</span><span class="token comment"># 1. 从节点同步数据时, 连接主节点超时</span><span class="token comment"># 2. 主节点向从节点发送 ack ping 超时</span><span class="token comment"># 3. 从节点连接主节点超时</span>repl-timeout <span class="token number">60</span><span class="token comment"># 复制积压缓冲区大小, 默认为 1m</span>repl-backlog-size 1mb<span class="token comment"># 主节点没法连接到从节点超过配置的时间, 复制积压缓冲区数据清掉</span>repl-backlog-ttl <span class="token number">3600</span><span class="token comment"># 从节点 priority 越低, 有着越高的保证,当主节点挂断的时候, 越有可能成为主节点</span>slave-priority <span class="token number">100</span><span class="token comment"># 所有从节点的延迟 (lag) 值, 大于或等于 10, 主节点拒绝执行写命令</span>min-slaves-max-lag <span class="token number">10</span> <span class="token comment"># 从节点数量少于 3 个, 主节点拒绝执行写命令</span>min-slaves-to-write <span class="token number">3</span><span class="token comment"># 当前节点作为从节点, 暴露给主节点的端口, 这个没有配置, 使用当前节点的运行的端口</span>slave-announce-port <span class="token number">6666</span><span class="token comment"># 当前节点作为从节点, 暴露给主节点的 IP</span>slave-announce-ip <span class="token number">127.0</span>.0.1</code></pre><h2 id="4-主从复制特点"><a href="#4-主从复制特点" class="headerlink" title="4 主从复制特点"></a>4 主从复制特点</h2><p>一主多从的特点:</p><blockquote><ol><li>主节点挂了, 从节点依然还是从节点, 无法变为主节点</li><li>主节点挂了, 重启后, 还是为主节点</li></ol></blockquote><h2 id="1-5-参考"><a href="#1-5-参考" class="headerlink" title="1.5 参考"></a>1.5 参考</h2><p><a href="https://blog.csdn.net/y1247793952/article/details/66974329">redis主从相关配置</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Reids 主从复制:&lt;br&gt;将一台 Redis 服务器的数据, 复制到其他的 Redis 服务器。前者称为主节点 (master), 后者称为从节点 (slave)。&lt;br&gt;数据的复制是单向的, 只能由主节点到从节点, 同时主节点以写为主 (可写也可以读),</summary>
        
      
    
    
    
    
    <category term="Redis" scheme="https://github.com/Lcn29/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>记一次 SQL 优化</title>
    <link href="https://github.com/Lcn29/article/2024/277668067/"/>
    <id>https://github.com/Lcn29/article/2024/277668067/</id>
    <published>2024-06-26T08:45:24.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>我们的数据库中配置了一套慢 SQL 的监控(这里存在 SQL 本身不慢, 但是触发某些场景, 比如 filesort 等也会被采集), 会不定时的输出一批需要排查的 SQL, 下面挑了几条比较有意思的进行分享。</p><h2 id="2-table-1"><a href="#2-table-1" class="headerlink" title="2 table_1"></a>2 table_1</h2><p>表结构:</p><pre class="language-sql" data-language="sql"><code class="language-sql">CEATE <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>        column_1<span class="token punctuation">,</span>    column_2<span class="token punctuation">,</span>    column_3<span class="token punctuation">,</span>    column_4<span class="token punctuation">,</span>    time_column_5    <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_001<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>column_3<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_002<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>column_2<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>column_3<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>time_column_5<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>SQL:</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> column_1 <span class="token keyword">from</span> table_1 <span class="token keyword">where</span> column_2 <span class="token operator">and</span> column_3 <span class="token operator">and</span> time_column_5 <span class="token operator">></span> ? <span class="token keyword">order</span> <span class="token keyword">by</span> time_column_5 <span class="token keyword">desc</span></code></pre><p>执行计划: </p><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_1</td><td align="center"></td><td align="center">range</td><td align="center">idx_001,idx_002</td><td align="center">idx_002</td><td align="center">133</td><td align="center"></td><td align="center">1</td><td align="center">5</td><td align="center">Using index condition</td></tr></tbody></table><p>通过分析执行过程, 可以发现这条 SQL 本身已经是 range 同时基本走到符合条件的索引 <strong>idx_002</strong> 了。<br>因为这条 SQL 只需要在查询出一个 column_1 字段, 如果还想再进一步优化的话, 可以直接将这个字段添加到 <strong>idx_002</strong> 的索引, 直接让这条 SQL 在索引树中处理, 不回表查询。</p><p>修改 idx_002 的索引如下 <strong>column_2, column_3, column_1, time_column_4</strong></p><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_1</td><td align="center"></td><td align="center">range</td><td align="center">idx_001, idx_002</td><td align="center">idx_002</td><td align="center">133</td><td align="center"></td><td align="center">1</td><td align="center">5</td><td align="center">Using where, Backward index scan, Using index</td></tr></tbody></table><p>可以发现 Extra 中, 整条 SQL 为 <strong>Using index</strong>, 只使用到了索引树, 同时利用到了 MySQL8 的新特性 backward index scan (MySQL 8 对字段倒序排序做的一种优化, 同样是直接在索引树上操作, 不回表处理)。</p><h2 id="3-table-2"><a href="#3-table-2" class="headerlink" title="3 table_2"></a>3 table_2</h2><p>表结构:</p><pre class="language-sql" data-language="sql"><code class="language-sql">CEATE <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_2<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>        column_1<span class="token punctuation">,</span>    column_2<span class="token punctuation">,</span>    column_3<span class="token punctuation">,</span>    column_4<span class="token punctuation">,</span>    time_column_5    <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_001<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>column_3<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_002<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>column_2<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>column_3<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>time_column_5<span class="token punctuation">`</span></span><span class="token punctuation">)</span>    <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_003<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>column_4<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>time_column_5<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>SQL:</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> column_1 <span class="token keyword">from</span> table_2 <span class="token keyword">where</span> <span class="token punctuation">(</span>column_2 <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">or</span> column_4 <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token operator">+</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">and</span> time_column_5 <span class="token operator">></span> ? <span class="token operator">and</span> time_column_5 <span class="token operator">&lt;=</span> ?</code></pre><p>执行计划: </p><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_2</td><td align="center"></td><td align="center">index_merge</td><td align="center">idx_001, idx_002, idx_003</td><td align="center">idx_002</td><td align="center">128128</td><td align="center"></td><td align="center">17907</td><td align="center">0.11</td><td align="center">Using sort_union(idx_002, idx_003); Using where</td></tr></tbody></table><p><strong>index_merge</strong>: 分别通过对两个独立的 index 进行过滤之后，将过滤之后的结果聚合在一起，然后在返回结果集<br><strong>sort_union</strong>: 简单理解: 使用到了 or, 回表捞到需要的数据，合并后再排序</p><p>column_2 和 column_4 都有各种适合的索引, 尝试通过 union all 将 or 替换掉</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> column_1 <span class="token keyword">from</span> table_2 <span class="token keyword">where</span> column_2 <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">and</span> time_column_5 <span class="token operator">></span> ? <span class="token operator">and</span> time_column_5 <span class="token operator">&lt;=</span> ?<span class="token keyword">union</span> <span class="token keyword">all</span><span class="token keyword">select</span> column_1 <span class="token keyword">from</span> table_2 <span class="token keyword">where</span> column_4 <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">and</span> time_column_5 <span class="token operator">></span> ? <span class="token operator">and</span> time_column_5 <span class="token operator">&lt;=</span> ?</code></pre><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_2</td><td align="center"></td><td align="center">range</td><td align="center">idx_002</td><td align="center">idx_002</td><td align="center">133</td><td align="center"></td><td align="center">6323</td><td align="center">1</td><td align="center">Using index condition; Using where</td></tr><tr><td align="center">SIMPLE</td><td align="center">table_2</td><td align="center"></td><td align="center">range</td><td align="center">idx_003</td><td align="center">idx_00</td><td align="center">133</td><td align="center"></td><td align="center">5</td><td align="center">1</td><td align="center">Using index condition; Using where</td></tr></tbody></table><p>观察 rows 预测扫描的行数少了, 同时 Extra 中切换到了 使用索引 + 回表查询</p><h2 id="4-table-3"><a href="#4-table-3" class="headerlink" title="4 table_3"></a>4 table_3</h2><p>表结构: </p><pre class="language-sql" data-language="sql"><code class="language-sql">CEATE <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_2<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>        column_1<span class="token punctuation">,</span>    column_2<span class="token punctuation">,</span>    char_column_3<span class="token punctuation">,</span>    time_column_4    <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_001<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>char_column_3<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>time_column_4<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>SQL:</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> column_1<span class="token punctuation">,</span> char_column_3<span class="token punctuation">,</span> time_column_4 <span class="token keyword">from</span> table_3 <span class="token keyword">where</span> char_column_3 <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token operator">+</span><span class="token punctuation">)</span> <span class="token keyword">order</span> <span class="token keyword">by</span> time_column_4 <span class="token keyword">desc</span> lmit ?<span class="token punctuation">,</span> ?</code></pre><p>执行计划: </p><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_3</td><td align="center"></td><td align="center">range</td><td align="center">idx_001</td><td align="center">idx_001</td><td align="center">128</td><td align="center"></td><td align="center">4</td><td align="center">5</td><td align="center">Using index condition; Using where; Using filesort</td></tr></tbody></table><p>这条 SQL 主要是因为使用到了 filesort。<br>通过索引 idx_001 可以看出 查询的条件 char_column_3 和 time_column_4 都是在索引里面的, 理而导致 Using filesort 的原因是因为 char_column_3 的条件是 in</p><p>尝试将 char_column_3 的条件修改为 &#x3D;, 执行计划如下</p><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_3</td><td align="center"></td><td align="center">ref</td><td align="center">idx_001</td><td align="center">idx_001</td><td align="center">128</td><td align="center">const</td><td align="center">4</td><td align="center">5</td><td align="center">Using index condition; Using where</td></tr></tbody></table><p>in 导致索引中的 time_column_4 失效原因:<br>索引是有序的, 通过索引找到的数据, 理论上也是有序的。<br>比如表中当前有数据 (1, 1), (2, 2), (3, 3), (1,5) (1,3)。<br>通过 char_column_3 in 查询出来的数据为 (1, 1), (1,3), (1,5), (2, 2), (3, 3), 可以发现是按照 char_column_3 排序好了。<br>但是现在我们需要的是按照 time_column_4 进行排序, 那么就在用 char_column_3 查询出来的数据后再进行多一次排序, 就导致了 filesort 的出现。  </p><p>尝试去掉 filesort, 建立 idx_02(time_column_4, char_column_3) 的组合索引, 同时强制走这个索引 (通过尝试, 发现 MySQL 的优化器分析走旧索引比较好)</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> column_1<span class="token punctuation">,</span> char_column_3<span class="token punctuation">,</span> time_column_4 <span class="token keyword">from</span> table_3 <span class="token keyword">force</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_02<span class="token punctuation">)</span> <span class="token keyword">where</span> char_column_3 <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token operator">+</span><span class="token punctuation">)</span> <span class="token keyword">order</span> <span class="token keyword">by</span> time_column_4 <span class="token keyword">desc</span> lmit ?<span class="token punctuation">,</span> ?</code></pre><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_3</td><td align="center"></td><td align="center">ref</td><td align="center">idx_001</td><td align="center">idx_001</td><td align="center">128</td><td align="center">const</td><td align="center">15</td><td align="center">0.33</td><td align="center">Using where</td></tr></tbody></table><p>可以发现 filesort 去掉了, 但是对应的 rows 查询条数上涨了。<br>结论: 当前 SQL 暂时这样, 不修改。</p><h2 id="5-table-4"><a href="#5-table-4" class="headerlink" title="5 table_4"></a>5 table_4</h2><p>表结构: </p><pre class="language-sql" data-language="sql"><code class="language-sql">CEATE <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_4<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>        column_1<span class="token punctuation">,</span>    column_2<span class="token punctuation">,</span>    column_3<span class="token punctuation">)</span></code></pre><p>SQL: </p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> table_4 <span class="token keyword">where</span> column_2 <span class="token operator">=</span> ? <span class="token operator">and</span> column_3 <span class="token operator">=</span> ?</code></pre><p>执行计划: </p><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_4</td><td align="center"></td><td align="center">ALL</td><td align="center"></td><td align="center"></td><td align="center">128</td><td align="center">const</td><td align="center">1026</td><td align="center">0.2</td><td align="center">Using where</td></tr></tbody></table><p>走到了 ALL, 整张表数据量也在 900+ 左右, 可能初期设想时不会有那么多数据, 所以没加索引。<br>现在走动了 ALL, 第一时间想到的是给查询的 2 个字段加上索引, 那么直接加上吗？</p><p>先分析一下 column_2 和 column_3 各自的分布。</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> column_2 <span class="token keyword">from</span> table_4 <span class="token keyword">group</span> <span class="token keyword">by</span> column_2</code></pre><table><thead><tr><th align="center">count(1)</th><th align="center">column_2</th></tr></thead><tbody><tr><td align="center">10</td><td align="center">2</td></tr><tr><td align="center">901</td><td align="center">3</td></tr><tr><td align="center">7</td><td align="center">4</td></tr><tr><td align="center">1</td><td align="center">5</td></tr><tr><td align="center">12</td><td align="center">6</td></tr><tr><td align="center">1</td><td align="center">7</td></tr><tr><td align="center">1</td><td align="center">8</td></tr><tr><td align="center">2</td><td align="center">9</td></tr></tbody></table><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> column_3 <span class="token keyword">from</span> table_4 <span class="token keyword">group</span> <span class="token keyword">by</span> column_3</code></pre><table><thead><tr><th align="center">count(1)</th><th align="center">column_3</th></tr></thead><tbody><tr><td align="center">9</td><td align="center">1</td></tr><tr><td align="center">64</td><td align="center">2</td></tr><tr><td align="center">861</td><td align="center">3</td></tr></tbody></table><p>可以发现 column_2 和 column_3 应该都是枚举值 (一开始可能考虑到都是枚举所以没加索引吧)。<br>回到代码中查看 SQL 的调用链, 发现调用的地方就 2 个, 查询的条件 column_2 主要在 (6,7,8), 而 column_3 则是 2。</p><p>虽然平常我们都知道枚举类型的字段不要加索引，因为区分度不高。<br>但是在某些情况下，还是建议建立索引的。举个例子: 有一张大表, 发送给客户的短信信息和状态, 表中有个字段存储的是当前这条短信是否发送给客户了，0: 未发送, 1: 已发送。<br>短信发送成功后, 会将状态修改为 1: 已发送。 基于这种情况, 这张大表中的未发送的数据量和远远小于已发送的数据量, 同时平时查询的时候也都几乎是查询未发送的, 这时候就可以给这个枚举值字段加上索引, 因为通过未发送这种情况可以筛选掉很多的数据量。</p><p>所以给 column_2 和 column_3 建立一个组合索引, 同时因为 column_2 的区分度更高, 所以将 column_2 放在 column_1 的前面。</p><h2 id="6-table-5"><a href="#6-table-5" class="headerlink" title="6 table_5"></a>6 table_5</h2><p>表结构: </p><pre class="language-sql" data-language="sql"><code class="language-sql">CEATE <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_5<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>        column_1<span class="token punctuation">,</span>    column_2<span class="token punctuation">,</span>    column_3    <span class="token keyword">KEY</span> idx_001<span class="token punctuation">(</span>column_1<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>SQL: </p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> table_5 <span class="token keyword">where</span> column_1 <span class="token operator">=</span> ? <span class="token operator">and</span> column_2 <span class="token operator">=</span> ? <span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token keyword">convert</span><span class="token punctuation">(</span>column_1 <span class="token keyword">using</span> gbk<span class="token punctuation">)</span></code></pre><p>执行计划: </p><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_5</td><td align="center"></td><td align="center">ref</td><td align="center">idx_001</td><td align="center">idx_001</td><td align="center">152</td><td align="center">const</td><td align="center">1</td><td align="center">5</td><td align="center">Using index condition; Using where; Using filesort</td></tr></tbody></table><p>同时是因为 filesort, 这里可以将排序的字段 column_1 加入到 idx 索引中。<br>但是因为 column_1 使用到了索引, 最终只会导致加的这个字段不起作用, 那么</p><ol><li>去掉这个函数, 排序而已, 对数据的准确性没有影响, 但是排序的的顺序和生产的不一致</li><li>将这个排序移到代码中进行</li></ol><h2 id="7-table-6"><a href="#7-table-6" class="headerlink" title="7 table_6"></a>7 table_6</h2><pre class="language-sql" data-language="sql"><code class="language-sql">CEATE <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_6<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>        column_1<span class="token punctuation">,</span>    column_2<span class="token punctuation">,</span>    column_3<span class="token punctuation">,</span>    is_deleted    <span class="token keyword">KEY</span> idx_001<span class="token punctuation">(</span>column_1<span class="token punctuation">,</span> is_deleted<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> idx_002<span class="token punctuation">(</span>column_2<span class="token punctuation">,</span> is_deleted<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>当前表数据量 80155064, 使用了逻辑删除, 未删除:已删除 &#x3D; 5:3 左右 </p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> column_1<span class="token punctuation">,</span> column_2<span class="token punctuation">,</span> column_3 <span class="token keyword">from</span> table_6 <span class="token keyword">where</span> column_1 <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">and</span> is_deleted <span class="token operator">=</span> <span class="token number">0</span></code></pre><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_6</td><td align="center"></td><td align="center">range</td><td align="center">idx_001</td><td align="center">idx_001</td><td align="center">303</td><td align="center"></td><td align="center">2</td><td align="center">10</td><td align="center">Using index condition; Using where</td></tr></tbody></table><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> column_1<span class="token punctuation">,</span> column_2<span class="token punctuation">,</span> column_3 <span class="token keyword">from</span> table_6 <span class="token keyword">where</span> column_2 <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">and</span> is_deleted <span class="token operator">=</span> <span class="token number">0</span></code></pre><table><thead><tr><th align="center">select_type</th><th align="center">table</th><th align="center">partitions</th><th align="center">type</th><th align="center">possible_keys</th><th align="center">key</th><th align="center">key_len</th><th align="center">ref</th><th align="center">rows</th><th align="center">filtered</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">table_6</td><td align="center"></td><td align="center">range</td><td align="center">idx_002</td><td align="center">idx_002</td><td align="center">153</td><td align="center"></td><td align="center">2</td><td align="center">10</td><td align="center">Using index condition; Using where</td></tr></tbody></table><p>2 条 SQL 的执行时间都是秒级别, 但是通过分析可以发现走的索引都很准确了, 通过调整索引的方式不太合适了。<br>那么有别的方式优化吗? 逻辑删除 –&gt; 已经删除的数据还有保存的意义吗? –&gt; 清除(或迁移到另一张表), 减轻表的数据量, 也能达到优化的效果。</p><h3 id="7-1-本地尝试清除数据"><a href="#7-1-本地尝试清除数据" class="headerlink" title="7.1 本地尝试清除数据"></a>7.1 本地尝试清除数据</h3><h4 id="7-1-1-初始数据"><a href="#7-1-1-初始数据" class="headerlink" title="7.1.1 初始数据"></a>7.1.1 初始数据</h4><table><thead><tr><th align="center">总数据量</th><th align="center">未删除</th><th align="center">已删除</th></tr></thead><tbody><tr><td align="center">10000001</td><td align="center">5002602</td><td align="center">4997399</td></tr></tbody></table><p>表内存情况</p><table><thead><tr><th align="center">Name</th><th align="center">Engine</th><th align="center">Version</th><th align="center">Row_formant</th><th align="center">Rows</th><th align="center">Avg_row_length</th><th align="center">Data_length</th><th align="center">Max_data_length</th><th align="center">Data_free</th><th align="center">Auto_increment</th><th align="center">Create_time</th><th align="center">Update_time</th><th align="center">Check_time</th><th align="center">Collation</th><th align="center">Checksum</th><th align="center">Create_options</th></tr></thead><tbody><tr><td align="center">table_6</td><td align="center">InnoDb</td><td align="center">10</td><td align="center">Dynamic</td><td align="center">9657234</td><td align="center">160</td><td align="center">1547698176 (1476.00M)</td><td align="center"></td><td align="center">3801726976 (3625.60M)</td><td align="center">4194304</td><td align="center">10000003</td><td align="center">2024-06-20 14:50:34</td><td align="center">2024-06-20 16:27:10</td><td align="center">NULL</td><td align="center">utf8_general_ci</td><td align="center">NULL</td></tr></tbody></table><p>备注:<br>date_length: 数据的大小<br>index_length: 索引的大小<br>data_free: 碎片空间的大小  </p><h4 id="7-1-2-继续往表追加数据"><a href="#7-1-2-继续往表追加数据" class="headerlink" title="7.1.2 继续往表追加数据"></a>7.1.2 继续往表追加数据</h4><p>向表中追加 1529500 条数据</p><table><thead><tr><th align="center">总数据量</th><th align="center">未删除</th><th align="center">已删除</th></tr></thead><tbody><tr><td align="center">11529501</td><td align="center">5766861</td><td align="center">5762640</td></tr></tbody></table><table><thead><tr><th align="center">Name</th><th align="center">Engine</th><th align="center">Version</th><th align="center">Row_formant</th><th align="center">Rows</th><th align="center">Avg_row_length</th><th align="center">Data_length</th><th align="center">Max_data_length</th><th align="center">Data_free</th><th align="center">Auto_increment</th><th align="center">Create_time</th><th align="center">Update_time</th><th align="center">Check_time</th><th align="center">Collation</th><th align="center">Checksum</th><th align="center">Create_options</th></tr></thead><tbody><tr><td align="center">table_6</td><td align="center">InnoDb</td><td align="center">10</td><td align="center">Dynamic</td><td align="center">11422530</td><td align="center">156</td><td align="center">1785724928 (1703.00M)</td><td align="center">0</td><td align="center">4484366336 (4276.62M)</td><td align="center">5242880</td><td align="center">11529503</td><td align="center">2024-06-20 14:50:34</td><td align="center">2024-06-20 16:53:30</td><td align="center">NULL</td><td align="center">utf8_general_ci</td><td align="center">NULL</td></tr></tbody></table><h4 id="7-1-3-尝试清除表中一半逻辑删除的数据"><a href="#7-1-3-尝试清除表中一半逻辑删除的数据" class="headerlink" title="7.1.3 尝试清除表中一半逻辑删除的数据"></a>7.1.3 尝试清除表中一半逻辑删除的数据</h4><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">from</span> table_6 <span class="token keyword">where</span> id <span class="token operator">&lt;=</span> <span class="token string">'5764751'</span> <span class="token operator">and</span> is_deleted <span class="token operator">=</span> <span class="token number">1</span></code></pre><table><thead><tr><th align="center">总数据量</th><th align="center">未删除</th><th align="center">已删除</th></tr></thead><tbody><tr><td align="center">8648665</td><td align="center">5766861</td><td align="center">2881804</td></tr></tbody></table><table><thead><tr><th align="center">Name</th><th align="center">Engine</th><th align="center">Version</th><th align="center">Row_formant</th><th align="center">Rows</th><th align="center">Avg_row_length</th><th align="center">Data_length</th><th align="center">Max_data_length</th><th align="center">Data_free</th><th align="center">Auto_increment</th><th align="center">Create_time</th><th align="center">Update_time</th><th align="center">Check_time</th><th align="center">Collation</th><th align="center">Checksum</th><th align="center">Create_options</th></tr></thead><tbody><tr><td align="center">table_6</td><td align="center">InnoDb</td><td align="center">10</td><td align="center">Dynamic</td><td align="center">8610990</td><td align="center">207</td><td align="center">1785724928 (1703.00M)</td><td align="center">0</td><td align="center">4484366336 (4276.62M)</td><td align="center">42991616</td><td align="center">11529503</td><td align="center">2024-06-20 14:50:34</td><td align="center">2024-06-20 17:14:58</td><td align="center">NULL</td><td align="center">utf8_general_ci</td><td align="center">NULL</td></tr></tbody></table><p>可以看到虽然删除了表中的部分数据, 但是实际占用的空间没有变化。 这时 InnoDB 内部的设计, 将删除的数据的位置标记为删除的, 后续有新的数据新增进来时, 就复用这个位置。<br>如果要强制进行空间的整理, 可以通过 <strong>alter table 表明 engine&#x3D;innodb;</strong> 的方式进行整理, 但是这个会很耗时。</p><h4 id="7-1-4-清除表中所有逻辑删除的数据"><a href="#7-1-4-清除表中所有逻辑删除的数据" class="headerlink" title="7.1.4 清除表中所有逻辑删除的数据"></a>7.1.4 清除表中所有逻辑删除的数据</h4><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">from</span> table_6 <span class="token keyword">where</span> is_deleted <span class="token operator">=</span> <span class="token number">1</span></code></pre><table><thead><tr><th align="center">总数据量</th><th align="center">未删除</th><th align="center">已删除</th></tr></thead><tbody><tr><td align="center">5766861</td><td align="center">5766861</td><td align="center">0</td></tr></tbody></table><p>通过 alter 手动整理空间</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> table_6 <span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">innodb</span><span class="token punctuation">;</span></code></pre><p>表内存情况</p><table><thead><tr><th align="center">Name</th><th align="center">Engine</th><th align="center">Version</th><th align="center">Row_formant</th><th align="center">Rows</th><th align="center">Avg_row_length</th><th align="center">Data_length</th><th align="center">Max_data_length</th><th align="center">Data_free</th><th align="center">Auto_increment</th><th align="center">Create_time</th><th align="center">Update_time</th><th align="center">Check_time</th><th align="center">Collation</th><th align="center">Checksum</th><th align="center">Create_options</th></tr></thead><tbody><tr><td align="center">table_6</td><td align="center">InnoDb</td><td align="center">10</td><td align="center">Dynamic</td><td align="center">5713155</td><td align="center">178</td><td align="center">1021296640 (973.98M)</td><td align="center">0</td><td align="center">1571340288 (1498.54M)</td><td align="center">3145728</td><td align="center">11529503</td><td align="center">2024-06-20 14:50:34</td><td align="center">NULL</td><td align="center">NULL</td><td align="center">utf8_general_ci</td><td align="center">NULL</td></tr></tbody></table><p>完整的清除数据和整理了碎片空间。</p><p>注: 最终落实到生产(保留前 3 个月的数据, 将 3 个月前的数据迁移到另一张表)</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1 背景&quot;&gt;&lt;/a&gt;1 背景&lt;/h2&gt;&lt;p&gt;我们的数据库中配置了一套慢 SQL 的监控(这里存在 SQL 本身不慢, 但是触发某些场景, 比如 filesort</summary>
        
      
    
    
    
    
    <category term="MySQL" scheme="https://github.com/Lcn29/tags/MySQL/"/>
    
    <category term="生产记录" scheme="https://github.com/Lcn29/tags/%E7%94%9F%E4%BA%A7%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis 内存回收和内存淘汰机制</title>
    <link href="https://github.com/Lcn29/article/2024/862777855/"/>
    <id>https://github.com/Lcn29/article/2024/862777855/</id>
    <published>2024-06-05T10:40:00.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>Redis 所有的数据都是存储在内存中的, 如果不进行任何的内存回收, 那么很容易出现内存爆满的情况。因此，在某些情况下需要对占用的内存空间进行释放。</p><p>Redis 中内存的释放主要分为两类<br>Redis 中内存的释放主要分为两类: </p><blockquote><ol><li>内存回收: 将过期的 key 清除，以减少内存占用</li><li>内存淘汰: 在内存使用达到上限(max_memory), 按照一定的策略删除一些键，以释放内存空间</li></ol></blockquote><p>两者都是通过删除 key (及其对应的 value) 来达到释放空间的效果。<br>区别在于前者清除的是用户明确不需要的 key, 而后者清除的则是用户可能仍然需要的 key。</p><h2 id="2-内存回收"><a href="#2-内存回收" class="headerlink" title="2 内存回收"></a>2 内存回收</h2><h3 id="2-1-过期策略"><a href="#2-1-过期策略" class="headerlink" title="2.1 过期策略"></a>2.1 过期策略</h3><p>在内存中的大量 key 中, 如何清除其中已经过期的 key 呢?</p><p>常用的方式有 3 种</p><blockquote><ol><li>定时过期 </li><li>惰性过期 </li><li>定期过期</li></ol></blockquote><p><strong>定时过期</strong></p><p>为每个 key 都创建一个定时器, 时间到了, 就将这个 key 清除。<br>该策略可以立即清除过期的数据, 对内存很友好。但是会占用大量的 CPU 资源去处理过期的数据, 从而影响缓存的响应时间和吞吐量。</p><p><strong>惰性过期</strong></p><p>key 过期了, 不进行处理。当后续访问到这个 key 时, 才会判断该 key 是否已过期, 过期则清除。<br>该策略可以最大化地节省 CPU 资源, 却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问, 从而不会被清除, 占用大量内存。</p><p><strong>定期过期</strong></p><p>将所有的 key 维护在一起, 每隔一段时间就从中扫描一定的数量的 key(采样), 并清除其中已经过期的 key。<br>通过调整定时扫描的时间间隔和每次扫描的耗时, 可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。</p><p>在 Reids 的实现中是通过 <strong>惰性过期</strong> + <strong>定期过期</strong> 2 种策略配合, 达到内存回收的效果。</p><h3 id="2-2-惰性过期-在-Redis-中的实现"><a href="#2-2-惰性过期-在-Redis-中的实现" class="headerlink" title="2.2 惰性过期 在 Redis 中的实现"></a>2.2 惰性过期 在 Redis 中的实现</h3><p>前提: Redis 中一个对象的过期时间存放在 dictEntry 的 v.s64 中, 至于 dictEntry 的设计可以看一下后面的<strong>附录</strong>。</p><p>Redis 大部分读写对象的命令, 在执行前都会调用 <strong>expireIfNeeded</strong> 函数做一个过期检查</p><blockquote><ol><li>如果 key 已经过期了, 将其删除</li><li>如果 key 未过期, 不做任何处理</li></ol></blockquote><p>expireIfNeeded 函数的定义如下</p><pre class="language-C" data-language="C"><code class="language-C">int expireIfNeeded(redisDb *db, robj *key) &#123;    &#x2F;&#x2F; key 未过期返回 0    if (!keyIsExpired(db,key)) return 0;    &#x2F;&#x2F; 下面的逻辑都是 Key 过期的逻辑处理    &#x2F;&#x2F; 当前的节点是从节点, 返回 1, 然后结束    &#x2F;&#x2F; 为了保持主从数据的一致, 从节点不会主动清除数据, 都是主节点同步消息在删除    if (server.masterhost !&#x3D; NULL) return 1;    &#x2F;&#x2F; 已经删除过期键个数 + 1    server.stat_expiredkeys++;    &#x2F;&#x2F; 向从节点和 AOF 文件传播 key 过期信息, 清除过期 key    propagateExpire(db,key,server.lazyfree_lazy_expire);    &#x2F;&#x2F; 发送事件通知    notifyKeyspaceEvent(NOTIFY_EXPIRED,&quot;expired&quot;,key,db-&gt;id);    &#x2F;&#x2F; lazyfree-lazy-expire 配置参数 (版本 4.0 以上支持), 默认为 0    &#x2F;&#x2F; 根据配置, 同步或异步删除 key (异步删除: 先将 key 逻辑删除, 然后在通过后台的线程池进行真正的空间释放)    return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : dbSyncDelete(db,key);&#125;int keyIsExpired(redisDb *db, robj *key) &#123;    &#x2F;&#x2F; 从过期字典中获取 key 对应的过期时间, 实际就是获取 dictEntity 的 v 中的 s64 值 (dictEntity.v.s64)    mstime_t when &#x3D; getExpire(db,key);    mstime_t now;    &#x2F;&#x2F; 没有过期时间    if (when &lt; 0) return 0;    &#x2F;&#x2F; redis 在加载数据中    if (server.loading) return 0;        &#x2F;&#x2F; 获取当前的事件    if (server.lua_caller) &#123;        &#x2F;&#x2F; 有 lua 脚本在执行中, 当前时间等于脚本开始执行前的时间        now &#x3D; server.lua_time_start;    &#125; else if (server.fixed_time_expire &gt; 0) &#123;        &#x2F;&#x2F; 有缓存时间, 线使用缓存时间        &#x2F;&#x2F; server.mstime 这个时间会在调用执行命令函数的 call() 前进行更新        &#x2F;&#x2F; 这样可以避免一些批量操作的命令, 比如 RPOPLPUSH 等命令, 这些命令会执行过程中可能多次访问这个 key        &#x2F;&#x2F; 而在多次的访问过程中, 可能出现上一次访问未过期, 下次访问已经过期了, 通过这个缓冲时间可以解决这个问题        now &#x3D; server.mstime;    &#125; else &#123;        &#x2F;&#x2F; 其他情况, 直接获取当前时间        now &#x3D; mstime();    &#125;    &#x2F;&#x2F; 当前时间是否大于 key 的过期时间    return now &gt; when;&#125;</code></pre><p>expireIfNeeded 的调用时机, 基本都是在各个命令内部。 以 String 的 get 命令为例, 大体的流程如下</p><pre class="language-C" data-language="C"><code class="language-C">&#x2F;** * get 命令对应的执行函数 * 需要的参数都封装在 client 对象中 *&#x2F;void getCommand(client *c) &#123;    &#x2F;&#x2F; getGenericCommand -&gt; lookupKeyReadOrReply -&gt; lookupKeyRead -&gt; lookupKeyReadWithFlags    &#x2F;&#x2F; getGenericCommand 经过几个函数最终调用到 lookupKeyReadWithFlags    getGenericCommand(c);&#125;robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) &#123;    robj *val;    &#x2F;&#x2F; expireIfNeeded 返回 &gt; 0, 过期了    if (expireIfNeeded(db,key) &#x3D;&#x3D; 1) &#123;        &#x2F;&#x2F; 省略过期处理        &#x2F;&#x2F; 过期的处理, 然后 return null    &#125;    &#x2F;&#x2F; 非过期处理, 查找然后返回    val &#x3D; lookupKey(db,key,flags);    if (val &#x3D;&#x3D; NULL)        server.stat_keyspace_misses++;    else        server.stat_keyspace_hits++;    return val;&#125;</code></pre><p>上面就是 get 指令的中的惰性过期的过程, 其他命令的逻辑差不多, 核心就是一个 expireIfNeeded 函数。</p><h3 id="2-3-定期过期在-Redis-中的实现"><a href="#2-3-定期过期在-Redis-中的实现" class="headerlink" title="2.3 定期过期在 Redis 中的实现"></a>2.3 定期过期在 Redis 中的实现</h3><p>Redis 默认是 16 个数据库, 每个数据库会将设置了过期时间的 key 放到各自的一个独立的字典中, 称为过期字典 (redisDb 对象的 dict *expires 属性)。</p><p>然后 Redis 默认会按照每秒 10 次的频率（可以通过 redis.conf 中的 hz 配置）进行过期扫描。<br>扫描的过程不会遍历整个过期字典，而是按照以下策略进行</p><blockquote><ol><li>从过期字典中随机选择 20 个 key </li><li>删除其中已经过期的键</li><li>如果超过 25% 的键被删除, 则重复步骤 1, 2, 3, 没有超过, 就结束这次扫描</li><li>同时为防止重复循环, 导致线程卡死, 增加了每 16 次抽样, 就做一次扫描时间的上限的检查 (默认是慢模式下, 上限是 25 毫秒, 如果是快模式，扫描上限是 1 毫秒), 超过就结束循环</li></ol></blockquote><p>定期过期删除的实现主要在 <strong>&#x2F;activeExpireCycle</strong> 函数, 大体的逻辑如下</p><pre class="language-C" data-language="C"><code class="language-C">&#x2F;** * 过期循环清除 * 为了便于理解, 这里对函数的逻辑做了一点小调整和删除一些非必要的逻辑, 但是整体的逻辑不变 * @type 模式, 取值有 2 个 ACTIVE_EXPIRE_CYCLE_SLOW (0, 慢模式), ACTIVE_EXPIRE_CYCLE_FAST (1, 快模式) *&#x2F;void activeExpireCycle(int type) &#123;    &#x2F;&#x2F; 静态变量, 当前处理的数据库索引    &#x2F;&#x2F; 静态的效果, 这个变量执行后的值不会被清空, 每次调用这个方法, 是上一次执行的值    &#x2F;&#x2F; 这样就可以保证 16 个数据库, 每次方法执行完, 下次进来可以执行到下一个数据库, 循环起来，而不是每次进来都从第 0 个开始    static unsigned int current_db &#x3D; 0;    &#x2F;&#x2F; 上一次清理是否是因为时间超时结束循环的, 同样是静态变量    static int timelimit_exit &#x3D; 0;        &#x2F;&#x2F; 上一次快速循环循环的时间, 同样是静态变量    static long long last_fast_cycle &#x3D; 0;    &#x2F;&#x2F; 当前时间    long long start &#x3D; ustime(),    &#x2F;&#x2F; 本次循环清除是快速循环, 上一次是时间超时获取 2 次快速循环的时间差在 2 毫秒内, 不执行    if (type &#x3D;&#x3D; ACTIVE_EXPIRE_CYCLE_FAST) &#123;        &#x2F;&#x2F; 上一次循环是因为时间超时结束的, 本次快速循环不进行        if (!timelimit_exit) return;        &#x2F;&#x2F; 上次快速循环距离当前时间在 1000 * 2 &#x3D; 2 毫秒内, 也不进行快速循环        if (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) return;        last_fast_cycle &#x3D; start;    &#125;    &#x2F;&#x2F; 计算循环的上限毫秒限制     &#x2F;&#x2F; server.hz 默认等于 10, ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC 等于 25    &#x2F;&#x2F; 1000000 * 25 &#x2F; 10 &#x2F; 100 &#x3D; 25000 单位: 微秒, 即 25 毫秒    long long timelimit &#x3D; 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC&#x2F;server.hz&#x2F;100;    &#x2F;&#x2F; ACTIVE_EXPIRE_CYCLE_FAST_DURATION &#x3D; 1000    &#x2F;&#x2F; 如果是快模式, 修改为 1000 微秒, 即 1 毫秒超时    if (type &#x3D;&#x3D; ACTIVE_EXPIRE_CYCLE_FAST)        timelimit &#x3D; ACTIVE_EXPIRE_CYCLE_FAST_DURATION;    &#x2F;&#x2F; CRON_DBS_PER_CALL &#x3D; 16, 每次循环处理的数据库数量    int dbs_per_call &#x3D; CRON_DBS_PER_CALL;    &#x2F;&#x2F; 遍历当前数据库的次数    int iteration &#x3D; 0;    &#x2F;&#x2F; 遍历循环 16 个数据库    for (int j &#x3D; 0; j &lt; dbs_per_call &amp;&amp; timelimit_exit &#x3D;&#x3D; 0; j++) &#123;        &#x2F;&#x2F; 清理过期的 key 个数        int expired;        &#x2F;&#x2F; 计算本次处理的数据库        redisDb *db &#x3D; server.db+(current_db % server.dbnum);        current_db++;        do &#123;            &#x2F;&#x2F; 开始循环清除当前数据库中过期的 key            &#x2F;&#x2F; 遍历次数 + 1            iteration++;            &#x2F;&#x2F; dictSize 获取整个过期字典的已经使用大小            unsigned long num &#x3D; dictSize(db-&gt;expires);            &#x2F;&#x2F; num &#x3D;&#x3D; 0 表示整个字典没有数据, 跳出循环，处理下一个数据库            if (num &#x3D;&#x3D; 0) &#123;                break;            &#125;            &#x2F;&#x2F; 计算整个过期字典的总大小            unsigned long slots &#x3D; dictSlots(db-&gt;expires);            &#x2F;&#x2F; DICT_HT_INITIAL_SIZE &#x3D; 4, 每个字典初始化时的默认值            &#x2F;&#x2F; num &gt; 0, 字典中有数据了, slots 大于 4, 表示当前的字典扩容过了            &#x2F;&#x2F; num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE, 当前的字典扩容过同时里面有数据            &#x2F;&#x2F; num * 100 &#x2F; slots &lt; 1 计算当前使用的数据占整个字典的百分比是否小于 1%            &#x2F;&#x2F; Redis 认为, 如果一个字典中的使用率小于 1%, 花时间去进行清理是一个昂贵的操作            &#x2F;&#x2F; 应该停下来，等待更好的时间再进行调整            &#x2F;&#x2F; 所以简单理解: 当这个字典中使用的空间小于 1%, 这里跳过了这个数据的处理            if (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp; (num * 100 &#x2F; slots &lt; 1))                 break;            expired &#x3D; 0;            &#x2F;&#x2F; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP &#x3D; 20             &#x2F;&#x2F; 本次从过期字典中获取多少个 key, 如果字典中的已经使用的 key 大于 20, 则只取 20 个, 否则有多少取多少            if (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)                num &#x3D; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;                        &#x2F;&#x2F; 循环 num 次从字典中获取 key             while (num--) &#123;                dictEntry *de;                &#x2F;&#x2F; 从过期字典中随机获取一个 key, 获取不到, 就停止本次循环                if ((de &#x3D; dictGetRandomKey(db-&gt;expires)) &#x3D;&#x3D; NULL) break;                &#x2F;&#x2F; 尝试释放这个 key, 如果 key 释放成功, 过期次数 + 1                if (activeExpireCycleTryExpire(db,de,now)) expired++;            &#125;            &#x2F;&#x2F; 0xf &#x3D; 15, iteration 表示遍历了 15 次            if ((iteration &amp; 0xf) &#x3D;&#x3D; 0) &#123;                &#x2F;&#x2F; 计算消耗时间                int elapsed &#x3D; ustime()-start;                &#x2F;&#x2F; 消耗时间超过了限制时间, 结束本次循环                if (elapsed &gt; timelimit) &#123;                    &#x2F;&#x2F; 超过时间限制标识设置为 true, 本次循环清除超时了, 结束本次循环清除                    timelimit_exit &#x3D; 1;                    break;                &#125;            &#125;            &#x2F;&#x2F; 本次清理的过期 key 超过了 25%, 继续, 否则结束            &#x2F;&#x2F; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP &#x3D; 20            &#x2F;&#x2F; 每次抽取的个数最大为 20 个, 控制 25%, 20 * 25% &#x3D; 5 个            &#x2F;&#x2F; 也就是过期的个数大于 5 就是大于 25%, (ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP&#x2F;4 &#x3D; 5)        &#125; while (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP&#x2F;4);    &#125;    &#x2F;&#x2F; 省略各种分析数据的记录&#125;</code></pre><p>调用 activeExpireCycle 的入口有 2 个</p><ol><li>Redis 定时事件触发</li></ol><pre class="language-C" data-language="C"><code class="language-C">&#x2F;** * Reids 启动时, 向事件轮询中注册的唯一一个定时事件(默认 100 毫秒执行一次), 执行的函数 *&#x2F;int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) &#123;    ...    &#x2F;&#x2F; 数据库扫描    databasesCron();    ...&#125;void databasesCron(void) &#123;    &#x2F;&#x2F; 过期功能开启中, 默认为开启    if (server.active_expire_enabled) &#123;        &#x2F;&#x2F; 主节点        if (server.masterhost &#x3D;&#x3D; NULL) &#123;            &#x2F;&#x2F; 慢模式循环清除            activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);        &#125; else &#123;            &#x2F;&#x2F; 从节点处理            expireSlaveKeys();        &#125;    &#125;    ...&#125;</code></pre><ol start="2"><li>事件轮询中, 进入阻塞前的调用函数</li></ol><pre class="language-C" data-language="C"><code class="language-C">void beforeSleep(struct aeEventLoop *eventLoop) &#123;    ...    &#x2F;&#x2F; 过期功能开启中同时为主节点    if (server.active_expire_enabled &amp;&amp; server.masterhost &#x3D;&#x3D; NULL)        &#x2F;&#x2F; 快模式循环清除        activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);    ...&#125;</code></pre><h2 id="3-内存淘汰"><a href="#3-内存淘汰" class="headerlink" title="3 内存淘汰"></a>3 内存淘汰</h2><h3 id="3-1-淘汰算法"><a href="#3-1-淘汰算法" class="headerlink" title="3.1 淘汰算法"></a>3.1 淘汰算法</h3><p>为了能够腾出内存空间, 需要在一大群对象中选择某一些进行淘汰, 哪么应该基于什么标准进行选择呢?<br>比较常见的算法有 2 个: LRU 和 LFU。</p><p>LRU (Least Recently Used): 最近最少使用算法, 根据数据的历史访问记录进行淘汰数据，优先移除<strong>最近最少使用</strong>的数据。<br>简单理解就是根据对象的访问时间, 优先淘汰访问时间最早的对象。</p><p>LFU (Least Frequently Used): 最少频率使用算法, 根据数据的访问频率频率进行淘汰数据, 优先移除<strong>最近使用频率最少</strong>的数据。<br>简单理解就是根据对象的访问次数, 优先淘汰访问次数最少的对象。</p><h3 id="3-2-Redis-内存淘汰策略"><a href="#3-2-Redis-内存淘汰策略" class="headerlink" title="3.2 Redis 内存淘汰策略"></a>3.2 Redis 内存淘汰策略</h3><p>在 LFU 和 LRU 的基础上, Redis 提供了 8 种淘汰策略</p><table><thead><tr><th align="center">策略</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">noeviction</td><td align="center">默认策略, 不会删除任何数据, 但是拒绝所有写入操作并返回客户端错误信息 (error)OOM command not allow when used memory。此时 Redis 只响应读操作。</td></tr><tr><td align="center">volatile-lru</td><td align="center">Least Recently Used, 最近最少使用。在所有设置了 expire 的 key 中删除最近最少使用的键值对, 即距离上次访问时间最久的。</td></tr><tr><td align="center">allkeys-lru</td><td align="center">Least Recently Used, 最近最少使用。在所有的 key 中删除最近最少使用的键值对, 即距离上次访问时间最久的。</td></tr><tr><td align="center">volatile-lfu</td><td align="center">Least Frequently Used, 最不经常使用。在所有设置了 expire 的 key 中删除最不经常使用的键值对, 即访问次数最少的。</td></tr><tr><td align="center">allkeys-lfu</td><td align="center">Least Frequently Used, 最不经常使用。在所有的 key 中删除最不经常使用的键值对, 即访问次数最少的。</td></tr><tr><td align="center">volatile-random</td><td align="center">在所有设置了 expire 的 key 中随机选择删除</td></tr><tr><td align="center">allkeys-random</td><td align="center">在所有的 key 中随机选择删除。</td></tr><tr><td align="center">volatile-ttl</td><td align="center">Time To Live, 存活时间。 在所有设置了 expire 的 key 中删除 ttl 值最多的。</td></tr></tbody></table><p>volatile-lru, volatile-random, volatile-ttl, 在没有符合条件的 key 的情况下, 会按照 noeviction 的策略进行处理。</p><h3 id="3-3-Redis-对象淘汰判断标准设计"><a href="#3-3-Redis-对象淘汰判断标准设计" class="headerlink" title="3.3 Redis 对象淘汰判断标准设计"></a>3.3 Redis 对象淘汰判断标准设计</h3><p>在上面介绍的几种策略可以知道, 要判断一个对象是否可以被淘汰, 需要对象自身存放使用策略对应的数据, 以便于判断<br>比如: </p><blockquote><ol><li>2 个 lru 策略, 需要对象自身保存好上次访问的时间</li><li>2 个 lfu 策略, 需要对象自身保存好访问次数</li><li>ttl 策略, 需要对象自身保存好过期时间</li><li>2 个 random 策略, 不需要保存额外的数据, 通过随机一个数, 根据这个数从字典中获取数据即可</li></ol></blockquote><h5 id="3-3-1-Redis-对象的设计"><a href="#3-3-1-Redis-对象的设计" class="headerlink" title="3.3.1 Redis 对象的设计"></a>3.3.1 Redis 对象的设计</h5><p>正常情况下, 当我们向 Redis 中存入一对键值对, 实际可以拆分为 2 个对象, 一个 key, 一个 value。<br>其中 key 可以明确为是一个字符串, 所以存入到 Redis 的键值对的 key 会被封装为 sds 对象。<br>但是 value 可以类型可以很多, 为了行为的统一等, 需要对 value 做一个封装, 落实到源码中就是一个 <strong>redisObject</strong> 对象, 其定义如下</p><pre class="language-C" data-language="C"><code class="language-C">typedef struct redisObject &#123;        &#x2F;**      * 标识这个对象的数据类型, 常说的 String, Hash, List 等     *&#x2F;    unsigned type:4;    &#x2F;**     * 可以理解为数据类型的具体实现类型     * 比如数据类型为 List, 在具体的实现中可以是 ArrayList LinkedList 等     *&#x2F;    unsigned encoding:4;    &#x2F;**      * LRU_BITS &#x3D; 24,     * 一个 24 位的变量, 表示对象最后一次被程序访问的时间或者访问的次数, 与内存回收有关     * 暂时知道有这个对象即可, 后面有分析     *&#x2F;    unsigned lru:LRU_BITS;    &#x2F;**     * 被引用的次数, 当 refcount 为 0 的时候, 表示该对象已经不被任何对象引用, 则可以进行垃圾回收了     *&#x2F;    int refcount;    &#x2F;**     * 一个指针, 指向具体的数据     *&#x2F;    void *ptr;&#125; robj;</code></pre><p>一个对象的 lru 和 lfu 计算后的值, 都是存放在这个对象的 lru 字段中的, 但是 lru 和 lfu 的计算方式是不一样的。</p><h5 id="3-3-2-lru-策略-对象的访问时间设计"><a href="#3-3-2-lru-策略-对象的访问时间设计" class="headerlink" title="3.3.2 lru 策略, 对象的访问时间设计"></a>3.3.2 lru 策略, 对象的访问时间设计</h5><h6 id="3-3-2-1-全局时间-lruclock"><a href="#3-3-2-1-全局时间-lruclock" class="headerlink" title="3.3.2.1 全局时间 lruclock"></a>3.3.2.1 全局时间 lruclock</h6><p>在 Redis 的中维护了一个全局的变量 lruclock, 表示当前时间的一个相对值。</p><pre class="language-C" data-language="C"><code class="language-C">&#x2F;** * redisServer 可以看做整个 Redis 运行时的上下文, 保存的数据, 配置等都在这个结构体中 *&#x2F;struct redisServer &#123;    unsigned int lruclock &#x3D; getLRUClock();&#125;unsigned int getLRUClock(void) &#123;    &#x2F;&#x2F; LRU_CLOCK_RESOLUTION &#x3D; 1000    &#x2F;&#x2F; mstime() 当前时间毫秒, 当前时间的毫秒&#x2F;LRU_CLOCK_RESOLUTION &#x3D; 当前时间的毫秒&#x2F;1000 &#x3D; 变为单位秒    &#x2F;&#x2F; LRU_CLOCK_MAX &#x3D; ((1&lt;&lt;LRU_BITS)-1) &#x3D; 1&lt;&lt;24-1 &#x3D; redisObject lru 字段的最大值    &#x2F;&#x2F; (当前的时间 &#x2F; 1000) &amp; (1&lt;&lt;24-1) 确保时间的精度是秒, 同时不会超过 24 位的整数的最多值    &#x2F;&#x2F; 整个全局时间的进度为秒, 2 个对象的访问时间差如果在秒内, 得到的是他们的访问时间是一样的        &#x2F;&#x2F; 得到一个当前时间的相对值    return (mstime()&#x2F;LRU_CLOCK_RESOLUTION) &amp; LRU_CLOCK_MAX;&#125;</code></pre><p>同时这个时间会在 Redis 的定时任务 serverCron 中定时的更新为最新的值</p><pre class="language-C" data-language="C"><code class="language-C">int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) &#123;    &#x2F;&#x2F; serverCron 默认是 100 毫秒执行一次    unsigned int lruclock &#x3D; getLRUClock();    atomicSet(server.lruclock,lruclock);&#125;</code></pre><h6 id="3-3-2-2-对象的访问时间设计"><a href="#3-3-2-2-对象的访问时间设计" class="headerlink" title="3.3.2.2 对象的访问时间设计"></a>3.3.2.2 对象的访问时间设计</h6><p>Redis 每次通过 key 在数据库中查询对应的 value 时, 在找到时, 就会进行 lru 字段的更新</p><pre class="language-C" data-language="C"><code class="language-C">robj *lookupKey(redisDb *db, robj *key, int flags) &#123;    &#x2F;&#x2F; 从字典中获取 key 对应的 dictEntry (字典的设计可以看一下后面的附录)    dictEntry *de &#x3D; dictFind(db-&gt;dict,key-&gt;ptr);    if (de) &#123;        &#x2F;&#x2F; 获取 key 对应的 dictEntry 的存在        &#x2F;&#x2F; 获取 dictEntry 的 value 也就是 redisObject 对象        robj *val &#x3D; dictGetVal(de);        if (server.rdb_child_pid &#x3D;&#x3D; -1 &amp;&amp; server.aof_child_pid &#x3D;&#x3D; -1 &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH)) &#123;            &#x2F;&#x2F; 没有在进行 RDB 或 AOF 操作, 并且 flags 没有设置 LOOKUP_NOTOUCH            &#x2F;&#x2F; 淘汰策略设置的的 LFU 策略            if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;                updateLFU(val);            &#125; else &#123;                &#x2F;&#x2F; 其他策略, 更新 lru 为全局的 lruclock                val-&gt;lru &#x3D; LRU_CLOCK();            &#125;        &#125;    &#125; else &#123;        &#x2F;&#x2F; key 不存在, 返回 null        return NULL;    &#125;&#125;unsigned int LRU_CLOCK(void) &#123;    unsigned int lruclock;    &#x2F;&#x2F; LRU_CLOCK_RESOLUTION &#x3D; 1000    &#x2F;&#x2F; 1000&#x2F;server.hz 就是上面定时任务 serverCron 的执行时间    &#x2F;&#x2F; &lt;&#x3D; 1000 说明 serverCron 的执行时间小于 1 秒, 直接获取 server.lruclock 的值    &#x2F;&#x2F; 如果大于 1000, 就调用 getLRUClock() 实时获取当前的时间, 因为频率太低了, 会造成更多的对象的访问时间一样    if (1000&#x2F;server.hz &lt;&#x3D; LRU_CLOCK_RESOLUTION) &#123;        atomicGet(server.lruclock,lruclock);    &#125; else &#123;        lruclock &#x3D; getLRUClock();    &#125;    return lruclock;&#125;</code></pre><h5 id="3-3-3-lfu-策略-对象的访问频率设计"><a href="#3-3-3-lfu-策略-对象的访问频率设计" class="headerlink" title="3.3.3 lfu 策略, 对象的访问频率设计"></a>3.3.3 lfu 策略, 对象的访问频率设计</h5><p>对象的 lfu 同样是存放在 redisObject 的 <strong>lru:LRU_BITS</strong> 字段。 这个 24 bits 字段, 被分为两部分</p><blockquote><ol><li>高 16 位用来记录访问时间 (单位为分钟，ldt, last decrement time)</li><li>低 8 位用来记录相对的访问次数, 简称 counter (logc, logistic counter)</li></ol></blockquote><p>Redis 中对 LFU 的实现比较特殊, 通过时间衰减的方式近似达到了 LFU 的效果。<br>大体的思路如下:</p><blockquote><ol><li>对象创建时, 初始访问次数为 5 (避免刚创建出来, 对象就被回收), 同时记录下当前时间, 单位分钟</li><li>对象被访问时, 获取当前时间, 单位分钟, 当前时间 - 对象本身记录的时间, 得到相差多少分钟, 访问次数就减少多少</li><li>然后对象的访问次数 + 1, 再次记录下当前时间</li></ol></blockquote><p>这样对象在单位分钟内, 访问越频繁, 访问次数越大, 同时随着时间的推移, 没有进行访问, 访问次数会逐渐减少, 从而达到了 LFU 的效果。</p><p>ldt 记录的是最近一次访问的时间, 16 位, 所以最大值为 65535, 单位是分钟, 差不多 45 天左右。<br>也就是一个对象如果一直被访问, 到了第 45 天后, 这个值又会重新回到 0 开始计算。</p><p>ldt 的计算</p><pre class="language-C" data-language="C"><code class="language-C">unsigned long LFUGetTimeInMinutes(void) &#123;  &#x2F;&#x2F; &amp; 65535 保证时间的范围在 0 ~ 65535 之间, 不会超过 16 数值的大小     return (server.unixtime&#x2F;60) &amp; 65535;&#125;</code></pre><p>同 lru 一样, lruclock 的计算, 后面的时间比前面的时间小,<br>说明后面的时间到了下一轮的重新开始了, 这时只需要后面的时间 + 65535 - 前面的时间, 就能得到 2 个时间的差值了。</p><p>logc 记录的是一个相对的访问次数。<br>本身只有 8 位, 也就是最大值为 255, 也就是一个对象只能保存 255 次访问次数, 这个基本不同满足日常的使用。<br>所以 Redis 内部设计了一个随机公式, 控制访问次数的增长, 即每次访问, 访问次数加不加一, 通过随机判断。</p><pre class="language-C" data-language="C"><code class="language-C">uint8_t LFULogIncr(uint8_t counter) &#123;    &#x2F;&#x2F; 当前的访问次数已经达到了最大值了    if (counter &#x3D;&#x3D; 255)         return 255;    &#x2F;&#x2F; 产生一个随机数    double r &#x3D; (double)rand()&#x2F;RAND_MAX;    &#x2F;&#x2F; 获取一个基础值, 当前的次数 - 对象初始化的默认次数 (LFU_INIT_VAL &#x3D; 5)    double baseval &#x3D; counter - LFU_INIT_VAL;    if (baseval &lt; 0) baseval &#x3D; 0;    &#x2F;&#x2F; 1.0 &#x2F; 基础值 * server.lfu_log_factor (默认值, 10, 可配置) + 1, 得到一个数    double p &#x3D; 1.0&#x2F;(baseval*server.lfu_log_factor+1);    &#x2F;&#x2F; 得到的数大于随机出来的数, 访问次数 + 1    if (r &lt; p) counter++;    return counter;&#125;</code></pre><p>官方的测试数据 (可以简单看成, counter &#x3D; 5, 在 100 - 1000w 次的调用, lfu_log_factor 不同取值下, 最终的 counter 的值)</p><table><thead><tr><th align="center">lfu_log_factor 取值</th><th align="center">100 次</th><th align="center">1000 次</th><th align="center">10w 次</th><th align="center">100w 次</th><th align="center">1000w 次</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">104</td><td align="center">255</td><td align="center">255</td><td align="center">255</td><td align="center">255</td></tr><tr><td align="center">1</td><td align="center">18</td><td align="center">49</td><td align="center">255</td><td align="center">255</td><td align="center">255</td></tr><tr><td align="center">10</td><td align="center">10</td><td align="center">18</td><td align="center">142</td><td align="center">255</td><td align="center">255</td></tr><tr><td align="center">100</td><td align="center">8</td><td align="center">11</td><td align="center">49</td><td align="center">143</td><td align="center">255</td></tr></tbody></table><p>lfu_log_factor 设置为 10 的情况下, 在 100w 次的访问中, 访问次数才达到为 255, 也就是最大值。<br>基本可以满足 10w 次的使用</p><h6 id="3-3-3-1-counter-衰减机制"><a href="#3-3-3-1-counter-衰减机制" class="headerlink" title="3.3.3.1 counter 衰减机制"></a>3.3.3.1 counter 衰减机制</h6><p>每个对象被返回时, counter 都会先进行一个衰减操作, 然后再通过上面的随机公式进行判断次数是否需要增加。</p><p>衰减的过程如下</p><pre class="language-C" data-language="C"><code class="language-C">unsigned long LFUDecrAndReturn(robj *o) &#123;    &#x2F;&#x2F; 右移 8 为, 也就是得的了高位的 16 位, 即 ldt, 得到上次记录的时间    unsigned long ldt &#x3D; o-&gt;lru &gt;&gt; 8;    &#x2F;&#x2F; 得到当前保存的次数    unsigned long counter &#x3D; o-&gt;lru &amp; 255;    &#x2F;&#x2F; lfu_decay_time 衰减时间, 默认 1, 单位分钟    &#x2F;&#x2F; 如果没有配置 lfu_decay_time, 则默认不进行衰减, counter 当前是多少就是多少    &#x2F;&#x2F; 获取 2 次访问的时间差 &#x2F; lfu_decay_time, 得到经过了多少个时间段       unsigned long num_periods &#x3D; server.lfu_decay_time ? LFUTimeElapsed(ldt) &#x2F; server.lfu_decay_time : 0;    if (num_periods)        &#x2F;&#x2F; 最新的次数 &#x3D; 当前的次数 - 经过了多少个时间段, 小于 0 时, 设置为 0         counter &#x3D; (num_periods &gt; counter) ? 0 : counter - num_periods;    return counter;&#125;&#x2F;&#x2F; 距离上次访问相差多少分钟unsigned long LFUTimeElapsed(unsigned long ldt) &#123;    unsigned long now &#x3D; LFUGetTimeInMinutes();    if (now &gt;&#x3D; ldt) return now-ldt;    return 65535-ldt+now;&#125;</code></pre><h6 id="3-3-3-2-对象的访问频率设计"><a href="#3-3-3-2-对象的访问频率设计" class="headerlink" title="3.3.3.2 对象的访问频率设计"></a>3.3.3.2 对象的访问频率设计</h6><p>Redis 每次通过 key 在数据库中查询对应的 value 时, 在找到时, 就会进行 lru 字段的更新</p><pre class="language-C" data-language="C"><code class="language-C">robj *lookupKey(redisDb *db, robj *key, int flags) &#123;        dictEntry *de &#x3D; dictFind(db-&gt;dict,key-&gt;ptr);    if (de) &#123;        robj *val &#x3D; dictGetVal(de);        if (server.rdb_child_pid &#x3D;&#x3D; -1 &amp;&amp; server.aof_child_pid &#x3D;&#x3D; -1 &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH)) &#123;            &#x2F;&#x2F; 淘汰策略设置的的 LFU 策略            if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;                updateLFU(val);            &#125; else &#123;                val-&gt;lru &#x3D; LRU_CLOCK();            &#125;        &#125;    &#125; else &#123;        return NULL;    &#125;&#125;void updateLFU(robj *val) &#123;    &#x2F;&#x2F; 通过衰减机制, 得到最新的 counter    unsigned long counter &#x3D; LFUDecrAndReturn(val);    &#x2F;&#x2F; 通过随机公式, 得到最新的 counter    counter &#x3D; LFULogIncr(counter);    &#x2F;&#x2F; 将最新的 counter 和 当前时间保存到 lru 字段中    val-&gt;lru &#x3D; (LFUGetTimeInMinutes()&lt;&lt;8) | counter;&#125;</code></pre><h3 id="3-4-Redis-内存淘汰策略的实现"><a href="#3-4-Redis-内存淘汰策略的实现" class="headerlink" title="3.4 Redis 内存淘汰策略的实现"></a>3.4 Redis 内存淘汰策略的实现</h3><p>Redis 的内存的实现方式都是通过<strong>随机采样 + 比较 lru 值决定是否淘汰</strong>的方式实现的。</p><p>大体过程如下:</p><blockquote><ol><li>Redis 启动时, 会初始一个默认容量为 16 的待淘汰数据池 <strong>evictionPoolEntry (本质就是一个数组)</strong></li><li>每个存入到 Redis 的对象 (redisObject) 都会在初始其 24 位的 lru 字段 (lru: 一个相对的访问时间, lfu: 一个相对的访问次数)</li><li>后面每次访问 Redis 的对象时, 更新其 lru 字段的值</li><li>同时每次执行一个 Redis 命令时, 就会判断一下当前的内存是否足够, 如果不够, 就计算出需要释放多少内存, 然后进行内存淘汰</li></ol></blockquote><p>内存淘汰的过程如下: </p><p><strong>4.1 首次淘汰</strong><br>从数据字典或过期字典 (由配置的淘汰策略决定) 中随机抽样选出<strong>最多 N 个数据</strong>放入到一个<strong>样例池</strong>。<br>数据量 N: 由 redis.conf 配置的 maxmemory-samples 决定, 默认值是 5。 配置为 10 将非常接近真实 LRU 效果。<br>采样参数 maxmemory-samples 配置的数值越大, 就越能精确的查找到待淘汰的缓存数据, 但是也消耗更多的 CPU 计算, 执行效率降低。<br>同时为了避免长时间找不到足够的数据填充<strong>样例池</strong>, 强制写死了单次寻找数据的最大次数是 maxsteps &#x3D; N*10。  </p><p><strong>4.2 再次淘汰</strong><br>遍历整个<strong>样例池</strong>, 遍历的对象通过 lru 计算处理的值, 只要比<strong>待淘汰数据池</strong>中的<strong>任意一条</strong>数据的小, 就将该数据填充至<strong>待淘汰数据池</strong>。<br>第一次淘汰时, <strong>待淘汰数据池</strong>为空, 所以第一次淘汰时, 会将所有的样例数据填充到<strong>待淘汰数据池</strong>中, 这个池子后面就都会有数据, 一直存在着。<br>后续的淘汰时, <strong>样例池</strong> 中的数据就有可能进入到<strong>待淘汰数据池</strong>中, 也有可能不进入。</p><p><strong>4.3 执行淘汰</strong><br>从<strong>待淘汰数据池</strong>的尾部向前找到第一个可以删除的 key (此时找到的 key 就是值最小&#x2F;大的, 既空闲时间最大&#x2F;访问次数最小&#x2F;存活时间最小), 对其进行淘汰</p><p><strong>4.4 继续淘汰</strong><br>计算删除了一个 key 后内存释放了多少, 如果没达到要求的释放量, 就回到步骤 <strong>4.1</strong> 继续淘汰</p><h4 id="3-4-1-Redis-内存淘汰策略的代码实现"><a href="#3-4-1-Redis-内存淘汰策略的代码实现" class="headerlink" title="3.4.1 Redis 内存淘汰策略的代码实现"></a>3.4.1 Redis 内存淘汰策略的代码实现</h4><p>入口: 每个命令的执行处</p><pre class="language-C" data-language="C"><code class="language-C">int processCommand(client *c) &#123;    ...    &#x2F;&#x2F; 有设置最大内存 同时当前没有 lua 脚本超时的情况    if (server.maxmemory &amp;&amp; !server.lua_timedout) &#123;        &#x2F;&#x2F; 有必要时, 尝试释放内存        int out_of_memory &#x3D; freeMemoryIfNeededAndSafe() &#x3D;&#x3D; C_ERR;        &#x2F;&#x2F; 内存不够 同时执行的命令是变更命令 或者 当前的客户端开启了事务, 同时执行的命令不是 exec         if (out_of_memory &amp;&amp; (c-&gt;cmd-&gt;flags &amp; CMD_DENYOOM || (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp; c-&gt;cmd-&gt;proc !&#x3D; execCommand))) &#123;            flagTransaction(c);            &#x2F;&#x2F; 响应 -OOM command not allowed when used memory &gt; &#39;maxmemory’            addReply(c, shared.oomerr);            return C_OK;        &#125;    &#125;    ...&#125;int freeMemoryIfNeededAndSafe(void) &#123;    &#x2F;&#x2F; 当前有 lua 脚本执行超时或者真正加载数据, 返回成功    if (server.lua_timedout || server.loading) return C_OK;    &#x2F;&#x2F; 是否内存如果有必要的话    return freeMemoryIfNeeded();&#125;</code></pre><p>释放内存的核心函数</p><pre class="language-C" data-language="C"><code class="language-C">int freeMemoryIfNeeded(void) &#123;    &#x2F;&#x2F; 如果是从节点同时配置了从节点忽略内存配置, 直接返回    if (server.masterhost &amp;&amp; server.repl_slave_ignore_maxmemory) return C_OK;    &#x2F;&#x2F; mem_reported 保存了整个 Redis 已经使用的内存    &#x2F;&#x2F; mem_tofree 经过计算本次应该释放的内存, 等于当前已经使用的内存 - 用于主从复制的复制缓冲区大小 - 配置的 maxmemory    &#x2F;&#x2F; mem_freed 已经释放了多少内存    size_t mem_reported, mem_tofree, mem_freed;    long long delta;    &#x2F;&#x2F; 从节点个数    int slaves &#x3D; listLength(server.slaves);    &#x2F;&#x2F; 判断当前的内存状态, 如果足够, 直接返回    if (getMaxmemoryState(&amp;mem_reported,NULL,&amp;mem_tofree,NULL) &#x3D;&#x3D; C_OK)        return C_OK;    &#x2F;&#x2F; 如果配置的策略为  noeviction    if (server.maxmemory_policy &#x3D;&#x3D; MAXMEMORY_NO_EVICTION)        goto cant_free;    mem_freed &#x3D; 0;    &#x2F;&#x2F; 没有达到需要的内存大小, 继续循环    while (mem_freed &lt; mem_tofree) &#123;        static unsigned int next_db &#x3D; 0;        sds bestkey &#x3D; NULL;        int bestdbid;        redisDb *db;        dict *dict;        dictEntry *de;                if (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) || server.maxmemory_policy &#x3D;&#x3D; MAXMEMORY_VOLATILE_TTL) &#123;            &#x2F;&#x2F; LRU + LFU + TTL 策略            &#x2F;&#x2F; 淘汰池            struct evictionPoolEntry *pool &#x3D; EvictionPoolLRU;            while(bestkey &#x3D;&#x3D; NULL) &#123;                                &#x2F;&#x2F; 遍历 16 个数据库                for (i &#x3D; 0; i &lt; server.dbnum; i++) &#123;                    db &#x3D; server.db+i;                    &#x2F;&#x2F; 根据 volatile 或 all 选择对应的数据字典                    dict &#x3D; (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ? db-&gt;dict : db-&gt;expires;                    &#x2F;&#x2F; 获取字典的数据大小, keys 为当前数据库的 key 的数量                    if ((keys &#x3D; dictSize(dict)) !&#x3D; 0) &#123;                        evictionPoolPopulate(i, dict, db-&gt;dict, pool);                        total_keys +&#x3D; keys;                    &#125;                &#125;                &#x2F;&#x2F; 没有可以处理的 keys                if (!total_keys) break;                &#x2F;&#x2F; EVPOOL_SIZE &#x3D;  16                for (k &#x3D; EVPOOL_SIZE-1; k &gt;&#x3D; 0; k--) &#123;                    if (pool[k].key &#x3D;&#x3D; NULL) continue;                    bestdbid &#x3D; pool[k].dbid;                    &#x2F;&#x2F; 从数据库中获取对应的节点                    if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) &#123;                        de &#x3D; dictFind(server.db[pool[k].dbid].dict, pool[k].key);                    &#125; else &#123;                        de &#x3D; dictFind(server.db[pool[k].dbid].expires, pool[k].key);                    &#125;                    &#x2F;&#x2F; 释放缓存                    if (pool[k].key !&#x3D; pool[k].cached)                        sdsfree(pool[k].key);                    pool[k].key &#x3D; NULL;                    pool[k].idle &#x3D; 0;                    &#x2F;&#x2F; 找到的释放对象存在, 先跳出这次循环                    if (de) &#123;                        bestkey &#x3D; dictGetKey(de);                        break;                    &#125; else &#123;                        &#x2F;&#x2F; 不存在, 进行循环查找                    &#125;                &#125;            &#125;        &#125; else if (server.maxmemory_policy &#x3D;&#x3D; MAXMEMORY_ALLKEYS_RANDOM || server.maxmemory_policy &#x3D;&#x3D; MAXMEMORY_VOLATILE_RANDOM) &#123;            &#x2F;&#x2F; random 策略        &#125;        &#x2F;&#x2F; 删除找到的 key        if (bestkey) &#123;                        db &#x3D; server.db+bestdbid;            &#x2F;&#x2F; 将 key 封装为 redisObject 对象            robj *keyobj &#x3D; createStringObject(bestkey,sdslen(bestkey));            &#x2F;&#x2F; 传播 key 过期信息到主从复制和 AOF 文件            propagateExpire(db,keyobj,server.lazyfree_lazy_eviction);            &#x2F;&#x2F; 获取当前的内存大小            delta &#x3D; (long long) zmalloc_used_memory();            &#x2F;&#x2F; 同步删除或异步删除 key            if (server.lazyfree_lazy_eviction) &#123;                dbAsyncDelete(db,keyobj);            else                dbSyncDelete(db,keyobj);            &#125;            &#x2F;&#x2F; 计算本次释放的内存            delta -&#x3D; (long long) zmalloc_used_memory();            mem_freed +&#x3D; delta;            &#x2F;&#x2F; 释放创建的 key redisObject 对象            decrRefCount(keyobj);            keys_freed++;            &#x2F;&#x2F; 如果有从节点, 推送缓冲区的数据            if (slaves) flushSlavesOutputBuffers();            &#x2F;&#x2F; 支持异步清除 同时 清除了 16 个 key            if (server.lazyfree_lazy_eviction &amp;&amp; !(keys_freed % 16)) &#123;                &#x2F;&#x2F; 再次判断内存情况, 如果内存足够了                if (getMaxmemoryState(NULL,NULL,NULL,NULL) &#x3D;&#x3D; C_OK) &#123;                    &#x2F;&#x2F; 更新已经释放的缓存大小 &#x3D; 需要释放的缓存大小                    mem_freed &#x3D; mem_tofree;                &#125;            &#125;        &#125;        &#x2F;&#x2F; 本次释放没有处理成功任何一个 key        if (!keys_freed) &#123;            goto cant_free;         &#125;    &#125;    return C_OK;cant_free:    &#x2F;&#x2F; 没有内存可以分配了, 做唯一可以做的一件事: 检查是否有 lazyfree 线程在执行释放内存任务, 有进行等待    &#x2F;&#x2F; 知道没有任务或者已有的内存达到了需要释放的内存    while(bioPendingJobsOfType(BIO_LAZY_FREE)) &#123;        &#x2F;&#x2F; 当前的内存达到了现在需要的释放的内存, 结束检查        if (((mem_reported - zmalloc_used_memory()) + mem_freed) &gt;&#x3D; mem_tofree)            break;        usleep(1000);    &#125;    return C_ERR;  </code></pre><p>淘汰池的填充</p><pre class="language-C" data-language="C"><code class="language-C">void evictionPoolPopulate(int dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool) &#123;    int j, k, count;    &#x2F;&#x2F; 采样结果数组, 最大容量为 mamemory_samples 的大小    dictEntry *samples[server.maxmemory_samples];    &#x2F;&#x2F; 从 sampledict 字典中采样 server.maxmemory_samples 个 key 存放到 samples, 同时返回总共采样的多少个    count &#x3D; dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);    for (j &#x3D; 0; j &lt; count; j++) &#123;        unsigned long long idle;        sds key;        robj *o;        dictEntry *de;        de &#x3D; samples[j];        key &#x3D; dictGetKey(de);               if (server.maxmemory_policy !&#x3D; MAXMEMORY_VOLATILE_TTL) &#123;            if (sampledict !&#x3D; keydict) de &#x3D; dictFind(keydict, key);            o &#x3D; dictGetVal(de);        &#125;        if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU) &#123;            &#x2F;&#x2F; LRU 算法            idle &#x3D; estimateObjectIdleTime(o);        &#125; else if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;            &#x2F;&#x2F; LRU 算法            idle &#x3D; 255 - LFUDecrAndReturn(o);        &#125; else if (server.maxmemory_policy &#x3D;&#x3D; MAXMEMORY_VOLATILE_TTL) &#123;            &#x2F;&#x2F; TTL 算法            idle &#x3D; ULLONG_MAX - (long)dictGetVal(de);        &#125; else &#123;            serverPanic(&quot;Unknown eviction policy in evictionPoolPopulate()&quot;);        &#125;        k &#x3D; 0;        &#x2F;&#x2F; 从 evictionPoolEntry 淘汰池中找到第一个闲置时间比当前淘汰 key 大的        while (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key &amp;&amp; pool[k].idle &lt; idle)             k++;                if (k &#x3D;&#x3D; 0 &amp;&amp; pool[EVPOOL_SIZE-1].key !&#x3D; NULL) &#123;            &#x2F;&#x2F; 如果找到的 key 比淘汰池中闲置时间最小的 key 还小, 同时淘汰池没有空间了, 则跳过这个 key            continue;        &#125; else if (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key &#x3D;&#x3D; NULL) &#123;            &#x2F;&#x2F; 插入的位置为空, 直接进入到下面的赋值节点        &#125; else &#123;            &#x2F;&#x2F; 核心就是将找到的位置 k 空出来            &#x2F;&#x2F; 最后的位置为空            if (pool[EVPOOL_SIZE-1].key &#x3D;&#x3D; NULL) &#123;                &#x2F;&#x2F; 将原本 k 位置和后面的数据向后移动 1 位                 sds cached &#x3D; pool[EVPOOL_SIZE-1].cached;                memmove(pool+k+1, pool+k, sizeof(pool[0])*(EVPOOL_SIZE-k-1));                pool[k].cached &#x3D; cached;            &#125; else &#123;                &#x2F;&#x2F; 插入的位置不为空                 &#x2F;&#x2F; 将原本 k 位置前面的数据往前移动 1 位, 原本的第一位丢弃                k--;                sds cached &#x3D; pool[0].cached;                if (pool[0].key !&#x3D; pool[0].cached) sdsfree(pool[0].key);                memmove(pool,pool+1,sizeof(pool[0])*k);                pool[k].cached &#x3D; cached;            &#125;        &#125;        &#x2F;&#x2F; 把找到的 key 放到 k 的位置        int klen &#x3D; sdslen(key);        &#x2F;&#x2F; EVPOOL_CACHED_SDS_SIZE &#x3D; 255        if (klen &gt; EVPOOL_CACHED_SDS_SIZE) &#123;            &#x2F;&#x2F; 创建一个新的 key 赋值给 pool[k].key            pool[k].key &#x3D; sdsdup(key);        &#125; else &#123;            &#x2F;&#x2F; 从 key 中拷贝 klen + 1 的长度到 pool[k].cached            memcpy(pool[k].cached,key,klen+1);            sdssetlen(pool[k].cached,klen);            pool[k].key &#x3D; pool[k].cached;        &#125;        pool[k].idle &#x3D; idle;        pool[k].dbid &#x3D; dbid;    &#125;&#125;unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count) &#123;    unsigned long j;     unsigned long tables;    unsigned long stored &#x3D; 0, maxsizemask;    unsigned long maxsteps;    &#x2F;&#x2F; 字典中的数据量小于需要的个数, 取的个数变为字典的数据大小    if (dictSize(d) &lt; count) count &#x3D; dictSize(d);    &#x2F;&#x2F; 最大次数 &#x3D; 次数 * 10    maxsteps &#x3D; count*10;    &#x2F;* 如果字典在 rehash 中, 尝试 count 一样次数的 rehash *&#x2F;    for (j &#x3D; 0; j &lt; count; j++) &#123;        if (dictIsRehashing(d))            _dictRehashStep(d);        else            break;    &#125;    &#x2F;&#x2F; 获取总的 HashTable 个数, 如果在 rehash 中就是 2 个, 否则 1 个    tables &#x3D; dictIsRehashing(d) ? 2 : 1;    &#x2F;&#x2F; 获取数组大小的掩码, 用于计算索引值    maxsizemask &#x3D; d-&gt;ht[0].sizemask;    if (tables &gt; 1 &amp;&amp; maxsizemask &lt; d-&gt;ht[1].sizemask)        maxsizemask &#x3D; d-&gt;ht[1].sizemask;    &#x2F;&#x2F; 随机获取一个位置    unsigned long i &#x3D; random() &amp; maxsizemask;    unsigned long emptylen &#x3D; 0;    &#x2F;&#x2F; 获取到的个数没达到需要的个数 或者尝试的次数还没达到 0     while(stored &lt; count &amp;&amp; maxsteps--) &#123;        for (j &#x3D; 0; j &lt; tables; j++) &#123;                &#x2F;&#x2F; 如果字典在 rehash 中, 同时当前处理的是第一个字典, 处理的位置小于 rehash 下次处理的位置,             &#x2F;&#x2F; 则跳过这个位置, 直接到 rehash 下次处理的位置            &#x2F;&#x2F; 因为第一个字典 rehash 下次处理的位置前的数据都迁移到第二个字典中了            if (tables &#x3D;&#x3D; 2 &amp;&amp; j &#x3D;&#x3D; 0 &amp;&amp; i &lt; (unsigned long) d-&gt;rehashidx) &#123;                &#x2F;&#x2F; 防止获取数据的位置 i 超过第二个字典的大小                if (i &gt;&#x3D; d-&gt;ht[1].size)                    i &#x3D; d-&gt;rehashidx;                else                    continue;            &#125;            &#x2F;&#x2F; 超过了数组的长度            if (i &gt;&#x3D; d-&gt;ht[j].size) continue;            &#x2F;&#x2F; 获取对应位置的数据            dictEntry *he &#x3D; d-&gt;ht[j].table[i];            &#x2F;&#x2F; 对应的位置为 null            if (he &#x3D;&#x3D; NULL) &#123;                emptylen++;                &#x2F;&#x2F; 获取 null 数据的次数大于 5 次 同时 大于需要的过期 key 的个数                if (emptylen &gt;&#x3D; 5 &amp;&amp; emptylen &gt; count) &#123;                    &#x2F;&#x2F; 重新计算获取的位置 i, 重新获取                    i &#x3D; random() &amp; maxsizemask;                    emptylen &#x3D; 0;                &#125;            &#125; else &#123;                emptylen &#x3D; 0;                while (he) &#123;                    &#x2F;&#x2F; he 本身是链表, 计算从链表中获取到的个数, 够了结束, 不够就 i+1, 从字典的下一个位置继续获取                    *des &#x3D; he;                    des++;                    he &#x3D; he-&gt;next;                    stored++;                    if (stored &#x3D;&#x3D; count) return stored;                &#125;            &#125;        &#125;        i &#x3D; (i+1) &amp; maxsizemask;    &#125;    return stored;&#125;</code></pre><p>dictGetSomeKeys 函数简单理解就是, 通过 random() 得到一个随机数, 这个随机数 &amp; 数组大小的掩码, 得到一个位置, 从这个位置向后获取 count 个过期 key。<br>这个处理的过程中</p><blockquote><ol><li>有可能字典在 rehash 中, 数据分布在 2 个字典中, 所以有时第一个字典获取不到需要到第二个字典获取</li><li>需要的过期 key 的个数小于等于 5 个, 通过计算得到的位置获取到的数据连续都为 null, 则重新通过 random() 计算一个新的位置</li><li>为了防止长时间的需要, 在外面还计算了最大的循环次数</li></ol></blockquote><p>从上面的代码实现可以看出, Redis 内部对 LRU + LFU 的实现都是不是很正式的实现, 带有一定的误差和随机性。</p><p>其本身考虑主用是从性能上做的折中。比如传统的 LRU 算法, 需要将所有的数据维护一个双向链表</p><blockquote><ol><li>访问节点, 如果节点存在, 则将该节点移动到链表的头节点, 并返回节点值, 不存在就返回 null</li><li>新增节点, 节点不存在, 就在链表的头部新增节点, 如果节点存在, 则更新节点数据, 然后将节点移动到链表的头节点</li></ol></blockquote><p>需要消耗的内存在维护链表的 + 节点的挑战, 对于一个大规模的数据, 这个消耗是非常大的。<br>所以 Redis 采用了其思想, 通过另外的方式达到类似的效果。</p><h2 id="4-附录-Redis-几个对象的介绍"><a href="#4-附录-Redis-几个对象的介绍" class="headerlink" title="4 附录: Redis 几个对象的介绍"></a>4 附录: Redis 几个对象的介绍</h2><h3 id="4-1-Redis-中的字典"><a href="#4-1-Redis-中的字典" class="headerlink" title="4.1 Redis 中的字典"></a>4.1 Redis 中的字典</h3><h4 id="4-2-1-HashTable"><a href="#4-2-1-HashTable" class="headerlink" title="4.2.1 HashTable"></a>4.2.1 HashTable</h4><p>存储在 Redis 中的基本都是键值对, 而这种键值对存储, 同时可以通过 key 快速查询到对应的 value, 最合适的实现就是 HashTable 了。<br>而实现 HashTable 的底层结构，基本就是一个数组或者链表, 同时为了解决 hash 冲突, 数组或链表的每个节点定义为一个链表。</p><p>Redis 中对 HashTable 的实现也是如此, 大体如下</p><p><img src="https://pic.imgdb.cn/item/66714d06d9c307b7e93742a9.png" alt="Alt &#39;dictht 设计&#39;"></p><p>Redis 中实现的 HastTable 叫做 dictht (Dictionary Hash Table)</p><p>对应的定义如下:</p><pre class="language-C" data-language="C"><code class="language-C">typedef struct dictht &#123;    &#x2F;&#x2F; 存放节点的数组    dictEntry **table;    &#x2F;&#x2F; HashTable 的大小, 2 的幂次方    unsigned long size;    &#x2F;&#x2F; HashTable 的大小掩码, 用于计算索引值    unsigned long sizemask;    &#x2F;&#x2F; HashTable 中已经使用的节点个数    unsigned long used;&#125; dictht;</code></pre><p>真实存储数据的链表节点的定义如下:  </p><pre class="language-C" data-language="C"><code class="language-C">typedef struct dictEntry &#123;    &#x2F;&#x2F; 存储的键值对的 key    void *key;    &#x2F;&#x2F; 存储的键值对的 value    union &#123;        void *val;        uint64_t u64;        int64_t s64;        double d;    &#125; v;    &#x2F;&#x2F; 指向下一个节点    struct dictEntry *next;&#125; dictEntry;</code></pre><p>key + v(value) + next 一个简单的链表定义。<br>有点特殊的就是对应着 value 属性的 v 的定义是一个联合体, 会在不同场景下使用不同的字段,<br>比如一个键值对的过期时间就存放在 <strong>s64</strong> 中, 这个 value 存放的值就放在 <strong>val</strong> 中。</p><p>一个 dictEntry 的字段存放内容大体如下:</p><p><img src="https://pic.imgdb.cn/item/66714a82d9c307b7e93175bd.png" alt="Alt &#39;dictEntry 内容&#39;"></p><h4 id="4-2-2-字典"><a href="#4-2-2-字典" class="headerlink" title="4.2.2 字典"></a>4.2.2 字典</h4><p>在使用 HashTable 时, 都需要提前声明好容量, 而随着程序的运行, 存放到 HashTable 的数据会越来越多, 最终达到上限, 这时就需要进行扩容了。<br>在 Java 的 HashMap 的扩容过程</p><blockquote><ol><li>创建一个更大容量的数组</li><li>将 HashMap 中旧数组一次性迁移到新的数组中</li><li>清除掉旧数组</li></ol></blockquote><p>这个扩容没多大问题, 但是放到 Redis 中合适吗?</p><blockquote><ol><li>Redis 是一个存内存的数据库, 所有的数据都存放在内存中, 基本是 GB 级别的数据量, 每次扩容迁移的数据量很多</li><li>Redis 是一个单线程的数据库, 一次只能处理一个事情, 如果全力在做扩容, 那么其他的请求将无法处理</li></ol></blockquote><p>所以 Redis 采用了一种 <strong>渐进式 rehash</strong> 的方法解决扩容缩容的问题, 过程如下</p><blockquote><ol><li>维护 2 个 dictht, 一个是真实存储数据的 HashTable A, 一个是扩容后存储数据的 TableTable B + 一个 rehash 位置的索引, 初始值为 0</li><li>在 rehash &gt;&#x3D;0 期间, 每次对 HashTable 进行操作, 除了正常的操作外, 还会将 A rehash 位置的数据都迁移到 B, 然后 rehash + 1</li><li>随着对 HashTable 的不断操作, 最终 A 中的数据都会迁移到 B, 这时将 rehash 设置为 -1</li></ol></blockquote><p>基于上面的渐进式 rehash 分析, 实际是需要 2 个 dictht, 所以 Redis 在此至上多封装了一层</p><pre class="language-C" data-language="C"><code class="language-C">typedef struct dict &#123;    dictType *type;    void *privdata;    dictht ht[2];   &#x2F;&#x2F; 2 个 HashTable    long rehashidx; &#x2F;&#x2F; rehash 的索引    unsigned long iterators;&#125; dict;</code></pre><p>这个就是 Redis 中的字典, 用于存储键值对的结构。</p><p>在将这个结构放到一个 redisDb 就是我们常见的 Redis 数据库了</p><pre class="language-C" data-language="C"><code class="language-C">typedef struct redisDb &#123;    dict *dict;     dict *expires;    ....&#125; redisDb;</code></pre><p>redisDb 就是我们常说的 Redis 16 个数据库的定义了。 每个数据库中都有 2 个字典</p><blockquote><ol><li>dict 正常的字典, 存储没有设置过期时间的键值对</li><li>expires 过期字典, 存储设置了过期时间的键值对</li></ol></blockquote><h3 id="4-2-Redis-的内存待淘汰池"><a href="#4-2-Redis-的内存待淘汰池" class="headerlink" title="4.2 Redis 的内存待淘汰池"></a>4.2 Redis 的内存待淘汰池</h3><pre class="language-C" data-language="C"><code class="language-C">struct evictionPoolEntry &#123;    unsigned long long idle;    &#x2F;&#x2F; 对象空闲时间 (使用的算法是 LFU 则是逆频率)    sds key;                    &#x2F;&#x2F; 待淘汰的键值对的 key    sds cached;                 &#x2F;&#x2F; 缓存的 key 名称 SDS 对象    int dbid;                   &#x2F;&#x2F; 待淘汰键值对的 key 所在的数据库 ID&#125;;</code></pre><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><a href="https://www.cnblogs.com/ltaodream/p/16299107.html">Redis源码解析-LRU</a><br><a href="https://www.cnblogs.com/reim/p/17422410.html#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">Redis内存兜底策略——内存淘汰及回收机制</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1 概念&quot;&gt;&lt;/a&gt;1 概念&lt;/h2&gt;&lt;p&gt;Redis 所有的数据都是存储在内存中的, 如果不进行任何的内存回收,</summary>
        
      
    
    
    
    
    <category term="Redis" scheme="https://github.com/Lcn29/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>一次 CPU 占用率过高的问题排查 (不断创建线程和线程上下文频繁切换)</title>
    <link href="https://github.com/Lcn29/article/2023/608272343/"/>
    <id>https://github.com/Lcn29/article/2023/608272343/</id>
    <published>2023-12-07T11:11:18.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p><img src="https://pic.imgdb.cn/item/65753aa3c458853aef8e62da.png" alt="Alt &#39;项目初始架构&#39;"></p><p>如图是生产中系统的架构图</p><blockquote><ol><li>主服务会在核心表数据变更后, 将变更记录的数据推送到 MQ </li><li>下游有不同的业务系统, 订阅了对应的 MQ 消息</li></ol></blockquote><p>而本人负责的服务 A 在消费消息时, 有以下的特点</p><blockquote><ol><li>上游推送的数据有不同的业务类型和不同的状态值</li><li>不同的业务类型的数据只有在达到某个指定状态前, 才需要处理</li></ol></blockquote><p>比如某条记录有个业务类型, 取值为 A, B, C, 同时有 1 个状态值 X, Y, Z, 当业务类型为 A 的记录, 只有在 Y 状态, 才需要处理。</p><p>这个特点决定了上游推送的消息, 在服务 A 是<strong>暂时不关心</strong>的 (但是这些消息对于其他的业务系统, 却是关心的, 所以上游不会停止推送), 消费这些消息很浪费服务 A 的资源 (上游的数据变更推送每日的数据量在亿级别, 高峰 QPS 可达到 2000 以上),<br>为了不影响调用服务 A 的其他服务和用户的正常使用, 决定主服务和服务 A 中间加多一个<strong>过滤服务</strong>, 将原本服务 A 的过滤逻辑迁移到这个服务中, 新的架构图如下:  </p><p><img src="https://pic.imgdb.cn/item/65753aa6c458853aef8e6c7e.png" alt="Alt &#39;改造后的项目架构&#39;"></p><p>由<strong>过滤服务</strong>直接对接到主服务的 MQ 消息, 对消息进行过滤服务条件的在通过 MQ 推送给下游的服务 A。</p><p>经过改造后, 过滤服务部署到生产, 但是每次部署上去后, 没过多久, 就频繁的提示 CPU 占用率过高的告警, 不得不进行排查。</p><h2 id="2-结论"><a href="#2-结论" class="headerlink" title="2 结论"></a>2 结论</h2><p>按照惯例, 先把结论整理一下, 经过排查, 后面导致 CPU 占用率过高的原因, 有 2 个</p><blockquote><ol><li>没有经过任何配置, 通过 SpringBoot 的 <strong>@Async</strong> 进行异步, 导致应用一直在创建线程, 销毁线程</li><li>高频的打印日志, 日志内部有个锁, 导致线程频繁地进行上下文切换, 消耗 CPU 资源</li></ol></blockquote><h2 id="3-过程"><a href="#3-过程" class="headerlink" title="3 过程"></a>3 过程</h2><h3 id="3-1-告警"><a href="#3-1-告警" class="headerlink" title="3.1 告警"></a>3.1 告警</h3><p>过滤服务预发验收没问题后, 逐步切流量进入过滤服务, 但是在流量切完, 几分钟后, 触发告警 <strong>xxx 服务 CPU 超过警戒线, 当前 CPU xxx</strong>。<br>打开 Grafana 进行查看, 发现几个实例 CPU 都在 150% 以上, 看起来不是某个特例触发了什么 bug。</p><h3 id="3-2-异常线程发现"><a href="#3-2-异常线程发现" class="headerlink" title="3.2 异常线程发现"></a>3.2 异常线程发现</h3><ol><li><p>先获取一下当前 Java 程序的进程 Id  </p><pre class="language-bash" data-language="bash"><code class="language-bash">jps <span class="token parameter variable">-l</span></code></pre></li><li><p>查看应用当前的线程栈信息</p></li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">jstack 上一步获取到的进程 Id</code></pre><p>通过观察基本线程都是 <strong>RUNNABLE</strong>, 初步看不出是什么问题。</p><ol start="3"><li>多次导出线程栈信息, 进行比较</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">jstack 上一步获取到的进程 Id <span class="token operator">>></span> stack-1.txt</code></pre><p>将当前应用的线程栈信息导出到 stack-1.txt 文件, 然后隔几秒, 再导出一次到 stack-2.txt, 重复 3 次。<br>此时本地有 3 个线程栈信息 stack-1.txt, stack-2.txt, stack-3.txt, 对三个文件的堆栈信息进行对比分析。  </p><p>stack-1 文件内容</p><pre class="language-stack" data-language="stack"><code class="language-stack">&quot;SimpleAsyncTaskExecutor-1&quot; #182 daemon prio&#x3D;5 os_prio&#x3D;31 tid&#x3D;0x00007f93aeaa0000 nid&#x3D;0x1b203 runnable [0x0000000314bbd000]  省略&quot;MqConsumer-1&quot; #104 daemon prio&#x3D;5 os_prio&#x3D;31 tid&#x3D;0x00007f93b12c6800 nid&#x3D;0xf203 runnable [0x000000030fcd4000]    省略&quot;Reference Handler&quot; #2 daemon prio&#x3D;10 os_prio&#x3D;31 tid&#x3D;0x00007f939e80b800 nid&#x3D;0x4723 in Object.wait() [0x000000030a6c7000]  省略&quot;VM Thread&quot; os_prio&#x3D;31 tid&#x3D;0x00007f93ae020800 nid&#x3D;0x4803 runnable &quot;GC task thread#0 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007f93b0809000 nid&#x3D;0x524f runnable     省略</code></pre><p>通过第一个文件 stack-1.txt 整体的线程可以分为 3 组</p><blockquote><ol><li>SimpleAsyncTaskExecutor-x SpringBoot 异步处理任务的线程</li><li>MqConsumer-x 消费 MQ 消息的线程</li><li>其他</li></ol></blockquote><p>查看第二个文件 stack-2.txt, 发现以 SimpleAsyncTaskExecutor 开头的线程有好几个消失了, 但是多了几个新的以  SimpleAsyncTaskExecutor 开头的线程, 就是编号不一致。<br>通过堆栈信息, 发现他们是使用 <strong>@Async</strong> 注解的异步处理方法, 怀疑是不是一直<strong>在创建线程处理任务</strong>, 任务处理完成就释放。  </p><ol start="4"><li>在对应的方法处, 打一个断点, 启动项目, 调用这个方法</li></ol><p><img src="https://pic.imgdb.cn/item/65753a9fc458853aef8e5660.png" alt="Alt &#39;断点排查方式&#39;"></p><p>如图, 这样就能获取整个线程栈信息, 通过线程栈查看。 按照我们怀疑的地方, 找到提交任务的地方, 也就是 <strong>org.springframework.aop.interceptor.AsyncExecutionAspectSupport#doSubmit</strong>。<br>发现线程池是有参数传入的, 那么继续往前走, 也就是 <strong>org.springframework.aop.interceptor.AsyncExecutionInterceptor#invoke</strong>, 在里面获取线程池的方法如下</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Nullable</span><span class="token keyword">protected</span> <span class="token class-name">AsyncTaskExecutor</span> <span class="token function">determineAsyncExecutor</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 在缓存 Map 中获取异步方法, 执行对应的线程池 </span>    <span class="token comment">// Map&lt;Method, AsyncTaskExecutor> executors</span>    <span class="token class-name">AsyncTaskExecutor</span> executor <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">AsyncTaskExecutor</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>executors<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 1. 在缓存中获取不到</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>executor <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1.1 获取当前方法上面的 @Async 注解里面的 value 值 (可以通过这个指定异步方法执行的线程池)</span>        <span class="token class-name">String</span> qualifier <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getExecutorQualifier</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Executor</span> targetExecutor<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">hasLength</span><span class="token punctuation">(</span>qualifier<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 1.1.1 从当前的 Spring 容器中获取 @Async 指定名称的线程池</span>            targetExecutor <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">findQualifiedExecutor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">,</span> qualifier<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 1.1.2 没有 @Async 或 @Async 没有配置 value 值</span>            <span class="token comment">// 在声明 AsyncExecutionAspectSupport 时, 可以设置一个默认的线程池, 存放在 defaultExecutor 这个属性</span>            <span class="token comment">// 一般我们也不会自己主动去声明 AsyncExecutionAspectSupport, 所以这个 defaultExecutor 为空</span>            targetExecutor <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultExecutor<span class="token punctuation">;</span>            <span class="token comment">// 1.1.3 获取不到默认配置的线程池</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>targetExecutor <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>executors<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>defaultExecutor <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 1.1.4 通过 getDefaultExecutor 方法获取执行线程池</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>defaultExecutor <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getDefaultExecutor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    targetExecutor <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultExecutor<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 1.2 经过尝试还是获取不到对应的执行线程池</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>targetExecutor <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        executor <span class="token operator">=</span> targetExecutor <span class="token keyword">instanceof</span> <span class="token class-name">AsyncListenableTaskExecutor</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token class-name">AsyncListenableTaskExecutor</span><span class="token punctuation">)</span>targetExecutor <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">TaskExecutorAdapter</span><span class="token punctuation">(</span>targetExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1.3 保存缓存</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>executors<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> executor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 2. 缓存中获取到, 直接返回</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">AsyncTaskExecutor</span><span class="token punctuation">)</span>executor<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">protected</span> <span class="token class-name">Executor</span> <span class="token function">getDefaultExecutor</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">BeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用父类的 getDefaultExecutor 获取线程池</span>    <span class="token class-name">Executor</span> defaultExecutor <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getDefaultExecutor</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 父类获取不到线程池, 那么就默认为 SimpleAsyncTaskExecutor</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Executor</span><span class="token punctuation">)</span><span class="token punctuation">(</span>defaultExecutor <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> defaultExecutor <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">SimpleAsyncTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">protected</span> <span class="token class-name">Executor</span> <span class="token function">getDefaultExecutor</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">BeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 1. 在当前的 Spring 容器中获取 TaskExecutor 的实例</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Executor</span><span class="token punctuation">)</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">TaskExecutor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoUniqueBeanDefinitionException</span> var6<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Could not find unique TaskExecutor bean"</span><span class="token punctuation">,</span> var6<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 2. 获取到了多个, 尝试获取名称为 taskExecutor 的 Executor 实例</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Executor</span><span class="token punctuation">)</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"taskExecutor"</span><span class="token punctuation">,</span> <span class="token class-name">Executor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchBeanDefinitionException</span> var4<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">isInfoEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"More than one TaskExecutor bean found within the context, and none is named 'taskExecutor'. Mark one of them as primary or name it 'taskExecutor' (possibly as an alias) in order to use it for async processing: "</span> <span class="token operator">+</span> var6<span class="token punctuation">.</span><span class="token function">getBeanNamesFound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchBeanDefinitionException</span> var7<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Could not find default TaskExecutor bean"</span><span class="token punctuation">,</span> var7<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 3. 尝试获取名称为 taskExecutor 的 Executor 实例</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Executor</span><span class="token punctuation">)</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"taskExecutor"</span><span class="token punctuation">,</span> <span class="token class-name">Executor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchBeanDefinitionException</span> var5<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"No task executor bean found for async processing: no bean of type TaskExecutor and no bean named 'taskExecutor' either"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上面的获取线程池的逻辑概括为</p><blockquote><ol><li>从 Spring 容器中获取 TaskExecutor 的实例, 获取到唯一一个, 那么就用这个执行这个异步方法</li><li>从 Spring 容器中获取 TaskExecutor 的实例有多个或一个都没有, 在从容器中尝试获取 bean 名为 taskExecutor 的 Executor 的实例, 获取到就用这个执行这个异步方法</li><li>兜底方法, 通过 SimpleAsyncTaskExecutor 这个线程池执行异步方法</li><li>补充一点, 如果项目没有通过 @EnableAsync 注解启动异步功能的话, @Async 是不会其作用的</li></ol></blockquote><p>在整个 SpringBoot 项目中如果没有创建 TasekExecutor 的实例或名为 taskExecutor 的 Executor 实例, 那么就会用 SimpleAsyncTaskExecutor 执行异步任务 (本文的情况)。</p><p>而 里面执行任务的逻辑如下</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doExecute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 通过线程工程创建一个线程, 执行任务 (这里 2 处都是通过线程工程创建线程, 区别是一个用用户指定的线程工厂, 一个内置默认的线程工厂)</span>    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory<span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createThread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>到了这里, 大体可以确定问题了</p><blockquote><ol><li>每消费一条 MQ 消息的过程中, 都会创建一个线程去处理一部分逻辑</li><li>上游并发的推送消息, 导致下游一直在创建线程和销毁线程, 消耗大量的 CPU 资源</li></ol></blockquote><p>本地尝试模拟不断创建线程和消耗线程的情况<br><img src="https://pic.imgdb.cn/item/65753a88c458853aef8e08ff.png" alt="Alt &#39;线程创建对 CPU 的影响&#39;"></p><p>绿色的线条是应用本身的 CPU 情况, 而蓝色的的是整个系统的 CPU 情况, 这个频繁创建和消耗线程的操作消耗了 30% 以上的 CPU。<br>至于解决方法, 就在上面获取线程池的逻辑里面, 自己定义了一个 TaskExecutor 的线程池, 并交给 Spring 容器即可。</p><h3 id="3-3-线程上下文频繁切换发现"><a href="#3-3-线程上下文频繁切换发现" class="headerlink" title="3.3 线程上下文频繁切换发现"></a>3.3 线程上下文频繁切换发现</h3><p>通过自定义线程池解决频繁创建线程的问题, 修改好代码后, 重新发布上线, 本以为解决了。<br>但是没过多久, 告警 <strong>xxx 服务 CPU 超过警戒线, 当前 CPU xxx</strong> 还是没有消失。  </p><p>通过</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">top</span> <span class="token parameter variable">-Hp</span> 进程 Id</code></pre><p>观察, 占用高 CPU 的线程 Id 一直在变化, 不是固定的几个。</p><p>再次通过 <strong>jstack</strong>, 获取线程栈信息, 通过观察, 发现少量的线程是 <strong>RUNNABLE</strong> 状态, 业务相关的就一个线程在输出日志,<br>很多线程都是 <strong>WAITING</strong> 状态, 线程栈都是很一致的在输出日志的地方阻塞住了。</p><pre class="language-stack" data-language="stack"><code class="language-stack">&quot;MqConsumer-2&quot; #178 daemon prio&#x3D;5 os_prio&#x3D;31 tid&#x3D;0x00007f93aea9f800 nid&#x3D;0x1ac03 waiting on condition [0x00000003147b2000]   java.lang.Thread.State: WAITING (parking)at sun.misc.Unsafe.park(Native Method)- parking to wait for  &lt;0x00000006c0142820&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:870)at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1199)at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLock.java:209)at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:285)at ch.qos.logback.core.OutputStreamAppender.writeBytes(OutputStreamAppender.java:197)at ch.qos.logback.core.OutputStreamAppender.subAppend(OutputStreamAppender.java:231)at ch.qos.logback.core.OutputStreamAppender.append(OutputStreamAppender.java:102)at ch.qos.logback.core.UnsynchronizedAppenderBase.doAppend(UnsynchronizedAppenderBase.java:84)at ch.qos.logback.core.spi.AppenderAttachableImpl.appendLoopOnAppenders(AppenderAttachableImpl.java:51)at ch.qos.logback.classic.Logger.appendLoopOnAppenders(Logger.java:270)at ch.qos.logback.classic.Logger.callAppenders(Logger.java:257)at ch.qos.logback.classic.Logger.buildLoggingEventAndAppend(Logger.java:421)at ch.qos.logback.classic.Logger.filterAndLog_1(Logger.java:398)at ch.qos.logback.classic.Logger.info(Logger.java:583)</code></pre><p>通过堆栈信息定位到 <strong>ch.qos.logback.core.OutputStreamAppender.writeBytes</strong> 处</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeBytes</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> byteArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>byteArray <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> byteArray<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 此处加锁, 会导致线程挂起</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 日志写入</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>outputStream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>byteArray<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>immediateFlush<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>outputStream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>到这里已经有个推测了, <strong>线程基本都是阻塞状态, 但是 CPU 很高</strong>, 有可能是线程频繁地上下文切换导致的 (日志的打印挺快的, 忽略这操作, 每个线程可以看做是在获取锁，释放锁的过程)。<br>线程上下文切换导致 CPU 升高的分析, 可以看一下这篇<a href="https://heapdump.cn/article/2677994">文章</a>。<br>而根据堆栈信息都是在日志处阻塞的, 应该是上游打印日志太过频繁了 (新上的项目, 为了方便定位问题, 输出了很多日志)。</p><p>为了验证这个可能, 删除部分无用的日志, 在几个高频的日志打印处, 加上一个开关</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>logSwitch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>然后通过 Apollo 控制这个开发, 重新发布项目到生产。<br>开关依旧是打开状态, CPU 依旧是在升高, 通过 Apollo 将开关关闭, 停止高频日志的打印, 没过多久日志顺利下降, 验证了猜想。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>至此, 整个 CPU 占用率高的排查过程就结束了, 后面再对整个过程做个总结</p><blockquote><ol><li>通过比较线程栈的信息, 定位到了 @Async 注解的实现中, 通过不断创建线程执行任务的, 这个行为会导致 CPU 消耗资源在重量级对象 Thread 的创建和消毁中</li><li>第二次通过观察线程栈信息, 定位到大量的线程阻塞在日志输出处, 执行的任务也是在输出日志, 猜测是频繁的日志打印, 导致线程上下文切换, 通过减少日志打印进行验证结论</li></ol></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1 背景&quot;&gt;&lt;/a&gt;1 背景&lt;/h2&gt;&lt;p&gt;&lt;img</summary>
        
      
    
    
    
    
    <category term="生产记录" scheme="https://github.com/Lcn29/tags/%E7%94%9F%E4%BA%A7%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>一次简单的 Http 请求异常处理 (请求 url 太长, Nginx 返回 400, 导致请求服务异常)</title>
    <link href="https://github.com/Lcn29/article/2023/3866295214/"/>
    <id>https://github.com/Lcn29/article/2023/3866295214/</id>
    <published>2023-11-21T15:45:54.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-结论"><a href="#1-结论" class="headerlink" title="1 结论"></a>1 结论</h2><p>按照惯例直接说结论。</p><p>后台服务 A 有一个 Http 接口, 代码如下:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/user"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserInfoVo</span><span class="token punctuation">></span></span> <span class="token function">getUserInfoByUserIds</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"userIds"</span><span class="token punctuation">)</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> userIds<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span></code></pre><p>没错, 一个 Get 请求, 入参是一个 **List<String>**。</p><p>同时有另一个后台服务 B, 里面有段逻辑会通过 RestTemplate 调用服务  A 的这个接口, 代码如下:  </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserInfoVo</span><span class="token punctuation">></span></span> <span class="token function">batchGetUserInfo</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> userIds<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s/user?userIds=%s"</span><span class="token punctuation">,</span> remoteHost<span class="token punctuation">,</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>userIds<span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> returnResult <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span></code></pre><p>在服务 B 中, 通过 batchGetUserInfo 方法请求服务 A 时, 传入了一个长度为 122 的 <strong>List<String></strong>, List 中每一项是一个 32 位的 UUID。<br><strong>结果导致调用服务  A  的 url 长度太长, Nginx 认为这时一个异常的请求格式, 直接返回状态码 400, 结构导致服务 B 逻辑异常</strong>。  </p><h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2 过程"></a>2 过程</h2><h3 id="2-1-反馈"><a href="#2-1-反馈" class="headerlink" title="2.1 反馈"></a>2.1 反馈</h3><p>下午, 突然收到用户反馈: 进入某个页面后, 直接白屏。</p><h3 id="2-2-定位到直接原因"><a href="#2-2-定位到直接原因" class="headerlink" title="2.2 定位到直接原因"></a>2.2 定位到直接原因</h3><p>直接通过 Nginx 请求日志, 发现用户反馈的操作时间段内, 有一个接口一直返回 400 的错误。<br>根据客户端反馈这个错误的确会导致页面白屏。  </p><p>知道了直接原因了, 但是没有解决, 还是需要定位到根本原因。</p><h3 id="2-3-Arthas-排查"><a href="#2-3-Arthas-排查" class="headerlink" title="2.3 Arthas 排查"></a>2.3 Arthas 排查</h3><p>通过错误的 url, 定位到对应的代码, 然后通过 Kibana 查看日志, 发现只有一个简单的异常提示, 没输出任何堆栈信息。  </p><p>因为是一个查询接口, 所以本地通过拼接参数, 尝试请求这个接口, 发现是逻辑正常的, 应该是数据问题, 这就尴尬了。  </p><p>通过分析代码逻辑, 看不出什么异常的。<br>在没有日志, 复现不出反馈情况, 代码逻辑分析不出异常时, 决定通过 <strong>Arthas</strong> 协助排查了。</p><p>在生产环境中, 启动了一个预发版本, 通过 url 模拟用户请求。</p><p>同时启动 Arthas, watch 对应的接口</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">watch</span> com.aaa.bbb.TestController testMethod <span class="token string">"&#123;params,returnObj,throwExp&#125;"</span> <span class="token parameter variable">-x</span> <span class="token number">4</span></code></pre><p>定位到以下异常: </p><pre class="language-log" data-language="log"><code class="language-log"><span class="token exception javastacktrace language-javastacktrace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span>HttpClientErrorException<span class="token punctuation">:</span> 400 <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span>DefaultResponseErrorHandler<span class="token punctuation">.</span><span class="token function">handleError</span><span class="token punctuation">(</span>DefaultResponseErrorHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>91<span class="token punctuation">)</span> ~[spring-web-4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE<span class="token punctuation">.</span>jar<span class="token punctuation">:</span>4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE]<span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span>RestTemplate<span class="token punctuation">.</span><span class="token function">handleResponse</span><span class="token punctuation">(</span>RestTemplate<span class="token punctuation">.</span>java<span class="token punctuation">:</span>700<span class="token punctuation">)</span> ~[spring-web-4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE<span class="token punctuation">.</span>jar<span class="token punctuation">:</span>4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE]<span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span>RestTemplate<span class="token punctuation">.</span><span class="token function">doExecute</span><span class="token punctuation">(</span>RestTemplate<span class="token punctuation">.</span>java<span class="token punctuation">:</span>653<span class="token punctuation">)</span> ~[spring-web-4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE<span class="token punctuation">.</span>jar<span class="token punctuation">:</span>4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE]<span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span>RestTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>RestTemplate<span class="token punctuation">.</span>java<span class="token punctuation">:</span>613<span class="token punctuation">)</span> ~[spring-web-4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE<span class="token punctuation">.</span>jar<span class="token punctuation">:</span>4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE]<span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span>RestTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>RestTemplate<span class="token punctuation">.</span>java<span class="token punctuation">:</span>287<span class="token punctuation">)</span> ~[spring-web-4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE<span class="token punctuation">.</span>jar<span class="token punctuation">:</span>4<span class="token punctuation">.</span>3<span class="token punctuation">.</span>7<span class="token punctuation">.</span>RELEASE]<span class="token keyword">at</span> com<span class="token punctuation">.</span>aaa<span class="token punctuation">.</span>bbb<span class="token punctuation">.</span><span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>RemoteServiceImpl<span class="token punctuation">.</span><span class="token function">batchGetUserInfo</span><span class="token punctuation">(</span>RemoteServiceImpl<span class="token punctuation">.</span>java<span class="token punctuation">:</span>206<span class="token punctuation">)</span> ~[classes/<span class="token punctuation">:</span>?]<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span></code></pre><p>根据堆栈信息定位到代码</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">StudentVo</span><span class="token punctuation">></span></span> <span class="token function">batchGetUserInfo</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> userIds<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s/user?userIds=%s"</span><span class="token punctuation">,</span> remoteHost<span class="token punctuation">,</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>userIds<span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> returnResult <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span></code></pre><p>看逻辑没多大的异常, 唯一比较惊讶的就是 Get 请求, 入参确实是一个 <strong>List<String></strong>, 不过 Http 本身就支持这样操作。</p><p>继续通过 Arthas, watch 对应的接口, 不过这次 watch 上面的代码:</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">watch</span> com.aaa.bbb<span class="token punctuation">..</span>service.impl.RemoteServiceImpl batchGetUserInfo <span class="token string">"&#123;params,returnObj,throwExp&#125;"</span> <span class="token parameter variable">-x</span> <span class="token number">4</span></code></pre><p>继续通过 url 模拟用户请求。  </p><p>发现堆栈信息同样的 <strong>HttpClientErrorException: 400</strong> 异常, 但是通过打印的<strong>参数列表</strong>发现, 入参竟然是 123 个的 String。  </p><p>第一时间感觉到: 参数太多, 拼接的 url 太长, 导致请求失败。<br>但是转念一下, Get 请求 url 的长度限制是<strong>浏览器的行为</strong>, <strong>Http 协议没有对传输的数据大小进行限制</strong>。<br>现在是 2 个后台服务的 Http 请求, 没有经过任什么浏览器, 理论上是这个长度无限制的。</p><h3 id="2-4-Nginx-直接返回-400-错误码"><a href="#2-4-Nginx-直接返回-400-错误码" class="headerlink" title="2.4 Nginx 直接返回 400 错误码"></a>2.4 Nginx 直接返回 400 错误码</h3><p>请求  url 感觉没什么问题?<br>既然这样, 会不会是结果响应方处理有什么异常吗? </p><p>同样通过 Kibana 查看日志, 发现对应的接口, 没有当前用户的请求日志。也就是说, 对应的请求没有到达服务 A。  </p><p>不是被调用方的问题, 那么会不会是 RestTemplate 这个框架内部做了限制呢?</p><p>从 <strong>restTemplate.getForObject</strong> 出发, 进入到源码, 发现内部也是没有对 url 长度做限制的, 同时定位到抛出异常的位置如下</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultResponseErrorHandler</span> <span class="token keyword">implements</span> <span class="token class-name">ResponseErrorHandler</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleError</span><span class="token punctuation">(</span><span class="token class-name">ClientHttpResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 从响应里面获取到状态码</span>    <span class="token class-name">HttpStatus</span> statusCode <span class="token operator">=</span> <span class="token function">getHttpStatusCode</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>statusCode<span class="token punctuation">.</span><span class="token function">series</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 状态码 4xx</span>      <span class="token keyword">case</span> <span class="token constant">CLIENT_ERROR</span><span class="token operator">:</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">HttpClientErrorException</span><span class="token punctuation">(</span>statusCode<span class="token punctuation">,</span> response<span class="token punctuation">.</span><span class="token function">getStatusText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            response<span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getResponseBody</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getCharset</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 状态码 5xx</span>      <span class="token keyword">case</span> <span class="token constant">SERVER_ERROR</span><span class="token operator">:</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">HttpServerErrorException</span><span class="token punctuation">(</span>statusCode<span class="token punctuation">,</span> response<span class="token punctuation">.</span><span class="token function">getStatusText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             response<span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getResponseBody</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getCharset</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">default</span><span class="token operator">:</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RestClientException</span><span class="token punctuation">(</span><span class="token string">"Unknown status code ["</span> <span class="token operator">+</span> statusCode <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>抛出异常的结果是根据请求返回的状态码来决定的。 也就是服务 B 有发起请求, 同时收到了一个 400 的错误码, restTemplate 将其封装为一个 HttpClientErrorException。</p><p>调用方有发起请求, 被调用方没有请求日志, 2 者之间通过通过 Http 请求, 那么有问题的的地方应该就是 2 者中间的 Nginx 了。</p><h3 id="2-5-验证"><a href="#2-5-验证" class="headerlink" title="2.5 验证"></a>2.5 验证</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">StudentVo</span><span class="token punctuation">></span></span> <span class="token function">batchGetUserInfo</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> userIds<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s/user?userIds=%s"</span><span class="token punctuation">,</span> remoteHost<span class="token punctuation">,</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>userIds<span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> returnResult <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span></code></pre><p>将上面的 remoteHost 替换为一个具体的 ip 地址, 直接请求对应的容器, 绕过 Nginx。<br>重新部署, 通过 url 模拟用户请求, 正常响应。  </p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>服务 A 的请求先经过 Nginx, 再由 Nginx 转发到 B。<br>而异常的用户的请求到了 Nginx, Nginx 直接返回了 400, 从而导致用户请求异常。</p><p>通过查询资料, Nginx 报 400 的场景如下</p><blockquote><ol><li>request_uri 过长超过 nginx 配置大小</li><li>cookie 或者 header 过大超过 nginx 配置大小</li><li>空 HOST 头</li><li>content_length 和 body 长度不一致</li></ol></blockquote><p>我们遇到的情况就是第一种。<br>Nginx 处理时认为客户端请求格式错误, 于是直接返回 400, 不会向 upstream server (也就是下游服务) 转发请求, 因而 upstream server 对这些错误请求其实完全是无感知的。</p><p>至此结束。</p><p>碎碎念:<br>其实对 Http 响应码有一点了解, 结合上面获取到的请求参数太多和堆栈的信息的 400, 基本可以推导出问题了, 不用像我一样, 一步步猜测验证。<br>而本身通过这次, 对 Http 的响应码和 Nginx 也算是多了一点了解。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;1-结论&quot;&gt;&lt;a href=&quot;#1-结论&quot; class=&quot;headerlink&quot; title=&quot;1 结论&quot;&gt;&lt;/a&gt;1 结论&lt;/h2&gt;&lt;p&gt;按照惯例直接说结论。&lt;/p&gt;
&lt;p&gt;后台服务 A 有一个 Http 接口, 代码如下:&lt;/p&gt;
&lt;pre</summary>
        
      
    
    
    
    
    <category term="生产记录" scheme="https://github.com/Lcn29/tags/%E7%94%9F%E4%BA%A7%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>一次 MQ 堆积的解决 (并发地从数据库中查询出大量数据导致数据库繁忙最终宕机)</title>
    <link href="https://github.com/Lcn29/article/2023/4068506469/"/>
    <id>https://github.com/Lcn29/article/2023/4068506469/</id>
    <published>2023-11-07T08:34:24.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这次事故实际的借鉴意义不大, 只是整个解决过程比较有趣, 所以记录一下。</strong></p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>为了应对旺季的到来, 加上一些重要的接口的性能未知, 所以决定对这些接口进行压测并优化。 </p><p>但是生产和测试环境的机器性能等差距很大, 为了准确性, 所以决定在生产环境进行压测。<br>先通过特定的账号进行压测, 然后删除这批账号产生的数据, 通过这种方式得到最准确的结果。</p><h2 id="2-结论"><a href="#2-结论" class="headerlink" title="2 结论"></a>2 结论</h2><p>压测的接口中有一个的功能, 高度概括如下:  </p><blockquote><ol><li>一次 Http 请求, 会产生 n 条数据库记录, 发送出 n 条 MQ 消息</li><li>每条 MQ 消息会从数据库中查询出所有的记录, 然后处理这些记录</li></ol></blockquote><p>对这个接口进行压测时, 随着请求量的增加</p><blockquote><ol><li>数据库记录越来越多 </li><li>MQ 消费时, 查询数据库时越来越慢, 消费能力随之下降, 最终导致 MQ 堆积</li></ol></blockquote><p>发现堆积时, 在不了解具体逻辑时, 本着先解决问题再定位原因的原则, 我们选择了不断提高 MQ 消费能力, 最终导致</p><blockquote><ol><li>数据库的查询压力越来越大, 先是触发了主从切换, 然后没多久整个库还是挂了</li><li>应用这边有的卡在等待数据库响应全部数据, 有的是查询到了大量数据, 进入了 GC</li></ol></blockquote><h2 id="3-过程"><a href="#3-过程" class="headerlink" title="3 过程"></a>3 过程</h2><h3 id="3-1-反馈"><a href="#3-1-反馈" class="headerlink" title="3.1 反馈"></a>3.1 反馈</h3><p>20:00, 测试开始压测。<br>20:30, 测试说明压测结束。<br>20:35, 测试反馈生产出现 MQ 堆积。</p><p><img src="https://pic.imgdb.cn/item/6549fa6fc458853aef785a69.png" alt="Alt &#39;MQ 堆积告警图&#39;"></p><h3 id="3-2-解决"><a href="#3-2-解决" class="headerlink" title="3.2 解决"></a>3.2 解决</h3><h4 id="3-2-1-启动新的实例-先解决堆积"><a href="#3-2-1-启动新的实例-先解决堆积" class="headerlink" title="3.2.1 启动新的实例, 先解决堆积"></a>3.2.1 启动新的实例, 先解决堆积</h4><p>这种 MQ 堆积的情况, 个人习惯都会先确定一下对应的消费线程的状态, 确定是消费慢, 还是消费阻塞等原因。</p><p>进入到某个生产实例, 执行 </p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">## 获取到当前 Java 程序的进程号</span>jps <span class="token parameter variable">-l</span> <span class="token comment">## 查看 MQ 消费线程堆栈的情况, ConsumeMessageThread 是我们定义的 MQ 消费线程的名称前缀</span>jstack <span class="token number">74</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"ConsumeMessageThread"</span> <span class="token parameter variable">-C</span> <span class="token number">50</span></code></pre><p>情况如下:</p><pre class="language-log" data-language="log"><code class="language-log"><span class="token string">"ConsumeMessageThread_20"</span> <span class="token operator">#</span><span class="token number">36030</span> prio<span class="token operator">=</span><span class="token number">5</span> os_prio<span class="token operator">=</span><span class="token operator">@</span> tid<span class="token operator">=</span><span class="token number">0x00007f1648035000</span> nid<span class="token operator">=</span>®x4b59b waiting on condition <span class="token operator">(</span><span class="token number">0x00007f1c0e9f0000</span><span class="token punctuation">]</span>    java<span class="token punctuation">.</span> lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>State<span class="token operator">:</span> WAITING <span class="token operator">(</span>parking<span class="token operator">)</span>    at sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">.</span>park <span class="token operator">(</span>Native Method<span class="token operator">)</span>    <span class="token operator">-</span> parking to wait for    <span class="token operator">&lt;</span><span class="token number">0x00000000c3a23938</span><span class="token operator">></span> <span class="token operator">(</span>a java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>AbstractQueuedSynchronizer<span class="token operator">$</span>Condition0bject<span class="token operator">)</span>    at java<span class="token punctuation">.</span>til<span class="token punctuation">.</span> concurrent<span class="token punctuation">.</span> locks<span class="token punctuation">.</span> LockSupport<span class="token punctuation">.</span>park<span class="token operator">(</span>LockSupport<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">175</span><span class="token operator">)</span>    at java<span class="token punctuation">.</span>til<span class="token punctuation">.</span> concurrent<span class="token punctuation">.</span> locks<span class="token punctuation">.</span>AbstractQueuedSynchronizer<span class="token operator">$</span>Condition0bject<span class="token punctuation">.</span>await <span class="token operator">(</span>AbstractQueuedSynchronizer<span class="token punctuation">.</span> java<span class="token operator">:</span> <span class="token number">2039</span><span class="token operator">)</span>    at java<span class="token punctuation">.</span>til<span class="token punctuation">.</span> concurrent<span class="token punctuation">.</span>LinkedBlockingQueue<span class="token punctuation">.</span>take <span class="token operator">(</span>LinkedBlockingQueue<span class="token punctuation">.</span> java<span class="token operator">:</span><span class="token number">442</span><span class="token operator">)</span>    at java<span class="token punctuation">.</span>til<span class="token punctuation">.</span> concurrent<span class="token punctuation">.</span> ThreadPoolExecutor<span class="token punctuation">.</span>getTask<span class="token operator">(</span>ThreadPoolExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1074</span><span class="token operator">)</span>    at java<span class="token punctuation">.</span>til<span class="token punctuation">.</span> concurrent<span class="token punctuation">.</span> ThreadPoolExecutor<span class="token punctuation">.</span>runWorker<span class="token operator">(</span>ThreadPoolExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1134</span><span class="token operator">)</span>    at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token operator">$</span>Worker<span class="token punctuation">.</span>run<span class="token operator">(</span>ThreadPoolExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">624</span><span class="token operator">)</span>    at java<span class="token punctuation">.</span> lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>run <span class="token operator">(</span>Thread<span class="token punctuation">.</span>java<span class="token operator">:</span> <span class="token number">748</span><span class="token operator">)</span></code></pre><p>所有的消费线程都是进入 WAITING 状态, 失去了消费能力, 连续抽查了几台生产实例, 都是相同的情况。</p><p>这种全局的等待, 初步怀疑是全局锁导致的, 比如数据库等 (实际上, 这时应该是在 FullGC, 全部线程都阻塞了)。<br>本着先解决问题, 再定位原因。所以先预发起了另一个版本实例, 然后切换流量过去。  </p><p>同样通过 jstack 查看, 消费线程都是 Runnable 状态, 默认是解决了, 等消息消费完就行了, 回到旧版本, 定位原因。</p><h4 id="3-2-2-加大生产实例-提高消费能力"><a href="#3-2-2-加大生产实例-提高消费能力" class="headerlink" title="3.2.2 加大生产实例, 提高消费能力"></a>3.2.2 加大生产实例, 提高消费能力</h4><p>20:50, 运维群各种反馈 MQ 堆积。<br>通过监控平台查看, 发现 MQ 堆积加重 (应该是正常业务的消息 + 重试的消息)</p><p>通过 jstack 查看线程有的在 Runable, 有的 WAITING, 而不是一开始的 WAITING。<br>所以先将应用是实例增加, 从 10 个增加到了 16 个, 提高一些消费能力, 看看能否降下来。</p><h4 id="3-2-3-增加堆内存-防止应用-GC-overhead-limit-exceeded"><a href="#3-2-3-增加堆内存-防止应用-GC-overhead-limit-exceeded" class="headerlink" title="3.2.3 增加堆内存, 防止应用 GC overhead limit exceeded"></a>3.2.3 增加堆内存, 防止应用 GC overhead limit exceeded</h4><p>通过观察监控平台, 堆积的情况没有好转。<br>这时告警平台不断的提示应用有异常, 进入到实例的日志, 发现  </p><pre class="language-log" data-language="log"><code class="language-log"><span class="token punctuation">[</span>xxxx<span class="token operator">-</span>xx<span class="token operator">-</span>xx <span class="token time number">21:05:53.978</span><span class="token punctuation">]</span><span class="token punctuation">[</span>ConsumeMessageThread_19<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token level error important">ERROR</span><span class="token punctuation">]</span><span class="token punctuation">[</span>com<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>qqq<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>service<span class="token punctuation">.</span>TodoSubscriber<span class="token operator">:</span><span class="token number">49</span><span class="token punctuation">]</span><span class="token punctuation">[</span>ConsumeMessageThread_19raceId<span class="token punctuation">]</span> TodoSubscriber<span class="token operator">:</span>onMessage<span class="token operator">:</span><span class="token exception javastacktrace language-javastacktrace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>SerializationException<span class="token punctuation">:</span> Cannot serialize; nested exception is org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>support<span class="token punctuation">.</span>SerializationFailedException<span class="token punctuation">:</span> Failed to serialize object using DefaultSerializer; nested exception is java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>OutOfMemoryError<span class="token punctuation">:</span> GC overhead limit exceeded<span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>JdkSerializationRedisSerializer<span class="token punctuation">.</span><span class="token function">serialize</span><span class="token punctuation">(</span>JdkSerializationRedisSerializer<span class="token punctuation">.</span>java<span class="token punctuation">:</span>93<span class="token punctuation">)</span><span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>core<span class="token punctuation">.</span>AbstractOperations<span class="token punctuation">.</span><span class="token function">rawValue</span><span class="token punctuation">(</span>AbstractOperations<span class="token punctuation">.</span>java<span class="token punctuation">:</span>117<span class="token punctuation">)</span><span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>core<span class="token punctuation">.</span>DefaultValueOperations<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>DefaultValueOperations<span class="token punctuation">.</span>java<span class="token punctuation">:</span>168<span class="token punctuation">)</span><span class="token keyword">at</span> com<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>qqq<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>ProtoCacheServiceImpl<span class="token punctuation">.</span><span class="token function">addTodoIds</span><span class="token punctuation">(</span>ProtoCacheServiceImpl<span class="token punctuation">.</span>kt<span class="token punctuation">:</span>154<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Caused by<span class="token punctuation">:</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>support<span class="token punctuation">.</span>SerializationFailedException<span class="token punctuation">:</span> Failed to serialize object using DefaultSerializer; nested exception is java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>OutOfMemoryError<span class="token punctuation">:</span> GC overhead limit exceeded<span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>support<span class="token punctuation">.</span>SerializingConverter<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>SerializingConverter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>68<span class="token punctuation">)</span><span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>support<span class="token punctuation">.</span>SerializingConverter<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>SerializingConverter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>35<span class="token punctuation">)</span><span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>JdkSerializationRedisSerializer<span class="token punctuation">.</span><span class="token function">serialize</span><span class="token punctuation">(</span>JdkSerializationRedisSerializer<span class="token punctuation">.</span>java<span class="token punctuation">:</span>91<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 23 moreCaused by<span class="token punctuation">:</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>OutOfMemoryError<span class="token punctuation">:</span> GC overhead limit exceeded</span></code></pre><p>出现该问题的原因：当 GC 为释放很小空间占用大量时间时会抛出此异常 (Sun 官方对此的定义, 超过 98% 的时间用来做 GC 并且回收了不到 2% 的堆内存时会抛出此异常)。<br>一般是因为堆太小, 导致异常的原因：没有足够的内存。</p><p>查看堆内存设置为 2G (-Xmx2G, 小堆多实例的配置), 先尝试将堆内存设置为 4G (-Xmx4G), 解决上面的异常, 让应用能够继续消费。</p><h4 id="3-2-4-消费能力提高-数据库压力增大"><a href="#3-2-4-消费能力提高-数据库压力增大" class="headerlink" title="3.2.4 消费能力提高, 数据库压力增大"></a>3.2.4 消费能力提高, 数据库压力增大</h4><p>通过切版本 + 增加实例 + 增加堆内存, 一步步加大了消费能力。</p><p>然而没多久, 运维群反馈主库挂了, 从库切换为主库了。<br>通过运维反馈, 虽然切换了, 但是整个库的查询压力还是很大, 一直在 100%。  </p><p><img src="https://pic.imgdb.cn/item/6549fceac458853aef7f7ab3.png" alt="Alt &#39;数据库高负载图&#39;"></p><p>同时, 数据库中大量的 SQL 语句处于 SendingData 状态 (这个状态一般是结果集太大, 数据库服务端一直在往客户端推送数据中)。</p><p>果然没过多久, 从库也挂了。</p><h4 id="3-2-5-减少实例-删除压测数据"><a href="#3-2-5-减少实例-删除压测数据" class="headerlink" title="3.2.5 减少实例, 删除压测数据"></a>3.2.5 减少实例, 删除压测数据</h4><p>到了这一步, 继续加大消费能力已经没有意义了。消息可以先堆积, 但是数据库影响着整个应用。  </p><p>所以在重启数据库后, 立即将实例减少到 10 个。</p><p>同时从测试获取到涉及压测的用户 id, 查询情况, 一个用户就产生了近 4 万的数据。 </p><p>因为是测试数据, 直接将所有压测的用户的数据清除。   </p><p>MQ 消费一波, 就清除一波, 整个堆积的情况也随着下来。</p><h2 id="4-回顾"><a href="#4-回顾" class="headerlink" title="4 回顾"></a>4 回顾</h2><p>在 MQ 堆积时, 我们的解决方案: 逐渐的增大消费能力。<br>最终没有解决堆积, 而是导致了数据库的宕机, 应用本身也进入了 GC。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;&lt;strong&gt;这次事故实际的借鉴意义不大, 只是整个解决过程比较有趣, 所以记录一下。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1 背景&quot;&gt;&lt;/a&gt;1</summary>
        
      
    
    
    
    
    <category term="生产记录" scheme="https://github.com/Lcn29/tags/%E7%94%9F%E4%BA%A7%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>一次接口大量异常的排查 (大对象强引用, 无法回收, 导致一直在 GC)</title>
    <link href="https://github.com/Lcn29/article/2023/4219406402/"/>
    <id>https://github.com/Lcn29/article/2023/4219406402/</id>
    <published>2023-10-22T06:17:19.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-结论"><a href="#1-结论" class="headerlink" title="1 结论"></a>1 结论</h2><p>先说一下结论:  </p><blockquote><ol><li>有一个方法分批的从数据库中查询数据, 然后放到一个 ArrayList 中, 最后拿着这个全量数据的 ArrayList 再做其他的操作</li><li>而这次事故中, 在分批查询过程中, 查询出了大量的数据, 触发了 GC, 但因为强引用无法回收, 结果整个应用一直都在 GC</li></ol></blockquote><h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2 过程"></a>2 过程</h2><h3 id="2-1-告警"><a href="#2-1-告警" class="headerlink" title="2.1 告警"></a>2.1 告警</h3><p>下午, 运维提示线上出现了大量的 50000 告警 (响应结果里面的状态码, 50000 在我们系统中, 基本都是非业务异常)。  </p><p>登上网关日志平台, 发现的确有大量的错误:<br><img src="https://pic.imgdb.cn/item/654ccbb1c458853aef9528cb.png" alt="Alt &#39;接口异常图示&#39;"></p><h3 id="2-2-排查"><a href="#2-2-排查" class="headerlink" title="2.2 排查"></a>2.2 排查</h3><h3 id="2-2-1-接口异常直接原因"><a href="#2-2-1-接口异常直接原因" class="headerlink" title="2.2.1 接口异常直接原因"></a>2.2.1 接口异常直接原因</h3><p>通过网关请求日志发现异常基本集中在几个动态相关的接口上,  于是随机抽出一个接口, 从代码中得到对应的 Controller 和方法。</p><p>进入到 APM 平台(应用性能监控平台), 搜索对应时间范围内 + 对应的 Controller 和方法的异常日志。<br>这里也可以直接通过请求的 traceId 到应用日志平台搜索, 这种非业务异常的日志, 通常都会打印到日志中。</p><p>发现异常日志如下:   </p><p><img src="https://pic.imgdb.cn/item/654ccc28c458853aef96a4b3.png" alt="Alt &#39;报错日志图示&#39;"></p><p>大体的意思: 调用 192.168.1.2 机器上应用的 Dubbo 接口超时了。</p><h3 id="2-2-2-接口提供方超时原因定位"><a href="#2-2-2-接口提供方超时原因定位" class="headerlink" title="2.2.2 接口提供方超时原因定位"></a>2.2.2 接口提供方超时原因定位</h3><p>根据日志上的地址 + 接口找到对应的应用。  </p><p>直接进入到应用日志, 看看能找到什么信息, 发现整个日志都停在了 15:14 (也是大量告警出现的时间点), 后面没有任何的日志输出。<br>日志无收获, 只能从<strong>应用自身</strong>的入手了。</p><ol><li>先获取一下当前 Java 程序的进程 Id  <pre class="language-bash" data-language="bash"><code class="language-bash">jps <span class="token parameter variable">-l</span></code></pre></li></ol><p><img src="https://pic.imgdb.cn/item/654ccd53c458853aef9ab9e7.png" alt="Alt &#39;Jps 进程 Id&#39;">  </p><p>可以得到当前的进程 Id 为 74。</p><ol start="2"><li>通过 top, 查看一下当前机器的 CPU 情况<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">top</span></code></pre></li></ol><p><img src="https://pic.imgdb.cn/item/654ccde5c458853aef9c951c.png" alt="Alt &#39;CPU 情况&#39;"></p><p>发现当前 CPU 很高, 达到了 248, 进程 ID 为 74, 和我们应用的进程 Id 一致。</p><ol start="3"><li>进一步查看当前进程的线程情况:</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">top</span> <span class="token parameter variable">-Hp</span> 进程 Id</code></pre><p><img src="https://pic.imgdb.cn/item/65502ac6c458853aef28e815.png" alt="Alt &#39;线程资源占用情况&#39;"></p><p>发现有 4 个线程的 CPU 都很高, 其他的几乎为 0 (当时没截图, 上面的数据凭印象造的, 主要的 CPU 和 PID, 不会有很大偏差)。</p><ol start="4"><li>抽取一个线程 Id, 查看当前它的堆栈信息进行分析:</li></ol><p>因为 Java JVM 中线程 Id 是 16 进制的, 而 <strong>top -Hp</strong> 查看到的是 10 进制的, 所以需要先转转换一下</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">printf</span> <span class="token string">"%x<span class="token entity" title="\n">\n</span>"</span> 抽取的线程 Id</code></pre><p>得到线程 Id  <strong>108</strong> 对应的 16 进制 Id 为 <strong>6c</strong></p><ol start="5"><li>通过 jstack 查看当前线程的堆栈信息</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">jstack 进程 Id <span class="token operator">|</span> <span class="token function">grep</span> 上面的线程 <span class="token number">16</span> 进制 Id <span class="token parameter variable">-C</span> <span class="token number">10</span></code></pre><p><img src="https://pic.imgdb.cn/item/65502bb1c458853aef2bd995.png" alt="Alt &#39;线程的堆栈信息&#39;"></p><p>找到 <strong>nid&#x3D;</strong> 处, 发现是 gc 线程。<br>查看另外 3 个高 CPU 的线程, 发现也是 gc 线程。 </p><p>到这里, 原因基本可以确定了: <strong>当前应用一直在 GC, 导致其他线程无法调度, 从而导致了大量的接口超时。</strong></p><h3 id="2-2-3-GC-原因定位"><a href="#2-2-3-GC-原因定位" class="headerlink" title="2.2.3 GC 原因定位"></a>2.2.3 GC 原因定位</h3><p>那么为什么会一直在 GC 呢? 可以通过当前的堆栈信息进行分析。</p><ol><li>先通过 jmap 获取当前的堆栈信息</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">jmap <span class="token parameter variable">-dump:format</span><span class="token operator">=</span>b,file<span class="token operator">=</span>heapdump.hprof 进程 Id</code></pre><p>获取到堆栈信息的文件: heapdump.hprof, 将其下载到本地, 然后导入到堆栈分析工具中查看, 这里使用的是 <strong>JProfile</strong>。</p><ol start="2"><li>导入后,一进来界面的是这样的</li></ol><p><img src="https://pic.imgdb.cn/item/65502c7fc458853aef2def60.png" alt="Alt &#39;JProfile 初始界面&#39;"></p><ol start="3"><li>直接选择最大对象</li></ol><p><img src="https://pic.imgdb.cn/item/65502d09c458853aef2f4501.png" alt="Alt &#39;JProfile 大对象&#39;"></p><p>发现最大对象的前几个中, 有 2 个 ArrayList, 结合当前应用一直在 GC 中, 选择其中一个的 ArrayList, 查看里面的内容。</p><p>查看内容的步骤大体如下:<br>选中查看的对象 -&gt; 右键 -&gt; 使用选定对象</p><p><img src="https://pic.imgdb.cn/item/65502e24c458853aef3250cd.png" alt="Alt &#39;JProfile 查看大对象第一步&#39;"></p><hr><p>在弹窗中, 选择引用 -&gt; 传出引用 -&gt; 确定</p><p><img src="https://pic.imgdb.cn/item/65502ed4c458853aef340bb3.png" alt="Alt &#39;JProfile 查看大对象第二步&#39;"></p><hr><p>发现里面的内容是业务数据, 有 15 万多条数据。</p><p><img src="https://pic.imgdb.cn/item/65502f7bc458853aef35b70d.png" alt="Alt &#39;JProfile 第一个大对象 ArrayList&#39;"></p><hr><p>查看另一个 ArrayList, 发现里面的内容是也是业务的家长打卡数据, 有 4 万多条数据。</p><p><img src="https://pic.imgdb.cn/item/65503031c458853aef37bae6.png" alt="Alt &#39;JProfile 第二个大对象 ArrayList&#39;"></p><hr><p>备注:<br>下面有用户对应的操作步骤, 可以点击对应的步骤, 回到上一次操作的界面。 </p><p><img src="https://pic.imgdb.cn/item/6550308cc458853aef38a6ee.png" alt="Alt &#39;JProfile 步骤回退&#39;"></p><p>到这一步可以确定问题出在了这 2 个 ArrayList 了。<br>程序一直往这 2 个 ArrayList 里面塞数据, 内存逐渐不够用, 触发了 GC, 而 ArrayList 中的数据又无法回收。</p><ol start="3"><li>定位 ArrayList 数据产生的位置</li></ol><p>将上面的传出引用, 变为传入引用</p><p><img src="https://pic.imgdb.cn/item/65503145c458853aef3aaa29.png" alt="Alt &#39;JProfile 线程栈定位第一步&#39;"></p><p>拖到最右边, 选择显示更多</p><p><img src="https://pic.imgdb.cn/item/655031bec458853aef3c27d3.png" alt="Alt &#39;JProfile 线程栈定位第二步&#39;"></p><hr><p>这样就可以查看到堆栈信息</p><p><img src="https://pic.imgdb.cn/item/65503255c458853aef3e5626.png" alt="Alt &#39;JProfile 线程栈信息&#39;"></p><p>最终定位到实际代码位置: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>yyyy<span class="token punctuation">.</span>broadcast<span class="token punctuation">.</span>service<span class="token punctuation">.</span>api<span class="token punctuation">.</span>impl<span class="token punctuation">.</span></span>SchoolStudentArchiveServiceApiImpl</span><span class="token punctuation">.</span><span class="token function">getClassPunchAnswerWithPhoto</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span><span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token punctuation">)</span></code></pre><p>分析代码发现是一个汇总分析的方法, 里面会查询出某个时间段的全部的数据, 然后汇总分析。</p><p>解决方案: 就根据具体业务进行分析解决。 </p><p>至此, 结束。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;1-结论&quot;&gt;&lt;a href=&quot;#1-结论&quot; class=&quot;headerlink&quot; title=&quot;1 结论&quot;&gt;&lt;/a&gt;1 结论&lt;/h2&gt;&lt;p&gt;先说一下结论:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;有一个方法分批的从数据库中查询数据, 然后放到一个</summary>
        
      
    
    
    
    
    <category term="生产记录" scheme="https://github.com/Lcn29/tags/%E7%94%9F%E4%BA%A7%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 线上服务假死, CPU 内存正常, 什么情况</title>
    <link href="https://github.com/Lcn29/article/2023/2603194288/"/>
    <id>https://github.com/Lcn29/article/2023/2603194288/</id>
    <published>2023-06-12T11:47:49.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<p>转载信息:<br>作者: <strong>小码农叔叔</strong><br>来源: CSDN<br>原文链接: <a href="https://blog.csdn.net/zhangcongyi420/article/details/131139599">SpringBoot线上服务假死, CPU内存正常, 什么情况？</a><br>版权声明: 本文为 CSDN 博主「小码农叔叔」的原创文章, 遵循 CC 4.0 BY-SA 版权协议, 转载请附上原文出处链接及本声明。</p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>开发小伙伴都知道线上服务挂掉, 基本都是因为 CPU 或者内存不足, 出现 GC 频繁 OOM 之类的情况。本篇文章区别以上的情况给小伙伴们带来不一样的服务挂掉。<br>还记得哔哩哔哩 713 事故中那场诡计多端的 0 吗？</p><p><img src="https://pic.imgdb.cn/item/65587d1ac458853aef47a792.png" alt="Alt &#39;哔哩哔哩 713 事故原因代码&#39;"></p><p>对就是这个0, 和本次事故没关系, 但深受启发。</p><h2 id="2-问题排查"><a href="#2-问题排查" class="headerlink" title="2 问题排查"></a>2 问题排查</h2><p>老规矩在集群环境中同一个服务几个节点无响应。如不及时解决会可能形成雪崩效应。</p><p>优先查看服务日志是否有报错, 礼貌习惯性查看服务 CPU 及内存情况。先复习下, 若服务无报错。CPU 或内存出现异常, 按如下步骤排查。</p><h3 id="2-1-常规排查"><a href="#2-1-常规排查" class="headerlink" title="2.1 常规排查"></a>2.1 常规排查</h3><blockquote><p>1、 查看服务进程中线程情况</p></blockquote><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">top</span> <span class="token parameter variable">-H</span> <span class="token parameter variable">-p</span> pid或<span class="token function">ps</span> <span class="token parameter variable">-mp</span> pid <span class="token parameter variable">-o</span> THREAD,tid,time</code></pre><blockquote><p>2、 查看系统异常线程 16 进制</p></blockquote><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">printf</span> “%x<span class="token punctuation">\</span>n” nid</code></pre><blockquote><p>3、查看异常线程堆栈信息</p></blockquote><pre class="language-bash" data-language="bash"><code class="language-bash">jstack pid <span class="token operator">|</span> <span class="token function">grep</span> number</code></pre><blockquote><p>4、查看占用最大内存对象前一百</p></blockquote><pre class="language-bash" data-language="bash"><code class="language-bash">jmap <span class="token parameter variable">-histo</span> pid<span class="token operator">|</span><span class="token function">head</span> <span class="token parameter variable">-100</span></code></pre><blockquote><p>5、导出到文件</p></blockquote><pre class="language-bash" data-language="bash"><code class="language-bash">jstack <span class="token parameter variable">-l</span> PID <span class="token operator">>></span> a.log</code></pre><blockquote><p>6、或 dump 信息使用工具 Mat 或 JProfiler 查看</p></blockquote><pre class="language-bash" data-language="bash"><code class="language-bash">jmap -dump:live,format<span class="token operator">=</span>b,file<span class="token operator">=</span>/dump.bin pid</code></pre><p>经过上面一通手法操作, 足以解决此类常规报错了, 通常大多是原因各种循环递归、或数据库慢查询等。</p><h3 id="2-2-Mat-使用"><a href="#2-2-Mat-使用" class="headerlink" title="2.2 Mat 使用"></a>2.2 Mat 使用</h3><p>在 MAT 中, 会有两种大小表示：</p><blockquote><p>Shallow Size：表示对象自身占用的内存大小, 不包括它引用的对象。<br>Retained size：当前对象内存大小 + 当前对象直接或间接引用的对象大小, 全部的总和, 简单理解, 就是当前对象被 GC 后, 总共能释放的内存大小。</p></blockquote><p>Histogram 视图<br><strong>以 Class Name 为维度, 分别展示各个类的对象数量。它默认是以 byte 为单位的</strong></p><p><img src="https://pic.imgdb.cn/item/65587d1ec458853aef47b3ba.png" alt="Alt &#39;MAT Histogram 图&#39;"></p><p>要显示让单位展示出来, 点击 Window -&gt; Preferences 选择最后一项, 点击 Apply and Close。</p><p><img src="https://pic.imgdb.cn/item/65587d20c458853aef47b9ea.png" alt="Alt &#39;MAT Histogram 显示单位配置界面&#39;"></p><p>再重新打开 Histogram 视图, 就会生效了。</p><p>Leak Suspects<br><strong>报表很直观地展现了一个饼图, 图中颜色深的部分表示可能存在内存泄漏的嫌疑。</strong></p><p>通过这个指标可以快速定位内存泄漏地方出现在哪个类方法里的哪行代码。</p><h3 id="2-3-本次问题排查"><a href="#2-3-本次问题排查" class="headerlink" title="2.3 本次问题排查"></a>2.3 本次问题排查</h3><blockquote><p>1、 信息收集分析</p></blockquote><p>因服务健康监测无响应, CPU 及内存情况正常, 直接查看堆栈信息, 看看线程都在干什么</p><pre class="language-bash" data-language="bash"><code class="language-bash">jstack <span class="token parameter variable">-l</span> PID <span class="token operator">>></span> a.log</code></pre><p>Jstack 的输出中, Java 线程状态主要是以下几种: </p><ul><li>RUNNABLE 线程运行中或 I&#x2F;O 等待</li><li>BLOCKED 线程在等待 monitor 锁 (synchronized 关键字)</li><li>TIMED_WAITING 线程在等待唤醒, 但设置了时限</li><li>WAITING 线程在无限等待唤醒</li></ul><p>发现都是 WAITING 线程。</p><pre class="language-log" data-language="log"><code class="language-log"><span class="token string">"http-nio-8888-exec-6666"</span> <span class="token operator">#</span><span class="token number">8833</span> daemon prio<span class="token operator">=</span><span class="token number">5</span> os_prio<span class="token operator">=</span><span class="token number">0</span> tid<span class="token operator">=</span><span class="token number">0x00001f2f0016e100</span> nid<span class="token operator">=</span><span class="token number">0x667d</span> waiting on condition <span class="token punctuation">[</span><span class="token number">0x00002f1de3c5200</span><span class="token punctuation">]</span><span class="token property">java.lang.Thread.State:</span> WAITING <span class="token operator">(</span>parking<span class="token operator">)</span>at sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">.</span>park<span class="token operator">(</span>Native Method<span class="token operator">)</span><span class="token operator">-</span> parking to wait for  <span class="token operator">&lt;</span><span class="token number">0x00000007156a29c8</span><span class="token operator">></span> <span class="token operator">(</span>a java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>AbstractQueuedSynchronizer<span class="token operator">$</span>ConditionObject<span class="token operator">)</span>at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>LockSupport<span class="token punctuation">.</span>park<span class="token operator">(</span>LockSupport<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">175</span><span class="token operator">)</span>at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>AbstractQueuedSynchronizer<span class="token operator">$</span>ConditionObject<span class="token punctuation">.</span>await<span class="token operator">(</span>AbstractQueuedSynchronizer<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">2039</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>DruidDataSource<span class="token punctuation">.</span>takeLast<span class="token operator">(</span>DruidDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1897</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>DruidDataSource<span class="token punctuation">.</span>getConnectionInternal<span class="token operator">(</span>DruidDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1458</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>DruidDataSource<span class="token punctuation">.</span>getConnectionDirect<span class="token operator">(</span>DruidDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1253</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>FilterChainImpl<span class="token punctuation">.</span>dataSource_connect<span class="token operator">(</span>FilterChainImpl<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">4619</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>stat<span class="token punctuation">.</span>StatFilter<span class="token punctuation">.</span>dataSource_getConnection<span class="token operator">(</span>StatFilter<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">680</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>FilterChainImpl<span class="token punctuation">.</span>dataSource_connect<span class="token operator">(</span>FilterChainImpl<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">4615</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>DruidDataSource<span class="token punctuation">.</span>getConnection<span class="token operator">(</span>DruidDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1231</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>DruidDataSource<span class="token punctuation">.</span>getConnection<span class="token operator">(</span>DruidDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1223</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>DruidDataSource<span class="token punctuation">.</span>getConnection<span class="token operator">(</span>DruidDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">90</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>dynamic<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>ds<span class="token punctuation">.</span>ItemDataSource<span class="token punctuation">.</span>getConnection<span class="token operator">(</span>ItemDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">56</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>dynamic<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>ds<span class="token punctuation">.</span>AbstractRoutingDataSource<span class="token punctuation">.</span>getConnection<span class="token operator">(</span>AbstractRoutingDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">48</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>DataSourceUtils<span class="token punctuation">.</span>doGetConnection<span class="token operator">(</span>DataSourceUtils<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">111</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>DataSourceUtils<span class="token punctuation">.</span>getConnection<span class="token operator">(</span>DataSourceUtils<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">77</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>mybatis<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span>SpringManagedTransaction<span class="token punctuation">.</span>openConnection<span class="token operator">(</span>SpringManagedTransaction<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">82</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>mybatis<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span>SpringManagedTransaction<span class="token punctuation">.</span>getConnection<span class="token operator">(</span>SpringManagedTransaction<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">68</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>BaseExecutor<span class="token punctuation">.</span>getConnection<span class="token operator">(</span>BaseExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">336</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>SimpleExecutor<span class="token punctuation">.</span>prepareStatement<span class="token operator">(</span>SimpleExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">84</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>SimpleExecutor<span class="token punctuation">.</span>doQuery<span class="token operator">(</span>SimpleExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">62</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>BaseExecutor<span class="token punctuation">.</span>queryFromDatabase<span class="token operator">(</span>BaseExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">324</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>BaseExecutor<span class="token punctuation">.</span>query<span class="token operator">(</span>BaseExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">156</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>CachingExecutor<span class="token punctuation">.</span>query<span class="token operator">(</span>CachingExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">109</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>github<span class="token punctuation">.</span>pagehelper<span class="token punctuation">.</span>PageInterceptor<span class="token punctuation">.</span>intercept<span class="token operator">(</span>PageInterceptor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">143</span><span class="token operator">)</span>at org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>plugin<span class="token punctuation">.</span>Plugin<span class="token punctuation">.</span>invoke<span class="token operator">(</span>Plugin<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">61</span><span class="token operator">)</span>at com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span><span class="token operator">$</span>Proxy571<span class="token punctuation">.</span>query<span class="token operator">(</span>Unknown Source<span class="token operator">)</span></code></pre><blockquote><p>2、定位关键信息, 追踪源代码</p></blockquote><pre class="language-log" data-language="log"><code class="language-log">at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>AbstractQueuedSynchronizer<span class="token operator">$</span>ConditionObject<span class="token punctuation">.</span>await<span class="token operator">(</span>AbstractQueuedSynchronizer<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">2039</span><span class="token operator">)</span>  at com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>DruidDataSource<span class="token punctuation">.</span>takeLast<span class="token operator">(</span>DruidDataSource<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1897</span><span class="token operator">)</span></code></pre><pre class="language-Java" data-language="Java"><code class="language-Java">DruidConnectionHolder takeLast() throws InterruptedException, SQLException &#123;try &#123;   while (poolingCount &#x3D;&#x3D; 0) &#123;      emptySignal(); &#x2F;&#x2F; send signal to CreateThread create connection              if (failFast &amp;&amp; isFailContinuous()) &#123;                  throw new DataSourceNotAvailableException(createError);              &#125;              notEmptyWaitThreadCount++;              if (notEmptyWaitThreadCount &gt; notEmptyWaitThreadPeak) &#123;                  notEmptyWaitThreadPeak &#x3D; notEmptyWaitThreadCount;              &#125;              try &#123;                  &#x2F;&#x2F; 数据库的连接都没有释放且被占用, 连接池中无可用连接, 导致请求被阻塞                  notEmpty.await(); &#x2F;&#x2F; signal by recycle or creator              &#125; finally &#123;                  notEmptyWaitThreadCount--;              &#125;              notEmptyWaitCount++;              if (!enable) &#123;                  connectErrorCountUpdater.incrementAndGet(this);                  throw new DataSourceDisableException();              &#125;          &#125;      &#125; catch (InterruptedException ie) &#123;          notEmpty.signal(); &#x2F;&#x2F; propagate to non-interrupted thread          notEmptySignalCount++;          throw ie;      &#125;      decrementPoolingCount();      DruidConnectionHolder last &#x3D; connections[poolingCount];      connections[poolingCount] &#x3D; null;      return last;&#125;</code></pre><p>结合日志报错定位到问题代码。因报错可用连接没有正常释放, 导致一直 await 卡死。</p><p>问题代码如下:</p><pre class="language-Java" data-language="Java"><code class="language-Java">try &#123;  SqlSession sqlSession &#x3D; sqlSessionFactory.openSession(ExecutorType.BATCH);  TestMapper mapper &#x3D; sqlSession.getMapper(TestMapper.class);  mapper.insetList(list);  sqlSession.flushStatements();&#125; catch (Exception e) &#123;   e.printStackTrace();&#125;</code></pre><h2 id="3-问题复现"><a href="#3-问题复现" class="headerlink" title="3 问题复现"></a>3 问题复现</h2><p>按照以上信息在多活环境复现。因线程被打满且都在等待导致监控检查无响应。  </p><p>Tomcat 线程被打满: </p><p><img src="https://pic.imgdb.cn/item/65587d22c458853aef47c101.png" alt="Alt &#39;Tomcat 线程池打满情况&#39;"></p><p>Tomcat 默认参数: </p><pre class="language-config" data-language="config"><code class="language-config">server.tomcat.max-threads&#x3D;200</code></pre><p>最大连接数默认是 10000</p><pre class="language-config" data-language="config"><code class="language-config">server.tomcat.max-connections&#x3D;10000</code></pre><p>等待队列长度, 默认 100。</p><pre class="language-config" data-language="config"><code class="language-config">server.tomcat.accept-count&#x3D;100</code></pre><p>最小工作空闲线程数, 默认 10。</p><pre class="language-config" data-language="config"><code class="language-config">server.tomcat.min-spare-threads&#x3D;100</code></pre><p>Druid 连接池的默认参数如下: </p><p><img src="https://pic.imgdb.cn/item/65587d29c458853aef47db45.png" alt="Alt &#39;Druid 连接池配置情况&#39;"></p><p>Druid 连接池的配置参数如下: </p><table><thead><tr><th align="center">属性</th><th align="center">说明</th><th align="center">建议值</th></tr></thead><tbody><tr><td align="center">username</td><td align="center">登录数据库的用户名</td><td align="center"></td></tr><tr><td align="center">password</td><td align="center">登录数据库的用户密码</td><td align="center"></td></tr><tr><td align="center">initialSize</td><td align="center">默认 0, 启动程序时, 在连接池中初始化多少个连接</td><td align="center">10-50 足够</td></tr><tr><td align="center">maxActive</td><td align="center">默认 8, 连接池中最多支持多少个活动会话</td><td align="center"></td></tr><tr><td align="center">maxWait</td><td align="center">默认 -1, 程序向连接池中请求连接时, 超过 maxWait 的值后, 认为本次请求失败, 即连接池, 没有可用连接, 单位毫秒, 设置 -1 时表示无限等待</td><td align="center">100</td></tr><tr><td align="center">minEvictableldleTimeMillis</td><td align="center">池中某个连接的空闲时长达到 N 毫秒后, 连接池在下次检查空闲连接时, 将回收该连接, 要小于防火墙超时设置 net.netflter.nf_conntrack_tcp_timeout_established</td><td align="center">见说明部分</td></tr><tr><td align="center">timeBetweenEvictionRunsMillis</td><td align="center">检查空闲连接的频率, 单位毫秒, 非正整数时表示不进行检查</td><td align="center"></td></tr><tr><td align="center">keepAlive</td><td align="center">程序没有 close 连接且空闲时长超过 minEvictableldleTimeMillis, 则会执, 行validationQuery 指定的 SQL, 以保证该程序连接不会池 kill 掉, 其范围不超过 minldle 指定的连接个数</td><td align="center">true</td></tr><tr><td align="center">minidle</td><td align="center">默认 8, 回收空闲连接时, 将保证至少有 minldle 个连接</td><td align="center">与 initialSize 相同</td></tr><tr><td align="center">removeAbandoned</td><td align="center">要求程序从池中 get 到连接后, N 秒后必须 close, 否则 druid 会强制回收该连接, 不管该连接中是活动还是空闲, 以防止进程不会进行 close 而霸占连接</td><td align="center">false, 当发现程序有未正常 close 连接时设置为 true</td></tr><tr><td align="center">removeAbandonedTimeout</td><td align="center">设置 druid 强制回收连接的时限, 当程序从池中 get 到连接开始算起, 超过此值后, druid 将强制回收该连接, 单位秒</td><td align="center">应大于业务运行最长时间</td></tr><tr><td align="center">logAbandoned</td><td align="center">当 druid 强制回收连接后, 是否将 stack trace 记录到日志中</td><td align="center">true</td></tr><tr><td align="center">testWhileldle</td><td align="center">当程序请求连接, 池在分配连接时, 是否先检查该连接是否有效。（高效）</td><td align="center">true</td></tr><tr><td align="center">validationQuery</td><td align="center">检查池中的连接是否仍可用的 SQL 语句, druid 会连接到数据库执行该 SQL, 如果正常返回, 则表示连接可用, 否则表示连接不可用</td><td align="center"></td></tr><tr><td align="center">testOnBorrow</td><td align="center">程序申请连接时, 进行连接有效性检查（低效, 影响性能）</td><td align="center">false</td></tr><tr><td align="center">testOnReturn</td><td align="center">程序返还连接时, 进行连接有效性检查（低效, 影响性能）</td><td align="center">false</td></tr><tr><td align="center">poolPreparedStatements</td><td align="center">缓存通过以下两个方法发起的 SQL: public PreparedStatement prepareStatement(String sql) 和 public PreparedStatement prepareStatement（String sql, int resultSetType, int resultSetConcurrency）</td><td align="center">true</td></tr><tr><td align="center">maxPoolPrepareStatementPerConnectionSize</td><td align="center">每个连接最多缓存多少个 SQL</td><td align="center">20</td></tr><tr><td align="center">filters</td><td align="center">这里配置的是插件, 常用的插件有: 监控统计: flter: stat, 日志监控: flter: log4j 或者 slf4j, 防御 SQL 注入: flter: wall</td><td align="center">stat, wall, slf4j</td></tr><tr><td align="center">connectProperties</td><td align="center">连接属性。比如设置一些连接池統计方面的配置。druid.stat.mergeSql&#x3D;true;druid.stat.slowSqIMillis&#x3D;5000 比如设置一些数据库连接庽性</td><td align="center"></td></tr></tbody></table><h2 id="4-解决"><a href="#4-解决" class="headerlink" title="4 解决"></a>4 解决</h2><blockquote><p>1、Druid 连接池的配置超时参数</p></blockquote><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>   <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>    <span class="token key atrule">password</span><span class="token punctuation">:</span>   <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">druid</span><span class="token punctuation">:</span>      <span class="token key atrule">stat-view-servlet</span><span class="token punctuation">:</span>        <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>        <span class="token key atrule">loginUsername</span><span class="token punctuation">:</span> admin        <span class="token key atrule">loginPassword</span><span class="token punctuation">:</span> <span class="token number">123456</span>    <span class="token key atrule">dynamic</span><span class="token punctuation">:</span>      <span class="token key atrule">druid</span><span class="token punctuation">:</span>        <span class="token key atrule">initial-size</span><span class="token punctuation">:</span> <span class="token number">5</span>        <span class="token key atrule">min-idle</span><span class="token punctuation">:</span> <span class="token number">5</span>        <span class="token key atrule">maxActive</span><span class="token punctuation">:</span> <span class="token number">20</span>        <span class="token key atrule">maxWait</span><span class="token punctuation">:</span> <span class="token number">60000</span>        <span class="token key atrule">timeBetweenEvictionRunsMillis</span><span class="token punctuation">:</span> <span class="token number">60000</span>        <span class="token key atrule">minEvictableIdleTimeMillis</span><span class="token punctuation">:</span> <span class="token number">300000</span>        <span class="token key atrule">validationQuery</span><span class="token punctuation">:</span> SELECT 1 FROM DUAL        <span class="token key atrule">testWhileIdle</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>        <span class="token key atrule">testOnBorrow</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>        <span class="token key atrule">testOnReturn</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>        <span class="token key atrule">poolPreparedStatements</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>        <span class="token key atrule">maxPoolPreparedStatementPerConnectionSize</span><span class="token punctuation">:</span> <span class="token number">20</span>        <span class="token key atrule">filters</span><span class="token punctuation">:</span> stat<span class="token punctuation">,</span>slf4j<span class="token punctuation">,</span>wall        <span class="token key atrule">connectionProperties</span><span class="token punctuation">:</span> druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000</code></pre><blockquote><p>2、异常及时关闭连接</p></blockquote><pre class="language-Java" data-language="Java"><code class="language-Java">sqlSession.close();</code></pre>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;转载信息:&lt;br&gt;作者: &lt;strong&gt;小码农叔叔&lt;/strong&gt;&lt;br&gt;来源: CSDN&lt;br&gt;原文链接: &lt;a</summary>
        
      
    
    
    
    
    <category term="转载" scheme="https://github.com/Lcn29/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="生产记录" scheme="https://github.com/Lcn29/tags/%E7%94%9F%E4%BA%A7%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>java.io.IOError: java.io.FileNotFoundException: Invalid file path 的问题定位</title>
    <link href="https://github.com/Lcn29/article/2023/1066841748/"/>
    <id>https://github.com/Lcn29/article/2023/1066841748/</id>
    <published>2023-02-27T10:03:18.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1 环境"></a>1 环境</h2><table><thead><tr><th align="center">环境</th><th align="center">版本</th></tr></thead><tbody><tr><td align="center">OS</td><td align="center">window 10</td></tr><tr><td align="center">jdk</td><td align="center">JDK-8u331</td></tr><tr><td align="center">SpringBoot</td><td align="center">2.0.0.RELEASE</td></tr></tbody></table><h2 id="2-现象"><a href="#2-现象" class="headerlink" title="2 现象"></a>2 现象</h2><p>一个 SpringBoot 的项目, 使用了 undertown 作为 web 容器的项目。<br>项目启动成功后, 第一次发起 http 请求接口, 任意一个接口都可以, 会直接抛出如下异常:<br><strong>nested exception is java.io.IOError: java.io.FileNotFoundException: Invalid file path</strong>  </p><pre class="language-log" data-language="log"><code class="language-log"><span class="token exception javastacktrace language-javastacktrace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>util<span class="token punctuation">.</span>NestedServletException<span class="token punctuation">:</span> Handler dispatch failed; nested exception is java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOError<span class="token punctuation">:</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileNotFoundException<span class="token punctuation">:</span> Invalid file path <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>DispatcherServlet<span class="token punctuation">.</span><span class="token function">doDispatch</span><span class="token punctuation">(</span>DispatcherServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>982<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>DispatcherServlet<span class="token punctuation">.</span><span class="token function">doService</span><span class="token punctuation">(</span>DispatcherServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>901<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>FrameworkServlet<span class="token punctuation">.</span><span class="token function">processRequest</span><span class="token punctuation">(</span>FrameworkServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>970<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>FrameworkServlet<span class="token punctuation">.</span><span class="token function">doPost</span><span class="token punctuation">(</span>FrameworkServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>872<span class="token punctuation">)</span> <span class="token keyword">at</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServlet<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>HttpServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>707<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>FrameworkServlet<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>FrameworkServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>846<span class="token punctuation">)</span> <span class="token keyword">at</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServlet<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>HttpServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>790<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>85<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>129<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>ApplicationContextHeaderFilter<span class="token punctuation">.</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>ApplicationContextHeaderFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>55<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>OncePerRequestFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>OncePerRequestFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>107<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>actuate<span class="token punctuation">.</span>trace<span class="token punctuation">.</span>WebRequestTraceFilter<span class="token punctuation">.</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>WebRequestTraceFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>110<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>OncePerRequestFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>OncePerRequestFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>107<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> com<span class="token punctuation">.</span>lcn29<span class="token punctuation">.</span>framework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>CustomTraceFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>CustomTraceFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>116<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> com<span class="token punctuation">.</span>lcn29<span class="token punctuation">.</span>framework<span class="token punctuation">.</span>tracer<span class="token punctuation">.</span>sofa<span class="token punctuation">.</span>springmvc<span class="token punctuation">.</span>SpringMvcSofaTracerFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>SpringMvcSofaTracerFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>153<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>CharacterEncodingFilter<span class="token punctuation">.</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>CharacterEncodingFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>197<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>OncePerRequestFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>OncePerRequestFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>107<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>actuate<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>MetricsFilter<span class="token punctuation">.</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>MetricsFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>106<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>OncePerRequestFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>OncePerRequestFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>107<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>84<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>ServletSecurityRoleHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletSecurityRoleHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>62<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletDispatchingHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletDispatchingHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>36<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>SSLInformationAssociationHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>SSLInformationAssociationHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>ServletAuthenticationCallHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletAuthenticationCallHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>57<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>PredicateHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>PredicateHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>security<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>AbstractConfidentialityHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>AbstractConfidentialityHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>46<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>ServletConfidentialityConstraintHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletConfidentialityConstraintHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>64<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>security<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>AuthenticationMechanismsHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>AuthenticationMechanismsHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>60<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>CachedAuthenticatedSessionHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>CachedAuthenticatedSessionHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>77<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>security<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>AbstractSecurityContextAssociationHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>AbstractSecurityContextAssociationHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>PredicateHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>PredicateHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>PredicateHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>PredicateHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler<span class="token punctuation">.</span><span class="token function">handleFirstRequest</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>292<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler<span class="token punctuation">.</span><span class="token function">access$100</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>81<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler$2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>138<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler$2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>135<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ServletRequestContextThreadSetupAction$1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ServletRequestContextThreadSetupAction<span class="token punctuation">.</span>java<span class="token punctuation">:</span>48<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ContextClassLoaderSetupAction$1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ContextClassLoaderSetupAction<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler<span class="token punctuation">.</span><span class="token function">dispatchRequest</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>272<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler<span class="token punctuation">.</span><span class="token function">access$000</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>81<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler$1<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>104<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>Connectors<span class="token punctuation">.</span><span class="token function">executeRootHandler</span><span class="token punctuation">(</span>Connectors<span class="token punctuation">.</span>java<span class="token punctuation">:</span>211<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>HttpServerExchange$1<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>HttpServerExchange<span class="token punctuation">.</span>java<span class="token punctuation">:</span>809<span class="token punctuation">)</span> <span class="token keyword">at</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">runWorker</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span> <span class="token keyword">at</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor$Worker<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span> <span class="token keyword">at</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span></span></code></pre><p>后续无论发送多少次请求, 则都是抛出另一个异常:<br><strong>nested exception is java.lang.NoClassDefFoundError: Could not initialize class org.xnio.channels.Channels</strong></p><pre class="language-log" data-language="log"><code class="language-log"><span class="token exception javastacktrace language-javastacktrace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>util<span class="token punctuation">.</span>NestedServletException<span class="token punctuation">:</span> Handler dispatch failed; nested exception is java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>NoClassDefFoundError<span class="token punctuation">:</span> Could not initialize class org<span class="token punctuation">.</span>xnio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>Channels <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>DispatcherServlet<span class="token punctuation">.</span><span class="token function">doDispatch</span><span class="token punctuation">(</span>DispatcherServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>982<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>DispatcherServlet<span class="token punctuation">.</span><span class="token function">doService</span><span class="token punctuation">(</span>DispatcherServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>901<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>FrameworkServlet<span class="token punctuation">.</span><span class="token function">processRequest</span><span class="token punctuation">(</span>FrameworkServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>970<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>FrameworkServlet<span class="token punctuation">.</span><span class="token function">doPost</span><span class="token punctuation">(</span>FrameworkServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>872<span class="token punctuation">)</span> <span class="token keyword">at</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServlet<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>HttpServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>707<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>FrameworkServlet<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>FrameworkServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>846<span class="token punctuation">)</span> <span class="token keyword">at</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServlet<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>HttpServlet<span class="token punctuation">.</span>java<span class="token punctuation">:</span>790<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>85<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>129<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>ApplicationContextHeaderFilter<span class="token punctuation">.</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>ApplicationContextHeaderFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>55<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>OncePerRequestFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>OncePerRequestFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>107<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>actuate<span class="token punctuation">.</span>trace<span class="token punctuation">.</span>WebRequestTraceFilter<span class="token punctuation">.</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>WebRequestTraceFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>110<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>OncePerRequestFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>OncePerRequestFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>107<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> com<span class="token punctuation">.</span>lcn29<span class="token punctuation">.</span>framework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>CustomTraceFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>CustomTraceFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>116<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> com<span class="token punctuation">.</span>lcn29<span class="token punctuation">.</span>framework<span class="token punctuation">.</span>tracer<span class="token punctuation">.</span>sofa<span class="token punctuation">.</span>springmvc<span class="token punctuation">.</span>SpringMvcSofaTracerFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>SpringMvcSofaTracerFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>153<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>CharacterEncodingFilter<span class="token punctuation">.</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>CharacterEncodingFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>197<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>OncePerRequestFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>OncePerRequestFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>107<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>actuate<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>MetricsFilter<span class="token punctuation">.</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>MetricsFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>106<span class="token punctuation">)</span> <span class="token keyword">at</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>OncePerRequestFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>OncePerRequestFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>107<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ManagedFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>ManagedFilter<span class="token punctuation">.</span>java<span class="token punctuation">:</span>61<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler$FilterChainImpl<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>FilterHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>FilterHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>84<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>ServletSecurityRoleHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletSecurityRoleHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>62<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletDispatchingHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletDispatchingHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>36<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>SSLInformationAssociationHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>SSLInformationAssociationHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>131<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>ServletAuthenticationCallHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletAuthenticationCallHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>57<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>PredicateHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>PredicateHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>security<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>AbstractConfidentialityHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>AbstractConfidentialityHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>46<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>ServletConfidentialityConstraintHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletConfidentialityConstraintHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>64<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>security<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>AuthenticationMechanismsHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>AuthenticationMechanismsHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>60<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>security<span class="token punctuation">.</span>CachedAuthenticatedSessionHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>CachedAuthenticatedSessionHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>77<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>security<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>AbstractSecurityContextAssociationHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>AbstractSecurityContextAssociationHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>PredicateHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>PredicateHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>PredicateHandler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>PredicateHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler<span class="token punctuation">.</span><span class="token function">handleFirstRequest</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>292<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler<span class="token punctuation">.</span><span class="token function">access$100</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>81<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler$2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>138<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler$2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>135<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ServletRequestContextThreadSetupAction$1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ServletRequestContextThreadSetupAction<span class="token punctuation">.</span>java<span class="token punctuation">:</span>48<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ContextClassLoaderSetupAction$1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ContextClassLoaderSetupAction<span class="token punctuation">.</span>java<span class="token punctuation">:</span>43<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler<span class="token punctuation">.</span><span class="token function">dispatchRequest</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>272<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler<span class="token punctuation">.</span><span class="token function">access$000</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>81<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>ServletInitialHandler$1<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ServletInitialHandler<span class="token punctuation">.</span>java<span class="token punctuation">:</span>104<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>Connectors<span class="token punctuation">.</span><span class="token function">executeRootHandler</span><span class="token punctuation">(</span>Connectors<span class="token punctuation">.</span>java<span class="token punctuation">:</span>211<span class="token punctuation">)</span> <span class="token keyword">at</span> io<span class="token punctuation">.</span>undertow<span class="token punctuation">.</span>server<span class="token punctuation">.</span>HttpServerExchange$1<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>HttpServerExchange<span class="token punctuation">.</span>java<span class="token punctuation">:</span>809<span class="token punctuation">)</span> <span class="token keyword">at</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">runWorker</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span> <span class="token keyword">at</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor$Worker<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span> <span class="token keyword">at</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span></span></code></pre><p>这里面有 2 个问题</p><blockquote><ol><li>请求进来后, 为什么会导致异常</li><li>第一次异常为 FileNotFoundException, 第二次及后续相同的请求, 抛出的则是 NoClassDefFoundError, 2 种不同的异常, 第一次特殊了</li></ol></blockquote><h2 id="3-第一个问题"><a href="#3-第一个问题" class="headerlink" title="3 第一个问题"></a>3 第一个问题</h2><p>通过异常日志定位到出现异常的地方为</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Conduits</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token constant">NULL_FILE_CHANNEL</span> <span class="token operator">=</span> <span class="token class-name">AccessController</span><span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">FileChannel</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">public</span> <span class="token class-name">FileChannel</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">final</span> <span class="token class-name">String</span> osName <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"os.name"</span><span class="token punctuation">,</span> <span class="token string">"unknown"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token class-name">Locale</span><span class="token punctuation">.</span><span class="token constant">US</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>osName<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"windows"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 抛出异常的位置</span>                        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"NUL:"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"/dev/null"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IOError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>抛出异常的位置 new FileOutputStream(“NUL:”).getChannel()。 这一行代码, 大体的逻辑为: 在 windows 系统中, 打开 NUL: 这个文件, 获取到其通道。<br>经过查询, 这里的 NUL:, 所在的文件路径为 C:\Windows\System32\drivers\null.sys。</p><pre class="language-log" data-language="log"><code class="language-log"><span class="token domain constant">null.sys</span> 文件的作用<span class="token operator">:</span> It allows a user to trivially throw away program output<span class="token punctuation">,</span> or to supply empty input<span class="token punctuation">.</span> 和 Linux 的 <span class="token file-path string">/dev/null作用类似</span><span class="token punctuation">,</span> 可以接收任意的输入<span class="token punctuation">,</span> 不产生输出。Linux 中经常将一下无用的日志都指向这个位置<span class="token operator">!</span></code></pre><p>初步怀疑是 <strong>null.sys</strong> 这个文件有异常, 从网上下载了一个正常的, 进行替换后, 还是同样的问题, 也就是 <strong>null.sys</strong> 文件正常。<br>排除是 null.sys 文件的问题后。 猜测是否为 new FileOutput(“NUL:”), JDK 在实现上有问题。</p><p>最终在 StackOverflow 的 <a href="https://stackoverflow.com/questions/71966064/java-fileoutputstreamnul-not-working-after-java-upgrade">“Java: FileOutputStream(“NUL:”) not working after Java upgrade “</a> 这篇文章中找到了问题的解决方案。  </p><p>同时顺藤摸瓜定位到官网中, 找到了问题所在, 的确是 JDK-8u331 这个版本的一个 bug。<br>bug 详情可以看这里 <a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8285445">“JDK-8285445 : cannot open file “NUL:””</a></p><p>总结一下,  JDK-8u331 中尝试避免去访问 ADS (alternate data streams), 而在代码实现上同时造成了 JDK 对设备文件的访问受阻。</p><p>解决方案:</p><blockquote><ol><li>在系统属性中添加 jdk.io.File.enableADS, 值为 false, 停用这个新特性即可</li><li>JDK-8u333 会对这种情况进行修复, 也就是更换 JDK 版本</li></ol></blockquote><p>到此第一个问题解决了。</p><h2 id="4-第二个问题"><a href="#4-第二个问题" class="headerlink" title="4 第二个问题"></a>4 第二个问题</h2><p>第二个问题, 为什么第二次及后面报的异常会和第一次的不同。</p><p>在上面的流程中, 2 次请求出现不同的异常:</p><blockquote><p>第一次请求抛出的是 FileNotFoundException<br>第二次后的所有请求抛出的是 NoClassDefFoundError</p></blockquote><p>NoClassDefFoundError 异常可以简单的理解为 Java 编译期能够找得到对应的 Class, 而到了运行时, 找不到合适的 Class。<br>抛出这个异常的线程会直接被停止, 即使 try-catch 住了异常, 线程也会被终止掉。</p><p>导致 NoClassDefFoundError 的原因有总的来说有 2 种</p><blockquote><ol><li>运行中找不到对应的类 (可能是 classpath 中没有这个 class, 存在多个类加载器等情况), 抛出的异常一般为 java.lang.NoClassDefFoundError: 没有找到的类的路径</li><li>类加载中初始化失败, 即 class 的 ＜clinit＞(), 也就是类的静态属性和静态代码出现了异常, 抛出的异常一般为 NoClassDefFoundError: Could not initialize class 类的路径</li></ol></blockquote><p>前者是真的在运行中没有找到这个类, 后者是加载类失败。</p><p>结合上面出现异常的位置的代码, 可以很快的知道第二次及后续出现的异常是因为第一次加载 Conduits 类执行其静态代码块失败了, 后续加载这个 Conduits 类, 直接不加载, 抛出 NoClasseDefFoundError 这个异常了</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><a href="https://segmentfault.com/a/1190000023381403">java.io.FileNotFoundException: NUL: (系统找不到指定的文件。)</a><br><a href="http://leybreeze.com/blog/?p=77885">Java 运行时发生 NoClassDefFoundError: Could not initialize class 的解决方法</a><br><a href="https://stackoverflow.com/questions/71966064/java-fileoutputstreamnul-not-working-after-java-upgrade">Java: FileOutputStream(“NUL:”) not working after Java upgrade</a><br><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8285445">JDK-8285445 : cannot open file “NUL:”</a>  </p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;1-环境&quot;&gt;&lt;a href=&quot;#1-环境&quot; class=&quot;headerlink&quot; title=&quot;1 环境&quot;&gt;&lt;/a&gt;1 环境&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;环境&lt;/th&gt;
&lt;th</summary>
        
      
    
    
    
    
    <category term="开发问题" scheme="https://github.com/Lcn29/tags/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>如何计算 MySQL 单表中能存放多少条数据</title>
    <link href="https://github.com/Lcn29/article/2022/277668067/"/>
    <id>https://github.com/Lcn29/article/2022/277668067/</id>
    <published>2022-04-08T06:08:24.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<p>转载信息:<br>作者: <strong>敲代码的小小酥</strong><br>来源: CSDN<br>原文链接: <a href="https://blog.csdn.net/qq1309664161/article/details/124032981">如何计算Mysql单表中能存放多少条数据</a><br>版权声明: 本文为 CSDN 博主「敲代码的小小酥」的原创文章, 遵循 CC 4.0 BY-SA 版权协议, 转载请附上原文出处链接及本声明。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>常听有人说, MySQL 数据库单张表的数据, 最多不要超过千万级别, 否则需要分表处理。那这个结论是如何来的呢, 是否正确呢？今天来探讨一番。</p><h2 id="一、页的结构"><a href="#一、页的结构" class="headerlink" title="一、页的结构"></a>一、页的结构</h2><p>前面讲过, Mysql在读取数据时, 是一页一页的读数据, 称之为预读。那页的结构到底是怎样的呢？<br>MySQL 表中的数据, 在硬盘上存成了 .ibd文件, 这个文件, 专业名词叫表空间。 在 .ibd 文件的内部, 把表数据分成了很多份的数据页, 每份大小 16k。类似于下图所示: </p><p><img src="https://pic.imgdb.cn/item/655039d0c458853aef539a12.png" alt="Alt &#39;MySQL 数据页&#39;"></p><p>每页中, 不仅只有表数据, 还有一些其他信息, 具体如下: </p><p><img src="https://pic.imgdb.cn/item/65503acec458853aef565544.png" alt="Alt &#39;MySQL 数据页结构&#39;"></p><p>页头: 页头占120字节大小, 里面包括页号(ibd文件里的偏移量), 指针(指向前一页和后一页)等信息。<br>页尾: 页尾占8字节, 包含校验码等信息。<br>页目录: 行数据太多的话, 进入每页中, 挨个遍历, 效率也不高, 页目录是提高页内数据搜索的效率。<br>剩下的就是表数据的区域。  </p><h2 id="二、B-tree-索引与页"><a href="#二、B-tree-索引与页" class="headerlink" title="二、B+tree 索引与页"></a>二、B+tree 索引与页</h2><p>MySQL 索引也是一个文件, 在索引文件的内部, 也会按页, 进行数据的切分。<br>每页的大小固定都是 16k。以主键索引为例, 在主键索引中, 非叶子节点, 只存放了数据的主键 id, 不存放数据的其他信息。<br>因此, 在非叶子节点的每个页中, 就能存放更多的索引信息。<br>因为索引是树形结构, 所以在非叶子节点的页中, 还会有指向下级节点的指针, 专业名词叫扇出。<br>B+tree 索引每个非叶子都扇出到下一级节点, 直到叶子节点的页中。 </p><p>叶子节点的页里, 存放的就是完整的行数据了 (仅针对主键索引, 二级索引叶子节点是索引列+id)。</p><p>如下图所示：<br><img src="https://pic.imgdb.cn/item/65503fa9c458853aef65db31.png" alt="Alt &#39;B+tree 数据存储&#39;"></p><h2 id="三、单表最多行数的计算"><a href="#三、单表最多行数的计算" class="headerlink" title="三、单表最多行数的计算"></a>三、单表最多行数的计算</h2><p><img src="https://pic.imgdb.cn/item/6550410cc458853aef6b6730.png" alt="Alt &#39;行数计算演示图&#39;"></p><p>上图中,<br>x 表示非叶子节点, 每页中的数据行数。<br>y 表示叶子节点, 每页中的数据行数。<br>z 表示 B+tree 树的高度。<br>那么, 这个 B+tree 的行数总量就是: (x ^ (z-1)) * y。</p><p><strong>x 的计算</strong><br>页 16k, 页头 120b, 页尾 8b, 剩余大约 15k 的空间来存索引数据。主键索引包括主键列和页号两部分组成。主键假设是 bigint 类型, 占 8b, 页号专业名词是 FIL_PAGE_OFFSET, 占4b, 也就是索引数据大约 12b。<br>剩余的 15k 里, 每条索引数据 12b, 那么就可以放 1280 条索引数据, 即每个非叶子节点有1280 个扇出。</p><p><strong>y 的计算</strong><br>叶子节点与非叶子节点页的结构一样, 所以也有 15k 的空间存放数据, 在主键索引中, 叶子节点存放的是整条记录, 这里假设整条记录是 1kb, 所以叶子节点每个页就能存放 15 条完整数据, 即 y &#x3D; 15。</p><p><strong>z 的计算</strong><br>z 代表树的高度, 树越高, 查询效率就越低, 所以, 一般维持树在三层高度。这样, 查询数据时, 最多进行 3 次 IO, 就可以查询到数据。即 z &#x3D; 3。</p><p>x &#x3D; 1280, y &#x3D; 15, z &#x3D; 3, 套入上述公式, 得:<br>(x ^ (z-1)) * y &#x3D; (1280 ^ (3-1)) * 15 ≈ 2.5kw。</p><p>所以, 单表最多可以存放 2.5kw 数据。</p><p>计算 y 时, 我们假设的一条数据 1kb。而单条数据达到 1kb, 算是比较大的数据了。 一般一条数据也就 300b 左右。如果按 300b 一条计算, 则 y &#x3D; 45。那么总行数就是: 2.5kw * 3 &#x3D; 7.5kw。即单表可以存七八千万条数据。</p><h2 id="四、联合索引的情况考虑"><a href="#四、联合索引的情况考虑" class="headerlink" title="四、联合索引的情况考虑"></a>四、联合索引的情况考虑</h2><p>上面的计算方式, 是按照主键索引来计算的。而真实生产中, 肯定会涉及到多条件查询。大数据量的情况下, 肯定要创建联合索引。那么考虑到联合索引, 如何计算单表最大行数呢？</p><p>假设一条多条件查询 SQL 命中了索引, 则首先是在联合索引中查询数据, 分两种情况讨论.  </p><h3 id="索引覆盖情况"><a href="#索引覆盖情况" class="headerlink" title="索引覆盖情况"></a>索引覆盖情况</h3><p>即通过联合索引, 就可以返回 SQL 所需的字段, 无需回表查询。</p><p><strong>x 的计算</strong><br>索引数据的空间还是剩余 15k 大小, 但是, 与主键索引不同的是, 联合索引每个非叶子节点, 会把索引列所有的字段都存起来, 其大小肯定比主键索引的 id 要大。我们假设联合索引有三个字段, 每个字段都是 varchar 类型, 且每个字段的值都是 5 个字 (utf8 编码), 那么每个字段就是 15b, 三个字段就是 45b。<br>所以, 一条数据的索引大小为 45b, 那么 15k, 能存 300 条数据, 也就是 300 个扇出。</p><p><strong>y 的计算</strong><br>联合索引的叶子节点, 存放的还是那几个联合索引列 +id 列。这里看成和 x 值相等, 45b, 一个页也能存 300 条数据。</p><p><strong>z 还按 3 计算</strong><br>那么总数是: (x ^ (z-1)) * y&#x3D; 300^2 * 300 &#x3D; 2.7kw。</p><p>这是按照联合索引 3 个字段, 每个字段 5 个汉字计算的。如果按照 3 个索引列, 每个字段 10个汉字计算, 10 个 utf8 编码的汉字占用字节为: 103 &#x3D; 30b。三个字段就是 90b。15k 就能存 150 条数据, 即 x &#x3D; y &#x3D; 150。  </p><p>z 还按 3 计算, 则总条数为: 150^2150 &#x3D; 330w。</p><p><strong>由此可见, 在索引覆盖的情况下, 一张表能存多少数据, 跟索引列大小有直接关系。索引列小时, 千万级别数据没问题, 索引列大时, 能存百万级别数据。</strong></p><h3 id="索引回表情况"><a href="#索引回表情况" class="headerlink" title="索引回表情况"></a>索引回表情况</h3><p>在联合索引需要回表的情况下, 需要先联合索引需要几次回表, 然后主键索引需要几次回表。这些确定了, 才能计算有多少数据量, 这里情况复杂, 不再详细计算。</p><h2 id="五、buffer-pool-size参数考虑"><a href="#五、buffer-pool-size参数考虑" class="headerlink" title="五、buffer_pool_size参数考虑"></a>五、buffer_pool_size参数考虑</h2><p>关于 Innodb_buffer_pool_size:《深入浅出 MySQL 》一文中这样描述 Innodb_buffer_pool_size:<br>该参数定义了 InnoDB 存储引擎的表数据和索引数据的最大内存缓冲区大小。和 MyISAM 存储引擎不同,  MyISAM 的<br>key_buffer_size 只缓存索引键,  而 innodb_buffer_pool_size 却是同时为数据块和索引块做缓存,<br>这个特性和 Oracle 是一样的。这个值设得越高, 访问表中数据需要的磁盘 I&#x2F;O 就越少。在一个专用的数据库<br>服务器上, 可以设置这个参数达机器物理内存大小的 80%。尽管如此, 还是建议用户不要把它设置得太大, 因为对物理内存的竞争可能在操作系统上导致内存调度。</p><p>可见, MySQL 的索引, 是可以在 bufferpool 中缓存的, 所以, 并不是每个节点, 都需要进行一次 IO 的。这也是为何上面的联合索引, 需要回表的情况, 我没有进一步讨论的原因。考虑到缓存等, 情况很复杂。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>综上所述, 对于单条数据量小, 涉及字段少的表, 存千万级别的数据, 是没问题的, 多者可以达到七八千万条数据。而对于单条数据量大, 字段多的表, 百万级别的量, 是可以承受的, 至于能不能存放千万级别的数据, 能存放几千万的数据, 这就需要根据实际情况, 进行性能的判断和判别了。无法通过理论的计算, 来获得一个很准确的值。</p><p>参考文章:<br><a href="https://mp.weixin.qq.com/s/mLosK11gCTFEzQlUjSPgtA">https://mp.weixin.qq.com/s/mLosK11gCTFEzQlUjSPgtA</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;转载信息:&lt;br&gt;作者: &lt;strong&gt;敲代码的小小酥&lt;/strong&gt;&lt;br&gt;来源: CSDN&lt;br&gt;原文链接: &lt;a</summary>
        
      
    
    
    
    
    <category term="转载" scheme="https://github.com/Lcn29/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="MySQL" scheme="https://github.com/Lcn29/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis AOF 源码</title>
    <link href="https://github.com/Lcn29/article/2021/4102538023/"/>
    <id>https://github.com/Lcn29/article/2021/4102538023/</id>
    <published>2021-12-20T07:59:59.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<p>在上篇, 我们已经从使用 &#x2F; 机制 &#x2F; AOF 过程中涉及的辅助功能等方面简单了解了 Redis AOF。<br>这篇将从源码的形式, 进行深入的了解。</p><h2 id="1-Redis-整个-AOF-主要功能"><a href="#1-Redis-整个-AOF-主要功能" class="headerlink" title="1 Redis 整个 AOF 主要功能"></a>1 Redis 整个 AOF 主要功能</h2><p>Redis 的 AOF 功能概括起来就 2 个功能</p><blockquote><ol><li>AOF 同步: 将客户端发送的变更命令, 保存到 AOF 文件中</li><li>AOF 重写: 随着 Redis 的运行, AOF 文件会不断变大, 在文件达到配置的条件时, 触发重写机制, 缩小文件的大小</li></ol></blockquote><h2 id="2-AOF-同步-将变更命令写入到文件"><a href="#2-AOF-同步-将变更命令写入到文件" class="headerlink" title="2 AOF 同步 - 将变更命令写入到文件"></a>2 AOF 同步 - 将变更命令写入到文件</h2><p><img src="https://pic.imgdb.cn/item/65a3caec871b83018a0217d0.png" alt="Alt &#39;AOF 同步过程&#39;"></p><p>如图 Redis AOF 同步过程</p><blockquote><ol><li>Redis 收到客户端发送的变更命令, 执行这个命令, 其间会修改在内存中数据库的数据</li><li>Redis 将这个变更命令同步到一个 <strong>AOF 缓冲区</strong></li><li>Redis 将 <strong>AOF 缓冲区</strong>中的数据同步到 AOF 文件中</li></ol></blockquote><p>整个 AOF 同步过程, 我们拆成 2 个部分进行分析</p><blockquote><ol><li>命令写入 AOF 缓冲区</li><li>AOF 缓冲区写入 AOF 文件</li></ol></blockquote><h3 id="2-1-变更命令写入-AOF-缓冲区"><a href="#2-1-变更命令写入-AOF-缓冲区" class="headerlink" title="2.1 变更命令写入 AOF 缓冲区"></a>2.1 变更命令写入 AOF 缓冲区</h3><h4 id="2-1-1-前置知识梳理"><a href="#2-1-1-前置知识梳理" class="headerlink" title="2.1.1 前置知识梳理"></a>2.1.1 前置知识梳理</h4><p>在 AOF 同步过程中, 在客户端的变更命令和 AOF 文件中, 有一个 <strong>AOF 缓冲区</strong>的存在。<br>主要作用是在 AOF 过程中, 可以缓冲客户端发送的命令, 后面可以将这些命令一次性多条写入到 AOF 文件中。</p><p>其本身的定义很简单, 就是一个字符串, 也就是 sds。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 很简单就是一个字符串, 后面的命令追加到这个字符串的后面</span>    sds aof_buf<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre><p>客户端发送的变更命令转为 RESP 协议格式的字符串, 然后追加到已有的字符串后面即可, 这样就形成了一个命令的缓冲区。</p><h4 id="2-1-2-逻辑触发入口"><a href="#2-1-2-逻辑触发入口" class="headerlink" title="2.1.2 逻辑触发入口"></a>2.1.2 逻辑触发入口</h4><p>在 AOF 开启过程中, 客户端的命令会在执行完成后, 再保存一份到 <strong>AOF 缓冲区</strong>, 这个保存的入口就是在 Redis 执行所有命令的 call 函数中。<br>可以简单理解为, Redis 接收到了客户端的命令后, 就会调用 call 函数, call 函数里面会在<strong>命令执行前</strong>做一些处理, 然后执行命令, 最后在<strong>命令执行后</strong>再做一些处理。</p><pre class="language-c" data-language="c"><code class="language-c">call 函数的逻辑如下<span class="token operator">:</span> ```c<span class="token comment">/** * Redis 命令执行过程 * @param c 客户端 * @param flags 一个标识, 通过二进制的形式封装了很多功能的标识, 比如当前命令是否需要 AOF 传播, 是否需要记录日志等 */</span><span class="token keyword">void</span> <span class="token function">call</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 执行对应的客户端命令</span>    c<span class="token operator">-></span>cmd<span class="token operator">-></span><span class="token function">proc</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 入参的 flags 设置了 CMD_CALL_PROPAGATE 标识, 表示当前的命令需要传播</span>    <span class="token comment">// 同时对应的客户端内部的标识不是 CLIENT_PREVENT_PROP (客户端的命令阻止传播)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> CMD_CALL_PROPAGATE <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_PREVENT_PROP<span class="token punctuation">)</span> <span class="token operator">!=</span> CLIENT_PREVENT_PROP<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 省略</span>        <span class="token comment">// 命令传播标识, 默认为 none, 即什么都不做</span>        <span class="token keyword">int</span> propagate_flags <span class="token operator">=</span> PROPAGATE_NONE<span class="token punctuation">;</span>                <span class="token comment">// 命令导致数据脏了, 也就是修改了数据, 需要 aof 和 repl 传播 (repl 也就是主从复制, 同步给从节点)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dirty<span class="token punctuation">)</span>             <span class="token comment">// 修改命令传播标识为需要 AOF 和 repl 传播</span>            propagate_flags <span class="token operator">|=</span> <span class="token punctuation">(</span>PROPAGATE_AOF<span class="token operator">|</span>PROPAGATE_REPL<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 当前的客户端设置了需要强制同步传播, 更新命令传播标识为需要 repl 传播</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_FORCE_REPL<span class="token punctuation">)</span>             propagate_flags <span class="token operator">|=</span> PROPAGATE_REPL<span class="token punctuation">;</span>                       <span class="token comment">// 当前的客户端设置了需要强制 AOF 传播, 更新命令传播标识为需要 AOF 传播</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_FORCE_AOF<span class="token punctuation">)</span>             propagate_flags <span class="token operator">|=</span> PROPAGATE_AOF<span class="token punctuation">;</span>                   <span class="token comment">// CLIENT_PREVENT_REPL_PROP  这个标识表示当前的客户端的命令不需要 repl 传播          </span>        <span class="token comment">// 命令的执行过程 (上面的 proc 函数就是调用各个命令各自的执行逻辑), 内部可以通过 preventCommandPropagation() 等函数</span>        <span class="token comment">// 给当前的客户端的 flags 设置 CLIENT_PREVENT_REPL_PROP 等标识, 也就是不需要主从复制的标识</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_PREVENT_REPL_PROP <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> CMD_CALL_PROPAGATE_REPL<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment">// 取消 命令传播标识 中的命令复制传播标识    </span>            propagate_flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>PROPAGATE_REPL<span class="token punctuation">;</span>             <span class="token comment">// 同上一步的取消主从复制传播标识</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_PREVENT_AOF_PROP <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> CMD_CALL_PROPAGATE_AOF<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment">// 取消 命令传播标识 中的 AOF 保存标识    </span>            propagate_flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>PROPAGATE_AOF<span class="token punctuation">;</span>                      <span class="token comment">//  命令传播标识 不为 none, 且当前的命令不是模块命令</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>propagate_flags <span class="token operator">!=</span> PROPAGATE_NONE <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-></span>cmd<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CMD_MODULE<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment">// 调用 propagate 进行命令的传播</span>            <span class="token function">propagate</span><span class="token punctuation">(</span>c<span class="token operator">-></span>cmd<span class="token punctuation">,</span>c<span class="token operator">-></span>db<span class="token operator">-></span>id<span class="token punctuation">,</span>c<span class="token operator">-></span>argv<span class="token punctuation">,</span>c<span class="token operator">-></span>argc<span class="token punctuation">,</span>propagate_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * Redis 命令传播 * @param cmd Redis 命令 * @param dbid Redis 命令执行的数据库号 * @param argv Redis 命令的参数 * @param argc Redis 命令的参数个数 * @param flags 命令标识 */</span><span class="token keyword">void</span> <span class="token function">propagate</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">,</span> <span class="token keyword">int</span> dbid<span class="token punctuation">,</span> robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// AOF 开启了, 同时命令传播标识为 需要 AOF 传播</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_state <span class="token operator">!=</span> AOF_OFF <span class="token operator">&amp;&amp;</span> flags <span class="token operator">&amp;</span> PROPAGATE_AOF<span class="token punctuation">)</span>        <span class="token comment">// 将当前的命令保存到 AOF 缓冲区</span>        <span class="token function">feedAppendOnlyFile</span><span class="token punctuation">(</span>cmd<span class="token punctuation">,</span>dbid<span class="token punctuation">,</span>argv<span class="token punctuation">,</span>argc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 命令传播标识为 需要 repl 传播  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> PROPAGATE_REPL<span class="token punctuation">)</span>        <span class="token comment">// 将当前的没拿过来同步给从节点</span>        <span class="token function">replicationFeedSlaves</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span>dbid<span class="token punctuation">,</span>argv<span class="token punctuation">,</span>argc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上面就是<strong>命令写入 AOF 缓冲区</strong>的触发入口, 而真正的<strong>命令写入 AOF 缓冲区</strong> 的过程的话就是 feedAppendOnlyFile 函数了。</p><h4 id="2-1-3-具体的实现逻辑"><a href="#2-1-3-具体的实现逻辑" class="headerlink" title="2.1.3 具体的实现逻辑"></a>2.1.3 具体的实现逻辑</h4><p>feedAppendOnlyFile 函数的定义如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 命令写入 AOF 缓冲区 * * @param cmd Redis 命令 * @param dictid Redis 命令执行的数据库号 * @param argv Redis 命令的参数 * @param argc Redis 命令的参数个数 */</span><span class="token keyword">void</span> <span class="token function">feedAppendOnlyFile</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">,</span> <span class="token keyword">int</span> dictid<span class="token punctuation">,</span> robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">int</span> argc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 缓存字符串, 用于临时存放命令的文本</span>    sds buf <span class="token operator">=</span> <span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    robj <span class="token operator">*</span>tmpargv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 命令写入的数据库和当前 AOF 选中的数据库不是配置的, 手动加入一段, select 对应的数据库</span>    <span class="token comment">// 后面通过 AOF 文件恢复数据, 才能恢复到正确的数据库中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dictid <span class="token operator">!=</span> server<span class="token punctuation">.</span>aof_selected_db<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> seldb<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">// 将当前命令选中的数据库号数 (0, 1, 2, 3) 写入到字符数组 seldb 中</span>        <span class="token function">snprintf</span><span class="token punctuation">(</span>seldb<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>seldb<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"%d"</span><span class="token punctuation">,</span>dictid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 拼接出一个 select 数据库号 的语句, 这个语句是遵守 RESP 协议 </span>        buf <span class="token operator">=</span> <span class="token function">sdscatprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token string">"*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>seldb<span class="token punctuation">)</span><span class="token punctuation">,</span>seldb<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 修改 aof 当前的选中的数据库号数</span>        server<span class="token punctuation">.</span>aof_selected_db <span class="token operator">=</span> dictid<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// expire / pexpire / expireat 这三个命令, 在 AOF 保存的时候, 会转为 expireat key 具体的过期时间 (单位毫秒) 的格式存入到 AOF 文件中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd<span class="token operator">-></span>proc <span class="token operator">==</span> expireCommand <span class="token operator">||</span> cmd<span class="token operator">-></span>proc <span class="token operator">==</span> pexpireCommand <span class="token operator">||</span> cmd<span class="token operator">-></span>proc <span class="token operator">==</span> expireatCommand<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 转为过期对应的文本, 同时追加到 buf 中</span>        buf <span class="token operator">=</span> <span class="token function">catAppendOnlyExpireAtCommand</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span>cmd<span class="token punctuation">,</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd<span class="token operator">-></span>proc <span class="token operator">==</span> setexCommand <span class="token operator">||</span> cmd<span class="token operator">-></span>proc <span class="token operator">==</span> psetexCommand<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// setnx / psetex 2 个命令拆分为 set 和 expireat 2 个命令进行处理</span>        tmpargv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">createStringObject</span><span class="token punctuation">(</span><span class="token string">"SET"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tmpargv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        tmpargv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">// 往 buf 中追加 set 命令</span>        buf <span class="token operator">=</span> <span class="token function">catAppendOnlyGenericCommand</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>tmpargv<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 创建的对象手动修改引用计数, 便于内存回收</span>        <span class="token function">decrRefCount</span><span class="token punctuation">(</span>tmpargv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 往 buf 中追加 expireat 命令, 同理会转弯为 expireat key 具体的过期时间 (单位毫秒) 的格式</span>        buf <span class="token operator">=</span> <span class="token function">catAppendOnlyExpireAtCommand</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span>cmd<span class="token punctuation">,</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd<span class="token operator">-></span>proc <span class="token operator">==</span> setCommand <span class="token operator">&amp;&amp;</span> argc <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// set 命令同时参数大于 3 个, 也就是带有超时时间了</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>        robj <span class="token operator">*</span>exarg <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">*</span>pxarg <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                <span class="token comment">// 同样是, 先写入 set 命令</span>        buf <span class="token operator">=</span> <span class="token function">catAppendOnlyGenericCommand</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 计算后面的超时时间</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span> <span class="token string">"ex"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> exarg <span class="token operator">=</span> argv<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">,</span> <span class="token string">"px"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> pxarg <span class="token operator">=</span> argv<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">serverAssert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>exarg <span class="token operator">&amp;&amp;</span> pxarg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 根据计算出来的超时时间, 转为 RESP 协议的文本</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>exarg<span class="token punctuation">)</span>            buf <span class="token operator">=</span> <span class="token function">catAppendOnlyExpireAtCommand</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span>server<span class="token punctuation">.</span>expireCommand<span class="token punctuation">,</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> exarg<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>pxarg<span class="token punctuation">)</span>            buf <span class="token operator">=</span> <span class="token function">catAppendOnlyExpireAtCommand</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span>server<span class="token punctuation">.</span>pexpireCommand<span class="token punctuation">,</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pxarg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 其他的命令直接转为 RESP 协议的字符串进行追加</span>        buf <span class="token operator">=</span> <span class="token function">catAppendOnlyGenericCommand</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span>argc<span class="token punctuation">,</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>    <span class="token comment">// 如果 AOF 功能开启中, 则将命令追加到 AOF 缓冲区中</span>    <span class="token comment">// 后续在进入事件循环之前，这些命令会被保存到磁盘上，并向给对应的 client 回复执行结果</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_state <span class="token operator">==</span> AOF_ON<span class="token punctuation">)</span>        <span class="token comment">// 3 个缓冲区中的一个, AOF 缓冲区, 保存变更的 Redis 命令</span>        server<span class="token punctuation">.</span>aof_buf <span class="token operator">=</span> <span class="token function">sdscatlen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果后台正在进行重写，那么将命令再追加一份到重写缓冲区中，以便我们记录重写时 AOF 文件和当前数据库的差异</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">// 这里不展开, 后面聊</span>        <span class="token function">aofRewriteBufferAppend</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>buf<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span></code></pre><p>变更命令到 <strong>AOF 命令缓冲区</strong>的过程到这里结束了, 接下来就是 AOF 缓冲区到 AOF 文件的过程了。</p><h3 id="2-2-AOF-缓冲区写入-AOF-文件"><a href="#2-2-AOF-缓冲区写入-AOF-文件" class="headerlink" title="2.2 AOF 缓冲区写入 AOF 文件"></a>2.2 AOF 缓冲区写入 AOF 文件</h3><h4 id="2-2-1-前置知识梳理"><a href="#2-2-1-前置知识梳理" class="headerlink" title="2.2.1 前置知识梳理"></a>2.2.1 前置知识梳理</h4><p><strong>1. write + fsync 函数</strong>  </p><p>在操作系统中, 将应用的内存数据保存到真正的磁盘文件中, 实际需要通过 2 个函数</p><blockquote><ol><li>write 函数, 将缓冲区中的数据写入到<strong>系统缓冲</strong>中, 一般是达到一定数量或者时间, 才会真正的写入到磁盘中, 单独的通过 write 函数, 无法 100% 保证数据的完整性</li><li>fsync 函数, 一个比较耗时的操作, 可以立刻将<strong>系统缓冲</strong>中的数据写入到磁盘中</li></ol></blockquote><p><strong>2. Redis 线程池 RIO</strong></p><p>因为 fsync 函数比较耗时, 所以 Redis 维护了一个线程池 (Redis 内部叫做 BIO), 用来处理一些比较耗时的操作。<br>现在 Redis 这个线程池只处理 3 种任务类型</p><blockquote><ol><li>close 函数, 也就是关闭文件</li><li>fsync 函数, 立即刷新系统缓冲到磁盘</li><li>Redis 内部的延长删除无用内存</li></ol></blockquote><p>所以在 AOF 缓存区写入到 AOF 文件中, 会先通过 write 将里面的数据写入到<strong>系统缓冲</strong>,<br>然后根据当前的 AOF 保存策略, 决定是否需要执行 fsync 函数和 fsync 的执行能否交给线程池。</p><p><strong>3. AOF 文件同步策略</strong><br>将 AOF 缓冲区中的数据写入到 AOF 文件, Redis 提供了 3 种策略</p><blockquote><ol><li>no: 不进行同步, 由操作系统自己决定, 也就是只执行 write 函数</li><li>always: 每次 write 后, 都立即执行 fsync</li><li>everysec: 每次 write 后, 不会立即执行 fsync, 理论是每秒执行一次 fsync, 同时内部会将 fysnc 的执行交由线程池执行</li></ol></blockquote><p><strong>4. everysec 的特殊性</strong><br>同步策略为 everysec 时, 为了性能, fsync 函数的执行不是由 Redis 的主线程处理的, 而是通过向线程池提交一个 fsync 的任务, 由后台线程池执行。<br>那么就存在一种特殊情况</p><blockquote><ol><li>主线程在 flushAppendOnlyFile (AOF 缓存区写入到文件的函数) 完了 write, 提交了一个任务到后台线程, 假设此时的数据量很大, fsync 需要执行很长时间</li><li>主线程又执行到了 flushAppendOnlyFile 了, 而上一次的 fsync 函数还没执行完, Redis 会选择<strong>延迟执行</strong>, 将一个变量 aof_flush_postponed_start 设置为当前时间, 结束</li><li>后面主线程执行到定时任务时, 会判断这个变量是否大于 0, 是的话, 会再次执行 flushAppendOnlyFile, 也就是这次 AOF 同步延迟到定时处进行执行</li><li>但是延迟到定时任务处触发, 还是无法保证后台线程一定执行完了 fsync 了, 所以 flushAppendOnlyFile, 会根据当前的时间和变量里面存储的时间进行比较, 还是在 2 秒内, 不做任何处理, 而大于 2 秒, 立即执行 AOF 缓冲区写入文件的逻辑</li></ol></blockquote><p>理解了上面 3 个点, 下面 AOF 缓冲区的数据写入到 AOF 文件的过程就简单很多了。</p><h4 id="2-2-2-逻辑触发入口"><a href="#2-2-2-逻辑触发入口" class="headerlink" title="2.2.2 逻辑触发入口"></a>2.2.2 逻辑触发入口</h4><p>将缓冲区中的数据写入到文件的函数为 <strong>flushAppendOnlyFile</strong>, 而在 Redis 中会触发这个函数的有 5 个地方</p><blockquote><ol><li>通过命令动态地关闭 AOF 功能时, 会进行一次保存, 即动态的将 appendonly yes 设置为 appendonly no</li><li>Redis 服务器正常关闭之前, 会执行一次</li><li>在 AE 事件循环中配置的 beforesleep 函数中就会调用一次, 这个是 AOF 功能的主要的保存入口</li><li>Redis 的定时器函数 serverCron  (默认为 100 毫秒执行一次), 会判断上次执行的 flushAppendOnlyFile 是不是延迟执行, 是会调一次 (这个延迟的行为, 在 flushAppendOnlyFile 中有分析)</li><li>最后一个就是定时器函数 serverCron (默认为 1000 毫秒执行一次), 判断上次 AOF 写入状态, 失败就执行一次</li></ol></blockquote><p>后面 2 种都是在 serverCron 中, 代码如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 上次的 AOF 写文件时, 没有执行, 而是将 aof_flush_postponed_start 设置为 true, 表示需要延迟处理, 则在这里进行判断出来 </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_flush_postponed_start<span class="token punctuation">)</span>         <span class="token function">flushAppendOnlyFile</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">run_with_period</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 上次的写文件失败了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_last_write_status <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span>            <span class="token function">flushAppendOnlyFile</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span></code></pre><h4 id="2-2-3-具体的实现逻辑"><a href="#2-2-3-具体的实现逻辑" class="headerlink" title="2.2.3 具体的实现逻辑"></a>2.2.3 具体的实现逻辑</h4><p>整个 AOF 缓冲区的数据写入到 AOF 文件的实现函数就是 flushAppendOnlyFile, 定义如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * AOF 缓冲区数据写入文件 * * 当持久策略被设置为 everysec, 实际上会由后台线程进行处理, 那么当前这次刷新写入时, 后台可能有线程还在写入, 所以这时的操作会延迟写入 *  * @param force 1：表示无视后台的 fsync, 直接写入, 0: 表示可以延迟, 一般 AOF 过程都是 0 */</span><span class="token keyword">void</span> <span class="token function">flushAppendOnlyFile</span><span class="token punctuation">(</span><span class="token keyword">int</span> force<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ssize_t</span> nwritten<span class="token punctuation">;</span>    <span class="token keyword">int</span> sync_in_progress <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">mstime_t</span> latency<span class="token punctuation">;</span>    <span class="token comment">// 缓冲区没有数据, 正常缓冲区没有数据, 就可以结束了</span>    <span class="token comment">// 但是 Redis 在里面对一个极端情况的兼容, 有点绕, 有兴趣可以了解一下, 也可以跳过</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sdslen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 即使在缓冲区数据为空的情况下, 也需要检查一次是否需要执行 fsync 操作 (fsync: 将缓冲区数据写回磁盘)</span>        <span class="token comment">// 因为在 everysec 模式下, fsync 仅在 AOF 缓冲区不为空时调用</span>        <span class="token comment">// 如果在一秒钟调用一次的 fsync 之前, 用户停止了写命令 (stop write commands, 也就是没有发送任何变更的命令), 将会导致缓冲中的数据无法及时刷新</span>        <span class="token comment">// 这种情况的分析, 个人的猜测在后面的备注中进行分析</span>        <span class="token comment">// 1. 配置的持久化策略为 everysec 每秒执行一次 fsync </span>        <span class="token comment">// 2. 已经同步到磁盘的内容大小 != 当前 AOF 文件的内容大小</span>        <span class="token comment">// 3. 当前的时间 > 上次 AOF fsync 的时间</span>        <span class="token comment">// 4. 当前没有请求 fsync 的任务在线程池中</span>        <span class="token comment">// 4 个条件都符合, 尝试进行 fsync, 否则直接返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_EVERYSEC <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>aof_fsync_offset <span class="token operator">!=</span> server<span class="token punctuation">.</span>aof_current_size             <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>unixtime <span class="token operator">></span> server<span class="token punctuation">.</span>aof_last_fsync <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>sync_in_progress <span class="token operator">=</span> <span class="token function">aofFsyncInProgress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">goto</span> try_fsync<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 持久策略为每秒 fsync 一次, 判断后台的线程池是否有线程在执行 fsync </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_EVERYSEC<span class="token punctuation">)</span>        <span class="token comment">// aofFsyncInProgress 返回值为 true, 表示当前有 BIO 线程在执行 fsync </span>        sync_in_progress <span class="token operator">=</span> <span class="token function">aofFsyncInProgress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 持久策略为每秒 fsync 一次, 同时不需要强制写入文件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_EVERYSEC <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>force<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 当前有 BIO 线程在执行 fsync</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sync_in_progress<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 0 表示当前没有延迟执行</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_flush_postponed_start <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 当前有后台线程在执行 fsync, 那么先延长一下, 设置 aof_flush_postponed_start 为当前时间， 然后结束, 后面定时器执行到了, 判断这个值大于 0, </span>                <span class="token comment">// 重新进入 flushAppendOnlyFile 函数进行 AOF 缓冲区保存, 也就是延迟执行</span>                server<span class="token punctuation">.</span>aof_flush_postponed_start <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>                        <span class="token comment">// 如果之前有设置延迟执行, 然后又进入到这个函数(大部分场景是定时器触发), 此次后台还是有线程在执行 fsync,</span>            <span class="token comment">// 但是当前时间和上一次设置的延迟时间小于 2 秒, 可以接受, 暂时还是不做任何处理</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>unixtime <span class="token operator">-</span> server<span class="token punctuation">.</span>aof_flush_postponed_start <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 直接返回</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                         <span class="token comment">// 上面的情况分析</span>            <span class="token comment">// 第一次执行完 flushAppendOnlyFile 后, 但是数据量很大, 导致 fsync 很耗时, </span>            <span class="token comment">// 那么第二次 flushAppendOnlyFile 极端情况需要在 2 秒后才会进行</span>            <span class="token comment">// 延迟 fsync 的次数 + 1</span>            <span class="token comment">// 到了这一步表示线程池中有请求 fsync 的任务, 同时上次延迟距离当前时间超过 2 秒了</span>            server<span class="token punctuation">.</span>aof_delayed_fsync<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">// 记录日志</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>              <span class="token comment">// 下面的 latency 开头的函数基本都是延迟统计相关的, 不影响具体的逻辑, 可以跳过</span>    <span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 步骤 BB, 后面备注分析在缓存区没有数据还需要执行 fsync 用到</span>    <span class="token comment">// 调用 write 函数将缓冲区中的数据写入到文件 (此时还在系统级缓存, 还没写入到磁盘, 可以通过 fsync 强制刷入到磁盘)</span>    nwritten <span class="token operator">=</span> <span class="token function">aofWrite</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fd<span class="token punctuation">,</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sync_in_progress<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"aof-write-pending-fsync"</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"aof-write-active-child"</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"aof-write-alone"</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"aof-write"</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将缓冲区中的数据 write 到系统后, 可以把延迟执行设置为 0</span>    server<span class="token punctuation">.</span>aof_flush_postponed_start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 写入到系统的数据长度不等于当前 AOF 缓冲区的长度, 进入异常处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token class-name">ssize_t</span><span class="token punctuation">)</span><span class="token function">sdslen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">static</span> <span class="token class-name">time_t</span> last_write_error_log <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> can_log <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 上次记录错误日志的时间距离现在 30 秒了, 需要再记录多一次移除日志</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>unixtime <span class="token operator">-</span> last_write_error_log<span class="token punctuation">)</span> <span class="token operator">></span> AOF_WRITE_LOG_ERROR_RATE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            can_log <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            last_write_error_log <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// -1, 没有写入任何数据, 就直接失败了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 写入失败</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>can_log<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Error writing to the AOF file: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 保存错误到 redisServer 的 aof_last_write_errno</span>                server<span class="token punctuation">.</span>aof_last_write_errno <span class="token operator">=</span> errno<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 大于 -1 但是不等于缓冲区的大小, 写入成功了一部分, </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>can_log<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 记录日志</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 将 AOF 的文件大小修改为 aof_current_size 的大小, 返回值 0 成功, -1 失败</span>            <span class="token comment">// 也就是恢复回写入前的文件内容</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ftruncate</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fd<span class="token punctuation">,</span> server<span class="token punctuation">.</span>aof_current_size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 记录日志</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 设置为 -1, 表示 AOF 中没有写入成功的部分数据</span>                nwritten <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            server<span class="token punctuation">.</span>aof_last_write_errno <span class="token operator">=</span> ENOSPC<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 同步策略为 always</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_ALWAYS<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 这种情况无法处理了, 已经告知客户端写入成功了, 但是当前写入失败了, 直接退出程序。</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 设置上一次写入状态为异常, 在定时器中会判断这个状态, 再次触发 flushAppendOnlyFile </span>            server<span class="token punctuation">.</span>aof_last_write_status <span class="token operator">=</span> C_ERR<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 更新当前 aof 文件的大小 = 当前的大小 + 写入部分的大小, 同时将缓冲区中这部分大小的数据移除</span>                <span class="token comment">// 表示这部分写入成功了, 剩余部分下次调用继续</span>                server<span class="token punctuation">.</span>aof_current_size <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>                <span class="token function">sdsrange</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">,</span>nwritten<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 写入成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_last_write_status <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 最新最近一次写的状态为 C_OK</span>            server<span class="token punctuation">.</span>aof_last_write_status <span class="token operator">=</span> C_OK<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 更新当前 AOF 文件的大小</span>    server<span class="token punctuation">.</span>aof_current_size <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>    <span class="token comment">// 如果当前 AOF 缓冲区足够小，小于 4K，那么重用这个缓存，否则释放 AOF 缓冲区, 然后重新分配一个</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">sdslen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">sdsavail</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">4000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sdsclear</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>aof_buf <span class="token operator">=</span> <span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>try_fsync<span class="token operator">:</span>    <span class="token comment">// no-appendfsync-on-rewrite (正在重写, 不执行 fsync) 被设置为 yes</span>    <span class="token comment">// 正在执行 后台保存 RDB  或者 后台保存 AOF, 直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_no_fsync_on_rewrite <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token comment">// 持久策略为 always </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_ALWAYS<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 宏定义, 在 Linux 系统中执行 fdatasync 函数, 其他系统执行 fsync 函数</span>        <span class="token function">redis_fsync</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"aof-fsync-always"</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新 aof_fsync_offset 为当前的 AOF 文件大小</span>        server<span class="token punctuation">.</span>aof_fsync_offset <span class="token operator">=</span> server<span class="token punctuation">.</span>aof_current_size<span class="token punctuation">;</span>        <span class="token comment">// 上次 fsync 为当前的时间</span>        server<span class="token punctuation">.</span>aof_last_fsync <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_EVERYSEC <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>unixtime <span class="token operator">></span> server<span class="token punctuation">.</span>aof_last_fsync<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 持久策略为 everysec 同时当前的时间大于上次 fsync 的时间</span>        <span class="token comment">// 步骤 AA, 后面备注分析在缓存区没有数据还需要执行 fsync 用到</span>        <span class="token comment">// 当前没有请求 fsync 的任务在线程池中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sync_in_progress<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 提交一个任务, 最终就是一个后台线程执行一次 redis_fsync 函数</span>            <span class="token function">aof_background_fsync</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 更新 aof_fsync_offset 为当前的页的大小</span>            server<span class="token punctuation">.</span>aof_fsync_offset <span class="token operator">=</span> server<span class="token punctuation">.</span>aof_current_size<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        server<span class="token punctuation">.</span>aof_last_fsync <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token comment">// 返回 true, 如果当前已经有一个请求 fsync 的任务了, 返回 true</span><span class="token keyword">int</span> <span class="token function">aofFsyncInProgress</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">bioPendingJobsOfType</span><span class="token punctuation">(</span>BIO_AOF_FSYNC<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// Redis 的 BIO 更像是一个线程池, 下面的方法是提交一个任务到对应任务链表</span><span class="token comment">// 同时会尝试唤醒线程池对应的线程去执行任务, 具体的实现可以看一下 bio.c 这个文件</span><span class="token keyword">void</span> <span class="token function">aof_background_fsync</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">bioCreateBackgroundJob</span><span class="token punctuation">(</span>BIO_AOF_FSYNC<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>fd<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 调用 write 函数, 写入数据到文件</span><span class="token class-name">ssize_t</span> <span class="token function">aofWrite</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ssize_t</span> nwritten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> totwritten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 调用 write 函数将 server.aof_buf 中的数据写入到系统级缓存中</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> totwritten <span class="token operator">?</span> totwritten <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        len <span class="token operator">-=</span> nwritten<span class="token punctuation">;</span>        buf <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>        totwritten <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 写入的内容大小</span>    <span class="token keyword">return</span> totwritten<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上面就是一个将 AOF 缓冲区中的数据写入到系统的过程, 一个<strong>正常</strong>的流程如下：</p><blockquote><ol><li>如果当前同步策略是每秒 fsync, 同时有 BIO 线程在后台处理 fsync 了, 设置 redisServer 的延迟 AOF 时间 aof_flush_postponed_start 为当前时间, 等待下次执行, 结束</li><li>调用 write 把 AOF 缓冲区的数据写入到系统级缓存中</li><li>获取写入到系统级缓存的数据长度</li><li>写入到系统级缓存的数据长度不等于 AOF 缓冲区的数据长度, 进行异常处理, 结束</li><li>长度一样, 更新 redisServer 的最新 AOF 写入状态 aof_last_write_status 为成功状态</li><li>更新当前 AOF 文件的大小 aof_current_size 为 aof_current_size + 最新写入的数据长度</li><li>清空 AOF 缓冲区的数据</li><li>如果配置的持久策略为 always, 立即执行 fsync</li><li>如果配置的持久策略为 everysec, 当前的时间大于上次 fsync 的时间, 同时线程池中没有 fsync 任务, 提交一个到线程池, 更新当前的 fsync 写入量的 aof_fsync_offset 为当前的 AOF 文件大小</li><li>更新最新的 AOF fsync 时间为当前时间</li></ol></blockquote><p>备注:<br>在上面的代码中, 在 AOF 缓冲区没有数据的情况下, 还会进行条件的判断后, 尝试进行 fsync 的操作, 需要进行这种情况的情景, 个人猜测如下</p><blockquote><ol><li>第一次走入这个方法, sync_in_progress 为 false, 走到下面的步骤 AA, 开启了一个后台 BIO 线程进行 fsync, 假设当前的 aof_fsync_offset &#x3D; aof_current_size &#x3D; xx</li><li>第二次走入到这个方法, sync_in_progress 为 true, 走到步骤 BB 时, 后台的 BIO 线程已经完成任务, 结束了, 所以这时候 sync_in_progress 理论应该为 false 了, 但是此时还是为 true</li><li>第二次同样走到了下面的步骤 AA, 这是 aof_current_size 已经是追加到了最新的大小了, 设为 yy, 因为 sync_in_progress 为 true, aof_fsync_offset 还是 xx, 最新的数据已经 write 到系统级缓存了, 但是没有 fsync</li><li>如果这时候用户没有在向 Redis 中进行更改命令, AOF 缓冲区就会一直为空, 无论走几次到这个方法, 都不会走到下面的逻辑, 这时候就存在 AOF 文件中的数据和真正的数据有偏差</li><li>所以在 AOF 缓冲区为空的情况下, 还要进行多一次判断, 进行 fsync</li></ol></blockquote><h2 id="3-AOF-重写-AOF-文件瘦身"><a href="#3-AOF-重写-AOF-文件瘦身" class="headerlink" title="3 AOF 重写 - AOF 文件瘦身"></a>3 AOF 重写 - AOF 文件瘦身</h2><p>整个 AOF 重写过程, 会稍微复杂一些, 因为涉及到 2 个进程。</p><p><img src="https://pic.imgdb.cn/item/65a3caf0871b83018a022af8.png" alt="Alt &#39;AOF 重写过程&#39;"></p><p>如图是整个 AOF 重写过程</p><p>当 Redis 服务端发现整个 AOF 文件达到配置的重写条件了</p><blockquote><ol><li>立即创建出 6 个 Pipe 通道 (这些通道主要用于父子进程的通信)</li><li>父进程通过 fork 操作, 创建出子进程 (fork 可以理解为克隆, 此时子进程和父进程完全一样, 拥有父进程所有数据的快照), 由子进程会执行 AOF 重写的过程</li></ol></blockquote><p>fork 操作后, 父进程将继续运行</p><blockquote><ol><li>在收到客户端的变更命令后, 处理完同步到内存数据库中, 写入到 <strong>AOF 缓冲区</strong>, 此时还会写入一份到 <strong>AOF 重写缓冲区</strong>中</li><li>后面不断将 <strong>AOF 重写缓冲区</strong>中的数据通过 Pipe 通道同步给子进程</li></ol></blockquote><p>备注: 在子进程重写的这段过程, 命令还是会写入到 AOF 缓冲区中, 并同步写入 AOF 文件中</p><p>fork 出来的子进程, 此时不会有任何的数据变更了</p><blockquote><ol start="3"><li>根据自身<strong>内存数据库</strong>, 将里面的数据写入到一个新的 AOF 临时文件</li><li>在将内存数据写入到 AOF 临时文件中, 会按照每写入 10m 数据到文件时, 就通过 Pipe 将父进程同步过来的差异命令保存到自身的 <strong>AOF 子进程差异缓冲区</strong>中</li><li>当内存数据库中的数据全部写入到 AOF 临时文件后, 通过 Pipe 向父级发送一个 !, 通知父进程停止同步差异命令</li><li>父进程收到子进程发送过来的 !, 会停止向子进程同步差异命令, 并通过 Pipe 发送一个 !, 进行响应</li><li>子进程收到父进程发送过来的 ! 后, 会将自身的 <strong>AOF 子进程差异缓冲区</strong> 中的数据写入到 AOF 临时文件中</li></ol></blockquote><p>备注: 此时子进程任务完成 </p><p>父进程运行过程中, 会不断检查 AOF 子进程的状态</p><blockquote><ol start="8"><li>当发现子进程已经停止了, 父进程进行将 <strong>AOF 重写缓冲区</strong>中的省略的数据写入到 AOF 临时文件中</li><li>写入完成后, 将 AOF 临时文件替换掉旧的 AOF 文件, AOF 重写过程完成, 后面收到的 Redis 命令, 会写入到新的 AOF 文件中</li></ol></blockquote><p>至此, 这个 AOF 重写过程就完成了。</p><p>将上面的过程, 再概括一下就是</p><blockquote><ol><li>fork 出来的子进程, 拥有了和父进程一样的内存数据, 子进程先把这些内存数据写入到一个 AOF 临时文件</li><li>父进程在子进程同步内存数据到文件的过程中, 还在处理客户端请求, 将这段时间的变更命令保存下来</li><li>子进程内存数据同步到临时文件完成了, 将父进程这段时间保存下来的变更命令拿过来, 继续追加到 AOF 临时文件中</li><li>父进程在子进程将变更命令追加到临时文件的过程中, 继续把这段时间的变更命令保存下来</li><li>子进程将第一次同步过来的的变更命令追加到 AOF 临时文件后, 完成任务, 结束</li><li>父进程在子进程结束后, 自己剩余的变更命令同步到 AOF 临时文件，这个 AOF 临时文件就是完整的数据了</li></ol></blockquote><h3 id="3-1-前置知识梳理"><a href="#3-1-前置知识梳理" class="headerlink" title="3.1 前置知识梳理"></a>3.1 前置知识梳理</h3><h4 id="3-1-1-AOF-重写过程中涉及到的-Pipe-通道"><a href="#3-1-1-AOF-重写过程中涉及到的-Pipe-通道" class="headerlink" title="3.1.1 AOF 重写过程中涉及到的 Pipe 通道"></a>3.1.1 AOF 重写过程中涉及到的 Pipe 通道</h4><p>整个 AOF 重写的过程是需要父子 2 个进程共同合作完成的, 那么这个过程就涉及到通讯, 在 Redis 中, 通讯的方式是通过 Pipe 管道来实现的。<br>从 Redis 对 Pipe 的使用可以得出下面的特点,</p><blockquote><ol><li>Pipe 需要两两配合使用, 比如 A 和 B 2个 Pipe 组成一对, 父进程向 A Pipe 写入数据, 子进程可通过 B Pipe 读取到父进程同步过来的数据</li><li>一对 Pipe 组合的数据同步方向是不可逆的, 父进程通过 A Pipe 同步给子进程, 子进程没法反着过来通过 B  Pipe 同步数据给父进程</li></ol></blockquote><p>从上面的流程图中可以看到有 6 个 Pipe, 共 3 组</p><blockquote><ol><li>aof_pipe_write_data_to_child 和 aof_pipe_read_data_from_parent, 主要是父进程将子进程重写过程中产生的变更命令同步给子进程</li><li>aof_pipe_write_ack_to_parent 和 aof_pipe_read_ack_from_child, 主要是用于子进程通知父进程停止同步变更命令</li><li>aof_pipe_write_ack_to_child 和 aof_pipe_read_ack_from_parent, 主要用于父进程响应子进程的停止同步变更命令的请求</li></ol></blockquote><h4 id="3-1-2-AOF-重写过程涉及到的-2-个缓冲区"><a href="#3-1-2-AOF-重写过程涉及到的-2-个缓冲区" class="headerlink" title="3.1.2 AOF 重写过程涉及到的 2 个缓冲区"></a>3.1.2 AOF 重写过程涉及到的 2 个缓冲区</h4><p><strong>1. AOF 重写缓冲区</strong>  </p><p>AOF 重写缓冲区, 主要是在 AOF 重写过程中, 缓冲这段时间修改了内存数据的命令。<br>fork 出来的子进程, 根据自身的内存数据库快照, 生成一个新的 AOF 临时文件后。<br>生成的过程中, 父进程还在处理客户端的命令, 这些命令会导致数据变更, 需要把这些命令追加到 AOF 临时文件, 才是最终完整的数据。<br>而这个缓存区中就是父进程保存子进程重写过程中, 导致数据变更的命令。</p><p>那么这个缓冲区是什么样的呢？</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 重写缓存链表, 当前正在进行重写时, 会把命令写入到这个列表, 待重写完成后, 再追加到文件</span>    list <span class="token operator">*</span>aof_rewrite_buf_blocks<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">/** * AOF 重写缓存列表的节点定义 */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aofrwblock</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 下面的缓存数组已经使用的空间和剩余的空间</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">,</span> free<span class="token punctuation">;</span>    <span class="token comment">// 用来缓存需要写入到文件的命令文本内容, 当数组所有空间使用完了, 会新建一个新的缓存节点</span>    <span class="token comment">// AOF_RW_BUF_BLOCK_SIZE = 1024*1024*10</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>AOF_RW_BUF_BLOCK_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> aofrwblock<span class="token punctuation">;</span></code></pre><p>一个链表, 链表的节点就是一个 10kb 的字节数组, 即每个节点可以存储 10kb 的数据, 写满了就再新建一个节点。</p><p>这个缓冲区的作用和写入的时机, 实际在上面的 AOF 重写同步中已经有遇到了, 这里对数据写入的时机和逻辑进行一个代码级别的整理。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 在上面 AOF 命令写入缓冲区中, 可以知道, 在执行命令执行后, 会有个命令传播的逻辑, 里面会调用到这个 feedAppendOnlyFile 函数 * 这个函数会判断当前是否正在进行 AOF 重写, 如果是, 会将命令追加一份到 AOF 重写缓冲区中, 保存子进程重写过程中, 主进程这段时间处理的变更命令 */</span><span class="token keyword">void</span> <span class="token function">feedAppendOnlyFile</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">,</span> <span class="token keyword">int</span> dictid<span class="token punctuation">,</span> robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">int</span> argc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 如果后台正在进行重写，那么将命令追加到重写缓冲区中，以便我们记录重写时 AOF 文件和当前数据库的差异</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">// 这里就是将变更命令写入到 AOF 重写缓冲区</span>        <span class="token function">aofRewriteBufferAppend</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>buf<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * @param s: 需要写入的数据 * @param len: 需要写入的数据长度 */</span><span class="token keyword">void</span> <span class="token function">aofRewriteBufferAppend</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取重写缓冲区列表</span>    listNode <span class="token operator">*</span>ln <span class="token operator">=</span> <span class="token function">listLast</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_rewrite_buf_blocks<span class="token punctuation">)</span><span class="token punctuation">;</span>    aofrwblock <span class="token operator">*</span>block <span class="token operator">=</span> ln <span class="token operator">?</span> ln<span class="token operator">-></span>value <span class="token operator">:</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 重写缓冲列表已经有数据了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>block<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 当前列表的最后一个节点需要分配多少的长度出来</span>            <span class="token comment">// 剩余的空间 &lt; 需要的空间 ? 剩余多少分配多少 : 存储内容需要的长度</span>            <span class="token keyword">unsigned</span> <span class="token keyword">long</span> thislen <span class="token operator">=</span> <span class="token punctuation">(</span>block<span class="token operator">-></span>free <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token operator">?</span> block<span class="token operator">-></span>free <span class="token operator">:</span> len<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>thislen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 当前的节点空间还有剩余的</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>block<span class="token operator">-></span>buf<span class="token operator">+</span>block<span class="token operator">-></span>used<span class="token punctuation">,</span> s<span class="token punctuation">,</span> thislen<span class="token punctuation">)</span><span class="token punctuation">;</span>                block<span class="token operator">-></span>used <span class="token operator">+=</span> thislen<span class="token punctuation">;</span>                block<span class="token operator">-></span>free <span class="token operator">-=</span> thislen<span class="token punctuation">;</span>                s <span class="token operator">+=</span> thislen<span class="token punctuation">;</span>                <span class="token comment">// 计算出还需要多少空间</span>                len <span class="token operator">-=</span> thislen<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// len > 0, 说明还需要空间, 但是当前的节点没有空间了, 需要新建一个节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 还需要空间</span>            <span class="token keyword">int</span> numblocks<span class="token punctuation">;</span>            <span class="token comment">// 分配以新的缓存节点, 同时放到列表的尾部</span>            block <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>block<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            block<span class="token operator">-></span>free <span class="token operator">=</span> AOF_RW_BUF_BLOCK_SIZE<span class="token punctuation">;</span>            block<span class="token operator">-></span>used <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token function">listAddNodeTail</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_rewrite_buf_blocks<span class="token punctuation">,</span>block<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 获取当前的重写缓存列表的节点长度</span>            numblocks <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_rewrite_buf_blocks<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 加 1 后是 10 的倍数</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>numblocks<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 记录日志</span>                <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>numblocks<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> LL_WARNING <span class="token operator">:</span> LL_NOTICE<span class="token punctuation">;</span>                <span class="token function">serverLog</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span><span class="token string">"Background AOF buffer size: %lu MB"</span><span class="token punctuation">,</span> <span class="token function">aofRewriteBufferSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 回到循环的头部, 再来一次循环</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 注册一个文件事件, 用来将缓冲区的数据写入到 aof_pipe_write_data_to_child 中, 然后在 Pipe 的作用下, 可以同步到 aof_pipe_read_data_from_parent</span>    <span class="token comment">// 只需要注册一个就可以了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeGetFileEvents</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>server<span class="token punctuation">.</span>aof_pipe_write_data_to_child<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> server<span class="token punctuation">.</span>aof_pipe_write_data_to_child<span class="token punctuation">,</span> AE_WRITABLE<span class="token punctuation">,</span> aofChildWriteDiffData<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 把当前的 AOF 缓冲区同步到 aof_pipe_write_data_to_child, 在 Pipe 的作用下间接同步到 aof_pipe_read_data_from_parent</span><span class="token keyword">void</span> <span class="token function">aofChildWriteDiffData</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>    aofrwblock <span class="token operator">*</span>block<span class="token punctuation">;</span>    <span class="token class-name">ssize_t</span> nwritten<span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>privdata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 获取头节点</span>        ln <span class="token operator">=</span> <span class="token function">listFirst</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_rewrite_buf_blocks<span class="token punctuation">)</span><span class="token punctuation">;</span>        block <span class="token operator">=</span> ln <span class="token operator">?</span> ln<span class="token operator">-></span>value <span class="token operator">:</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token comment">// 停止同步或者没有 AOF 缓冲区时, 删除这个事件</span>        <span class="token comment">// 后续如果停止同步的标识还是 true, 又有缓冲区数据, 在 aofRewriteBufferAppend 会重新新建一个这个事件, 可以重新开始执行</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_stop_sending_diff <span class="token operator">||</span> <span class="token operator">!</span>block<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 删除这个事件</span>            <span class="token function">aeDeleteFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>server<span class="token punctuation">.</span>aof_pipe_write_data_to_child<span class="token punctuation">,</span> AE_WRITABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>block<span class="token operator">-></span>used <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 把 block 的数据写入到 aof_pipe_write_data_to_child</span>            nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_pipe_write_data_to_child<span class="token punctuation">,</span> block<span class="token operator">-></span>buf<span class="token punctuation">,</span> block<span class="token operator">-></span>used<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token function">memmove</span><span class="token punctuation">(</span>block<span class="token operator">-></span>buf<span class="token punctuation">,</span>block<span class="token operator">-></span>buf<span class="token operator">+</span>nwritten<span class="token punctuation">,</span>block<span class="token operator">-></span>used<span class="token operator">-</span>nwritten<span class="token punctuation">)</span><span class="token punctuation">;</span>            block<span class="token operator">-></span>used <span class="token operator">-=</span> nwritten<span class="token punctuation">;</span>            block<span class="token operator">-></span>free <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>block<span class="token operator">-></span>used <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token function">listDelNode</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_rewrite_buf_blocks<span class="token punctuation">,</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>看起来很长的一段逻辑, 实际概括起来就 2 个步骤。</p><p><img src="https://pic.imgdb.cn/item/65a3caf2871b83018a0233a0.png" alt="Alt &#39;AOF 重写缓冲区写入过程&#39;"></p><blockquote><ol><li>将客户端的命令转为 RESP 协议格式的字符串</li><li>将 RESP 协议格式的字符串写入到 AOF 缓冲区中<blockquote><p>2.1 写入的 AOF 缓冲区本质是一个链表, 尾节点还有空间, 那么尾结点能写多少就写多少<br>2.2 尾节点写完了, 就重新分配一个节点, 然后继续写入, 直到现在的命令字符串写完</p></blockquote></li></ol></blockquote><p><strong>2. AOF 子进程差异缓冲区</strong>  </p><p>通过上面的简单流程, 我们知道: 整个 AOF 重写过程是在通过 fork 函数, 克隆出一个子进程进行操作。<br>因为正常整个 Redis 的内存会很大, 重写的时间会很长, 如果把这个过程放在父进程, 过程会影响到 Redis 的正常运行,</p><p>同理, 整个 Redis 的内存很大, 所以整个 AOF 重写的过程不会很快, 那么这段时间产生的新的变更命令 (存放在上面的 AOF 重写缓冲区), 可能也会很多。<br>如果这些命令追加到新的 AOF 文件中放在父进程, 也可能会影响到 Redis 的正常运行。  </p><p>所以 Redis 重写过程中，会通过 Pipe 通道, 将这些命令同步给子进程自己的一个缓存区。<br>子进程在根据内存数据库重写完成后, 随便将这个缓冲区的数据追加到新的 AOF 文件中, 即把这段重写过程中产生的变更命令还是让子进程来处理。  </p><p>而这个缓冲区就是 <strong>AOF 子进程差异缓冲区</strong>，定义如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// AOF 子进程差异缓冲区</span>    sds aof_child_diff<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre><p>同样是一个字符串 sds。</p><p>子进程通过 Pipe 将 AOF 重写缓存区的数据同步到这个 AOF 子进程差异缓冲区的逻辑如下:</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 将 aof_pipe_read_data_from_parent 中的数据读取到 server.aof_child_diff 中</span><span class="token class-name">ssize_t</span> <span class="token function">aofReadDiffFromParent</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">65536</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">ssize_t</span> nread<span class="token punctuation">,</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 将 aof_pipe_read_data_from_parent 中的数据读取到 buf 中</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nread <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_pipe_read_data_from_parent<span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 把 buf 的数据拼接到 aof_child_diff 中</span>        server<span class="token punctuation">.</span>aof_child_diff <span class="token operator">=</span> <span class="token function">sdscatlen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_diff<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>nread<span class="token punctuation">)</span><span class="token punctuation">;</span>        total <span class="token operator">+=</span> nread<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> total<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>备注: 这里还有个问题, 子进程将重写过程 AOF 变更命令追加到 AOF 文件的过程中, 还是会产生新的变更命令 (此时还是存放在 AOF 重写缓冲区中),<br>Redis 将这段时间的变更命令的写入文件放在了父进程执行了。</p><p>整个 AOF 重写的过程, 需要的了解的前提知识大概就这些了, 后面进入代码的逻辑分析。</p><h3 id="3-2-逻辑触发入口"><a href="#3-2-逻辑触发入口" class="headerlink" title="3.2 逻辑触发入口"></a>3.2 逻辑触发入口</h3><p>在 Redis 触发重写机制的方式有 2 个</p><blockquote><ol><li>通过 bgrewriteaof 命令</li><li>定时器, 定时检查 AOF 文件, 如果满足配置文件里面设置的条件, 就触发</li></ol></blockquote><p>bgrewriteaof 命令方式对应的逻辑函数为 <strong>bgrewriteaofCommand</strong>, 里面的逻辑如下</p><blockquote><ol><li>如果已经在执行重写中了, 返回错误提示</li><li>如果当前正在执行 RDB 保存时, 只会先将 redisServer 中的 aof_rewrite_scheduled 属性设置为 true, 返回提示后, 结束, 后面通过定时器判断这个状态确定是否需要触发</li><li>调用 rewriteAppendOnlyFileBackground 执行重写</li></ol></blockquote><p>而定时器的触发代码如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 代码省略</span>    <span class="token comment">// 后台没有进程在 RDB 和 AOF, 同时通过 bgrewriteaof 命令设置了定时刷新重写 AOF  </span>    <span class="token comment">// 当用户调用 bgrewriteaof 命令时, Redis 正在 RDB, 会先将 aof_rewrite_scheduled 设置为 true, 然后返回, 而不是执行 AOF </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>aof_rewrite_scheduled<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">rewriteAppendOnlyFileBackground</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 后台有进程在 RDB 或者 AOF</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token function">ldbPendingChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 代码省略</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 代码省略</span>        <span class="token comment">// 1. 开启了 AOF 功能</span>        <span class="token comment">// 2. 后台没有进程在 RDB 和 AOF</span>        <span class="token comment">// 3. 配置了目前 AOF 文件大小超过上次重写的 AOF 文件的百分比</span>        <span class="token comment">// 4. 当前的 AOF 文件大小超过了配置的需要触发重写的最小大小</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_state <span class="token operator">==</span> AOF_ON <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span>            server<span class="token punctuation">.</span>aof_rewrite_perc <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>aof_current_size <span class="token operator">></span> server<span class="token punctuation">.</span>aof_rewrite_min_size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 计算当前的文件增长的比例</span>            <span class="token keyword">long</span> <span class="token keyword">long</span> base <span class="token operator">=</span> server<span class="token punctuation">.</span>aof_rewrite_base_size <span class="token operator">?</span> server<span class="token punctuation">.</span>aof_rewrite_base_size <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> <span class="token keyword">long</span> growth <span class="token operator">=</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_current_size<span class="token operator">*</span><span class="token number">100</span><span class="token operator">/</span>base<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">100</span><span class="token punctuation">;</span>              <span class="token comment">// 超过了就调用 rewriteAppendOnlyFileBackground 进行重写</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>growth <span class="token operator">>=</span> server<span class="token punctuation">.</span>aof_rewrite_perc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">rewriteAppendOnlyFileBackground</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 代码省略</span><span class="token punctuation">&#125;</span></code></pre><p>上面就是 AOF 重写触发的入口了, 而 AOF 重写的逻辑最终都是统一到了 <strong>rewriteAppendOnlyFileBackground</strong> 函数。</p><h3 id="3-3-具体的实现逻辑"><a href="#3-3-具体的实现逻辑" class="headerlink" title="3.3 具体的实现逻辑"></a>3.3 具体的实现逻辑</h3><h4 id="3-3-1-父进程执行-rewriteAppendOnlyFileBackground-函数-AOF-重写前的操作"><a href="#3-3-1-父进程执行-rewriteAppendOnlyFileBackground-函数-AOF-重写前的操作" class="headerlink" title="3.3.1 父进程执行 rewriteAppendOnlyFileBackground 函数, AOF 重写前的操作"></a>3.3.1 父进程执行 rewriteAppendOnlyFileBackground 函数, AOF 重写前的操作</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">rewriteAppendOnlyFileBackground</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> childpid<span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> start<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token comment">// 创建 Pipe 通道, 用于父子进程之间通信</span>    <span class="token comment">// 内部会创建父子通讯需要的 6 个 Pipe</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aofCreatePipes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span>         <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>      <span class="token comment">// 开通另一组通道, 不涉及主流程</span>    <span class="token comment">// 用于子进程向父子进程通讯, 在 AOF 中主要用于通知父进程, 子进程此次重写使用了多少额外内存</span>    <span class="token function">openChildInfoPipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取当前时间</span>    start <span class="token operator">=</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>childpid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 子进程 </span>        <span class="token comment">// fork 完成, 子进程, 从这里开始执行逻辑</span>        <span class="token comment">// 清除子进程不需要的资源</span>        <span class="token function">closeClildUnusedResourceAfterFork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置标题</span>        <span class="token function">redisSetProcTitle</span><span class="token punctuation">(</span><span class="token string">"redis-aof-rewrite"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 创建临时文件, 文件名 temp-rewriteaof-bg-进程ID.aof</span>        <span class="token function">snprintf</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">,</span><span class="token string">"temp-rewriteaof-bg-%d.aof"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 执行 rewriteAppendOnlyFile 函数, 进行 AOF 文件的重写 </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rewriteAppendOnlyFile</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 子进程重写完成的一些收尾工作, 基本不涉及主流程, 通知父进程过程中子进程修改了多少数据</span>            <span class="token comment">// 计算当前进程使用修改了多少内存</span>            <span class="token class-name">size_t</span> private_dirty <span class="token operator">=</span> <span class="token function">zmalloc_get_private_dirty</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>private_dirty<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span> <span class="token string">"AOF rewrite: %zu MB of memory used by copy-on-write"</span><span class="token punctuation">,</span> private_dirty<span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            server<span class="token punctuation">.</span>child_info_data<span class="token punctuation">.</span>cow_size <span class="token operator">=</span> private_dirty<span class="token punctuation">;</span>            <span class="token comment">// 子进程的信息发送给父进程, 也就是拷贝到 server.child_info_pipe[2] 中</span>            <span class="token function">sendChildInfo</span><span class="token punctuation">(</span>CHILD_INFO_TYPE_AOF<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 结束</span>            <span class="token function">exitFromChild</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token function">exitFromChild</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 父进程</span>        <span class="token comment">// fork 完成, 父进程, 从这里开始执行逻辑</span>        <span class="token comment">// 计算 fork 消耗的时间</span>        server<span class="token punctuation">.</span>stat_fork_time <span class="token operator">=</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start<span class="token punctuation">;</span>        <span class="token comment">// 计算 fork 的速率，GB/每秒</span>        server<span class="token punctuation">.</span>stat_fork_rate <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000000</span> <span class="token operator">/</span> server<span class="token punctuation">.</span>stat_fork_time <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 延迟统计</span>        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">,</span>server<span class="token punctuation">.</span>stat_fork_time<span class="token operator">/</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>childpid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// fork 失败 关闭通道</span>            <span class="token function">closeChildInfoPipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Can't rewrite append only file in background: fork: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">aofClosePipes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"Background append only file rewriting started by pid %d"</span><span class="token punctuation">,</span>childpid<span class="token punctuation">)</span><span class="token punctuation">;</span>                server<span class="token punctuation">.</span>aof_rewrite_scheduled <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>aof_rewrite_time_start <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">=</span> childpid<span class="token punctuation">;</span>        <span class="token comment">// 和 RDB 类似, 更新全局的 dict.dict_can_resize 进行字典扩容的控制, 控制存储数据的 dict 扩容</span>        <span class="token function">updateDictResizePolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>aof_selected_db <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 清空 redisServer 的 repl_scriptcache_dict 字典和 repl_scriptcache_fifo 这个列表</span>        <span class="token comment">// 和主从复制相关</span>        <span class="token function">replicationScriptCacheFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="3-3-2-子进程执行的-rewriteAppendOnlyFile-函数就是-AOF-重写真正过程"><a href="#3-3-2-子进程执行的-rewriteAppendOnlyFile-函数就是-AOF-重写真正过程" class="headerlink" title="3.3.2 子进程执行的 rewriteAppendOnlyFile 函数就是 AOF 重写真正过程"></a>3.3.2 子进程执行的 rewriteAppendOnlyFile 函数就是 AOF 重写真正过程</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 这里的入参 filename 格式为 temp-rewriteaof-bg-进程 ID, 而不是真正的 AOF 文件名</span><span class="token keyword">int</span> <span class="token function">rewriteAppendOnlyFile</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    rio aof<span class="token punctuation">;</span>    FILE <span class="token operator">*</span>fp<span class="token punctuation">;</span>    <span class="token keyword">char</span> tmpfile<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> byte<span class="token punctuation">;</span>    <span class="token comment">// 重新根据进程ID 获取一个文件名 temp-rewriteaof-进程ID.aof 的文件</span>    <span class="token comment">// 数据先写入到这个文件, 后面在重命名为入参的 filename</span>    <span class="token function">snprintf</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">,</span><span class="token string">"temp-rewriteaof-%d.aof"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 清空 aof_child_diff 的数据, 这个就是 AOF 子进程差异缓冲区</span>    server<span class="token punctuation">.</span>aof_child_diff <span class="token operator">=</span> <span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 初始 rio 流, 也就是 IO 流, 用于写入数据到文件</span>    <span class="token function">rioInitWithFile</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>aof<span class="token punctuation">,</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置文件自动同步</span>    <span class="token comment">// 当写入的字节数达到了 REDIS_AUTOSYNC_BYTES (1024*1024*32) 的倍数, 就执行一次 fsync,</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_rewrite_incremental_fsync<span class="token punctuation">)</span>        <span class="token function">rioSetAutoSync</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>aof<span class="token punctuation">,</span>REDIS_AUTOSYNC_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Redis 4.0 的特性, AOF 和 RDB 混用</span>    <span class="token comment">// 先将当前的数据以 RDB 的格式存储下来, 添加的这段时间, 在缓冲区的再以 AOF 的方式存储</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_use_rdb_preamble<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> error<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveRio</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>error<span class="token punctuation">,</span>RDB_SAVE_AOF_PREAMBLE<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            errno <span class="token operator">=</span> error<span class="token punctuation">;</span>            <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 将当前 Redis 内存数据库中的数据写入到 AOF 文件中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rewriteAppendOnlyFileRio</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>aof<span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// 当前的内存数据库的数据都写入完成</span>    <span class="token comment">// 执行 fflush 函数, 更新缓存中的数据到文件中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fflush</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>      <span class="token comment">// 执行 fsync 函数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fsync</span><span class="token punctuation">(</span><span class="token function">fileno</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token keyword">int</span> nodata <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">mstime_t</span> start <span class="token operator">=</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 尽量 将内存数据写入到 AOF 临时文件过程中 产生的差异命令同步过来</span>    <span class="token comment">// 当前时间和重写的开始时间差在 1 秒内, 同时没有连续 20 次读取到空数据</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start <span class="token operator">&lt;</span> <span class="token number">1000</span> <span class="token operator">&amp;&amp;</span> nodata <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 尝试从通道 aof_pipe_read_data_from_parent 也就是重写缓冲区中读取数据, 每次阻塞 1 毫秒</span>        <span class="token comment">// 读取到的数据长度小于等于 0, 进入下一次循环, 为读取到数据次数 + 1</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeWait</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_pipe_read_data_from_parent<span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            nodata<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        nodata <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment">// 从重写缓冲区读数据到 aof_child_diff</span>        <span class="token function">aofReadDiffFromParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 写入一个 ！ 到 aof_pipe_write_ack_to_parent, 通过通道间接同步到父级的 aof_pipe_read_ack_from_child</span>    <span class="token comment">// 请求父进程停止发送差异数据, 也就是重写缓冲区</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">write</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_pipe_write_ack_to_parent<span class="token punctuation">,</span><span class="token string">"!"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token comment">// 将从父级读取 ack 的 aof_pipe_read_ack_from_parent 设置为非阻塞的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">anetNonBlock</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>server<span class="token punctuation">.</span>aof_pipe_read_ack_from_parent<span class="token punctuation">)</span> <span class="token operator">!=</span> ANET_OK<span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token comment">// 在 5000ms 之内，从 aof_pipe_read_ack_from_parent 读取 1 个字节的数据保存在 byte 中, 同时判断 byte 是否为 '!'</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">syncRead</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_pipe_read_ack_from_parent<span class="token punctuation">,</span><span class="token operator">&amp;</span>byte<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5000</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span> <span class="token operator">||</span> byte <span class="token operator">!=</span> <span class="token char">'!'</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"Parent agreed to stop sending diffs. Finalizing AOF..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 此时父进程不会在同步差异命令过来了, 再做最后一次同步, 将 Pipe 通道中残留的数据同步过来</span>    <span class="token comment">// 再次从父级中读取差异数据</span>    <span class="token function">aofReadDiffFromParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span> <span class="token string">"Concatenating %.2f MB of AOF diff received from parent."</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_diff<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将 aof_child_diff 中的数据写入到 aof 文件中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>aof<span class="token punctuation">,</span>server<span class="token punctuation">.</span>aof_child_diff<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_diff<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fflush</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fsync</span><span class="token punctuation">(</span><span class="token function">fileno</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token comment">// 重命名文件名</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rename</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span>filename<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Error moving temp append only file on the final destination: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">unlink</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"SYNC append only file rewrite performed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>werr<span class="token operator">:</span>    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Write error writing append only file on disk: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unlink</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span></code></pre><p><strong>子进程将自身内存数据库中的数据写入到 AOF 临时文件的逻辑</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 将 Redis 数据库中的数据都写入到文件 * 原理就是变量数据库中的数据, 然后将每个 key 和 key 对应的 value 写入到文件中 * 同时为较小文件的大小, 会使用批量相关的命令来替代单个命令 * 比如向 list 类型的结构添加数据, 可以通过 lset 一个一个元素的添加, 也可以通过 RPUSH 一次添加多个 * 所以 Redis AOF 文件能缩小的原因就是这个 *  * 同时内部为了安全性, 单个批量命令内部的元素会控制不超过 AOF_REWRITE_ITEMS_PER_CMD 64 个 */</span><span class="token keyword">int</span> <span class="token function">rewriteAppendOnlyFileRio</span><span class="token punctuation">(</span>rio <span class="token operator">*</span>aof<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    dictIterator <span class="token operator">*</span>di <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> processed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token comment">// 逐个遍历所有的数据库</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> selectcmd<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"*2\r\n$6\r\nSELECT\r\n"</span><span class="token punctuation">;</span>        redisDb <span class="token operator">*</span>db <span class="token operator">=</span> server<span class="token punctuation">.</span>db<span class="token operator">+</span>j<span class="token punctuation">;</span>        dict <span class="token operator">*</span>d <span class="token operator">=</span> db<span class="token operator">-></span>dict<span class="token punctuation">;</span>        <span class="token comment">// 对应的数据库没有数据, 跳过</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dictSize</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token comment">// 字典迭代器</span>        di <span class="token operator">=</span> <span class="token function">dictGetSafeIterator</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 向文件中写入 *2\r\n$6\r\nSELECT\r\n数据库的编号的长度\r\n数据库的编号, 也就是 select 数据库</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWrite</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span>selectcmd<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>selectcmd<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkLongLong</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>de <span class="token operator">=</span> <span class="token function">dictNext</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                sds keystr<span class="token punctuation">;</span>            robj key<span class="token punctuation">,</span> <span class="token operator">*</span>o<span class="token punctuation">;</span>            <span class="token keyword">long</span> <span class="token keyword">long</span> expiretime<span class="token punctuation">;</span>            keystr <span class="token operator">=</span> <span class="token function">dictGetKey</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>            o <span class="token operator">=</span> <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 将字符串的 key 转为 redisObject 对象, 编码 encoding 默认为 OBJ_ENCODING_RAW, 引用次数 refcount 为 1</span>            <span class="token function">initStaticStringObject</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>keystr<span class="token punctuation">)</span><span class="token punctuation">;</span>                    expiretime <span class="token operator">=</span> <span class="token function">getExpire</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>type <span class="token operator">==</span> OBJ_STRING<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">char</span> cmd<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"*3\r\n$3\r\nSET\r\n"</span><span class="token punctuation">;</span>                <span class="token comment">// 写入上面的文本</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWrite</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span>cmd<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>                <span class="token comment">// 写入 key </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>                <span class="token comment">// 写入 value</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span>o<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>type <span class="token operator">==</span> OBJ_LIST<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rewriteListObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">,</span>o<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>type <span class="token operator">==</span> OBJ_SET<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 下面的几个写入和 list 类型跳过</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rewriteSetObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">,</span>o<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>type <span class="token operator">==</span> OBJ_ZSET<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rewriteSortedSetObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">,</span>o<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>type <span class="token operator">==</span> OBJ_HASH<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rewriteHashObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">,</span>o<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>type <span class="token operator">==</span> OBJ_STREAM<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rewriteStreamObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">,</span>o<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>type <span class="token operator">==</span> OBJ_MODULE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rewriteModuleObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">,</span>o<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">"Unknown object type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                        <span class="token comment">// 如果 key 设置了过期时间, 写入过期时间</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>expiretime <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">char</span> cmd<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"*3\r\n$9\r\nPEXPIREAT\r\n"</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWrite</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span>cmd<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkObject</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkLongLong</span><span class="token punctuation">(</span>aof<span class="token punctuation">,</span>expiretime<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// AOF_READ_DIFF_INTERVAL_BYTES = 1024*10</span>            <span class="token comment">// 重写文件每写入 10 M,  就通过通道从父级中读取差异</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>aof<span class="token operator">-></span>processed_bytes <span class="token operator">></span> processed <span class="token operator">+</span> AOF_READ_DIFF_INTERVAL_BYTES<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 更新已写的字节数</span>                processed <span class="token operator">=</span> aof<span class="token operator">-></span>processed_bytes<span class="token punctuation">;</span>                <span class="token comment">// 通过通道 aof_pipe_read_data_from_parent 将重写缓冲区中的数据读取到 aof_child_diff 中</span>                <span class="token function">aofReadDiffFromParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>werr<span class="token operator">:</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>di<span class="token punctuation">)</span>        <span class="token function">dictReleaseIterator</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// list 类型的数据写入</span><span class="token keyword">int</span> <span class="token function">rewriteListObject</span><span class="token punctuation">(</span>rio <span class="token operator">*</span>r<span class="token punctuation">,</span> robj <span class="token operator">*</span>key<span class="token punctuation">,</span> robj <span class="token operator">*</span>o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> items <span class="token operator">=</span> <span class="token function">listTypeLength</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>encoding <span class="token operator">==</span> OBJ_ENCODING_QUICKLIST<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            quicklist <span class="token operator">*</span>list <span class="token operator">=</span> o<span class="token operator">-></span>ptr<span class="token punctuation">;</span>        quicklistIter <span class="token operator">*</span>li <span class="token operator">=</span> <span class="token function">quicklistGetIterator</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> AL_START_HEAD<span class="token punctuation">)</span><span class="token punctuation">;</span>        quicklistEntry entry<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">quicklistNext</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span><span class="token operator">&amp;</span>entry<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token comment">// 获取当前  rpush 的元素个数, 最大为 AOF_REWRITE_ITEMS_PER_CMD 64 个</span>                <span class="token keyword">int</span> cmd_items <span class="token operator">=</span> <span class="token punctuation">(</span>items <span class="token operator">></span> AOF_REWRITE_ITEMS_PER_CMD<span class="token punctuation">)</span> <span class="token operator">?</span>  AOF_REWRITE_ITEMS_PER_CMD <span class="token operator">:</span> items<span class="token punctuation">;</span>                <span class="token comment">// 写入参数个数 *参数个数</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkCount</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span><span class="token char">'*'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">+</span>cmd_items<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">// 写入 rpush 命令</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkString</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span><span class="token string">"RPUSH"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">// 写入 key 值</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkObject</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 依次写入元素</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkString</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>entry<span class="token punctuation">.</span>value<span class="token punctuation">,</span>entry<span class="token punctuation">.</span>sz<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWriteBulkLongLong</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>entry<span class="token punctuation">.</span>longval<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 写入一次 count + 1 次, 当 count == 上限的 64 个, 重新值为 0</span>            <span class="token comment">// 从而可以重新写入一个 rpush</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>count <span class="token operator">==</span> AOF_REWRITE_ITEMS_PER_CMD<span class="token punctuation">)</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            items<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">quicklistReleaseIterator</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">"Unknown list encoding"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>整个 AOF 重写的因为涉及到了子进程, 所以复杂度就上去了, 整理如下:</p><p>父进程</p><blockquote><ol><li>定时器判断满足重写条件或者执行了 bgrewriteaof 命令, 触发 AOF 重写</li><li>父进程创建出 6 个文件描述符, 用来创建 6 个通道, 分别用于: 父进程将数据写给子进程, 子进程通知父进程 ack, 父进程通知子进程 ack</li><li>创建完通道后, 设置 aof_stop_sending_diff 为 0, 也就是 false, 表示可以将重写缓冲区的数据继续推送给子进程</li><li>父进程 fork 出一个子进程, 然后进行一些统计相同的配置后, 进行处理其他的命令 (此处是子进程的开始地方)</li><li>父进程处理到修改性质的命令时, 依旧是会进行把当前命令的变更写的已有的 AOF 文件中, 同时判断到当前在进行 AOF 重写, 会把当前命令对应的文本保存到 AOF 重写缓存区  aof_rewrite_buf_blocks</li><li>判断当前的 AE 循环中是否有 aof_pipe_write_data_to_child 这个文件描述符 (这个就是上面 6 个文件描述符之一) 对应的文件, 没有则创建 1 个文件, 执行的逻辑为 aofChildWriteDiffData</li><li>因为有事件存在, 每次 AE 循环时, 都会执行到 aofChildWriteDiffData 函数, 逻辑就是将 AOF 重写缓存区 aof_rewrite_buf_blocks 中的数据全部写到 aof_pipe_write_data_to_child 中, 同时在 aof_stop_sending_diff 为 true 或者 aof_rewrite_buf_blocks 中的数据转移完成时, 删除这个事件。写入到 aof_pipe_write_data_to_child 的数据在通道的作用下, 会自动同步到子进程的 aof_pipe_read_data_from_parent 中</li></ol></blockquote><p>上面就是父进程的逻辑, 下面的子进程的逻辑  </p><blockquote><ol><li>因为子进程是通过 fork 操作创建出来的, 所以子进程和父进程是完全一样的, 也就是当前子进程拥有着和父进程一样的字典, 存放着所有键值对的数据, 同时不受父进程的影响, 也就是快照</li><li>临时创建出一个 temp-rewriteaof-bg-进程ID.aof 文件, 用来保存当前的数据</li><li>判断 server.aof_use_rdb_preamble 是否为 true, 也就是是否开启了 RDB 和 AOF 混用的功能, 开启了, 就先将当前的数据字典的数据以 RDB 的方式进行保存, 否则就是根据数据字典执行命令重写</li><li>命令重写的逻辑: 用批量相关的命令来替代单个命令, 同时在执行的过程中不断的将 aof_pipe_read_data_from_parent 中的数据读取到自身的 aof_child_diff 中</li><li>数据字典中的数据都处理完成后, 子进程向 aof_pipe_write_ack_to_parent 写入一个 !, 在通道的同步下, 同步到父进程的 aof_pipe_read_ack_from_child 中 (父级收到了, 先将 aof_stop_sending_diff 设置为 true, 向 aof_pipe_write_ack_to_child 写入了一个 ！, 同样在管道的同步下, 最终到了子进程的 aof_pipe_read_ack_from_parent, 最后删除这个 aof_pipe_read_ack_from_child 描述符的事件)</li><li>向 aof_pipe_write_ack_to_parent 写入 ! 后, 等待 5000ms, 从 aof_pipe_read_ack_from_parent 中读取数据, 超时读取, 读取到的不是 !, 异常处理, 结束</li><li>从 aof_pipe_read_ack_from_parent 读取到了 ！, 表示读取到了父级的确认 ack, 最后一次从 aof_pipe_read_data_from_parent 读取数据到 aof_child_diff, 确保在文件描述符中没有父进程写向子进程的数据了</li><li>把 aof_child_diff 中的数据追加到临时的 AOF 文件中</li><li>通过 rename 函数将临时文件重命名为配置的入参的文件名 (AOF 重写入参的文件名为: temp-rewriteaof-bg-进程ID.aof,  rename 函数会先将同名的文件, 文件夹删除)</li></ol></blockquote><p>从上面的过程中看起来, 好像完美了, 但是别忘了这里涉及到了并发, 在父子进程互相 ack 确认时, 父进程收到 ack 时, 只是把 aof_stop_sending_diff 设置为 true, 也就是确保 AOF 重写缓存区的数据不会再写给子进程。<br>而子进程收到 ack, 只是把当前所有的 AOF 重写缓存区中的数据写入到文件中, 子进程自己的任务到此就结束了。  </p><p>而这个过程, 父进程还会继续处理其他的命令, 这些新的命令只能由父进程自己处理</p><blockquote><ol><li>将当前 AOF 重写缓存区中的数据写入到 AOF 临时文件</li><li>重命名 AOF 临时文件, 整个 AOF 重写正式完成</li></ol></blockquote><h4 id="3-3-3-父进程监听子进程结束-AOF-重写收尾"><a href="#3-3-3-父进程监听子进程结束-AOF-重写收尾" class="headerlink" title="3.3.3 父进程监听子进程结束, AOF 重写收尾"></a>3.3.3 父进程监听子进程结束, AOF 重写收尾</h4><p>首先入口, 还是在定时器 serveCron 中, 定时的检查子进程的状态是否为结束了, 是的话, 执行结束逻辑</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 省略</span>    <span class="token comment">// 检查是否有 RDB 子进程或者 AOF 重写子进程结束了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token function">ldbPendingChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> statloc<span class="token punctuation">;</span>        <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>                <span class="token comment">// wait3 可以获取所有的进程是否有一个进程退出状态的, 有的话, 进行彻底的销毁，同时返回其进程 id</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">wait3</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>statloc<span class="token punctuation">,</span>WNOHANG<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> exitcode <span class="token operator">=</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>statloc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> bysignal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFSIGNALED</span><span class="token punctuation">(</span>statloc<span class="token punctuation">)</span><span class="token punctuation">)</span>                 bysignal <span class="token operator">=</span> <span class="token function">WTERMSIG</span><span class="token punctuation">(</span>statloc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 异常情况, 打印日志</span>                <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"wait3() returned an error: %s. rdb_child_pid = %d, aof_child_pid = %d"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> server<span class="token punctuation">.</span>rdb_child_pid<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> server<span class="token punctuation">.</span>aof_child_pid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> server<span class="token punctuation">.</span>rdb_child_pid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// rdb 进程逻辑省略</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> server<span class="token punctuation">.</span>aof_child_pid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 进程 id 为 AOF 重写进程 id</span>                <span class="token comment">// 执行最终的清除逻辑</span>                <span class="token function">backgroundRewriteDoneHandler</span><span class="token punctuation">(</span>exitcode<span class="token punctuation">,</span>bysignal<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bysignal <span class="token operator">&amp;&amp;</span> exitcode <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                     <span class="token comment">// 获取子进程发送给父进程的信息</span>                    <span class="token function">receiveChildInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 其他的情况</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ldbRemoveChild</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Warning, detected child with unmatched pid: %ld"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>              <span class="token comment">// 重新设置字典的可以扩容标识为 true</span>            <span class="token function">updateDictResizePolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 关闭 Pipe </span>            <span class="token function">closeChildInfoPipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 判断是否需要进行 RDB 或者 AOF 重写</span>        <span class="token comment">// 省略</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span><span class="token comment">// 父进程对 AOF 重写最后的处理</span><span class="token keyword">void</span> <span class="token function">backgroundRewriteDoneHandler</span><span class="token punctuation">(</span><span class="token keyword">int</span> exitcode<span class="token punctuation">,</span> <span class="token keyword">int</span> bysignal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// exitcode == 0 表示子进程是执行完逻辑后, 主动退出的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bysignal <span class="token operator">&amp;&amp;</span> exitcode <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> newfd<span class="token punctuation">,</span> oldfd<span class="token punctuation">;</span>        <span class="token keyword">char</span> tmpfile<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">mstime_t</span> latency<span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span> <span class="token string">"Background AOF rewrite terminated with success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 再次通过子进程的进程 ID 获取到 AOF 重写的临时文件名 temp-rewriteaof-bg-进程ID.aof, 也就是 AOF 重写临时文件</span>        <span class="token function">snprintf</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">,</span><span class="token string">"temp-rewriteaof-bg-%d.aof"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span>aof_child_pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打开文件</span>        newfd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span>O_WRONLY<span class="token operator">|</span>O_APPEND<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newfd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Unable to open the temporary AOF produced by the child: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 把最后剩余的信息从 aof_rewrite_buf_blocks 写入到指定的文件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aofRewriteBufferWrite</span><span class="token punctuation">(</span>newfd<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Error trying to flush the parent diff to the rewritten AOF: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">close</span><span class="token punctuation">(</span>newfd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"aof-rewrite-diff-write"</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"Residual parent diff successfully flushed to the rewritten AOF (%.2f MB)"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token function">aofRewriteBufferSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// aof_fd 为当前的 AOF 文件的文件描述符, 等于 -1, 应该是 AOF 功能停用了</span>        <span class="token comment">// 这时为了下面的流程能走下去, 从配置文件中获取到配置的文件名, 尝试打开禁用前的文件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            oldfd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_filename<span class="token punctuation">,</span>O_RDONLY<span class="token operator">|</span>O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            oldfd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将临时文件重命名为配置的文件名</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rename</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span>server<span class="token punctuation">.</span>aof_filename<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Error trying to rename the temporary AOF file %s into %s: %s"</span><span class="token punctuation">,</span> tmpfile<span class="token punctuation">,</span> server<span class="token punctuation">.</span>aof_filename<span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">close</span><span class="token punctuation">(</span>newfd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldfd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">close</span><span class="token punctuation">(</span>oldfd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"aof-rename"</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">close</span><span class="token punctuation">(</span>newfd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            oldfd <span class="token operator">=</span> server<span class="token punctuation">.</span>aof_fd<span class="token punctuation">;</span>            server<span class="token punctuation">.</span>aof_fd <span class="token operator">=</span> newfd<span class="token punctuation">;</span>            <span class="token comment">// 根据同步策略进行 fsync</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_ALWAYS<span class="token punctuation">)</span>                <span class="token function">redis_fsync</span><span class="token punctuation">(</span>newfd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_EVERYSEC<span class="token punctuation">)</span>                <span class="token function">aof_background_fsync</span><span class="token punctuation">(</span>newfd<span class="token punctuation">)</span><span class="token punctuation">;</span>            server<span class="token punctuation">.</span>aof_selected_db <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>             <span class="token comment">// 更新当前 AOF 文件的大小</span>            <span class="token function">aofUpdateCurrentSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 更新最新的 AOF 文件大小和重写大小</span>            server<span class="token punctuation">.</span>aof_rewrite_base_size <span class="token operator">=</span> server<span class="token punctuation">.</span>aof_current_size<span class="token punctuation">;</span>            server<span class="token punctuation">.</span>aof_fsync_offset <span class="token operator">=</span> server<span class="token punctuation">.</span>aof_current_size<span class="token punctuation">;</span>               <span class="token function">sdsfree</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            server<span class="token punctuation">.</span>aof_buf <span class="token operator">=</span> <span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>        server<span class="token punctuation">.</span>aof_lastbgrewrite_status <span class="token operator">=</span> C_OK<span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span> <span class="token string">"Background AOF rewrite finished successfully"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_state <span class="token operator">==</span> AOF_WAIT_REWRITE<span class="token punctuation">)</span>            server<span class="token punctuation">.</span>aof_state <span class="token operator">=</span> AOF_ON<span class="token punctuation">;</span>        <span class="token comment">// 关闭打开的文件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldfd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token function">bioCreateBackgroundJob</span><span class="token punctuation">(</span>BIO_CLOSE_FILE<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>oldfd<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_VERBOSE<span class="token punctuation">,</span><span class="token string">"Background AOF rewrite signal handler took %lldus"</span><span class="token punctuation">,</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bysignal <span class="token operator">&amp;&amp;</span> exitcode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 非正常退出</span>        server<span class="token punctuation">.</span>aof_lastbgrewrite_status <span class="token operator">=</span> C_ERR<span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Background AOF rewrite terminated with error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 非正常退出</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bysignal <span class="token operator">!=</span> SIGUSR1<span class="token punctuation">)</span>            server<span class="token punctuation">.</span>aof_lastbgrewrite_status <span class="token operator">=</span> C_ERR<span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Background AOF rewrite terminated by signal %d"</span><span class="token punctuation">,</span> bysignal<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>cleanup<span class="token operator">:</span>    <span class="token comment">// 清除工作</span>    <span class="token function">aofClosePipes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">aofRewriteBufferReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">aofRemoveTempFile</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>aof_rewrite_time_last <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token operator">-</span>server<span class="token punctuation">.</span>aof_rewrite_time_start<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>aof_rewrite_time_start <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_state <span class="token operator">==</span> AOF_WAIT_REWRITE<span class="token punctuation">)</span>        server<span class="token punctuation">.</span>aof_rewrite_scheduled <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">// AOF 重写缓冲区数据写入文件</span><span class="token class-name">ssize_t</span> <span class="token function">aofRewriteBufferWrite</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>    listIter li<span class="token punctuation">;</span>    <span class="token class-name">ssize_t</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_rewrite_buf_blocks<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        aofrwblock <span class="token operator">*</span>block <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ssize_t</span> nwritten<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>block<span class="token operator">-></span>used<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>block<span class="token operator">-></span>buf<span class="token punctuation">,</span>block<span class="token operator">-></span>used<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token class-name">ssize_t</span><span class="token punctuation">)</span>block<span class="token operator">-></span>used<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> errno <span class="token operator">=</span> EIO<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            count <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>到了这一步, 整个 AOF 的重写过程才真正的结束了。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><a href="https://blog.csdn.net/men_wen/article/details/71375513">Redis源码剖析和注释（十八）— Redis AOF持久化机制</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在上篇, 我们已经从使用 &amp;#x2F; 机制 &amp;#x2F; AOF 过程中涉及的辅助功能等方面简单了解了 Redis AOF。&lt;br&gt;这篇将从源码的形式, 进行深入的了解。&lt;/p&gt;
&lt;h2 id=&quot;1-Redis-整个-AOF-主要功能&quot;&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="Redis" scheme="https://github.com/Lcn29/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis AOF 基础</title>
    <link href="https://github.com/Lcn29/article/2021/3668008816/"/>
    <id>https://github.com/Lcn29/article/2021/3668008816/</id>
    <published>2021-12-19T06:59:59.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<p>因为 Redis AOF 的实现有些绕, 就分成 2 篇进行分析, 本篇主要是介绍一下 AOF 的一些特性和依赖的其他函数的逻辑,为下一篇 (Redis AOF 源码) 源码分析做一些铺垫。</p><p>AOF 全称: Append Only File, 是 Redis 提供了一种数据保存模式, Redis 默认不开启。<br>AOF 采用日志的形式来记录每个写操作, 并追加到文件。开启后, 执行更改 Redis 数据的命令时, 就会把命令写入到 AOF 文件中。<br>Redis 重启时会根据日志文件的内容把写指令从前到后执行一次以完成数据的恢复工作。</p><h2 id="1-AOF-相关的配置"><a href="#1-AOF-相关的配置" class="headerlink" title="1 AOF 相关的配置"></a>1 AOF 相关的配置</h2><pre class="language-bash" data-language="bash"><code class="language-bash">appendonly no                   <span class="token comment"># AOF 开关, 默认为关闭</span>appendfilename <span class="token string">"appendonly.aof"</span> <span class="token comment"># 保存的文件名</span>appendfsync everysec            <span class="token comment"># AOF 持久化策略 (硬盘缓存写入到硬盘) </span></code></pre><p>AOF 简单使用的话就这 3 个配置, 前 2 个就是字面的意思, 理解其他比较简单。<br>我们说明一下第三个配置的使用。</p><p>开启 AOF 后, 每次修改的命令都会存到 Redis 的一个<strong>缓存区</strong>。<br>缓存区的数据最终是需要写入到磁盘的, 而 Redis 是通过 <strong>write</strong> 函数, 将缓存中的数据写入到磁盘中。<br>但是 <strong>write</strong> 函数实际是先将数据先保存到<strong>系统层级的缓存</strong>, 后续由系统自身将数据保存到磁盘, 系统默认为 30 秒保存一次。这样的话, 可能有风险, 如果系统直接宕机了<br>可能会丢失 30 秒左右的数据, 所以系统提供了一个 <strong>fsync</strong> 函数, 可以把系统层级的缓存立即写入到磁盘中, 但是这是一个阻塞且缓慢的操作, 会影响到执行的线程。</p><p>所以上面的配置的第 3 项就是控制这个 Redis 缓存到磁盘的行为</p><blockquote><ol><li>everysec: AOF 默认的持久化策略。每秒执行一次 fsync, 可能导致丢失 1s 数据, 这种策略兼顾了安全性和效率</li><li>no: 表示不执行 fsync, 由操作系统保证数据同步到磁盘, 速度最快, 但是不太安全</li><li>always: 表示每次写入到执行 fsync, 保证数据同步到磁盘, 效率很低</li></ol></blockquote><p>除了上面的 3 个基础配置, 还有几个关于 AOF 执行中的行为配置</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 默认为 100</span><span class="token comment"># 当目前 AOF 文件大小超过上次重写的 AOF 文件的百分之多少进行重写 (重写的含义可以看下面的重写机制), 即当 AOF 文件增长到一定大小的时候, Redis 能够调用 bgrewriteaof 对日志文件进行重写</span>auto-aof-rewrite-percentag  <span class="token number">100</span><span class="token comment"># 默认为 64m</span><span class="token comment"># 设置允许重写的最小 AOF 文件大小, 避免达到约定百分比但占用的容量仍然很小的情况就重写</span>auto-aof-rewrite-min-size  64mb<span class="token comment"># 默认为 no</span><span class="token comment"># 在 AOF 重写时, 是否不要执行 fsync, 将缓存写入到磁盘, 默认为 no。</span><span class="token comment"># 如果对低延迟要求很高的应用, 这里可以设置为 yes, 否则设置为 no, 这样对持久化特性来说这是更安全的选择</span><span class="token comment"># 设置为 yes 表示重写期间对新的写操作不 fsync, 暂时存在内存中, 等重新操作完成后再写入</span><span class="token comment"># 默认为 no, 建议改为 yes, 因为 Linux 的默认 fsync 策略为 30 秒, 所以可能丢失 30 秒数据</span>no-appendfsync-on-rewrite  no<span class="token comment"># 默认为 yes</span><span class="token comment"># 当 Redis 启动的时候, AOF 文件的数据会被重新载入内存</span><span class="token comment"># 但是 AOF 文件可能在尾部是不完整的, 比如突然的断电宕机什么的, 可能导致 AOF 文件数据不完整</span><span class="token comment"># 对于不完整的 AOF 文件如何处理</span><span class="token comment"># 配置为 yes, 当截断的 AOF 文件被导入的时候, 会自动发布一个 log 给客户端, 然后继续加载文件中的数据</span><span class="token comment"># 配置为 no, 用户必须手动 redis-check-aof 修复 AOF 文件才可以</span>aof-load-truncated <span class="token function">yes</span></code></pre><h2 id="2-AOF-重写机制"><a href="#2-AOF-重写机制" class="headerlink" title="2 AOF 重写机制"></a>2 AOF 重写机制</h2><p>上面的配置中有好几个提示到<strong>重写</strong>的概念, 那么什么是重写呢?  </p><p>由于 AOF 持久化是 Redis 不断将写命令记录到 AOF 文件中, 随着 Redis 不断的运行, AOF 文件将会越来越大, 占用服务器磁盘越来越大, 同时 AOF 恢复要求时间越长。  </p><p>为了解决这个问题, Redis 新增了重写机制, 当 AOF 文件的大小超过了所设定的阈值时, Redis 就会自动启动 AOF 文件的内容压缩, 只保留可以恢复数据的最小指令集。<br>AOF 文件不是对原文件进行整理, 而是直接读取服务器现有的键值对, 然后用一条命令去代替之前记录这个键值对的多条命令, 生成一个新的文件替换原来的 AOF 文件。  </p><p>用户可以通过 <strong>bgrewriteaof</strong> 命令来手动触发 AOF 文件的重写, 这个重写的过程也是通过子进程实现的。<br>在子进程进行 AOF 重写时, 主线程需要保证</p><blockquote><ol><li>处理客户端的请求</li><li>将新增和更新命令追加到现有的 AOF 文件中</li><li>将新增和更新命令追加到 AOF 重写缓存中</li></ol></blockquote><h2 id="3-AOF-文件的优势和劣势"><a href="#3-AOF-文件的优势和劣势" class="headerlink" title="3 AOF 文件的优势和劣势"></a>3 AOF 文件的优势和劣势</h2><p>优势  </p><blockquote><ol><li>AOF 持久化的方法提供了多种的同步频率, 即使使用默认的同步频率每秒同步一次, Redis 最多也就丢失 1 秒的数据而已</li><li>AOF 日志文件以 append-only 模式写入, 所以没有任何磁盘寻址的开销, 写入性能非常高, 而且文件不容易受损, 即使文件尾部受损, 也能很容易恢复, 打开文件, 把后面损坏的数据删除即可</li></ol></blockquote><p>劣势  </p><blockquote><ol><li>对于具有相同数据的的 Redis, AOF 文件通常会比 RDF 文件体积更大 (RDB 存的是数据快照) </li><li>虽然 AOF 提供了多种同步的频率, 默认情况下, 每秒同步一次的频率也具有较高的性能。但是在高并发的情况下, RDB 比 AOF 具好更好的性能保证</li></ol></blockquote><h2 id="4-AOF-和-RDB-两种方案比较"><a href="#4-AOF-和-RDB-两种方案比较" class="headerlink" title="4 AOF 和 RDB  两种方案比较"></a>4 AOF 和 RDB  两种方案比较</h2><p>如果可以忍受一小段时间内数据的丢失, 使用 RDB 是最好的, 定时生成 RDB 快照 (snapshot) 非常便于进行数据库备份, 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快, 否则使用 AOF。  </p><p>但是一般情况下建议不要单独使用某一种持久化机制, 而是应该两种一起用, 在这种情况下, 当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据, 因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</p><p>在 Redis 4.0 带来了一个新的持久化选项 —— 混合持久化。将 RDB 文件的内容和增量的 AOF 日志文件存在一起。<br>这里的 AOF 日志不再是全量的日志, 而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志, 通常这部分 AOF 日志很小。</p><p>在 Redis 重启的时候, 可以先加载 RDB 的内容, 然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放, 重启效率因此大幅得到提升。</p><h2 id="5-AOF-的过程"><a href="#5-AOF-的过程" class="headerlink" title="5 AOF 的过程"></a>5 AOF 的过程</h2><p>高度概括如下: </p><blockquote><ol><li>所有的修改命令会追加到 Redis 的一个 AOF 缓存区</li><li>AOF 缓存区根据配置的策略向硬盘做同步操作</li><li>随着 AOF 文件越来越大, 达到配置的条件, 对 AOF 文件进行重写, 达到压缩的目的</li></ol></blockquote><p>到此, AOF 的理论知识就没了, 下面是介绍几个比较重要的函数的逻辑。</p><h2 id="6-AOF-文件结构"><a href="#6-AOF-文件结构" class="headerlink" title="6 AOF 文件结构"></a>6 AOF 文件结构</h2><p>如果现在向 Redis 中写入一个 key 为 redis-key, value 为 redis-value 的字符串键值对后, 这对键值对会以下面的格式保存在 AOF 文件中:</p><pre class="language-none"><code class="language-none">*3\r\n$3\r\nset\r\n$9\r\nredis-key\r\n$11\r\nredis-value\r\n</code></pre><p>以 <code>*数字</code> 的格式开始, 表示后面的命令的参数个数, 然后通过 <code>$数字</code> 表示后面参数的长度, 然后各个分隔之间通过 <code>\r\n</code> 进行分隔。 </p><p>整体的格式就是 Redis 自定义的 RESP 协议, 具体的 RESP 介绍, 可以看一下这篇<a href="https://blog.csdn.net/ldw201510803006/article/details/126093440">文章</a>。</p><p>可以看到这种文本格式具有很高的可读性, 同时可以直接进行修改。</p><p>注: Redis 中有多个数据库, 写入的数据是保存在哪个数据库的?<br>在写入对应的数据库数据时, 内部会自动插入一条 <strong>select 数据库的编号</strong> 的命令到 AOF 文件, 表明对应的数据库, 解析时也是通过这条命令切换到对应的数据库。</p><p>源码中将 key 和 value 转换为上面的文件格式的实现是由 2 个函数实现的: catAppendOnlyGenericCommand 和 catAppendOnlyExpireAtCommand, 前者处理的是正常的命令, 而后者处理的是命令的过期时间。</p><h3 id="6-1-catAppendOnlyGenericCommand-没有过期时间的命令"><a href="#6-1-catAppendOnlyGenericCommand-没有过期时间的命令" class="headerlink" title="6.1 catAppendOnlyGenericCommand - 没有过期时间的命令"></a>6.1 catAppendOnlyGenericCommand - 没有过期时间的命令</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 将入参的参数转为 RESP 格式写入到入参的 dst * @param dst 当前未写入到文件的命令文本, 新的命令会追加到这个的后面 * @param argc 命令参数的个数 * @param argv 命令参数, 比如 set key value */</span>sds <span class="token function">catAppendOnlyGenericCommand</span><span class="token punctuation">(</span>sds dst<span class="token punctuation">,</span> <span class="token keyword">int</span> argc<span class="token punctuation">,</span> robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    robj <span class="token operator">*</span>o<span class="token punctuation">;</span>    <span class="token comment">// 上面的 set redis-key redis-value, 按照 RESP 协议转换的内容如下</span>    <span class="token comment">// *3\r\n$3\r\nset\r\n$9\r\nredis-key\r\n$11\r\nredis-value\r\n</span>    <span class="token comment">// 这里面可以拆为 2 部分处理 </span>    <span class="token comment">// 1. *3\r\n  --> 命令的参数个数</span>    <span class="token comment">// 2. $3\r\nset\r\n$9\r\nredis-key\r\n$11\r\nredis-value\r\n  --> 具体的命令</span>    <span class="token comment">// 1. 处理命令的参数个数部分</span>        <span class="token comment">// 命令开始的前缀为 *</span>    buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'*'</span><span class="token punctuation">;</span>    <span class="token comment">// argc 表示的是写入命令的个数, 经过这一步 buf = *参数个数</span>    len <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">+</span><span class="token function">ll2string</span><span class="token punctuation">(</span>buf<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>argc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 追加 \r\n, 到了这一步 经过这一步 buf = *参数个数\r\n</span>    buf<span class="token punctuation">[</span>len<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\r'</span><span class="token punctuation">;</span>    buf<span class="token punctuation">[</span>len<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>    <span class="token comment">// 先将处理的文本第一步拼接到 dst 的后面, 此时 dst = *参数个数\r\n</span>    dst <span class="token operator">=</span> <span class="token function">sdscatlen</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 处理具体的命令</span>    <span class="token comment">// 拼接参数列表</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 将对应的参数转为字符串类型</span>        o <span class="token operator">=</span> <span class="token function">getDecodedObject</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'$'</span><span class="token punctuation">;</span>        <span class="token comment">// 将命令的长度写入到 buf 中</span>        len <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">+</span><span class="token function">ll2string</span><span class="token punctuation">(</span>buf<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>o<span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 继续在后面拼接 \r\n, 到这一步 buf = $命令的长度\r\n</span>        buf<span class="token punctuation">[</span>len<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\r'</span><span class="token punctuation">;</span>        buf<span class="token punctuation">[</span>len<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>        <span class="token comment">// 同样将 $命令的长度\r\n 写入到 dst</span>        dst <span class="token operator">=</span> <span class="token function">sdscatlen</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将当前的命令具体的内容 写入到 dst</span>        dst <span class="token operator">=</span> <span class="token function">sdscatlen</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span>o<span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>o<span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 在 dist 后面追加一个 \r\n</span>        dst <span class="token operator">=</span> <span class="token function">sdscatlen</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span><span class="token string">"\r\n"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 经过一次循环, dist 里面多了一段 $命令的长度\r\n命令\r\n 的内容</span>        <span class="token comment">// 引用此数 - 1</span>        <span class="token function">decrRefCount</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dst<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 如果入参的对象是 raw 或者 embstr 编码, 引用次数 + 1 * 如果为 int 编码, 根据这个整数创建出一个字符串, 同时返回这个字符串 * 其他类型不会处理 */</span>robj <span class="token operator">*</span><span class="token function">getDecodedObject</span><span class="token punctuation">(</span>robj <span class="token operator">*</span>o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    robj <span class="token operator">*</span>dec<span class="token punctuation">;</span>    <span class="token comment">// 判断一个对象的编码是否为 OBJ_ENCODING_EMBSTR 或者 OBJ_ENCODING_RAW</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sdsEncodedObject</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 对象的引用次数还没达到最大值时, 进行引用次数 + 1</span>        <span class="token function">incrRefCount</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> o<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 是字符串类型同时编码为 OBJ_ENCODING_INT</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token operator">-></span>type <span class="token operator">==</span> OBJ_STRING <span class="token operator">&amp;&amp;</span> o<span class="token operator">-></span>encoding <span class="token operator">==</span> OBJ_ENCODING_INT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 整形转为 char 数组</span>        <span class="token function">ll2string</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>o<span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 转为字符串</span>        dec <span class="token operator">=</span> <span class="token function">createStringObject</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dec<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">"Unknown encoding type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-7-2-catAppendOnlyExpireAtCommand-带过期时间的命令"><a href="#2-7-2-catAppendOnlyExpireAtCommand-带过期时间的命令" class="headerlink" title="2.7.2 catAppendOnlyExpireAtCommand - 带过期时间的命令"></a>2.7.2 catAppendOnlyExpireAtCommand - 带过期时间的命令</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 将入参的过期时间转为 RESP 格式的字符串并存入 buf * @param buf 当前未写入到文件的命令文本, 新的命令会追加到这个的后面, 同时将命令修改为 pexpireat 的格式 * @param cmd 执行的命令 * @param key redis 的 key 值 * @param second 过期的时间, 单位秒 */</span>sds <span class="token function">catAppendOnlyExpireAtCommand</span><span class="token punctuation">(</span>sds buf<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">,</span> robj <span class="token operator">*</span>key<span class="token punctuation">,</span> robj <span class="token operator">*</span>seconds<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> when<span class="token punctuation">;</span>    robj <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 转为字符串类型, 以便使用 strtoll 函数</span>    seconds <span class="token operator">=</span> <span class="token function">getDecodedObject</span><span class="token punctuation">(</span>seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 根据指定的进制将入参的 char 数组转为一个整数, 10 --> 10 进制</span>    <span class="token comment">// 得到过期的时间</span>    when <span class="token operator">=</span> <span class="token function">strtoll</span><span class="token punctuation">(</span>seconds<span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 当前执行的命令为 expire, setex expireat 将参数的秒转换成毫秒</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd<span class="token operator">-></span>proc <span class="token operator">==</span> expireCommand <span class="token operator">||</span> cmd<span class="token operator">-></span>proc <span class="token operator">==</span> setexCommand <span class="token operator">||</span> cmd<span class="token operator">-></span>proc <span class="token operator">==</span> expireatCommand<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        when <span class="token operator">*=</span> <span class="token number">1000</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将 expire, setex expireat 命令的参数，从相对时间设置为绝对时间</span>    <span class="token comment">// 以前可能是 10s 后过期, 经过这一步，得到的是 xxx 年 yyy 月 的具体时间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd<span class="token operator">-></span>proc <span class="token operator">==</span> expireCommand <span class="token operator">||</span> cmd<span class="token operator">-></span>proc <span class="token operator">==</span> pexpireCommand <span class="token operator">||</span> cmd<span class="token operator">-></span>proc <span class="token operator">==</span> setexCommand <span class="token operator">||</span> cmd<span class="token operator">-></span>proc <span class="token operator">==</span> psetexCommand<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        when <span class="token operator">+=</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 减少 second 的引用次数, 便于回收</span>    <span class="token function">decrRefCount</span><span class="token punctuation">(</span>seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 拼接为 pexpireat key 超时时间 的命令格式</span>    argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">createStringObject</span><span class="token punctuation">(</span><span class="token string">"PEXPIREAT"</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>    argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">createStringObjectFromLongLong</span><span class="token punctuation">(</span>when<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将上面的 pexpireat key 过期时间 的命令通过 catAppendOnlyGenericCommand 转为 RESP 格式的字符串</span>    buf <span class="token operator">=</span> <span class="token function">catAppendOnlyGenericCommand</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">decrRefCount</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">decrRefCount</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回buf</span>    <span class="token keyword">return</span> buf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="7-代码中涉及的几个模块"><a href="#7-代码中涉及的几个模块" class="headerlink" title="7 代码中涉及的几个模块"></a>7 代码中涉及的几个模块</h2><p>在 Redis 的 AOF 中涉及了几个模块功能, 这些功能辅助着整个 AOF 的功能, 这里对这些功能进行一个简单的讲解, 需要说明的时, 这些功能具体的实现可以不用去深入理解, 到了 AOF 源码时, 知道对应的函数的功能就行了。</p><p>这里也只是简单的介绍一下, 感兴趣了解一下大体的思路而已, 可以在后面 AOF 源码分析后, 再回来看一下。</p><h3 id="7-1-延迟统计"><a href="#7-1-延迟统计" class="headerlink" title="7.1 延迟统计"></a>7.1 延迟统计</h3><p>Redis 中会对一些比较耗时的操作做一下统计, 便于后面的性能分析。<br>而在 AOF 中在调用 write 函数等操作也会进行延迟操作的统计。<br>大体的延迟统计实现如下:</p><p><strong>统计延迟信息的配置</strong></p><pre class="language-C" data-language="C"><code class="language-C">#define CONFIG_DEFAULT_LATENCY_MONITOR_THRESHOLD 0struct redisServer &#123;    &#x2F;&#x2F; 延迟监视的阈值, 默认值为 0, 如果配置为大于 0 的值, 表示开启延迟监控, 同时超过了这个时间就进行延迟记录    long long latency_monitor_threshold;    &#x2F;&#x2F; 字典, 也就是延迟记录的保存地方, 保存的格式是 延迟记录的事件名 和 latencyTimeSeries (一个数组)    dict *latency_events;&#125;</code></pre><p><strong>统计延迟样本对象的定义</strong></p><pre class="language-C" data-language="C"><code class="language-C">struct latencyTimeSeries &#123;    &#x2F;&#x2F; 用于记录的下一个延迟样本的位置, 超过了数组的长度, 会重新被赋值为 0     int idx;    &#x2F;&#x2F; 最大的延时    uint32_t max;    &#x2F;&#x2F; 最近的延时记录样本数组    struct latencySample samples[LATENCY_TS_LEN];&#125;struct latencySample &#123;    &#x2F;&#x2F; 延时样本创建的时间    int32_t time;     &#x2F;&#x2F; 延迟样本的延迟时间, 单位毫秒    uint32_t latency;&#125;</code></pre><p><strong>统计延迟样本的函数定义</strong></p><pre class="language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 下面的函数做了小改动, 逻辑一样的&#x2F;&#x2F; 获取延迟事件的时间void latencyStartMonitor(var) &#123;     &#x2F;&#x2F; mstime() 获取到当前的时间    var &#x3D; server.latency_monitor_threshold ? mstime() : 0;&#125;void latencyEndMonitor(var) &#123;    if (server.latency_monitor_threshold) &#123;        var &#x3D; mstime() - var;    &#125;&#125;&#x2F;** * 判断是否需要记录延迟时间  * @param event 事件名 * @param var 延迟事件的耗时时间 *&#x2F;void latencyAddSampleIfNeeded(event,var) &#123;    if (server.latency_monitor_threshold &amp;&amp;  (var) &gt;&#x3D; server.latency_monitor_threshold)        latencyAddSample((event),(var));&#125;&#x2F;** * 添加延迟事件到 redisServer 的 latency_events 字典 *&#x2F; void latencyAddSample(char *event, mstime_t latency) &#123;    &#x2F;&#x2F; 找出 event 对应的延时事件记录结构体    struct latencyTimeSeries *ts &#x3D; dictFetchValue(server.latency_events,event);    time_t now &#x3D; time(NULL);    int prev;    &#x2F;&#x2F; 没有对应事件的 latencyTimeSeries, 添加一个    if (ts &#x3D;&#x3D; NULL) &#123;        ts &#x3D; zmalloc(sizeof(*ts));        ts-&gt;idx &#x3D; 0;        ts-&gt;max &#x3D; 0;        memset(ts-&gt;samples,0,sizeof(ts-&gt;samples));        dictAdd(server.latency_events,zstrdup(event),ts);    &#125;    &#x2F;&#x2F; 获取存储的位置    prev &#x3D; (ts-&gt;idx + LATENCY_TS_LEN - 1) % LATENCY_TS_LEN;    &#x2F;&#x2F; 数组对应位置的样本的创建时间等于当前时间    if (ts-&gt;samples[prev].time &#x3D;&#x3D; now) &#123;        &#x2F;&#x2F; 当前的延迟时间大于样本里面的延迟时间, 更新为当前时间        if (latency &gt; ts-&gt;samples[prev].latency)            ts-&gt;samples[prev].latency &#x3D; latency;        return;    &#125;    &#x2F;&#x2F; 修改对应位置的样本的时间信息    ts-&gt;samples[ts-&gt;idx].time &#x3D; time(NULL);    ts-&gt;samples[ts-&gt;idx].latency &#x3D; latency;    &#x2F;&#x2F; 如果大于当前所有样本的时间, 更新最大延迟时间为当前的延迟时间    if (latency &gt; ts-&gt;max)         ts-&gt;max &#x3D; latency;    ts-&gt;idx++;    &#x2F;&#x2F; 超过了上限, 重新设置为 0     if (ts-&gt;idx &#x3D;&#x3D; LATENCY_TS_LEN)         ts-&gt;idx &#x3D; 0;    &#125;</code></pre><p>上面就是延迟事件的创建和保存, 至于在哪里使用的, 如何汇总分析, AOF 这里没有涉及, 就跳过了, 如果需要继续研究可以查看 <strong>latency.h</strong> 和 <strong>latency.c</strong> 这 2 个文件。</p><h3 id="7-2-BIO-后台线程"><a href="#7-2-BIO-后台线程" class="headerlink" title="7.2 BIO - 后台线程"></a>7.2 BIO - 后台线程</h3><p>在上面的介绍中可以知道 fsync 是一个很耗时的过程, 如果把这个过程同样放在 Redis 的主线程中, 那么可能影响到整个 Redis 的性能, 所以 Redis 将 fsync 的过程交给了后台的线程处理。<br>Reids 将后台相关耗时的操作封装为了一个 BIO 的功能, 可以看出是一个线程池, 线程池在启动时初始了几个线程, 然后生产者向这个池中添加任务。<br>而 Redis 主线程在执行到 fsync 时, 会提交一个 fsync 的任务到 BIO 中, 完成结束。真正的 fsync 由后台线程处理。</p><p>大体的实现如下:</p><p><strong>任务类型定义</strong></p><pre class="language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 执行 close 函数, 也就是文件的关闭#define BIO_CLOSE_FILE    0 &#x2F;&#x2F; 执行 redis_fsync 函数, 也就是 fsync 函数#define BIO_AOF_FSYNC     1&#x2F;&#x2F; 延迟对象释放#define BIO_LAZY_FREE     2 &#x2F;&#x2F; 任务类型的总数#define BIO_NUM_OPS       3</code></pre><p><strong>BIO 的初始化</strong></p><pre class="language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 存放声明的线程数组static pthread_t bio_threads[BIO_NUM_OPS];&#x2F;&#x2F; 线程锁, 这里是多线程场景了, 所以有并发问题static pthread_mutex_t bio_mutex[BIO_NUM_OPS];&#x2F;&#x2F; 添加任务相关的 condition, 简单的理解就是, 线程会被阻塞在这个 condition, 另一个线程可以唤醒这个 condition 上的线程static pthread_cond_t bio_newjob_cond[BIO_NUM_OPS];&#x2F;&#x2F; 执行过程相关的 conditionstatic pthread_cond_t bio_step_cond[BIO_NUM_OPS];&#x2F;&#x2F; 任务列表static list *bio_jobs[BIO_NUM_OPS];&#x2F;&#x2F; 存放对应的任务类型还有多少个任务等待执行static unsigned long long bio_pending[BIO_NUM_OPS];void bioInit(void) &#123;    pthread_attr_t attr;    pthread_t thread;    size_t stacksize;    int j;    &#x2F;&#x2F; 初始锁, condition, 任务列表    for (j &#x3D; 0; j &lt; BIO_NUM_OPS; j++) &#123;        pthread_mutex_init(&amp;bio_mutex[j],NULL);        pthread_cond_init(&amp;bio_newjob_cond[j],NULL);        pthread_cond_init(&amp;bio_step_cond[j],NULL);        bio_jobs[j] &#x3D; listCreate();        bio_pending[j] &#x3D; 0;    &#125;    &#x2F;&#x2F;设置线程栈空间    pthread_attr_init(&amp;attr);    pthread_attr_getstacksize(&amp;attr,&amp;stacksize);     if (!stacksize)         stacksize &#x3D; 1;     while (stacksize &lt; REDIS_THREAD_STACK_SIZE)         stacksize *&#x3D; 2;    pthread_attr_setstacksize(&amp;attr, stacksize);    &#x2F;&#x2F; 创建线程, 并存放到 bio_threads 这个线程数组    for (j &#x3D; 0; j &lt; BIO_NUM_OPS; j++) &#123;        void *arg &#x3D; (void*)(unsigned long) j;        &#x2F;&#x2F; 创建线程, 线程执行的逻辑为 bioProcessBackgroundJobs        if (pthread_create(&amp;thread,&amp;attr,bioProcessBackgroundJobs,arg) !&#x3D; 0) &#123;            serverLog(LL_WARNING,&quot;Fatal: Can&#39;t initialize Background Jobs.&quot;);            exit(1);        &#125;        bio_threads[j] &#x3D; thread;    &#125;&#125;</code></pre><p><strong>线程执行的逻辑</strong></p><pre class="language-C" data-language="C"><code class="language-C">void *bioProcessBackgroundJobs(void *arg) &#123;    struct bio_job *job;    unsigned long type &#x3D; (unsigned long) arg;    sigset_t sigset;    &#x2F;&#x2F; 任务类型校验    if (type &gt;&#x3D; BIO_NUM_OPS) &#123;        serverLog(LL_WARNING, &quot;Warning: bio thread started with wrong type %lu&quot;,type);        return NULL;    &#125;    &#x2F;&#x2F; 配置 thread 能够在任何时候被杀掉    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);    &#x2F;&#x2F; 获取锁    pthread_mutex_lock(&amp;bio_mutex[type]);    sigemptyset(&amp;sigset);    sigaddset(&amp;sigset, SIGALRM);    if (pthread_sigmask(SIG_BLOCK, &amp;sigset, NULL))        serverLog(LL_WARNING, &quot;Warning: can&#39;t mask SIGALRM in bio.c thread: %s&quot;, strerror(errno));    &#x2F;&#x2F; 线程主逻辑    while(1) &#123;        listNode *ln;         &#x2F;&#x2F; 没有任务, 进行等待,         if (listLength(bio_jobs[type]) &#x3D;&#x3D; 0) &#123;            pthread_cond_wait(&amp;bio_newjob_cond[type],&amp;bio_mutex[type]);            continue;        &#125;          &#x2F;&#x2F; 获取列表的第一个任务        ln &#x3D; listFirst(bio_jobs[type]);        job &#x3D; ln-&gt;value;         &#x2F;&#x2F; 释放锁, 这个锁的功能主要是为了确保任务的获取        pthread_mutex_unlock(&amp;bio_mutex[type]);        if (type &#x3D;&#x3D; BIO_CLOSE_FILE) &#123;            close((long)job-&gt;arg1);        &#125; else if (type &#x3D;&#x3D; BIO_AOF_FSYNC) &#123;            redis_fsync((long)job-&gt;arg1);        &#125; else if (type &#x3D;&#x3D; BIO_LAZY_FREE) &#123;            if (job-&gt;arg1)                lazyfreeFreeObjectFromBioThread(job-&gt;arg1);            else if (job-&gt;arg2 &amp;&amp; job-&gt;arg3)                lazyfreeFreeDatabaseFromBioThread(job-&gt;arg2,job-&gt;arg3);            else if (job-&gt;arg3)                lazyfreeFreeSlotsMapFromBioThread(job-&gt;arg3);        &#125; else &#123;            serverPanic(&quot;Wrong job type in bioProcessBackgroundJobs().&quot;);        &#125;        zfree(job);        &#x2F;&#x2F; 获取锁        pthread_mutex_lock(&amp;bio_mutex[type]);        &#x2F;&#x2F; 删除任务        listDelNode(bio_jobs[type],ln);        &#x2F;&#x2F; 需要执行的任务减 1        bio_pending[type]--;        &#x2F;&#x2F; 唤醒所有等待在 bio_step_cond 上的线程        pthread_cond_broadcast(&amp;bio_step_cond[type]);    &#125;      &#125;</code></pre><p><strong>添加任务</strong></p><pre class="language-C" data-language="C"><code class="language-C">void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3) &#123;    struct bio_job *job &#x3D; zmalloc(sizeof(*job));    job-&gt;time &#x3D; time(NULL);    job-&gt;arg1 &#x3D; arg1;    job-&gt;arg2 &#x3D; arg2;    job-&gt;arg3 &#x3D; arg3;        &#x2F;&#x2F; 获取锁    pthread_mutex_lock(&amp;bio_mutex[type]);    &#x2F;&#x2F; 添加任务    listAddNodeTail(bio_jobs[type],job);    bio_pending[type]++;    &#x2F;&#x2F; 通知等待在 bio_newjob_cond 的线程    pthread_cond_signal(&amp;bio_newjob_cond[type]);    &#x2F;&#x2F; 释放锁    pthread_mutex_unlock(&amp;bio_mutex[type]);&#125;</code></pre><h3 id="7-3-pipe-父子进程通信"><a href="#7-3-pipe-父子进程通信" class="headerlink" title="7.3 pipe - 父子进程通信"></a>7.3 pipe - 父子进程通信</h3><p>Redis 的 AOF 重写机制和 RDB 类型, 也是通过 fork 创建子进程, 将整个 AOF 重写过程交给子进程处理。<br>不同的时: AOF 重写过程中会不断和父进程通信获取父进程的命令缓存。 父子进程之间就是通过 pipe 进行通讯的。</p><p>这里只做一下简单的了解。</p><pre class="language-C" data-language="C"><code class="language-C">#include &lt;unistd.h&gt;int Pipe(int pipefd[2]);</code></pre><p>通过 pipe 的函数可以在 2 个文件描述符之间建立一个通道, 第一个用来读 <strong>read(fd[0])</strong>, 第二个用来写 **write(fd[1])**。</p><p>具体的分析可以看一下这篇文章 <a href="https://blog.csdn.net/men_wen/article/details/59131762">APUE读书笔记—进程间通信(IPC)之管道和有名管道（FIFO）</a></p><p>而 Redis 中建立了 3 套通道</p><pre class="language-C" data-language="C"><code class="language-C">int aofCreatePipes(void) &#123;    int fds[6] &#x3D; &#123;-1, -1, -1, -1, -1, -1&#125;;    int j;    &#x2F;&#x2F;  parent -&gt; children data    if (pipe(fds) &#x3D;&#x3D; -1) goto error;    &#x2F;&#x2F; children -&gt; parent ack    if (pipe(fds+2) &#x3D;&#x3D; -1) goto error;     &#x2F;&#x2F; parent -&gt; children ack    if (pipe(fds+4) &#x3D;&#x3D; -1) goto error;     &#x2F;&#x2F; 同步非阻塞    if (anetNonBlock(NULL,fds[0]) !&#x3D; ANET_OK) goto error;    if (anetNonBlock(NULL,fds[1]) !&#x3D; ANET_OK) goto error;    &#x2F;&#x2F; 注册一个事件, 执行的函数为 aofChildPipeReadable, 里面的逻辑就是读取 aof_pipe_read_ack_from_child 的数据到 aof_pipe_write_ack_to_child    if (aeCreateFileEvent(server.el, fds[2], AE_READABLE, aofChildPipeReadable, NULL) &#x3D;&#x3D; AE_ERR) goto error;    &#x2F;&#x2F; 6 个通道    server.aof_pipe_write_data_to_child &#x3D; fds[1];    server.aof_pipe_read_data_from_parent &#x3D; fds[0];    server.aof_pipe_write_ack_to_parent &#x3D; fds[3];    server.aof_pipe_read_ack_from_child &#x3D; fds[2];    server.aof_pipe_write_ack_to_child &#x3D; fds[5];    server.aof_pipe_read_ack_from_parent &#x3D; fds[4];    server.aof_stop_sending_diff &#x3D; 0;    return C_OK;&#125;</code></pre><p>最终形成的效果如下：<br><img src="https://pic.imgdb.cn/item/657ead7bc458853aefbc4aea.png" alt="Alt &#39;AOF 创建的通道&#39;"></p><p>父进程写入到 aof_pipe_read_data_from_parent 的数据会自动同步到子进程的 aof_pipe_read_data_from_parent, 另外 2 个类似。</p><p>至此, AOF 的一些概念和源码中相关的一些代码就介绍完了, 下篇开始真正的 AOF 源码分析。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;因为 Redis AOF 的实现有些绕, 就分成 2 篇进行分析, 本篇主要是介绍一下 AOF 的一些特性和依赖的其他函数的逻辑,为下一篇 (Redis AOF 源码) 源码分析做一些铺垫。&lt;/p&gt;
&lt;p&gt;AOF 全称: Append Only File, 是 Redis</summary>
        
      
    
    
    
    
    <category term="Redis" scheme="https://github.com/Lcn29/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis RDB</title>
    <link href="https://github.com/Lcn29/article/2021/2629732721/"/>
    <id>https://github.com/Lcn29/article/2021/2629732721/</id>
    <published>2021-12-01T10:38:38.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<p>基于内存的 Redis, 数据都是存储在内存中的。 那么如果重启的话, 数据就会丢失。 为了解决这个问题, Redis 提供了 2 种数据持久化的方案: RDB 和 AOF。<br>RDB 是 Redis 默认的持久化方案。当满足一定条件的时候, 会把当前内存中的数据写入磁盘, 生成一个快照文件 <strong>dump.rdb</strong>。Redis 重启会通过加载 dump.rdb 文件恢复数据。</p><h2 id="1-触发-RDB-的方式"><a href="#1-触发-RDB-的方式" class="headerlink" title="1  触发 RDB 的方式"></a>1  触发 RDB 的方式</h2><h3 id="1-1-RDB-文件相关的配置"><a href="#1-1-RDB-文件相关的配置" class="headerlink" title="1.1 RDB 文件相关的配置"></a>1.1 RDB 文件相关的配置</h3><pre class="language-c" data-language="c"><code class="language-c">dir    <span class="token punctuation">.</span><span class="token operator">/</span>               # RDB 文件路径<span class="token punctuation">,</span> 默认在启动目录下dbfilename  dump<span class="token punctuation">.</span>rdb    # REB 文件名称rdbcompression yes      # 开启 LZF 压缩<span class="token punctuation">,</span> 这样可以节省存储空间<span class="token punctuation">,</span> 但是会消耗一些 CPU 的计算时间<span class="token punctuation">,</span> 默认开启rdbchecksum  yes        # 使用 CRC64 算法来进行数据校验<span class="token punctuation">,</span> 但是这样会增加大约 <span class="token number">10</span><span class="token operator">%</span> 的性能消耗<span class="token punctuation">,</span> 默认开启stop<span class="token operator">-</span>writes<span class="token operator">-</span>on<span class="token operator">-</span>bgsave<span class="token operator">-</span>error yes # 在 RDB 持久化操作失败时<span class="token punctuation">,</span> Redis 则会停止接受更新操作<span class="token punctuation">,</span> 让用户知道异常的出现<span class="token punctuation">,</span> 否则无感知的话<span class="token punctuation">,</span> 会造成大的存储问题<span class="token punctuation">,</span> 默认开启</code></pre><p>以上是 RDB 开启的默认一些配置, 在这些配置的基础下, 有 2 种方式可以触发 RDB 的进行, 也就是数据持久化的触发。</p><h3 id="1-2-通过配置规则触发"><a href="#1-2-通过配置规则触发" class="headerlink" title="1.2 通过配置规则触发"></a>1.2 通过配置规则触发</h3><p>在 redis.conf 的 SNAPSHOTING 配置中, 定义了触发把数据保存到磁盘的触发频率 (如果不需要 RDB 默认方案, 注释掉 save 或配置成空字符串 “” 即可)。</p><pre class="language-c" data-language="c"><code class="language-c">save <span class="token number">900</span> <span class="token number">1</span>      # <span class="token number">900</span> 秒内至少有一个 key 被修改 <span class="token punctuation">(</span>包括添加<span class="token punctuation">)</span>save <span class="token number">300</span> <span class="token number">10</span>     # <span class="token number">300</span> 秒内至少有 <span class="token number">10</span> 个 key 被修改save <span class="token number">60</span> <span class="token number">100</span>     # <span class="token number">60</span> 秒内至少有 <span class="token number">100</span> 个 key 被修改</code></pre><p>上面的配置是不冲突的, 只要满足任意一个都会触发。</p><h3 id="1-3-通过命令触发"><a href="#1-3-通过命令触发" class="headerlink" title="1.3 通过命令触发"></a>1.3 通过命令触发</h3><p>Redis 提供了 2 条命令 <strong>save</strong> 和 <strong>bgsave</strong> 可以用来手动触发数据保存。</p><p>save: 在生成快照的时候会阻塞当前 Redis 服务器, Redis 不能处理其他命令。如果内存中的数据比较多, 会造成 Redis 长时间阻塞。 生产中不建议使用这个命令。<br>bgsave: Redis 进程通过 fork 函数, 创建出一个子进程 (copy-on-write)。 RDB 持久化过程由子进程负责, 完成后自动结束。它不会记录 fork 之后的命令, 阻塞只发生在 fork 阶段, 一般时间很短。</p><p>Redis 提供了 <strong>lastsave</strong> 命令, 用来查看最近一次生成快照的时间。</p><p>当然通过 <strong>shutdown</strong> 命令关闭 Redis, 也会触发 RDB 持久化的发生, 以确保服务器正常关闭和后面启动数据能正常准确地重新加载。</p><h2 id="2-RDB-文件的优势和劣势"><a href="#2-RDB-文件的优势和劣势" class="headerlink" title="2 RDB 文件的优势和劣势"></a>2 RDB 文件的优势和劣势</h2><p>优势</p><blockquote><ol><li>RDB 是一个非常紧凑 (compact) 的文件, 它保存了 Redis 在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复</li><li>生成 RDB 文件的时候, Redis 进程会 fork 一个子进程来处理所有的保存工作, 主进程不需要进行任何磁盘 IO 操作</li><li>RDB 在恢复大数据集时的速度比 AOF 恢复速度快</li></ol></blockquote><p>劣势</p><blockquote><ol><li>RDB 方式数据没办法做到实时持久化或秒级持久化。因为 bgsave 每次运行都要执行 fork 函数, 创建子进程, 频繁执行成本高</li><li>在一定间隔时间做一次备份, 所以如果 Redis 意外 down 掉的话, 就会丢失最后一次快照之后的修改 (数据丢失)</li></ol></blockquote><p>如果数据相对来说比较重要, 希望将损失降到最小, 则可以使用 AOF 方式进行持久化。</p><h2 id="3-RDB-持久化的过程"><a href="#3-RDB-持久化的过程" class="headerlink" title="3 RDB 持久化的过程"></a>3 RDB 持久化的过程</h2><blockquote><ol><li>配置的规则条件达到或者收到了 bgsave &#x2F; save 命令, 持久化开始</li><li>主进程通过 fork 函数, 创建出一个子进程</li><li>父进程进行一些统计状态和指标的保存, 然后可以进行处理其他的命令</li><li>fork 出的子进程, 创建出一个临时文件, 将数据库中的数据写入到临时文件中</li><li>整个数据库的数据都写入完成了, 通过 rename 函数将临时文件命名为配置的 RDB 文件名 (如果重命名的文件已经存在, 会先被删除, 再进行重命名)</li><li>子进程在 RDB 文件持久完成后, 把持久化中的一些信息通知给父级, 然后退出子进程, 整个持久化就完成了</li></ol></blockquote><p>到此, RDB 的理论知识就没了, 下面是从源码进行分析。</p><p>注: 下面的分析都是以 <strong>Redis 5.x 版本</strong>进行分析的, 跨大版本可能会有一些不一样。</p><h2 id="4-RDB-文件结构"><a href="#4-RDB-文件结构" class="headerlink" title="4 RDB 文件结构"></a>4 RDB 文件结构</h2><p>要了解 RDB 的过程, 其中有一个绕不开的点: RDB 文件的结构。</p><p><img src="https://pic.imgdb.cn/item/656ace2bc458853aef650fd0.png" alt="Alt &#39;RDB 文件内容格式&#39;"></p><p>如图是 RDB 的<strong>逻辑文件结构</strong> (当前这个图片中显示的结构和真正的 RDB 文件有些差距的, 但是差距不大), 整个文件的内容如下:</p><ol><li><strong>REDIS</strong>, 文件开头的前 5 个字符的内容固定为 <strong>REDIS</strong>, 占用 5 个字节, 标识这是一个 Redis 可以处理的文件  </li><li>RDB_VERSION, 标识当前的 RDB 文件的版本号, 占用 4 个字节  </li><li>AUX_FIELD_KEY_VALUE_PAIRS, 这个属性不是简单的属性, 可以看成是 8 个 key-value 公共组成的一个属性值</li></ol><ul><li>3.1. key 为 <strong>redis-ver</strong>, value 为<strong>当前 Redis 的版本</strong>, 比如 5.0.0 版本  </li><li>3.2. key 为 <strong>redis-bit</strong>, value 为<strong>当前 Redis 的位数</strong>, 64 位 &#x2F; 32 位   </li><li>3.3. key 为 <strong>ctime</strong>, value 为 <strong>RDB 创建时的时间戳</strong>   </li><li>3.4. key 为 <strong>used-mem</strong>, value 为 <strong>dump 时 Redis 占的内存</strong>, 单位字节   </li><li>3.5. key 为 <strong>repl-steam-db</strong>,  和<strong>主从复制相关</strong>, 在 server.master 客户端中选择的数据库, 这个不一定有, 只有在当前的 RDB 文件是用作主从复制时才有值, 数据持久化时, 没有这个属性   </li><li>3.6. key 为 <strong>repl-id</strong>, 和<strong>主从复制相关</strong>, 当前实例 replication ID, 这个不一定有, 只有当前的 RDB 文件是用作主从复制时, 不是数据持久化时, 才有  </li><li>3.7. key 为 <strong>repl-offset</strong>, 和<strong>主从复制相关</strong>, 当前实例复制的偏移量, 这个不一定有, 只有当前的 RDB 文件是用作主从复制时, 不是数据持久化时, 才有  </li><li>3.8. key 为 <strong>aof-preamble</strong>, value 为<strong>是否开启了 aof&#x2F;rdb 的混合使用</strong></li></ul><ol start="4"><li>DB_NUM, 当前后面的数据是存储在哪个数据库的, Redis 中有 16 个数据库</li><li>DB_DIC_SIZE, 当前数据库键值对散列表的大小。Redis 的每个数据库是一个散列表, 这个字段指明当前数据库散列表的大小。这样在加载时可以直接将散列表扩展到指定大小, 提升加载速度  </li><li>EXPIRE_DIC_SIZE, 当前数据库过期时间散列表的大小。Redis 数据的过期时间也是保存为一个散列表, 该字段指明当前数据库过期时间散列表的大小</li><li>KEY_VALUE_PAIRS, 这个部分就是 Redis 中真正存储的数据了<br><strong>我们知道 Redis 中有 16 个数据库, 所以在多个数据库都有数据的情况下, 第四, 五, 六, 七这 4 个部分可能有多套的</strong>。</li><li>固定为 <strong>EOF</strong>, 一个常量, 文件结束标志</li><li>CHECK_NUM, 8 字节的校验码, 用来确保文件的正确性</li></ol><p>这 9 个部分就是 RDB 文件的内容了。<br>从上图中, 我们还可以知道, RDB 文件中的 KEY_VALUE_PAIRS 中, 实际存储了多个 KEY_VALUE_PAIR。 这些键值对就是我们存储在 Redis 里面的数据。<br>而我们存储在 Redis 里面的键值对除了单纯的 key-value 外, 还包含了其他的信息, 比如过期时间, 过期策略等。  </p><p>所以代表真正数据的 KEY_VALUE_PAIR 可以划分出 5 部分</p><blockquote><ol><li>EXPIRE_TIME, 当前这个键值对过期时间, 占 8 个字节, 如果 key 没有过期时间, 这一项可以没有</li><li>LRU 或 LFU, 当前这个键值对过期的方式, 同样是可选项, 如果 key 没有过期配置, 这一项也可以没有</li><li>VALUE_TYPE, 当前这个键值对的值的存储类型, 比如是字符串, 整数, 列表等, 取值看下面</li><li>KEY, 键值对的 KEY 值</li><li>VALUE, 键值对的 VALUE 值</li></ol></blockquote><p>VALUE_TYPE 就是存储 VALUE 的类型, 具体的取值如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_STRING</span>             <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_LIST</span>               <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_SET</span>                <span class="token expression"><span class="token number">2</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_ZSET</span>               <span class="token expression"><span class="token number">3</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_HASH</span>               <span class="token expression"><span class="token number">4</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_ZSET_2</span>             <span class="token expression"><span class="token number">5</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_MODULE</span>             <span class="token expression"><span class="token number">6</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_MODULE_2</span>           <span class="token expression"><span class="token number">7</span>   </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_HASH_ZIPMAP</span>        <span class="token expression"><span class="token number">9</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_LIST_ZIPLIST</span>       <span class="token expression"><span class="token number">10</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_SET_INTSET</span>         <span class="token expression"><span class="token number">11</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_ZSET_ZIPLIST</span>       <span class="token expression"><span class="token number">12</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_HASH_ZIPLIST</span>       <span class="token expression"><span class="token number">13</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_LIST_QUICKLIST</span>     <span class="token expression"><span class="token number">14</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RDB_TYPE_STREAM_LISTPACKS</span>   <span class="token expression"><span class="token number">15</span></span></span></code></pre><p>这几个就是<strong>数据类型的定义</strong></p><h2 id="5-数据以什么格式存入二进制文件"><a href="#5-数据以什么格式存入二进制文件" class="headerlink" title="5 数据以什么格式存入二进制文件"></a>5 数据以什么格式存入二进制文件</h2><p>在进入到 Redis 是如何写数据到 RDB 文件前, 我们先看一个例子吧。</p><p>将设现在我有一个备忘录, 里面有内容如下</p><blockquote><p>123 4567 8900 (手机号码)<br>021-3000 9000 (座机号码)<br>123456789012345678 (18 位的身份证)<br>60606060606060606 (银行卡号, 17位, 银行卡实际的长度不定, 但是长度在 15-19 位之间)</p></blockquote><p>现在需要将他们写入到一个文件中, 并且期望</p><blockquote><ol><li>尽可能的省空间</li><li>后面还能正常的读取出来</li></ol></blockquote><p>现在最直接的省空间的, 当然直接将他们拼接在一起, 最终就是这样了: <strong>123 4567 8900021-3000 12345678901234567860606060606060606</strong>    </p><p>但是后面的如何正确的读取呢? 我们先对备忘录里面的内容做个分类</p><blockquote><ol><li>普通的手机号码, 固定长度 13 位</li><li>座机号码, 固定长度 11 位 </li><li>身份证号, 固定长度为 18 位</li><li>中国银行卡号, 长度不定, 但是长度在 15-19 位之间</li></ol></blockquote><p>概括为</p><blockquote><ol><li>内容的长度是固定的, 比如手机号 13 位, 身份证 18 位</li><li>内容长度是不固定的, 比如银行卡号</li></ol></blockquote><p>那么我们是否可以指定一个规则, 写入文件时, 备忘录的每一个内容前面都会加入一个数字, 每个数字都代表了一种内容格式</p><ul><li>数字 1 表示后面的内容是手机号码, 长度固定为 13 位</li><li>数字 2 表示后面的内容是座机号, 长度固定为 11 位</li><li>数字 3 表示后面的内容为身份证号, 长度为 18 位</li><li>数字 4 表示后面的内容是特殊内容, 长度不确定</li></ul><p>通过这个规则, 我们的内容变成 <strong>1</strong>123 4567 8900<strong>2</strong>021-3000 9000<strong>3</strong>123456789012345678<strong>4</strong>60606060606060606</p><p>读取时, 我们都是先读取第一位, 确定后面的内容是什么, 得到需要读取多少位。<br>比如先读取到 <strong>1</strong>, 根据规则 <strong>1</strong>, 表示后面的内容为手机号, 需要一次性读取 13 位内容, 其他同理。<br>但是当读取到 <strong>4</strong>, 我们卡住了, 根据规则 <strong>4</strong>, 代表后面是特殊内容, 那需要读取多长的内容?</p><p>这时我们在指定一套<strong>表示整数</strong>的规则</p><blockquote><p>数字 1 表示后面的内容的长度为 15<br>数字 2 表示后面的内容的长度为 16<br>数字 3 表示后面的内容的长度为 17<br>数字 4 表示后面的内容的长度为 18<br>数字 5 表示后面的内容的长度为 19</p></blockquote><p>修改上面内容格式的规则, 将数字 4 修改为如下</p><ul><li>数字 4 表示后面的内容是特殊内容, 同时后面会紧跟一个一位数的整数, 表示后面的内容的长度</li></ul><p>最终通过修改后的规则, 我们的内容变成 <strong>1</strong>123 4567 8900<strong>2</strong>021-3000 9000<strong>3</strong>123456789012345678<strong>44</strong>60606060606060606</p><p>这时按照规则读取到数字 <strong>4</strong>, 知道后面的内容为特殊内容, 需要在往后读取 1 位, 得到特殊内容的长度, 这时读取到 <strong>4</strong>, 根据整数规则, 得到长度为 17。</p><p>上面就是 Redis 以二进制存储数据到文件的大体思路, 只是他设计得更巧妙一下, 没那么粗暴。<br>总体就是确定<strong>内容的长度</strong>, 而在确定内容的长度, 有 2 种方式</p><blockquote><ol><li>内容的长度是<strong>定长</strong>的, 我们就给他制定特有的<strong>内容类型</strong>, 这个<strong>内容类型</strong>本身就代表了后面<strong>内容的长度</strong></li><li>内容的长度是<strong>不定长</strong>的, 就通过自定义的一套<strong>整数规则</strong>, 在内容前面加上一个符合<strong>整数规则</strong>的数字, 表示内容的长度</li></ol></blockquote><h3 id="5-1-自定义的整数的规则"><a href="#5-1-自定义的整数的规则" class="headerlink" title="5.1 自定义的整数的规则"></a>5.1 自定义的整数的规则</h3><p><strong>备注: 下面二进制之间每 8 位就手动空了一个空格, 只是为了方便理解, 真正写入文件时, 中间是不会有空格的</strong></p><p>在实际中, Reids 会将数据以二进制的形式写入到文件中, 格式可能如下</p><pre class="language-none"><code class="language-none">00010000 11000011 11011010 01010101 .....</code></pre><p>在开始介绍 Redis 自定义的整数规则前, 先看一个 Redis <strong>将数据写入文件</strong>的伪代码</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rdbSaveContentString</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> content<span class="token punctuation">,</span> <span class="token keyword">long</span> contentLength<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1. 数据的长度在 11 个字节以内 (int 最大值, 21 亿, 10 位数)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>contentLength <span class="token operator">&lt;</span> <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 尝试转为 int 写入</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryWriteIntegerContent</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> contentLength<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 2. 开启了 LZF 压缩算法, 同时数据长度大于 20 个字节</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_compression <span class="token operator">&amp;&amp;</span> contentLength <span class="token operator">></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">saveLzfStringObject</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> contentLength<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 3. 兜底</span>    <span class="token function">writeContentLen</span><span class="token punctuation">(</span>contentLength<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">writeContent</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> contentLength<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>逻辑整理如下</p><blockquote><ol><li>输入的数据长度在 11 个字节内, 同时可以转为 int 时, 以<strong>整数 int</strong>的形式写入 rdb 文件</li><li>开启了 LZF 压缩功能, 同时数据长度在 20 个字节以上, 以<strong>LZF 压缩字符串</strong>的形式写入 rdb 文件</li><li>数据不能转为整数, 同时长度在 20 个字节内, 数据的长度在 11 到 20 个字节内或者没有开启 LZF 压缩功能, 以<strong>长度 + 数据</strong>的形式写入 rdb 文件</li></ol></blockquote><p>可以看到 Redis 对写入到 RDB 文件的数据有 3 中模式。</p><p><strong>模式一</strong><br>写入 RDB 文件的数据可以转为一个整数, 同时大小在 int 的取值范围内, 会以 **整数 int (这里可以看作是数据类型 + 内容模式)**的形式存储这个整数</p><p>长度的表示: <strong>11|XXXXXX</strong></p><blockquote><p>1 <strong>11|000000</strong> (十进制: 192), 表示后面的内容类型为 byte,  是一个长度为 1 个字节的整数<br>2 <strong>11|000001</strong> (十进制: 193), 表示后面的内容类型为 short, 是一个长度为 2 个字节的整数<br>3 <strong>11|000010</strong> (十进制: 194), 表示后面的内容类型为 int,   是一个长度为 4 个字节的整数<br>4 <strong>11|000011</strong> (十进制: 195), 表示后面为 FASTLZ 压缩算法压缩的字符串, 后面分析</p></blockquote><p>举个例子, 我们现在如果要向 RDB 文件写入内容: 10</p><blockquote><ol><li>内容 10 在程序中可以转为 1 个 byte 类型的 10 (00001010), </li><li>byte 类型的数据, 只需要 1 个字节, 可以用 Redis 定义的整数规则 <strong>11|000000</strong> 表示其数据的长度, 最终写入到 RDB 文件就是 <strong>11000000 00001010</strong></li></ol></blockquote><p>同理写入一个 257 (00000001 00000001), 需要用 2 个字节, 也就是 short 类型。可以用 <strong>11|000001</strong> 表示其数据的长度, 最终写入到 RDB 文件的就是 <strong>11000001 00000001 00000001</strong></p><p>这个模式就是我们备忘录里面的 <strong>直接数据类型, 这个数据类型就直接表示后面数据长度</strong>的模式。</p><p><strong>模式二</strong> </p><p>条件</p><blockquote><ol><li>数据不能转为整数, 同时长度在 20 个字节内, 比如 ’abc‘</li><li>数据的长度在 11 到 20 个字节之间 (也就是即使能转为整数, 但是整数大于 int 最大值, 也是按照这种方式处理), 比如 ‘abcdefghijkl’ 或 ‘2147483648’ (int 最大值 + 1)</li><li>没有开启 LZF 压缩功能<br>以<strong>长度 + 数据</strong>的形式存储数据</li></ol></blockquote><p>长度的表示有 4 种模式</p><ol><li><strong>00|XXXXXX</strong> &#x3D;&gt; 1 个字节, 前 2 位固定为 <strong>00</strong>, 后面 6 位表示具体的数字, <strong>最大值为 63, 也就是表示后面的数据长度为 64 个字节</strong></li><li><strong>01|XXXXXX XXXXXXXX</strong> &#x3D;&gt; 2 个字节, 前 2 位固定为 <strong>01</strong>, 后面 14 位表示具体的数字, <strong>最大值为 16383</strong></li><li><strong>10|000000 [32 bit integer]</strong> &#x3D;&gt; 5 个字节, 前 8 位固定为 <strong>10000000</strong>, 后面 32 位表示具体的数字, <strong>int 的最大值</strong></li><li><strong>10|000001 [64 bit integer]</strong> &#x3D;&gt; 9 个字节, 前 8 为固定为 <strong>10000001</strong>, 后面 64 位表示具体的数字, <strong>long 的最大值</strong></li></ol><p>举个例子, 我们现在如果要向 RDB 文件写入内容: a (a 不能转为整数, 所以跳过了模式一)</p><blockquote><ol><li>a 本身只需要一个字节存储就行了, 也就是表示长度的规则, 可以选 <strong>00|000001</strong>, a 本身的二进制为 01100001 (ASCII 码, 二进制),<br>那么最终写入到 RDB 文件的数据就是 <strong>00000001 01100001</strong></li></ol></blockquote><p>同理写入 65 个 ‘a’, 需要 65 个字节, 表示长度的规则为 <strong>01000000 01000001</strong> (00|XXXXXX 模式不够了), 后面接着 65 个 a 的二进制。  </p><p>这个模式就是我们备忘录里面的 <strong>内容类型 + 数据长度</strong>的模式 (内容长度, 看每个字节的前 2 位确定的)。</p><p><strong>模式三</strong><br>当 Redis 开启了 LZF 压缩功能时, 如果写入的数据的长度大于 20 个字节了, 会对存储的数据进行压缩后再存储,<br>存储的格式为: <strong>11|000011 + 压缩后的长度 + 原始的数据长度 + 压缩后的数据</strong>, 模式一中的特殊模式。</p><p>看起来有点绕吧，做个总结, Redis 为了能将内容准确地存储下来, 定义了一套<strong>整数规则</strong>  </p><blockquote><ol><li><strong>11|XXXXXX</strong> &#x3D;&gt; 表示整数编码<blockquote><p>1.1 如果后面的 XXXXXX 6 位的值为 0, 表示后面的内容长度为 1 个字节, 也就是一个 byte 整数<br>1.2 如果后面的 XXXXXX 6 位的值为 1, 表示后面的内容长度为 2 个字节, 同时是一个 short 整数<br>1.3 如果后面的 XXXXXX 6 位的值为 2, 表示后面的内容长度为 4 个字节, 同时是一个 int 整数<br>1.4 如果后面的 XXXXXX 6 位的值为 3, 表示后面为 FASTLZ 压缩算法压缩的字符串, 特殊处理, 内容的格式为 <strong>11|000011 压缩后的长度 (长度用上面的规则进行表示) + 原始的数据长度 (同理) + 压缩后的数据</strong>*  </p></blockquote></li><li><strong>00|XXXXXX</strong> &#x3D;&gt; 1 个字节, 前 2 位固定为 <strong>00</strong>, 后面 6 位表示具体的数字, <strong>最大值为 63</strong>, 表示后面紧接的内容长度</li><li><strong>01|XXXXXX XXXXXXXX</strong> &#x3D;&gt; 2 个字节, 前 2 位固定为 <strong>01</strong>, 后面 14 位表示具体的数字, 表示后面紧接的内容长度</li><li><strong>10|000000 [32 bit integer]</strong> &#x3D;&gt; 5 个字节, 前 8 位固定为 <strong>10000000</strong>, 后面 32 位表示具体的数字, 表示后面紧接的内容长度</li><li><strong>10|000001 [64 bit integer]</strong> &#x3D;&gt; 9 个字节, 前 8 为固定为 <strong>10000001</strong>, 后面 64 位表示具体的数字, 表示后面紧接的内容长度</li></ol></blockquote><p>在使用时, 可以直接根据第一个字节的前 2 位, 得到后面数据的解析方式。</p><h3 id="5-2-操作码"><a href="#5-2-操作码" class="headerlink" title="5.2 操作码"></a>5.2 操作码</h3><p>在分析上面的 RDB 文件的逻辑结构中, 可以发现有一些属性, 在某些情况下是没有的, 这会造成什么问题呢?<br>顺着二进制文件一直读下去, 虽然数据解析出来了, 但是我们不知道这个数据是什么。</p><p>比如存储具体数据的 KEY_VALUE_PAIRS 中, 过期时间 <strong>EXPIRE_TIME</strong> 是可以没有的。</p><p>这时如果顺着二进制文件, 假设这时读取到了 6, 这个数字, 那么他是 KEY_VALUE_PAIRS 中的过期时间 EXPIRE_TIME, 还是键值对的数据类型 VALUE_TYPE (没有过期时间, 也就没有过期策略, 下一位就是键值值类型)。</p><p>为了应对这种不一定存在的情况, Redis 定义了一套 <strong>操作码</strong>, 通过操作码表示后面的数据是什么, 让解析出来的数据能真正赋值到对应的属性。</p><p>操作码: </p><table><thead><tr><th align="center">变量名</th><th align="center">取值</th><th align="center">操作码后面数据的含义</th></tr></thead><tbody><tr><td align="center">RDB_OPCODE_MODULE_AUX</td><td align="center">247</td><td align="center">module 相关辅助字段</td></tr><tr><td align="center">RDB_OPCODE_IDLE</td><td align="center">248</td><td align="center">lru 空闲时间</td></tr><tr><td align="center">RDB_OPCODE_FREQ</td><td align="center">249</td><td align="center">lfu 频率</td></tr><tr><td align="center">RDB_OPCODE_AUX</td><td align="center">250</td><td align="center">辅助字段类型</td></tr><tr><td align="center">RDB_OPCODE_RESIZEDB</td><td align="center">251</td><td align="center">resized, 和 DB_DIC_SIZE 和 EXPIRE_DIC_SIZE 的散列表个数有个相关</td></tr><tr><td align="center">RDB_OPCODE_EXPIRETIME_MS</td><td align="center">252</td><td align="center">毫秒级别过期时间</td></tr><tr><td align="center">RDB_OPCODE_EXPIRETIME</td><td align="center">253</td><td align="center">秒级别过期时间</td></tr><tr><td align="center">RDB_OPCODE_SELECTDB</td><td align="center">254</td><td align="center">数据库序号, 也就是 DB_NUM 项</td></tr><tr><td align="center">RDB_OPCODE_EOF</td><td align="center">255</td><td align="center">结束标志, 即 EOF 项</td></tr></tbody></table><h3 id="5-3-例子"><a href="#5-3-例子" class="headerlink" title="5.3 例子"></a>5.3 例子</h3><p>上面聊了 RDB 文件的逻辑结构, 自定义的整数规则和操作码, 这里就举一个例子, 结合起来理解一下 (括号内为说明, 对应的内容自行转为二进制)</p><p>如果这时如果直接打开了一个 RDB 文件, 对应的内容如下</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token number">01010010</span> <span class="token number">01000101</span> <span class="token number">01000100</span> <span class="token number">01001001</span> <span class="token number">01010011</span> <span class="token punctuation">(</span>前 <span class="token number">5</span> 个字节<span class="token punctuation">,</span> 固定为 REDIS 字符串的二进制<span class="token punctuation">)</span><span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00001001</span>          <span class="token punctuation">(</span>固定 <span class="token number">4</span> 个字节的 RDB 版本<span class="token punctuation">,</span> Redis <span class="token number">5.0</span> 版本中默认为 <span class="token number">9</span><span class="token punctuation">)</span><span class="token number">11111010</span> <span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">,</span> 操作码<span class="token punctuation">,</span> 表示后面辅助字段<span class="token punctuation">)</span> <span class="token number">00001001</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">00</span><span class="token operator">|</span>XXXXXX<span class="token punctuation">,</span> 表示后面辅助字段 key 的长度<span class="token punctuation">)</span> redis<span class="token operator">-</span><span class="token function">ver</span> <span class="token punctuation">(</span>这里没有转为二进制<span class="token punctuation">)</span> <span class="token number">00000110</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">00</span><span class="token operator">|</span>XXXXXX 表示后面辅助字段 value 的长度<span class="token punctuation">)</span> <span class="token number">5.0</span><span class="token number">.10</span><span class="token punctuation">(</span>这里没有转为二进制<span class="token punctuation">)</span><span class="token number">11111010</span> <span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">,</span> 操作码<span class="token punctuation">,</span> 表示后面辅助字段<span class="token punctuation">)</span> <span class="token number">00001010</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">00</span><span class="token operator">|</span>XXXXXX<span class="token punctuation">,</span> 辅助字段 key 的长度<span class="token punctuation">)</span> redis<span class="token operator">-</span><span class="token function">bits</span> <span class="token punctuation">(</span>这里没有转为二进制<span class="token punctuation">)</span> <span class="token number">01000000</span> <span class="token number">01000000</span> <span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">01</span><span class="token operator">|</span>XXXXXX XXXXXXXX<span class="token punctuation">,</span> redis<span class="token operator">-</span>bits 后面的内容直接用整数表示即可<span class="token punctuation">)</span><span class="token number">11111010</span> <span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">,</span> 操作码<span class="token punctuation">,</span> 表示后面辅助字段<span class="token punctuation">)</span> <span class="token number">00000101</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">00</span><span class="token operator">|</span>XXXXXX<span class="token punctuation">)</span> <span class="token function">ctime</span> <span class="token punctuation">(</span>这里没有转为二进制<span class="token punctuation">)</span> <span class="token number">11000010</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">11</span><span class="token operator">|</span>XXXXXX<span class="token punctuation">)</span> <span class="token number">00101111</span> <span class="token number">11001001</span> <span class="token number">10111100</span> <span class="token number">01011111</span> <span class="token punctuation">(</span>时间戳<span class="token punctuation">,</span> 单位秒<span class="token punctuation">,</span> 小端存储<span class="token punctuation">,</span> 实际值<span class="token operator">:</span> <span class="token number">1606207791</span><span class="token punctuation">)</span> 其他的 AUX_FIELD_KEY_VALUE_PAIRS 键值对<span class="token number">11111001</span> <span class="token punctuation">(</span><span class="token number">254</span><span class="token punctuation">,</span> 操作码<span class="token punctuation">,</span> 数据库序号项<span class="token punctuation">)</span> <span class="token number">00000000</span> <span class="token punctuation">(</span><span class="token number">0</span> 号数据库<span class="token punctuation">,</span> 因为 Redis 的数据库最多 <span class="token number">16</span> 个<span class="token punctuation">,</span> 所以直接读取后面一个字节就行<span class="token punctuation">,</span> 不需要自定义的整数规则<span class="token punctuation">)</span>  <span class="token number">11111011</span> <span class="token punctuation">(</span><span class="token number">251</span><span class="token punctuation">,</span> 操作码<span class="token punctuation">,</span> RESIZED 项<span class="token punctuation">)</span> <span class="token number">00000001</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">00</span><span class="token operator">|</span>XXXXXX<span class="token punctuation">,</span> 当前数据库键值对散列表只有 <span class="token number">1</span> 个<span class="token punctuation">)</span> <span class="token number">00000010</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">00</span><span class="token operator">|</span>XXXXXX<span class="token punctuation">,</span> 当前数据库过期时间散列表有 <span class="token number">2</span> 个<span class="token punctuation">)</span><span class="token number">11111100</span> <span class="token punctuation">(</span><span class="token number">252</span><span class="token punctuation">,</span> 操作码<span class="token punctuation">,</span> 毫秒级别过期时间项<span class="token punctuation">,</span> 这一项不一定都有<span class="token punctuation">,</span> 如果 key 没有过期配置<span class="token punctuation">,</span> 这一项就没有的<span class="token punctuation">)</span> <span class="token number">11101101</span> <span class="token number">00001110</span> <span class="token number">10111010</span> <span class="token number">00111000</span> <span class="token number">01110110</span> <span class="token number">000000001</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token punctuation">(</span>固定的 <span class="token number">8</span> 个字节<span class="token punctuation">,</span> 时间戳<span class="token punctuation">,</span> 实际值<span class="token operator">:</span> <span class="token number">1607269486317</span><span class="token punctuation">,</span> 同样小端存储<span class="token punctuation">)</span><span class="token number">11111000</span> <span class="token punctuation">(</span><span class="token number">248</span><span class="token punctuation">,</span> 操作码<span class="token punctuation">,</span> 过期策略<span class="token punctuation">,</span> 这里也可能为 <span class="token number">249</span><span class="token punctuation">)</span> <span class="token number">00101111</span> <span class="token number">11001001</span> <span class="token number">10111100</span> <span class="token number">01011111</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token punctuation">(</span>固定 <span class="token number">8</span> 个字节<span class="token punctuation">,</span> 存储的是过期的时间<span class="token punctuation">,</span> 单位秒<span class="token punctuation">,</span> 如果配置是 lfu<span class="token punctuation">,</span> 即 <span class="token number">249</span><span class="token punctuation">,</span> 则这个为 <span class="token number">1</span> 个字节<span class="token punctuation">,</span> 表示引用次数<span class="token punctuation">,</span> 取值为 <span class="token number">0</span> <span class="token operator">-</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token number">00000000</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> 上面 RDB 文件结构中有说明<span class="token punctuation">,</span> 存储到里面数据类型的取值<span class="token punctuation">,</span> 这里 <span class="token number">0</span><span class="token punctuation">,</span> 表示为字符串<span class="token punctuation">)</span> <span class="token number">00000010</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">00</span><span class="token operator">|</span>XXXXXX<span class="token punctuation">,</span> 后面 key 的长度<span class="token punctuation">)</span> k1 <span class="token number">00000010</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> 整数规则<span class="token operator">:</span> <span class="token number">00</span><span class="token operator">|</span>XXXXXX<span class="token punctuation">,</span> 后面 value 的长度<span class="token punctuation">)</span> v1<span class="token number">11111111</span> <span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> 操作码<span class="token punctuation">,</span> 结束项<span class="token punctuation">)</span><span class="token number">000000001</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> 固定 <span class="token number">8</span> 个字节<span class="token punctuation">,</span> 文件的校验码<span class="token punctuation">)</span></code></pre><p>上面的 KEY_VALUE_PAIRS 举的例子为 String 类型, 所以比较简单。<br>而实际中, Redis 在 KEY_VALUE_PAIR 还会根据不同的值类型, 内部会做一下优化。<br>不同的数据类型, 会有不同的编码进行数据的组织, 而有些编号会在前面先保存一个当前编码数据的节点数, 然后在保存数据。<br>比如 quicklist, 组织的方式如下: <code>quicklist 中的节点数 | ziplist1 | ziplist2 | ziplist3</code>, 多了一个节点数的字段。</p><p>有这种行为的有: dict, qicklist, skiplist 等</p><p>到此就是 RDB 文件的内容, 很绕。</p><h2 id="6-代码实现"><a href="#6-代码实现" class="headerlink" title="6 代码实现"></a>6 代码实现</h2><p>在日常的使用中, RDB 一般都是通过配置文件, 配置规则触发的, 那么以这个为入口开始分析。</p><h3 id="6-1-配置规则封装对象"><a href="#6-1-配置规则封装对象" class="headerlink" title="6.1 配置规则封装对象"></a>6.1 配置规则封装对象</h3><pre class="language-none"><code class="language-none">save 900 1  # 900 秒内至少有一个 key 被修改 (包括添加)save 300 10 # 300 秒内至少有 10 个 key 被修改save 60 100 # 60 秒内至少有 100 个 key 被修改</code></pre><p>一般上面就是配置 RDB 的自动触发规则了, 每一条规则在代码中会被封装为如下一个对象</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">saveparam</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 秒数</span>    <span class="token class-name">time_t</span> seconds<span class="token punctuation">;</span>    <span class="token comment">// 修改的次数</span>    <span class="token keyword">int</span> changes<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h3 id="6-2-RDB-相关的配置的存储"><a href="#6-2-RDB-相关的配置的存储" class="headerlink" title="6.2 RDB 相关的配置的存储"></a>6.2 RDB 相关的配置的存储</h3><p>RDB 相关的配置的话, 比如是否启用, 是否使用压缩等, 都保存在 redisServer 这个结构体中</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">/** 上次保存后对数据库 key 的修改次数 */</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> dirty<span class="token punctuation">;</span>      <span class="token comment">/** 用于在 BGSAVE 失败时, 恢复 dirty */</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> dirty_before_bgsave<span class="token punctuation">;</span>      <span class="token comment">/** 保存 RDB 的子进程 ID */</span>    <span class="token class-name">pid_t</span> rdb_child_pid<span class="token punctuation">;</span>       <span class="token comment">/** 保存规则数组 */</span>    <span class="token keyword">struct</span> <span class="token class-name">saveparam</span> <span class="token operator">*</span>saveparams<span class="token punctuation">;</span>     <span class="token comment">/** RDB 文件名, 默认为 dump.rdb */</span>    <span class="token keyword">char</span> <span class="token operator">*</span>rdb_filename<span class="token punctuation">;</span>    <span class="token comment">/** 是否启用 LZF 压缩算法对 RDB 文件压缩, 默认 yes */</span>    <span class="token keyword">int</span> rdb_compression<span class="token punctuation">;</span>               <span class="token comment">/** 是否启用 RDB 文件校验, 默认 yes */</span>    <span class="token keyword">int</span> rdb_checksum<span class="token punctuation">;</span>     <span class="token comment">/** 上一次 save 成功的时间 */</span>    <span class="token class-name">time_t</span> lastsave<span class="token punctuation">;</span>              <span class="token comment">/** 上一次尝试 bgsave 的时间 */</span>    <span class="token class-name">time_t</span> lastbgsave_try<span class="token punctuation">;</span>     <span class="token comment">/** 上次 RDB save 使用的时间 */</span>    <span class="token class-name">time_t</span> rdb_save_time_last<span class="token punctuation">;</span>        <span class="token comment">/** 当前 RDB 开始 save 的时间 */</span>    <span class="token class-name">time_t</span> rdb_save_time_start<span class="token punctuation">;</span>        <span class="token comment">/** 激活的子进程当前执行的 RDB 类型 (Redis 主从复制也是有依赖 RDB 的), 当前的执行 RDB 是要写入磁盘, 还是写入 socket, 发送给从节点 */</span>    <span class="token keyword">int</span> rdb_child_type<span class="token punctuation">;</span>    <span class="token comment">/** 上次 bgsave 的执行结果  C_OK / C_ERR */</span>    <span class="token keyword">int</span> lastbgsave_status<span class="token punctuation">;</span>       <span class="token comment">/** 是否允许写入, 如果不能 BGSAVE, 则不允许写入 */</span>    <span class="token keyword">int</span> stop_writes_on_bgsave_err<span class="token punctuation">;</span>    <span class="token comment">/** 无磁盘同步, 通过管道向父级写数据 */</span>    <span class="token keyword">int</span> rdb_pipe_write_result_to_parent<span class="token punctuation">;</span>    <span class="token comment">/** 无磁盘同步, 通过管道从从节点读数据 */</span>    <span class="token keyword">int</span> rdb_pipe_read_result_from_child<span class="token punctuation">;</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><h3 id="6-3-功能的触发"><a href="#6-3-功能的触发" class="headerlink" title="6.3 功能的触发"></a>6.3 功能的触发</h3><p>要触发 RDB 的话, 可以通过 save 和 bgsave 2 个命令和配置的规则达到了。<br>虽然是不同的方式, 但是在底层最终还是走到了相同的方法, 所以这里以配置规则的方式进行讲解。</p><p>配置规则的触发同样是基于定时器的, 也就是 serverCron 这个 Redis 的定时函数。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 前面代码省略</span>    <span class="token comment">// 判断后台是否正在进行 RDB 或者 AOF 操作或者还有子进程阻塞在父级</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token function">ldbPendingChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 代码省略</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果没有后台 RDB/AOF 在进行中, 进行检查是否需要立即开启 RDB/AOF</span>        <span class="token comment">// 遍历我们的触发规则列表</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>saveparamslen<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 配置规则</span>            <span class="token keyword">struct</span> <span class="token class-name">saveparam</span> <span class="token operator">*</span>sp <span class="token operator">=</span> server<span class="token punctuation">.</span>saveparams<span class="token operator">+</span>j<span class="token punctuation">;</span>            <span class="token comment">// 当前 Redis 中修改过的 key 的数量 > 规则配置的 key 修改数量值 并且 当前的时间 - 上次保存的时间 > 规则配置的时间频率 (配置的条件达到了)</span>            <span class="token comment">// 当前的时间 - 上次 bgsave 的时间 > 5 秒 或者 上次的 bgsave 为成功状态 (内部的判断条件)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>dirty <span class="token operator">>=</span> sp<span class="token operator">-></span>changes <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>unixtime<span class="token operator">-</span>server<span class="token punctuation">.</span>lastsave <span class="token operator">></span> sp<span class="token operator">-></span>seconds                 <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>unixtime <span class="token operator">-</span> server<span class="token punctuation">.</span>lastbgsave_try <span class="token operator">></span> CONFIG_BGSAVE_RETRY_DELAY <span class="token operator">||</span> server<span class="token punctuation">.</span>lastbgsave_status <span class="token operator">==</span> C_OK<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token comment">//记录日志</span>                <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"%d changes in %d seconds. Saving..."</span><span class="token punctuation">,</span> sp<span class="token operator">-></span>changes<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>sp<span class="token operator">-></span>seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// rdbSaveIndo 用来存储从节点的信息</span>                <span class="token comment">// Redis 中主从节点的数据同步也有通过 RDB 的</span>                <span class="token comment">// 把数据保存为一个 RDB 文件, 发送给从节点, 我们这里研究的是主节点自身数据的保存, 所以这里把这里的逻辑省略</span>                rdbSaveInfo rsi<span class="token punctuation">,</span> <span class="token operator">*</span>rsiptr<span class="token punctuation">;</span>                rsiptr <span class="token operator">=</span> <span class="token function">rdbPopulateSaveInfo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rsi<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 开始 RDB 数据保存</span>                <span class="token function">rdbSaveBackground</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_filename<span class="token punctuation">,</span>rsiptr<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// AOF 判断</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_state <span class="token operator">==</span> AOF_ON <span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 代码省略</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>上面就是配置规则的触发了, 条件达到后, 最终会执行 rdbSaveBackground 函数。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">rdbSaveBackground</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> rdbSaveInfo <span class="token operator">*</span>rsi<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> childpid<span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> start<span class="token punctuation">;</span>    <span class="token comment">// 再次判断是否有子线程在 RDB/ AOF </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token comment">// 保存当前的 dirty 到 dirty_before_bgsave</span>    server<span class="token punctuation">.</span>dirty_before_bgsave <span class="token operator">=</span> server<span class="token punctuation">.</span>dirty<span class="token punctuation">;</span>    <span class="token comment">// 更新为当前的时间</span>    server<span class="token punctuation">.</span>lastbgsave_try <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 打开一个父子通道, 用于将 RDB/AOF 保存过程中的信息从子进程移动到父级</span>    <span class="token function">openChildInfoPipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 当前的时间</span>    start <span class="token operator">=</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// fork 一个子进程, 如果返回值是 0, 表示为子进程, 大于 0 表示为父进程, -1 则表示 fork 失败</span>    <span class="token comment">// fork 成功后, 子进程也会从这里继续执行</span>    <span class="token comment">// 这个 fork 操作, 可以理解为克隆, 从父类克隆了一个完全一样的子类, 克隆后子类持有和父类一样的数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>childpid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 子进程逻辑</span>        <span class="token comment">// 释放掉一些子进程不需要的资源</span>        <span class="token function">closeClildUnusedResourceAfterFork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置一个执行过程的标题</span>        <span class="token function">redisSetProcTitle</span><span class="token punctuation">(</span><span class="token string">"redis-rdb-bgsave"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 调用 rdbSave 真正的执行 RDB 备份</span>        retval <span class="token operator">=</span> <span class="token function">rdbSave</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span>rsi<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 执行成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 计算当前进程使用了多少额外的内存</span>            <span class="token class-name">size_t</span> private_dirty <span class="token operator">=</span> <span class="token function">zmalloc_get_private_dirty</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>private_dirty<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span> <span class="token string">"RDB: %zu MB of memory used by copy-on-write"</span><span class="token punctuation">,</span> private_dirty<span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            server<span class="token punctuation">.</span>child_info_data<span class="token punctuation">.</span>cow_size <span class="token operator">=</span> private_dirty<span class="token punctuation">;</span>            <span class="token comment">// 将子进程的信息发送给父进程, 也就是拷贝到 server.child_info_pipe[2] 中</span>            <span class="token function">sendChildInfo</span><span class="token punctuation">(</span>CHILD_INFO_TYPE_RDB<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 退出子进程</span>        <span class="token function">exitFromChild</span><span class="token punctuation">(</span><span class="token punctuation">(</span>retval <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 父进程逻辑</span>        <span class="token comment">// 父进程 fork 出子进程后, 就能继续执行自身的任务了</span>        <span class="token comment">// fork 消耗的时间</span>        server<span class="token punctuation">.</span>stat_fork_time <span class="token operator">=</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start<span class="token punctuation">;</span>        <span class="token comment">// 计算 fork 频率, 单位 GB/second</span>        server<span class="token punctuation">.</span>stat_fork_rate <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000000</span> <span class="token operator">/</span> server<span class="token punctuation">.</span>stat_fork_time <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 尝试添加延迟事件</span>        <span class="token comment">// 当后面的时间大于 server.latency_monitor_threshold, 会向 server.latency_events 添加一个延迟事件, 用于后面的延迟分析</span>        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">,</span>server<span class="token punctuation">.</span>stat_fork_time<span class="token operator">/</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// fork 失败</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>childpid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 关闭父子通道</span>            <span class="token function">closeChildInfoPipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 更新 上一次 bgsave_status 为失败状态</span>            server<span class="token punctuation">.</span>lastbgsave_status <span class="token operator">=</span> C_ERR<span class="token punctuation">;</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Can't save in background: fork: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 返回错误码</span>            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"Background saving started by pid %d"</span><span class="token punctuation">,</span>childpid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// RDB 开始的时间</span>        server<span class="token punctuation">.</span>rdb_save_time_start <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 子进程的进程 ID</span>        server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">=</span> childpid<span class="token punctuation">;</span>        <span class="token comment">// RDB 类型为写入磁盘类型</span>        server<span class="token punctuation">.</span>rdb_child_type <span class="token operator">=</span> RDB_CHILD_TYPE_DISK<span class="token punctuation">;</span>        <span class="token comment">// 更新全局的 dict.dict_can_resize 进行字典扩容的控制, 控制存储数据的 dict 扩容</span>        <span class="token function">updateDictResizePolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 更新 dict 的扩容行为 */</span><span class="token keyword">void</span> <span class="token function">updateDictResizePolicy</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 当前的没有 rdb 子进程 和 aof 子进程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_child_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>aof_child_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">// 更新 dict.c 中的 dict_can_resize 为 1, 表示全部的 dict 可以进行扩容</span>        <span class="token function">dictEnableResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment">// 更新 dict.c 中的 dict_can_resize 为 0, 表示全部的 dict 不可以进行扩容, 但是这个配置在 dict 中的数据达到某个条件后, 还是能进行扩容的</span>        <span class="token function">dictDisableResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上面就是 rdbSaveBackgroud 方法的逻辑了, 其最重要的一点就是 fork 出一个子进程, 执行最终的 RDB 文件的保存, 也就是 <strong>rdbSave</strong> 函数。<br>补充一点, 通过 bgsave 命令, 最终会走到上面的 rdbSaveBackground 函数, 而直接的 save 命令则是直接走到了 rdbSave 函数。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 真正的 RDB 文件保存</span><span class="token keyword">int</span> <span class="token function">rdbSave</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> rdbSaveInfo <span class="token operator">*</span>rsi<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> tmpfile<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/** 错误消息的当前工作目录路径 */</span>    <span class="token keyword">char</span> cwd<span class="token punctuation">[</span>MAXPATHLEN<span class="token punctuation">]</span><span class="token punctuation">;</span>     FILE <span class="token operator">*</span>fp<span class="token punctuation">;</span>    rio rdb<span class="token punctuation">;</span>    <span class="token keyword">int</span> error <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">snprintf</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">,</span><span class="token string">"temp-%d.rdb"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 创建打开一个临时文件</span>    fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 打开临时文件失败</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>cwdp <span class="token operator">=</span> <span class="token function">getcwd</span><span class="token punctuation">(</span>cwd<span class="token punctuation">,</span> MAXPATHLEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Failed opening the RDB file %s (in server root dir %s) for saving: %s"</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> cwdp <span class="token operator">?</span> cwdp <span class="token operator">:</span> <span class="token string">"unknown"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 初始化一个 rio 对象, 该对象是一个文件对象 IO</span>    <span class="token function">rioInitWithFile</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rdb<span class="token punctuation">,</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 配置判断, 通过分批将数据 fsync 到硬盘, 用来缓冲 io</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_save_incremental_fsync<span class="token punctuation">)</span>        <span class="token function">rioSetAutoSync</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rdb<span class="token punctuation">,</span>REDIS_AUTOSYNC_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// RDB_SAVE_NONE = 0 </span>    <span class="token comment">// 向文件流里面写入内容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveRio</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rdb<span class="token punctuation">,</span><span class="token operator">&amp;</span>error<span class="token punctuation">,</span>RDB_SAVE_NONE<span class="token punctuation">,</span>rsi<span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        errno <span class="token operator">=</span> error<span class="token punctuation">;</span>        <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 将缓冲区中的数据写入到文件流中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fflush</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">EOF</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token comment">// 执行多一次 fsync, 确保数据都写入到文件中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fsync</span><span class="token punctuation">(</span><span class="token function">fileno</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token comment">// 关闭文件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">EOF</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token comment">// 原子性改变 rdb 文件的名字, 如果存在同名的文件会删除</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rename</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span>filename<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 改变名字失败, 则获得当前目录路径, 发送日志信息, 删除临时文件</span>        <span class="token keyword">char</span> <span class="token operator">*</span>cwdp <span class="token operator">=</span> <span class="token function">getcwd</span><span class="token punctuation">(</span>cwd<span class="token punctuation">,</span>MAXPATHLEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span> <span class="token string">"Error moving temp DB file %s on the final destination %s (in server root dir %s): %s"</span><span class="token punctuation">,</span> tmpfile<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> cwdp <span class="token operator">?</span> cwdp <span class="token operator">:</span> <span class="token string">"unknown"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">unlink</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"DB saved on disk"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 更新 RDB 的结构</span>    server<span class="token punctuation">.</span>dirty <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>lastsave <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>lastbgsave_status <span class="token operator">=</span> C_OK<span class="token punctuation">;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>werr<span class="token operator">:</span>    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Write error saving DB on disk: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unlink</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 向文件流里面写入内容</span><span class="token keyword">int</span> <span class="token function">rdbSaveRio</span><span class="token punctuation">(</span>rio <span class="token operator">*</span>rdb<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>error<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> rdbSaveInfo <span class="token operator">*</span>rsi<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    dictIterator <span class="token operator">*</span>di <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>    <span class="token keyword">char</span> magic<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> cksum<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> processed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 开启了 RDB 文件校验码功能</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_checksum<span class="token punctuation">)</span>        rdb<span class="token operator">-></span>update_cksum <span class="token operator">=</span> rioGenericUpdateChecksum<span class="token punctuation">;</span>    <span class="token comment">// RDB_VERSION = 9</span>    <span class="token comment">// magic = REDIS0009</span>    <span class="token function">snprintf</span><span class="token punctuation">(</span>magic<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>magic<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"REDIS%04d"</span><span class="token punctuation">,</span>RDB_VERSION<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 写入 REDIS0009</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbWriteRaw</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span>magic<span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token comment">// 写入辅助字段 redis-ver, redis-bits, ctime, used-mem, 如果入参的 rsi 不为空, 再写入 repl-stream-db repl-id repl-offset, 最后写入 aof-preamble</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveInfoAuxFields</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span>flags<span class="token punctuation">,</span>rsi<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token comment">// 写入 module 相关的信息, 新版本增加的, 暂时跳过, 操作码为上面的 247</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveModulesAux</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span> REDISMODULE_AUX_BEFORE_RDB<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token comment">// 遍历数据库数量</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                redisDb <span class="token operator">*</span>db <span class="token operator">=</span> server<span class="token punctuation">.</span>db<span class="token operator">+</span>j<span class="token punctuation">;</span>        dict <span class="token operator">*</span>d <span class="token operator">=</span> db<span class="token operator">-></span>dict<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dictSize</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token comment">// 迭代器</span>        di <span class="token operator">=</span> <span class="token function">dictGetSafeIterator</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 写入 254 操作码, 也就是数据库编号</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveType</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span>RDB_OPCODE_SELECTDB<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token comment">// 写入数据库编号</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveLen</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token class-name">uint64_t</span> db_size<span class="token punctuation">,</span> expires_size<span class="token punctuation">;</span>        <span class="token comment">// 数据库数据数量</span>        db_size <span class="token operator">=</span> <span class="token function">dictSize</span><span class="token punctuation">(</span>db<span class="token operator">-></span>dict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 数据库过期数量</span>        expires_size <span class="token operator">=</span> <span class="token function">dictSize</span><span class="token punctuation">(</span>db<span class="token operator">-></span>expires<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 写入 251 操作码, 也就是 resized 相关的内容</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveType</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span>RDB_OPCODE_RESIZEDB<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveLen</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span>db_size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveLen</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span>expires_size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token comment">// 遍历数据</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>de <span class="token operator">=</span> <span class="token function">dictNext</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// key</span>            sds keystr <span class="token operator">=</span> <span class="token function">dictGetKey</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// value</span>            robj key<span class="token punctuation">,</span> <span class="token operator">*</span>o <span class="token operator">=</span> <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">long</span> <span class="token keyword">long</span> expire<span class="token punctuation">;</span>            <span class="token comment">// 把一个 sds 解析为 robj</span>            <span class="token function">initStaticStringObject</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>keystr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 过期时间</span>            expire <span class="token operator">=</span> <span class="token function">getExpire</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 写入 KeyValuePair </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveKeyValuePair</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">,</span>o<span class="token punctuation">,</span>expire<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                 <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>            <span class="token comment">// RDB_SAVE_AOF_PREAMBLE = 1, AOF_READ_DIFF_INTERVAL_BYTES = 1024*10</span>            <span class="token comment">// 通过 rdbSaveBackground() 方法到这里的 flags = RDB_SAVE_NONE = 0, 所以下面的不会执行到</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> RDB_SAVE_AOF_PREAMBLE <span class="token operator">&amp;&amp;</span> rdb<span class="token operator">-></span>processed_bytes <span class="token operator">></span> processed<span class="token operator">+</span>AOF_READ_DIFF_INTERVAL_BYTES<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                processed <span class="token operator">=</span> rdb<span class="token operator">-></span>processed_bytes<span class="token punctuation">;</span>                <span class="token function">aofReadDiffFromParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 释放迭代器</span>        <span class="token function">dictReleaseIterator</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">;</span>        di <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// rsi 从节点信息, 正常的 RDB, rsi 为 null</span>    <span class="token comment">// Redis lua 预置脚本: Redis 提供了先将 lua 脚本保存到数据库中, 同时返回一个 SHA1 的字符串, 然后客户端调用这个 SHA1 字符串就能调用到对应的 lua 脚本</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rsi <span class="token operator">&amp;&amp;</span> <span class="token function">dictSize</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>lua_scripts<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 主从配置, 才会进入到这里, 正常的 RDB 保存不会</span>        di <span class="token operator">=</span> <span class="token function">dictGetIterator</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>lua_scripts<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>de <span class="token operator">=</span> <span class="token function">dictNext</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            robj <span class="token operator">*</span>body <span class="token operator">=</span> <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 写入 aux 配置, </span>            <span class="token comment">// 先写入 250 操作符, </span>            <span class="token comment">// 再 aux 属性, key 为 lua, Value 为 server.lua_scripts 的 lua 脚本</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveAuxField</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span><span class="token string">"lua"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>body<span class="token operator">-></span>ptr<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>body<span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">dictReleaseIterator</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">;</span>        di <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token comment">// 操作码 247</span>    <span class="token comment">// 同时将 module 的配置写入</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveModulesAux</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span> REDISMODULE_AUX_AFTER_RDB<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token comment">// EOF 结束操作码 写入</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveType</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span>RDB_OPCODE_EOF<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    cksum <span class="token operator">=</span> rdb<span class="token operator">-></span>cksum<span class="token punctuation">;</span>    <span class="token comment">// 校验码获取</span>    <span class="token function">memrev64ifbe</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cksum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 写入校验码</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rioWrite</span><span class="token punctuation">(</span>rdb<span class="token punctuation">,</span><span class="token operator">&amp;</span>cksum<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>         <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>  <span class="token comment">// 写入错误</span>werr<span class="token operator">:</span>    <span class="token comment">// 保存错误码</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">*</span>error <span class="token operator">=</span> errno<span class="token punctuation">;</span>      <span class="token comment">// 如果没有释放迭代器, 则释放</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>di<span class="token punctuation">)</span> <span class="token function">dictReleaseIterator</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span></code></pre><p>上面就是整个 RDB 文件保存的过程了。至于 RDB 文件的读取, 则可以通过 rdbLoad 函数, 这里就不展开了。</p><p>从中可以看出</p><blockquote><ol><li>父进程 fork 出子进程后, 子进程里面的数据和父进程是一样的</li><li>后面在子进程将自身的数据写入到文件中, 父进程修改的数据，子进程是无感知的</li><li>基于第二步, 在子进程开始 RDB 和 RDB 结束的这段时间, Redis 宕机或者重启, 父级处理成功的部分数据会丢失</li><li>同时 RDB 不是实时触发的, 只有在某个时间段 key 变更了多少次 (配置文件配置的), 才会触发 RDB, 在没有触发的这段时间, Redis 宕机或者重启, 这部分的数据也会丢失</li></ol></blockquote><p>自此整个 Redis RDB 过程就结束了。  </p><blockquote><p>触发执行的整个过程很简单, 整段逻辑读下去基本没有什么烧脑的<br>唯一有的绕的就是数据写入时, 各种数据如何写入到文件中, 但是理解了上面的文件结构，整数规则和操作码基本可以猜测到里面的逻辑了</p></blockquote><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h2><p><a href="https://blog.csdn.net/men_wen/article/details/71248449">Redis源码剖析和注释 (十七) — RDB持久化机制</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;基于内存的 Redis, 数据都是存储在内存中的。 那么如果重启的话, 数据就会丢失。 为了解决这个问题, Redis 提供了 2 种数据持久化的方案: RDB 和 AOF。&lt;br&gt;RDB 是 Redis 默认的持久化方案。当满足一定条件的时候,</summary>
        
      
    
    
    
    
    <category term="Redis" scheme="https://github.com/Lcn29/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 命令处理过程</title>
    <link href="https://github.com/Lcn29/article/2021/1674753191/"/>
    <id>https://github.com/Lcn29/article/2021/1674753191/</id>
    <published>2021-11-29T10:41:00.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道 Redis 是一个基于内存的高性能键值数据库, 它支持多种数据结构, 提供了丰富的命令, 可以用来实现缓存、消息队列、分布式锁等功能。<br>而在享受 Redis 带来的种种好处时, 是否曾好奇过 Redis 是如何处理我们发往它的命令的呢？</p><p>本文将以<strong>伪代码</strong>的形式简单分析一下 Redis 命令处理的过程, 探讨其背后的机制。</p><h2 id="1-例子"><a href="#1-例子" class="headerlink" title="1 例子"></a>1 例子</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> myKey myValueok</code></pre><p>上面是一个简单的 Redis 命令执行过程:  </p><blockquote><ol><li>用户借助 Redis 的<strong>客户端</strong> (redis-cli, 或者各种第三方的客户端) 向 Redis <strong>服务端</strong>发送了一个 set 命令</li><li>Redis <strong>服务端</strong>将其后面的 myKey 和 myValue 存储下来</li><li>Redis <strong>服务端</strong>再向客户端响应一个 ok 值, 表示处理成功。</li></ol></blockquote><p>下面我们就以这个为例子, 来分析一下 Redis 命令处理的过程。</p><p>备注:</p><blockquote><ol><li>下面的逻辑, 是按照 <strong>Redis 5.x</strong> 的版本进行分析的, 各个大版本之间可能会有出入</li><li>在伪代码分析过程中, 会将大部分无关的逻辑和异常场景进行省略</li><li>因为整个过程会涉及到大量 <strong>Redis 事件轮询</strong>的知识和以 set 为例, 会涉及 <strong>Redis String 编码</strong>的知识, 可以先看一下往期这 2 篇先了解一下</li></ol></blockquote><h2 id="2-认识一下-redisServer-和-client"><a href="#2-认识一下-redisServer-和-client" class="headerlink" title="2 认识一下 redisServer 和 client"></a>2 认识一下 redisServer 和 client</h2><p>在真正进行分析前, 有 2 个对象需要先介绍一下, 可以说他们贯穿了整个命令处理的过程。</p><h3 id="2-1-redisServer"><a href="#2-1-redisServer" class="headerlink" title="2.1 redisServer"></a>2.1 redisServer</h3><p>redisServer 可以看做是整个 Redis 服务端运行时的上下文, 保存着整个 Redis 的配置和运行中产生的数据。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> redisServer <span class="token punctuation">&#123;</span>        <span class="token comment">// Tcp 连接对应的文件描述符 fd 存放的数组</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ipfd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 所有存入到 Redis 中的数据, 都会存放到这里</span>    redisDb<span class="token punctuation">[</span><span class="token punctuation">]</span> db <span class="token operator">=</span> <span class="token keyword">new</span> redisDb<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 命令字典, 保存着 Redis 支持的所有命令</span>    <span class="token comment">// Redis 支持的所有命令和命令对应的执行函数, 都会存放到这里</span>    dict commands<span class="token punctuation">;</span>        <span class="token comment">// 一个双向链表, 所有连接到 Redis 的客户端, 都会存放到这里</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span>client<span class="token punctuation">></span></span> clients<span class="token punctuation">;</span>        <span class="token comment">// 向 Redis 发起请求的客户端, Redis 处理完成后, 如果需要响应客户端数据</span>    <span class="token comment">// 会将这个客户端先放到这里, 后面统一响应</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span>client<span class="token punctuation">></span></span> clients_pending_write<span class="token punctuation">;</span>        <span class="token comment">// 事件循环, Redis 的核心</span>    aeEventLoop el<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="2-1-1-int-ipfd"><a href="#2-1-1-int-ipfd" class="headerlink" title="2.1.1 int[] ipfd"></a>2.1.1 int[] ipfd</h4><pre class="language-config" data-language="config"><code class="language-config">bind 127.0.0.1 </code></pre><p>上面的配置应该很熟悉吧。<br>在 Redis 的配置文件中, 加上了这个配置, 就表示 Redis 只有本地可以访问, 因为他只会监听本地机器上的的连接, 当然也可以配置具体的 Ip 地址。 </p><p>在 Redis 服务端启动后, 会和<strong>bind 指定的 Ip 地址</strong> 建立对应的 Tcp 连接, 同时会获取到一个文件描述符 fd (可以理解代表当前 Tcp 连接的唯一 Id, 持有这个文件描述符, 代表了持有了对应的端口的监听能力),<br>并将连接的 fd 存放在这个 ipfd 数组中, 最大支持 16 个连接。</p><h4 id="2-1-2-redisDb-db"><a href="#2-1-2-redisDb-db" class="headerlink" title="2.1.2 redisDb[] db"></a>2.1.2 redisDb[] db</h4><p>Redis 本身默认支持 16 个数据库, 只是我们正常情况都是在使用 0 号数据库。 可以通过 <strong>select [0 到 15]</strong> 进行切换。<br>而这个 redisDb[] db 是一个长度为 16 的数组, 每个元素都是一个 redisDb 对象, 代表着一个 Redis 数据库。</p><p>redisDb 本身的定义很简单, 如下:  </p><p><img src="https://pic.imgdb.cn/item/6562e0fdc458853aeffe9db0.png" alt="Alt &#39;redisDb 定义&#39;"></p><p>其中 dict 是字典的意思, 本身就是一个 key-value 的数据结构, 可以直接看做是一个 Map (JDK 1.7 的 HashMap), 本质是一个数组, 数组中的每个元素是一个 dictEntry。<br>当发送了 <strong>set myKey myValue</strong> 到服务端, myKey, myValue 就会以键值对的形式存储在 redisDb 中的 dict 中。</p><h4 id="2-1-3-dict-commands"><a href="#2-1-3-dict-commands" class="headerlink" title="2.1.3 dict commands"></a>2.1.3 dict commands</h4><p>首先它也是一个 dict, 也就是一个 Map, 一个 key-value 的映射属性, 具体的含义就是命令字典。</p><p>在平时中执行的 Redis 命令, 这个命令对应的执行函数就是存放在这里, 格式如: Map&lt;命令的 key, redisCommand&gt;。<br>当发送了 <strong>set myKey myValue</strong> 到服务端, 服务端就用通过 <strong>set</strong> 这个命令 key 到这里找到对应的 setCommand, 然后执行里面的函数。</p><h4 id="2-1-4-List-clients"><a href="#2-1-4-List-clients" class="headerlink" title="2.1.4 List&lt;client&gt; clients"></a>2.1.4 List&lt;client&gt; clients</h4><p>客户端双向链表。<br>Redis 本身是支持多个客户端的, Redis 接收到客户端的连接后, Redis 内部会将其封装为 client, 然后维护在这个双向链表。<br>具体的属性下面讲解。</p><h4 id="2-1-5-List-clients-pending-write"><a href="#2-1-5-List-clients-pending-write" class="headerlink" title="2.1.5 List&lt;client&gt; clients_pending_write"></a>2.1.5 List&lt;client&gt; clients_pending_write</h4><p>待响应客户端双向链表。<br>服务端处理完客户端的请求后, 可能需要响应客户端结果, 也就是响应数据。<br>而 Redis 不是处理完就立即响应的, 而是先将响应结果放到客户端的<strong>输出缓存区</strong>, 然后再后面统一一起响应。<br>所以, 有数据需要响应的客户端, 会将其放到这个链表中。</p><h4 id="2-1-6-aeEventLoop-el"><a href="#2-1-6-aeEventLoop-el" class="headerlink" title="2.1.6 aeEventLoop *el"></a>2.1.6 aeEventLoop *el</h4><p>事件轮询对象: 本质就是一个包装了多路复用的死循环。</p><p>大体的实现如下:<br><img src="https://pic.imgdb.cn/item/6562e034c458853aeffbd257.png" alt="Alt &#39;aeEventLoop 定义&#39;"></p><h3 id="2-2-client"><a href="#2-2-client" class="headerlink" title="2.2 client"></a>2.2 client</h3><p>client 是理解 Redis 命令处理过程的另一个重要对象, 他代表着一个客户端连接。<br>Redis 客户端连接到服务端时, 服务端将这个客户端的封装成这个对象。</p><p>client 本身的属性如下:</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> client <span class="token punctuation">&#123;</span>        <span class="token comment">// 同 redisServer 的 ipfd</span>    <span class="token comment">// 当 Redis 接收到客户端的连接后, 会获取到一个代表这个客户端 Tcp 连接的文件描述符 fd, 然后存放到这个属性中</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>        <span class="token comment">// 当前客户端的是否已经经过了密码认证, 0 代表未认证, 1 代表已认证</span>    <span class="token keyword">int</span> authenticated<span class="token punctuation">;</span>    <span class="token comment">// 输入缓存区, 客户端发送过来的数据会先存放在这里</span>    sds querybuf<span class="token punctuation">;</span>        <span class="token comment">// 命令参数的个数, 一个客户端发送过来的命令, 会被 Redis 拆分成多个参数</span>    <span class="token comment">// 比如 set myKey myValue, 总共 3 个参数</span>    <span class="token keyword">int</span> argc<span class="token punctuation">;</span>        <span class="token comment">// 命令参数, 一个客户端发送过来的命令, 会被 Redis 拆分成多个参数</span>    <span class="token comment">// 比如 set myKey myValue, 就会被拆分成 3 个参数, 3 个参数会存放在这个数组中</span>    robj<span class="token punctuation">[</span><span class="token punctuation">]</span> argv<span class="token punctuation">;</span>        <span class="token comment">// 一个数组, 固定输出缓冲区, 用来存放响应客户端的数据</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">16</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 一个链表, 动态输出缓冲区, 同样是用来存放响应客户端的数据</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span>clientReplyBlock<span class="token punctuation">></span></span> reply<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>下面介绍一下几个重要的属性。</p><h4 id="2-2-1-sds-querybuf"><a href="#2-2-1-sds-querybuf" class="headerlink" title="2.2.1 sds querybuf"></a>2.2.1 sds querybuf</h4><p>输入缓冲区。<br>客户端发送到服务端的数据, Redis 服务端收到了, 会先存放到这里。实现结构是一个 sds。 大体的定义如下:<br><img src="https://pic.imgdb.cn/item/6562e2b5c458853aef04f939.png" alt="Alt &#39;sds 定义&#39;"></p><h4 id="2-2-2-robj-argv"><a href="#2-2-2-robj-argv" class="headerlink" title="2.2.2 robj[] argv"></a>2.2.2 robj[] argv</h4><p>querybuf 中的数据进行解析后的数据存放的地方, 具体的属性是一个 redisObject 的数组。<br>而一个 sds 类型 redisObject 的结构如下:<br><img src="https://pic.imgdb.cn/item/6562e2b6c458853aef04ff46.png" alt="Alt ‘sds 类型的 redisObject&#39;"></p><h4 id="2-2-3-char-buf"><a href="#2-2-3-char-buf" class="headerlink" title="2.2.3 char[] buf"></a>2.2.3 char[] buf</h4><p>一个可以存放 16 * 1024 个字符的数组。 客户端发送的命令, Redis 服务端处理完成后, 需要进行响应, 而响应的内容会先存放到这里。<br>因为是一个长度固定的数组, 所以叫做<strong>固定输出缓冲区</strong>, 最多可以存放 16kb 的响应数据。</p><h4 id="2-2-4-List-reply"><a href="#2-2-4-List-reply" class="headerlink" title="2.2.4 List&lt;clientReplyBlock&gt; reply"></a>2.2.4 List&lt;clientReplyBlock&gt; reply</h4><p><strong>动态输出缓冲区</strong>。<br>当 Redis 服务端响应客户端数据大于上面的 char[] buf 的容量时, 就先放到这里 (双向链表理论上没有大小限制)。</p><p>本质是一个 clientReplyBlock 的双向链表。<br>clientReplyBlock 的定义也很简单。如下, 可以简单的看做是一个 char[] 的封装。<br><img src="https://pic.imgdb.cn/item/6562e2b2c458853aef04effc.png" alt="Alt &#39;clientReplyBlock 定义&#39;"></p><p>可以看出来, Redis 的响应缓存区是由一个固定大小的 <strong>char 数组</strong>加一个动态变化的 <strong>char 数组链表</strong>共同构成的。<br>这么组织的好处是: 16kb 的固定 buffer, 基本满足大部分的情况的使用, 提前声明好可以避免频繁分配、回收内存。<br>动态的响应链表则是起到一个兜底的作用, 保证大数据量时的响应。而本身在需要时进行再分配内存, 使用后释放, 可以起到节省内存的作用。</p><p>到此, Redis 命令处理过程中的 2 个重要对象: redisServer 和 client 就介绍完了, 只需要大体知道 2 个对象里面有哪些属性, 大体是干什么的即可,<br>怎么实现等都可以不用深入, 在开始前先介绍这 2 个对象, 只是是为了后面的分析更加清晰。</p><h2 id="3-Redis-服务端启动流程"><a href="#3-Redis-服务端启动流程" class="headerlink" title="3 Redis 服务端启动流程"></a>3 Redis 服务端启动流程</h2><pre class="language-bash" data-language="bash"><code class="language-bash">./redis-server ./redis.conf <span class="token parameter variable">--port</span> <span class="token number">6666</span> <span class="token parameter variable">--dbfilename</span> dump.rdb</code></pre><p>在服务器上可以通过上面的命令启动一个 Redis 服务端。<br>启动脚本 redis-server 后面紧跟的是 Redis 的配置文件, 再后面是用户想要指定的参数 (这里将端口修改为 6666)。</p><p>整个启动的过程如下:<br><img src="https://pic.imgdb.cn/item/6562e472c458853aef0b6a5f.png" alt="Alt &#39;Redis 服务端启动流程&#39;"></p><blockquote><ol><li>通过脚本启动 Redis 服务端</li><li>创建一个 redisServer 对象, 这时 redisServer 里面所有的配置都是默认值, 比如监听的端口, 连接超时等</li><li>读取配置文件和命令行参数并覆盖掉 redisServer 里面的默认配置, 比如这里的端口, 默认为 6379, 通过命令行参数覆盖为 6666, 在这个过程, 还会将 server.c 里面写好的命令和命令对应的函数从一个静态数组中加载到 redisServer 的 commands 字典中</li><li>将 redisServer 里面的事件轮询 aeEventLoop 创建出来</li><li>和配置文件里面的 <strong>bind 地址 + 启动端口</strong>建立起 Tcp 连接, 可以得到对应连接的文件描述 fd, 可以理解为一个 Id</li><li>为每一个文件描述符, 也就是 Tcp 连接, 在事件轮询中注册一个<strong>可读的文件事件</strong>, 执行函数为 <strong>acceptTcpHandler</strong> (可以理解为告诉多路复用, 关心对应的 Tcp 连接的连接事件, 触发了执行 acceptTcpHandler 函数)</li><li>从磁盘中将 Redis 上次运行的数据加载到 redisServer 的 16 个 redisDb 中 (如果有的话)</li><li>设置事件轮询的阻塞前和阻塞后执行的函数</li><li>启动事件轮询, 进入一个死循环, 整个 Redis 服务端启动成功</li></ol></blockquote><p>大体的伪代码逻辑如下: </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// server.c </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. redisServer 各个属性进行默认值设置</span>    <span class="token function">initServerConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 解析命令行参数</span>    <span class="token comment">// 启动脚本的参数会通过 main 方法的 argv 传递进来， 这里会对这些参数进行解析处理</span>    <span class="token function">parsingCommandLineArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3. 根据配置文件和命令行参数的配置覆盖掉 redisServer 的默认值</span>    <span class="token comment">// 内部会执行一个函数 populateCommandTable(), 将 Reids 所以支持的命令和对应的函数放到 redisServer.commands 中</span>    <span class="token function">loadServerConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 4. 初始化服务端</span>    <span class="token comment">// 4.1 创建事件轮询对象</span>    <span class="token comment">// 4.2 对所有绑定的 Ip 对应的 6666 端口(默认为 6379, 上面启动命令修改为了 6666) 开启 TCP 监听, 并得到对应的 Ip 文件描述符 fd, 存放到 redisServer 的 ipfd 中</span>    <span class="token comment">// 4.3 对 Redis 的 16 个数据库进行初始化</span>    <span class="token comment">// 4.4 向事件轮询注册 1 个时间事件: 100 毫秒执行一次, 执行函数 serverCron</span>    <span class="token comment">// 4.5 对每个 ipfd 向事件轮询注册 1 个可读的文件事件: 执行函数 acceptTcpHandler</span>    <span class="token comment">// 其他无法的省略</span>    <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 5. 从磁盘中加载数据到 redisServer 的 redisDB 中 (AOF, RDB)</span>    <span class="token function">loadDataFromDisk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 6. 向事件轮询注册 阻塞前调用函数 beforeSleep</span>    <span class="token function">aeSetBeforeSleepProc</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>beforeSleep<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 7. 向事件轮询注册 阻塞后调用函数 afterSleep</span>    <span class="token function">aeSetAfterSleepProc</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>afterSleep<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 8. 启动事件轮询, 这时进入了死循环, 整个服务端启动</span>    <span class="token function">aeMain</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 9. 从事件轮询中退出来，表示程序需要退出了, 删除事件轮询</span>    <span class="token function">aeDeleteEventLoop</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>启动后的 redisServer 的状态如下:<br><img src="https://pic.imgdb.cn/item/6562e87cc458853aef1ab4b2.png" alt="Alt &#39;Redis 服务端启动后 redisServer 的状态&#39;"></p><h2 id="4-Redis-客户端连接服务端"><a href="#4-Redis-客户端连接服务端" class="headerlink" title="4 Redis 客户端连接服务端"></a>4 Redis 客户端连接服务端</h2><p>Redis 服务端端启动后, 整个 Redis 就进入到事件轮询里面的死循环, 一直在执行下面的逻辑</p><p><img src="https://pic.imgdb.cn/item/6562e690c458853aef1391f4.png" alt="Alt &#39;Redis 服务端启动后事件轮询中执行的死循环逻辑&#39;"></p><p>这时有个客户端通过 <strong>Ip + 端口</strong>连接到 Redis 服务端, 多路复用观察到有上游关心的可读事件, 会保留下这个连接请求事件。<br>这时 redisServer 的事件轮询执行到了 <strong>从多路复用中获取事件</strong>, 获取到了客户端的连接事件, 接着触发了 acceptTcpHandler 函数。</p><p><img src="https://pic.imgdb.cn/item/6562e694c458853aef13a01d.png" alt="Alt &#39;Redis 服务端接收到客户端的连接&#39;"></p><p>触发的 acceptTcpHandler 函数的逻辑如下: </p><p><img src="https://pic.imgdb.cn/item/6562e9c3c458853aef1f6a84.png" alt="Alt &#39;Redis acceptTcpHandler 函数逻辑&#39;"> </p><blockquote><ol><li>将连接到  Redis 服务端的客户端封装为 client, 代表当前的客户端</li><li>将封装后的 client, 放到 redisServer 的客户端双写链表 List&lt;client&gt; clients 中</li><li>向事件轮询为这个客户端注册一个<strong>可读的文件事件</strong>, 触发执行的函数为 readQueryFromClient</li></ol></blockquote><p>大体的伪代码逻辑如下: </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// networking.c</span><span class="token keyword">void</span> <span class="token function">acceptTcpHandler</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 1. 获取客户端 Tcp 连接对应的文件描述符</span>    <span class="token keyword">int</span> cfd <span class="token operator">=</span> <span class="token function">anetTcpAccept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 创建 client </span>    <span class="token function">createClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3. 向事件轮询注册一个当前客户端的可读的文件事件, 执行函数为: readQueryFromClient</span>    <span class="token function">registerClientFdReadFilesEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4. 初始化 client 的属性, 比如选中的数据库默认为第一个, 输入和输出缓存区创建</span>    <span class="token function">initClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 5. 将 client 添加到 redisServer 的 client 双向链表中</span>    <span class="token function">linkClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 6. 最大客户端数量检查, 如果超过了, 就关闭这个连接 (默认为 10000) </span>    <span class="token function">maxClientNumCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 7. 保护模式检查, 默认开启 (protected-mode yes)</span>    <span class="token comment">// 开启保护模式时, 没有配置 bind Ip 和密码, 同时客户端的 Ip 地址不是 127.0.0.1 或 ::1, 就关闭这个连接</span>    <span class="token function">protectedModeCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>接受了客户端的连接后的 redisServer 的状态如下:<br><img src="https://pic.imgdb.cn/item/6562ea80c458853aef221ddf.png" alt="Alt &#39;Redis 接收到客户端的连接后 redisServer 的状态&#39;"></p><h2 id="5-客户端发送命令到服务端"><a href="#5-客户端发送命令到服务端" class="headerlink" title="5 客户端发送命令到服务端"></a>5 客户端发送命令到服务端</h2><p>Redis 的客户端和服务端之间的数据的传输, 都是遵循内部自定义的一套协议: <strong>RESP</strong>。</p><h3 id="5-1-RESP-协议"><a href="#5-1-RESP-协议" class="headerlink" title="5.1 RESP 协议"></a>5.1 RESP 协议</h3><p>当用户在客户端输入对应的请求命令时, 比如 <strong>set myKey myValue</strong>, 客户端会将这个命令转换为 RESP 协议的格式, 然后发送到服务端。</p><p>RESP 介绍的具体介绍, 可以看一下这篇<a href="https://blog.csdn.net/ldw201510803006/article/details/126093440">文章</a></p><p>所有的内容通过 <strong>\r\n</strong> 进行分割, 然后定义了几个标识符, 如下:<br><code>+</code> 标识后面是一个简单的字符串<br><code>$</code> 表示后面的内容是一个二进制安全的字符串, 后面会紧跟着一个数字, 表示字符串的长度<br><code>*</code> 表示后面的内容是一个数组, 后面同样紧跟一个数字, 表示数组的长度<br>…… 后面省略  </p><p>比如:<br><strong>set myKey myValue</strong>   </p><ol><li>三个字符串 (set + myKey + myValue), 那么转换后就是 3 个二进制安全的字符串, 所以开头就是 <code>*3</code></li><li>跟后面的内容用 \r\n 分隔, 所以就是 <code>*3\r\n</code></li><li>第一个字符串是 set, 长度 3, 所以就是 <code>*3\r\n$3\r\nset\r\n</code>  </li><li>后面的 myKey 和 myValue 类似, 最终转换后的内容如下 <code>*3\r\n$3\r\nset\r\n$5\r\nmyKey\r\n$7\r\nmyValue\r\n</code></li></ol><h3 id="5-2-请求类型"><a href="#5-2-请求类型" class="headerlink" title="5.2 请求类型"></a>5.2 请求类型</h3><p>在 Redis 解析客户端的请求内容前, 还需要确定当前的请求的方式, 判断的逻辑如下: </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 请求内容以 * 开头, 那么请求类型为 mult bulk 请求, 否则是 inline 请求</span><span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>querybuf<span class="token punctuation">[</span>c<span class="token operator">-></span>qb_pos<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    c<span class="token operator">-></span>reqtype <span class="token operator">=</span> PROTO_REQ_MULTIBULK<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    c<span class="token operator">-></span>reqtype <span class="token operator">=</span> PROTO_REQ_INLINE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到  Redis 支持 2 种请求的类型 <strong>mult bulk 请求</strong>, 还是 <strong>inline 请求</strong>。<br>2 者的区别也很简单, 以请求内容的开头是否为 * 开头进行区分。<br>以 * 开头的内容, 可以看出就是遵循 REST 协议的请求, 而其他的请求就是 inline 请求。</p><p>之所以有 inline 请求, 其实是为了兼容一下特殊的客户端, 比如 Linux 的 telnet 等。</p><p>在 Linux 可以通过 <strong>telnet Ip 端口</strong> 连接到服务端, 然后直接发送请求到服务端, 而这些请求是直接发送到服务端的, 没有中间转为 RESP 协议的。<br>所以 Redis 选择了兼容这些特殊的情况, 并将这些请求称为 inline 请求。</p><p>所以客户端发送命令到服务端的过程如下<br><img src="https://pic.imgdb.cn/item/6562ead1c458853aef233f55.png" alt="Alt &#39;Redis 客户端按照 RESP 协议转换发送请求&#39;"></p><blockquote><ol><li>Redis 客户端接收用户的输入请求</li><li>将这些请求按照 RESP 协议进行转换 (inline 请求, 不会有这一步)</li><li>将转换后的请求内容发送给 Redis 服务端</li></ol></blockquote><h2 id="6-服务端接收到客户端发送的命令"><a href="#6-服务端接收到客户端发送的命令" class="headerlink" title="6 服务端接收到客户端发送的命令"></a>6 服务端接收到客户端发送的命令</h2><p>在上面客户端连接时, 向事件轮询中为当前的客户端注册了一个<strong>可读的文件事件</strong>, 触发函数为 <strong>readQueryFromClient</strong>。<br>而在客户端将请求发送到服务端后, 事件轮询从多路复用中获取到了这个<strong>文件事件</strong>后, 会执行里面的函数 readQueryFromClient 函数。</p><p>整个 redisQueryFromClient 可以拆分为 2 部分</p><blockquote><ol><li>请求参数处理</li><li>具体请求命令的执行</li></ol></blockquote><h3 id="6-1-请求参数处理"><a href="#6-1-请求参数处理" class="headerlink" title="6.1 请求参数处理"></a>6.1 请求参数处理</h3><p>在上面我们知道, 客户端向服务端发送了一段 RESP 格式的请求 *<strong>3\r\n$3\r\nset\r\n$5\r\nmyKey\r\n$7\r\nmyValue\r\n</strong>, 服务端会</p><blockquote><ol><li>将客户端发送过来的请求 <code>*3\r\n$3\r\nset\r\n$5\r\nmyKey\r\n$7\r\nmyValue\r\n</code>, 原封不动的存储到对应 client 的<strong>输入缓冲区</strong> queryBuf<br><img src="https://pic.imgdb.cn/item/6562ebe7c458853aef2735fd.png" alt="Alt &#39;Redis redaQueryFromCLient - 存储请求&#39;"></li><li>存储在 client querybuf 的内容 <code>*3\r\n$3\r\nset\r\n$5\r\nmyKey\r\n$7\r\nmyValue\r\n</code>, 按照 RESP 协议解析为 3 个 embstr 编码的 redisObject (String 的三种编码有讲解), 然后存储到 client 的 argv 数组中。<br><img src="https://pic.imgdb.cn/item/6562ebf0c458853aef27575d.png" alt="Alt &#39;Redis redaQueryFromCLient - 命令解析&#39;"></li><li>根据 client 的参数数组 argv 的第一个参数 (第一个参数一定是命令参数) 到 redisServer 的命令字典 commands 查找当前的命令<br><img src="https://pic.imgdb.cn/item/6562ebf8c458853aef277504.png" alt="Alt &#39;Redis redaQueryFromCLient  执行命令查询&#39;"></li><li>找到命令后, 当然是执行对应的命令里面的函数了</li></ol></blockquote><p>上面是 redisQueryFromClient 第一部分, 忽略<strong>请求命令的逻辑</strong>后的简化过程, 想要继续深入了解里面的其他判断可以看一下下面的伪代码</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// networking.c</span><span class="token keyword">void</span> <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1. 先将客户端的请求数据读取到 client 的 querybuf 中</span>    <span class="token function">putRequestContentIntoClientQueryBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 如果 querybuf 中的数据超过了 1GB, 就关闭这个连接</span>    <span class="token function">checkClientQueryBufferMoreThanOneGb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3. 临时暂停这次请求, 等待后面触发, 对应的状态有</span>    <span class="token comment">// 3.1 当前的 client 的为阻塞状态 (如果 querybuf 中的数据超过了 256MB, 就将这个 client 的状态设置为 REDIS_BLOCKED)</span>    <span class="token comment">// 3.2 当前有一个 lua 脚本在执行中</span>    <span class="token comment">// 3.3 当前的客户端是准备关闭状态</span>    <span class="token comment">// 3.4 客户端被暂停了</span>    <span class="token function">temporaryPaurseThisRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4. 根据请求参数的第一个字符是否为 *, 确定当前的请求是 mult bulk 请求还是 inline 请求</span>    <span class="token function">confirmThisRequestType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 5. 根据请求类型, 对 querybuf 的参数进行解析, 然后存放到 argv </span>    <span class="token function">parseRequestContentIntoClientArgvByRequestType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 6. 命令处理</span>    <span class="token function">processCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// server.c</span><span class="token keyword">int</span> <span class="token function">processCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1. 模块过滤器, 前置处理</span>    <span class="token comment">// https://redis.io/resources/modules/</span>    <span class="token function">moduleCallCommandFilters</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. argv[0] 为 quit (断开连接)</span>    <span class="token comment">// 将客户端的标识设置为 client_close_after_reply, 等待后面的处理, 然后返回</span>    <span class="token function">ifQuitCommandHandle</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3. 根据 argv[0], 也就是 key, 从 redisServer 的 commands 中找到对应的 redisCommand, 也就是执行命令</span>    c<span class="token operator">-></span>cmd <span class="token operator">=</span> c<span class="token operator">-></span>lastcmd <span class="token operator">=</span> <span class="token function">lookupCommand</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4. 命令 null 检查和命令需要的参数格个数和实际参数个数检查, 不符合就返回错误</span>    <span class="token function">commandNullAndArgumentsNumberCheck</span><span class="token punctuation">(</span>c<span class="token operator">-></span>cmd， c<span class="token operator">-></span>argc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 5. 服务端需要密码认证, 同时当前的客户端未认证, 并且执行的命令不是 auth 命令, 返回错误</span>    <span class="token function">requirePassCheckWhenCmdNotAuth</span><span class="token punctuation">(</span>c<span class="token operator">-></span>authenticated<span class="token punctuation">,</span> c<span class="token operator">-></span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 6. 开启了集群模式, 根据 key 计算出对应的执行服务端节点, 如果当前的服务端不是执行的服务端节点, 通知客户端重定向</span>    <span class="token function">redirectClientIfNeedByKeyWhenClusterEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 7. 如果设置了最大内存同时当前没有正在执行的 lua 脚本, 就尝试释放内存</span>    <span class="token function">tryToReleaseMemoryWhenSetMaxMemoryAndNoLuaScriptTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 8. 当前是主节点, 磁盘检测失败, 执行的命令具备变更属性(新增, 修改, 删除等)或者是 ping 命令,  返回错误</span>    <span class="token comment">// 磁盘检测失败的场景</span>    <span class="token comment">// 8.1 开启了 RDB, 上一次 RDB 失败了,  同时配置了 RDB 失败停止写操作 (stop_writes_on_bgsave_error yes)</span>    <span class="token comment">// 8.2 开启了 AOF, 上一次 AOF 失败了</span>    <span class="token function">pingAndWriteCommandsDeniedByDiskErrorByMaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 9. 主从复制配置检查</span>    <span class="token comment">// 配置了 repl_min_slaves_to_write 和 repl_min_slaves_max_lag</span>    <span class="token comment">// 当前需要有多少个心跳正常的从节点存活, 否则变更属性的命令不执行, 返回错误</span>    <span class="token function">writeCommandsDeniedByMinSlavesNumberReply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 10. 当前的客户端是从节点, 并且配置了 slave_read_only, 并且执行的命令具备变更属性, 返回错误</span>    <span class="token function">writeCommandDeniedBySlaveReadOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 11. 当前的客户端是一个订阅客户端 (subscribe), 执行的命令不是 subscribe, unsubscribe, psubscribe, punsubscribe, ping, 返回错误</span>    <span class="token function">subscribeClientCanHandleCommandCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 12. 从节点和主节点失去了联系或者正在执行复制中, 同时 slave-serve-stale-data 设置为了 no, 执行的命令不是 stale 属性(info, slaveof), 返回错误</span>    <span class="token function">slaveSynchronizingOrConnectStateUnusualCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 13. 服务端正在从磁盘中加载数据, 执行的命令不是 loading 属性(info, subscribe, unsubscribe, psubscribe, punsubscribe, publish) , 返回错误</span>    <span class="token function">loadingFromDiskCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 14. 当前正在执行 lua 脚本, 执行的命令不是 auth, replconf, shutdown, script, 返回错误</span>    <span class="token function">luaScribtBusyCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 15. 开启了事务, 执行的命令不是 exec, discard, multi, watch, 返回错误</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">openTranscation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">commandIsNotExecAndDiscardAndMultiAndWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 15.1 命令入队列</span>        <span class="token function">queueMultiCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 17. 将要执行的命令, 发送给监控器</span>    <span class="token comment">// Redis 客户端可以成为服务端的监控器, 服务端执行的命令会同步传输给客户端</span>    <span class="token function">sendCommandToMonitors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 18. 对应 key 的命令函数执行, 后面会以 setCommand 为例进行分析</span>    c<span class="token operator">-></span>cmd<span class="token operator">-></span><span class="token function">proc</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 19. 如果需要，进行统计记录</span>    <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 20. 如果需要, 慢日志记录</span>    <span class="token function">slowlogPushEntryIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 21. 命令传播, 如果有必要进行命令替换</span>    <span class="token comment">// aof 和 主从复制需要当前执行的命令进行数据处理</span>    <span class="token comment">// 一些随机性的命令, 不能直接就传播出去, 需要根据当前的执行结果进行替换, 比如 SPOP key [count], 从 set 中随机弹出若干个元素</span>    <span class="token function">propagateCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="6-2-具体请求命令的执行"><a href="#6-2-具体请求命令的执行" class="headerlink" title="6.2 具体请求命令的执行"></a>6.2 具体请求命令的执行</h3><p>在 redisQueryFromClient 的逻辑中, 有一段代码</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">processCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">// 这一步就是具体的命令执行的地方, 以 set 命令为例, 了解一下 set 命令的执行过程</span>    c<span class="token operator">-></span>cmd<span class="token operator">-></span><span class="token function">proc</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><p>就是具体的请求命令的执行时机, 这里以 setCommand 为了, 这次直接看伪代码先</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// t_string.c</span><span class="token keyword">void</span> <span class="token function">setCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 上面的 c->cmd->proc(c), 最终执行到的函数就是这个</span>    <span class="token comment">// SET key value [NX] [XX] [EX &lt;seconds>] [PX &lt;milliseconds>] </span>    <span class="token comment">// 1. 根据参数计算超时时间</span>    robj <span class="token operator">*</span>expire <span class="token operator">=</span> <span class="token function">calExpireTime</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">,</span> c<span class="token operator">-></span>argc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 尝试对 value 进行字符串的编码优化</span>    <span class="token comment">// 2.1 编码不是 embstr 和 raw, 就直接返回原数据, 不是字符串类型, 没必要优化</span>    <span class="token comment">// 2.2 value 长度小于 20, 同时可以转为整数</span>    <span class="token comment">// 2.2.1 没有配置最大内存, 同时内存回收策略不是 MAXMEMORY_FLAG_NO_SHARED_INTEGERS (涉及 lru/lfu 这 2 种模式的回收策略), </span>    <span class="token comment">// 转换的数字大于等于 0, 小于 10000, 返回共享整数池中返回这个数字, 都不满足, 新建一个整数</span>    <span class="token comment">// 2.2.2 原本的 reidsObject 的编码为 raw, 将入参的 redisObject 转为 int 编码, *ptr 修改为转换后的整数值</span>    <span class="token comment">// 2.2.3 原本的 reidsObject 的编码为 embstr, 重新创建一个新的 int 编码的 redisObject</span>    <span class="token comment">// 2.2 逻辑结束 下面为 2.2 不满足情况</span>    <span class="token comment">// 2.3 入参的 redisObject 内容长度小于等于 44, 重新创建一个 embstr 的字符串, 将入参的 redisObject 转为 embstr 编码,  *ptr 修改为转换后的整数值</span>    <span class="token comment">// 2.3 逻辑结束 下面为 2.3 不满足情况</span>        <span class="token comment">// 2.4 到了这里, 说明客户端传过来的 value 大于 44, 只能用 raw 编码, 但是 raw 编码还可以 尝试进行 trim 优化, 也就是去空格</span>    c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">tryObjectEncoding</span><span class="token punctuation">(</span>c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3. 将 key 和 value 存放到 当前客户端选择的 redisDb[] db 中</span>    <span class="token function">putTheKeyAndValueToDb</span><span class="token punctuation">(</span>c<span class="token operator">-></span>db<span class="token punctuation">,</span> c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4. 如果设置了参数时间, 将更新 redisObject 的 expireTime</span>    <span class="token function">setExpireTimeIfNeed</span><span class="token punctuation">(</span>c<span class="token operator">-></span>db<span class="token punctuation">,</span> c<span class="token operator">-></span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> expire<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 5. 如果需要, 将当前的客户端放到 redisServer 的 pending_write_clients 中, 表明当前的客户端有数据需要响应</span>    <span class="token function">putCurrentClientToClientsPendingWriteIfNeed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 6. 将响应内容 +OK\r\n (响应结果也遵循 RESP 协议) 写入到客户端的 buf 中, 无法写入就写入到客户端的 reply</span>    <span class="token function">tryWriteResponseToBufOrReply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 7. 当写入的内容是写入到 reply 中时, 需要检查当前客户端待响应的内容的大小是否超过了限制, 是的话, 关闭当前客户端</span>    <span class="token function">checkClientOutputBufferLimitsWhenWriteToReply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>逻辑概括如下:</p><blockquote><ol><li>根据参数计算超时时间, Redis 的 set 命令支持很多种参数格式, 需要根据这些参数计算出一个当前 String 的过期时间 (如果有设置的话)</li><li>参数数组 argv[2], 一定是要存入到 Redis 的 value, 当前的 value 虽然已经是 redisObject 了, 但如果它是 embstr 和 raw, 尝试寻找更合适的编码 (这一部分都是 Redis String 编码的内容)<br><img src="https://pic.imgdb.cn/item/6562ecbcc458853aef2a32dc.png" alt="Alt &#39;Redis setCommand  重编码尝试过程&#39;"></li><li>将处理好的 myKey 和 myValue 存到 redisServer 的 redisDb 数组中的第一个 (如果使用前, 通过 select 修改了使用的数据库, 那么存在对应的数据库, 默认为 0, 第一个)<br><img src="https://pic.imgdb.cn/item/6562ecc4c458853aef2a4d31.png" alt="Alt &#39;Redis setCommand  保存对象过程&#39;"></li><li>如果有必要, 对 redisObject 的过期时间的进行更新</li><li>数据处理完了, 当前的命令如果有数据需要响应客户端时, 需要将当前客户端放到 redisServer 的待响应客户端双向链表 clients_pending_write 中, set 命令处理完需要响应一个 ok, 所以当前 client 需要加入这个链表<br><img src="https://pic.imgdb.cn/item/6562eccdc458853aef2a6beb.png" alt="Alt &#39;Redis setCommand  客户端加入待响应客户端双向链表&#39;"></li><li>如果有数据需要响应, 将响应的数据放到 client 的固定输出缓冲区 <strong>char buf[]</strong> 中, 如果无法直接存放进去, 则存放到动态输出缓冲区 <strong>List<clientReplyBlock> reply</strong> 中, set 回应的是 ok, 经过 RESP 协议后假设可以直接放到固定输出缓冲区<br><img src="https://pic.imgdb.cn/item/6562ecd6c458853aef2a8bdb.png" alt="Alt &#39;Redis setCommand  响应结果写入缓冲区&#39;"></li></ol></blockquote><p>服务端接收到客户端发送的命令并处理后, redisServer 的状态如下:<br><img src="https://pic.imgdb.cn/item/6562efb8c458853aef3512b4.png" alt="Alt &#39;Redis 服务端接收到客户端发送的命令后 redisServer 状态&#39;"></p><p>此时 client 的状态如下:<br><img src="https://pic.imgdb.cn/item/6562f46ac458853aef458b27.png" alt="Alt &#39;Redis 服务端接收到客户端发送的命令后 client 状态&#39;"></p><h2 id="7-服务端响应客户端"><a href="#7-服务端响应客户端" class="headerlink" title="7 服务端响应客户端"></a>7 服务端响应客户端</h2><p>存放在 client 的输出缓冲区的数据, 是什么时候发送给客户端的呢?<br>在 Redis 里面是经过 2 个步骤实现的</p><blockquote><ol><li>为每一个待发送的客户端注册一个可写的文件事件, 执行函数为 sendReplyToClient</li><li>事件轮询获取这个可写事件并触发 sendReplyToClient 函数</li></ol></blockquote><h3 id="7-1-为待发送的客户端注册发送数据的文件事件"><a href="#7-1-为待发送的客户端注册发送数据的文件事件" class="headerlink" title="7.1 为待发送的客户端注册发送数据的文件事件"></a>7.1 为待发送的客户端注册发送数据的文件事件</h3><p>Redis 服务端端启动后, 整个 Redis 就进入到事件轮询里面的死循环, 一直在执行下面的逻辑</p><p>!<img src="https://pic.imgdb.cn/item/6562e690c458853aef1391f4.png" alt="Alt &#39;Redis 服务端启动后事件轮询中执行的死循环逻辑&#39;"></p><p>而这次在<strong>阻塞前 beforesleep 函数执行</strong> 时, 在 beforesleep 函数中会:<br>遍历 redisServer 的待响应客户端双向链表 clients_pending_write 中的所有客户端, </p><blockquote><ol><li>将对应的客户端从双向链表删除</li><li>删除的客户端如果有数据要发送, 为他在多路复用各注册一个可写的文件事件, 触发函数 sendReplyToClient</li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/6562f2d4c458853aef400eda.png" alt="Alt &#39;Redis 服务端注册发送数据文件事件&#39;"></p><p>对应的地方为 beforeSleep 函数逻辑如下:</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// server.c</span><span class="token keyword">void</span> <span class="token function">beforeSleep</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">// 处理带有输出缓冲区的客户端</span>    <span class="token function">handleClientsWithPendingWrites</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">handleClientsWithPendingWrites</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    client <span class="token operator">*</span>c    <span class="token comment">// 1. 遍历 redisServer 的 clients_pending_write </span>    <span class="token keyword">while</span><span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token function">getNextNodeFromLinkList</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 将当前的 client 从 clients_pending_write 链表中删除</span>        <span class="token function">removeTheClientFromeClientsPendingWrite</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 当前的客户端有数据需要发送 (client->buf 或 client->reply 不为空),</span>        <span class="token comment">// 向多路复用注册一个可写的文件事件, 执行函数为 sendReplyToClient</span>        <span class="token function">registFileEventForClientWhenClientHaveDataToWrite</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="7-2-触发发送数据的文件事件"><a href="#7-2-触发发送数据的文件事件" class="headerlink" title="7.2 触发发送数据的文件事件"></a>7.2 触发发送数据的文件事件</h3><p>事件轮询在执行完阻塞前函数后, 又进入到多路复用中获取文件事件, 这时会获取到刚刚注册的可写事件文件, 触发 sendReplyToClient 的逻辑, 过程如下:</p><p><img src="https://pic.imgdb.cn/item/6562f2dbc458853aef4026ca.png" alt="Alt &#39;Redis 服务端响应客户端过程&#39;"></p><blockquote><ol><li>逐步将 client 的缓冲区推送给客户端 (单次推送数据有上限要求, 超过的需要到下次事件轮询再推送)</li><li>client 推送数据完成, 将其对应的文件事件从多路复用中删除 (如果还有数据没推送, 事件不会被删除, 下次事件轮询还能触发, 推送剩下的)</li></ol></blockquote><p>具体的逻辑如下:</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// networking.c</span><span class="token keyword">void</span> <span class="token function">sendReplyToClient</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//  client 的输出缓冲区有数据需要发送</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// client 的 buf 有数据需要发送</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clientBufHasDataToSend</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">writeDataToClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果 client 的 reply 有数据, 获取链表的第一个节点, 将里面的数据发送给客户端, 同时从双写链表中删除这个节点</span>            <span class="token function">writeDataToClientIfClientReplyHasData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 当前已经发送的数据达到了单次发送的上线 1024*64</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">currentHaveSendMoreThanMaxLimit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 没有设置最大内存, 当前发送数据停止</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">noSetMaxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 设置了最大内存, 当前已经使用的内存大小小于最大内存, 当前发送数据停止</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">haveSetMaxMemoryAndCurrentUsedMemoryLessThanMaxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 设置了最大内存了, 当前使用的内存大于等于最大内存了, 继续循环, 尽量多发送一些, 释放内存</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 当前 client 没有数据需要发送了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 从事件轮询中删除当前的发送数据事件</span>        <span class="token function">delCurrentFileEventFromEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// client 还有数据, 那么不删除事件, 继续保留, 下次事件轮询执行, 继续执行</span></code></pre><p>需要留意的是执行一个 sendReplyToClient 函数, 给这个客户端推送数据</p><blockquote><ol><li>每次个客户端推送数据最大为 1024 * 64, 超过了会停止这次推送, 将剩下的留到下次再继续推送 (伪代码里面表明了一些特殊情况了)</li></ol></blockquote><p>至此</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> myKey myValueok</code></pre><p>一个完整的流程就结束了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;我们知道 Redis 是一个基于内存的高性能键值数据库, 它支持多种数据结构, 提供了丰富的命令, 可以用来实现缓存、消息队列、分布式锁等功能。&lt;br&gt;而在享受 Redis 带来的种种好处时, 是否曾好奇过 Redis</summary>
        
      
    
    
    
    
    <category term="Redis" scheme="https://github.com/Lcn29/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis SkipList 编码</title>
    <link href="https://github.com/Lcn29/article/2021/3671033365/"/>
    <id>https://github.com/Lcn29/article/2021/3671033365/</id>
    <published>2021-11-29T01:33:09.000Z</published>
    <updated>2024-10-10T11:58:04.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-跳表的特点"><a href="#1-跳表的特点" class="headerlink" title="1 跳表的特点"></a>1 跳表的特点</h2><p>在 <strong>Redis 5.x</strong> 的源码中,  zset (order set) 的编码为 ziplist 或 skiplist (Redis 6.0 后变为 listpack 或 dict + skiplist)。</p><p>skiplist 的特点</p><blockquote><ol><li>本身是一种<strong>空间换时间</strong>的<strong>有序</strong>数据结构</li><li>本身可以达到了<strong>二分查找</strong>的效果, 时间复杂度在 O(log n), 最坏 O(n), 和平衡树一样</li><li>实现逻辑简单, 数据变更时, 数据的再平衡 (有序) 比平衡树简单很多</li></ol></blockquote><p>而 skiplist 本质可以看作是一个<strong>有序链表</strong>, 保留着链表的变更简单, 同时通过空间换时间的方式提升查询的效率。</p><p>注: 下面的分析也是按照 <strong>Redis 5.x</strong> 进行分析。</p><h2 id="2-跳表的查询"><a href="#2-跳表的查询" class="headerlink" title="2 跳表的查询"></a>2 跳表的查询</h2><p>既然 skiplist 是本质是一个有序链表, 我们先简单的了解一下有序链表。</p><p><img src="https://pic.imgdb.cn/item/655382f8c458853aefbf63a9.png" alt="Alt &#39;有序链表&#39;"></p><p>如上图, 是一个简单的有序链表。<br>所有的数据按照升序&#x2F;降序的方式组织在一起, 每个节点都有一个指向下一个节点的指针, 最后一个节点指向了 null。</p><p>如果需要从当前的链表中查找 22, 从第一个节点开始一直往下找 1 -&gt; 4 -&gt; 6 -&gt; 19 -&gt; 22, 需要经过 5 个节点。</p><p>有没有办法加速这个查询的过程吗?   </p><p>制定一个这样的规则: </p><blockquote><ol><li>从当前的链表随机选择几个节点重新构成一个新的有序链表</li><li>第一个节点必定被选中</li></ol></blockquote><p>假设, 原本的有序链表, 变成了如下:  </p><p><img src="https://pic.imgdb.cn/item/65538443c458853aefc4c1cc.png" alt="Alt &#39;双层有序链表&#39;"></p><p>这时, 可以从新的链表中查找 22, 同样从第一个节点开始找 1 -&gt; 6 -&gt; 19 -&gt; 22,  经过链表的节点少了, 这次只需要经过 4 个节点。</p><p>这样可以加速查找, 那么是否可以以新的链表为原型, 按照相关的规则, 再次构建一条更短的有序链表</p><p>假设, 这时的有序链表变为</p><p><img src="https://pic.imgdb.cn/item/655384afc458853aefc67fd3.png" alt="Alt &#39;三层有序链表&#39;"></p><p>这时, 同样是查询 22, 只需要经过 2 个节点 (1 -&gt; 22)</p><p>制定这样的规则, 现在看起来可以加速查询的效率, 但是有个问题: <strong>要查找的数据不在新建的链表中</strong>。</p><p><img src="https://pic.imgdb.cn/item/655384afc458853aefc67fd3.png" alt="Alt &#39;三层有序链表&#39;"></p><p>还是这张图, 假设现在我们现在需要查找的数据是 54。<br>这时如果直接从先建的第 2 条链表中查找, 是查询不到的, 但是 54 实际是存在的。</p><p>所以需要继续追加规则</p><blockquote><ol start="3"><li>新增<strong>层</strong>的概念, 同一条链表为同一层, 原始的链表为 0 层 (也可以定为 1 层), 逐层递增</li></ol></blockquote><p>那么最新的链表变为:  </p><p><img src="https://pic.imgdb.cn/item/6553856dc458853aefc99fbf.png" alt="Alt &#39;明确三层分离的有序链表&#39;"></p><p>再加一条规则</p><blockquote><ol start="4"><li>通过 0 层产生的节点之间是一个整体, 一个整体内, 高层的节点可以下降到低一层的节点, 但是无法往上升</li></ol></blockquote><p>最新的链表又变成如下:  </p><p><img src="https://pic.imgdb.cn/item/655385dbc458853aefcb7b00.png" alt="Alt &#39;明确三层分离和节点有序链表&#39;"></p><p>加两条查询的规则</p><blockquote><ol start="5"><li>查找数据时, 必须从最高层开始找</li><li>查找过程中, 通过和同一层的后一个元素比较大小, 决定在同一层继续往后找, 还是在同一个整体的下一层</li></ol></blockquote><p><img src="https://pic.imgdb.cn/item/65538635c458853aefcd229f.png" alt="Alt &#39;简易跳表查询&#39;"></p><p>在最新的链表中, 查找 54 时, 过程如下:  </p><blockquote><ol><li>从最高层的的第 1 个节点开始, 也就是第 2 层的第 1 个节点 1 开始</li><li>此时第 2 层第 1 个节点 1 的后一个节点为 22, 查找的数字比 22 大, 跳到同一层的下一个节点 22</li><li>此时到了第 2 层第 2个节点 22, 它的后一个节点为 null, 只能下到自己的下一层的节点, 也就是第 1 层的第 4 个节点 22</li><li>此时到了第 1 层第 4 个节点 22 , 同样后一个节点为 null, 只能下到自己的下一层的节点, 也就是第 1 层的第 5 个节点 22</li><li>此时到了第 0 层第 5 个节点 22 , 后一个节点为 54, 找到了</li></ol></blockquote><p>此时经过的节点为 1 -&gt; (22, 22, 22, 一个整体的 3 层) -&gt; 54, 可以看作经过了 5 个节点。<br>看起来和直接查找 1 -&gt; 4 -&gt; 6 -&gt; 19 -&gt; 22 -&gt; 54 的 5 个节点一样。 </p><p>但是在实际中, 一个整体的几个层的节点可以用数组进行组织, 达到随机访问的效果, 也就是这里实际是 3 个节点的。</p><p>最后的结构基本就是跳表结构的雏形, 从中可以大体到跳表的结构的性质, 这里对跳表结构做一个定义</p><blockquote><ol><li>跳表本质是一个有序的单向链表</li><li>链表中的每个节点除了存放自己的排序值, 还有若干个<strong>层</strong>节点, 层节点存储着当前节点的排序值, 和同一层的下一个节点或者 null </li><li>查询时, 从第一个节点的最高层开始, 通过比较当前层的下一个节点, 确定是在往同一层的下一个节点, 还是同一个节点的下一层查询</li></ol></blockquote><h2 id="3-Redis-对跳表的实现"><a href="#3-Redis-对跳表的实现" class="headerlink" title="3 Redis 对跳表的实现"></a>3 Redis 对跳表的实现</h2><p>具体的源码可以查看 <strong>t_zset.c</strong> 这个文件。  </p><h3 id="3-1-跳表中的几个对象的定义"><a href="#3-1-跳表中的几个对象的定义" class="headerlink" title="3.1 跳表中的几个对象的定义"></a>3.1 跳表中的几个对象的定义</h3><h4 id="3-1-1-跳表本身的定义"><a href="#3-1-1-跳表本身的定义" class="headerlink" title="3.1.1 跳表本身的定义"></a>3.1.1 跳表本身的定义</h4><p><img src="https://pic.imgdb.cn/item/655387c2c458853aefd3dac5.png" alt="Alt &#39;SkipList 声明&#39;"></p><p>可以看到跳表本身的定义很简单</p><blockquote><ol><li>header 跳表的头节点</li><li>tail 跳表的尾节点</li><li>length 跳表中第一层 (数据最完整的) 的节点长度</li><li>level 跳表中节点中的最高层数</li></ol></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplist</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 跳表的头节点 和 跳表的尾节点</span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>header<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>    <span class="token comment">// 跳表的节点长度, 只算第一层的节点</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>    <span class="token comment">// 跳表的节点中的最高层数</span>    <span class="token keyword">int</span> level<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> zskiplist<span class="token punctuation">;</span></code></pre><h4 id="3-1-2-跳表中的节点定义"><a href="#3-1-2-跳表中的节点定义" class="headerlink" title="3.1.2 跳表中的节点定义"></a>3.1.2 跳表中的节点定义</h4><p><img src="https://pic.imgdb.cn/item/65538837c458853aefd5c67f.png" alt="Alt &#39;SkipNode 声明&#39;"></p><p>节点的定义也很简单</p><blockquote><ol><li>ele 节点存储的数据</li><li>score 节点的分值</li><li>backward 节点的前置节点, 主要用于从表尾向表头遍历时使用</li><li>levels 跳表的特点, 层节点</li></ol></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 节点存储的数据</span>    sds ele<span class="token punctuation">;</span>    <span class="token comment">// 当前节点的分值</span>    <span class="token keyword">double</span> score<span class="token punctuation">;</span>    <span class="token comment">// 当前节点的前置节点, 也就是前一个节点</span>    <span class="token comment">// 主要用于从表尾向表头遍历时使用</span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>backward<span class="token punctuation">;</span>    <span class="token comment">// 当前节点层节点    </span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> levels<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>zskiplistNode<span class="token punctuation">;</span></code></pre><h4 id="3-1-3-跳表节点中的层定义"><a href="#3-1-3-跳表节点中的层定义" class="headerlink" title="3.1.3 跳表节点中的层定义"></a>3.1.3 跳表节点中的层定义</h4><p><img src="https://pic.imgdb.cn/item/65538921c458853aefd99647.png" alt="Alt &#39;SkipListLevel 声明&#39;"></p><p>层节点的定义</p><blockquote><ol><li>forward 当前层节点指向的下一个跳表节点</li><li>span 当前跳表节点和 forward 所指的跳表节点之间跳过了多少个节点</li></ol></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 当前层节点指向的下一个跳表表节点, 不是具体的层节点</span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span>    <span class="token comment">// 以第一层为标准 (第一层数据是最全的, 有多少数据, 第一层就有多少个节点)</span>    <span class="token comment">// 当前层节点指向的链表节点, 中间跳过了多少个跳表节点 </span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> span<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> zskiplistLevel<span class="token punctuation">;</span></code></pre><p>span 的定义了解</p><p>假设现在有一个跳表如下</p><p><img src="https://pic.imgdb.cn/item/65538bdfc458853aefe5b6d2.png" alt="Alt &#39;分析 Span 的跳表&#39;"></p><p>跳表中有 4 个节点 (头节点不算), 分别存储了 A, B, C, D, 每个节点上面的 L 代表了层节点, 括号里面的数字就是 span 的值。</p><p>SkipListNode-1 这个节点的 L4 层, 下一个节点为 null, 到达 null 中间跨过了 SkipListNode-2, SkipListNode-3, SkipListNode-4, null 本身, 总共 4 个节点,  所以 SkipListNode-1 的 L4 层的 span 为 4。  </p><p>同理 SkipListNode-1 节点的 L3 层, 下一个节点为 SkipListNode-3, 中间跨过了 SkipListNode-2, SkipListNode-3 本身, 所以对应的 span 为 2。</p><p>到这里, 可以理解层节点的 span 的含义: 当前跳表节点和 forward 所指的跳表节点 (也就是下一个跳表节点) 之间跨过了多少个节点, 跨过的节点本身也算是一个节点。</p><h3 id="3-2-创建一个跳表对象"><a href="#3-2-创建一个跳表对象" class="headerlink" title="3.2 创建一个跳表对象"></a>3.2 创建一个跳表对象</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 跳表创建 * @return 创建的跳表 */</span>zskiplist <span class="token operator">*</span><span class="token function">zslCreate</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>    <span class="token comment">// 为 zskiplist 分配内存, 可以看为 Java 中的 new zskiplist()</span>    zsl <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>zsl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 当前跳表的最大层高, 默认为 1, 头节点不算</span>    zsl<span class="token operator">-></span>level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 当前跳表的节点长度, 默认为 0, 头节点不算</span>    zsl<span class="token operator">-></span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 创建头节点</span>    <span class="token comment">// ZSKIPLIST_MAXLEVEL, 跳表中节点的最大层数, 默认为 32</span>    zsl<span class="token operator">-></span>header <span class="token operator">=</span> <span class="token function">zslCreateNode</span><span class="token punctuation">(</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 初始头节点的所有层节点的数据</span>    <span class="token comment">// 下一个链表节点为 null, 跳过的节点 span = 0</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> ZSKIPLIST_MAXLEVEL<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        zsl<span class="token operator">-></span>header<span class="token operator">-></span>level<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        zsl<span class="token operator">-></span>header<span class="token operator">-></span>level<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 头节点的前置节点为 NULL</span>    zsl<span class="token operator">-></span>header<span class="token operator">-></span>backward <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">// 跳表的尾节点设置为 NULL</span>    zsl<span class="token operator">-></span>tail <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> zsl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 创建链表节点 * @param level 创建的节点的层高 * @param score 创建的节点的分值 * @param ele   创建的节点的内容 * @return 创建的节点 */</span>zskiplistNode <span class="token operator">*</span><span class="token function">zslCreateNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">double</span> score<span class="token punctuation">,</span> sds ele<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 为跳表的节点分配内存</span>    zskiplistNode <span class="token operator">*</span>zn <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>zn<span class="token punctuation">)</span><span class="token operator">+</span>level<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置跳表节点的分数为入参的 score, 内容为入参的 ele</span>    zn<span class="token operator">-></span>score <span class="token operator">=</span> score<span class="token punctuation">;</span>    zn<span class="token operator">-></span>ele <span class="token operator">=</span> ele<span class="token punctuation">;</span>    <span class="token keyword">return</span> zn<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/65538a31c458853aefde125d.png" alt="Alt &#39;初始跳表&#39;"></p><p>从图中可以看到, Redis 跳表的初始状态</p><blockquote><ol><li>Redis 中限制了节点的层高最大为 32 层 (层数会消耗空间的, 需要有一个合理的限制值)</li><li>跳表的头节点, 默认就是一个最大层高的节点, 但是里面所有内容都指向了 null</li></ol></blockquote><p>这个逻辑很简单, 创建了一个层高 32 的跳表节点, 跳表的头节点执行这个节点, 没了, 节点内的数据都为默认值。</p><h3 id="3-3-向跳表添加第一个元素"><a href="#3-3-向跳表添加第一个元素" class="headerlink" title="3.3 向跳表添加第一个元素"></a>3.3 向跳表添加第一个元素</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 向跳表中新增一个节点 * @param zsl 新增节点的跳表 * @param score 分值 * @param ele  内容  */</span>zskiplistNode <span class="token operator">*</span><span class="token function">zslInsert</span><span class="token punctuation">(</span>zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">,</span> <span class="token keyword">double</span> score<span class="token punctuation">,</span> sds ele<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// update 保存的是新增节点每一层的前一个节点 (也就是这个节点的下一个节点就是新增的节点)</span>    zskiplistNode <span class="token operator">*</span>update<span class="token punctuation">[</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token comment">// rank[i] 存储的是头节点到 update[i] 的中间跨过的跳表节点</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> rank<span class="token punctuation">[</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> level<span class="token punctuation">;</span>    <span class="token function">serverAssert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isnan</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        x <span class="token operator">=</span> zsl<span class="token operator">-></span>header<span class="token punctuation">;</span>        <span class="token comment">// zsl->level 为当前跳表除头结点外的最大层数</span>    <span class="token comment">// 1. 通过遍历跳表, 找到新增节点的应该保存的位置 </span>    <span class="token comment">// 从头节点的这个最大层数出发, 向后或向下遍历, 找到新增节点时, 每一层的前一个节点, 同时记录头节点到这个前一个节点的跨过的节点数</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-></span>level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// for 循环控制同一个节点的下层遍历, 也就是向下遍历</span>        <span class="token comment">// 下面的 while 循环控制同一层的遍历, 也就是向后遍历</span>                        <span class="token comment">// 把上一层经过的跨过节点数继承下来, 然后加上这一层后面的节点(有的话), 就是这一层真正跨过的节点数</span>        <span class="token comment">// 从 for 循环进来, level - 1, 也就是向下遍历, 向下遍历前的节点和向下遍历达到的节点, 只是层数不一样, 实际还是同一个节点,</span>        <span class="token comment">// 所以原本节点的上一层的跨过的节点数继承下来, 再加上这一层后面处理的节点数, 就是这一层真正跨过的节点数</span>        rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">==</span> <span class="token punctuation">(</span>zsl<span class="token operator">-></span>level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> rank<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 先比较分数, 分数相同的话, 再比较内容</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward             <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">&lt;</span> score <span class="token operator">||</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">==</span> score <span class="token operator">&amp;&amp;</span> <span class="token function">sdscmp</span><span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>ele<span class="token punctuation">,</span>ele<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span<span class="token punctuation">;</span>            x <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 新增位置的前一个节点就是 x 了</span>        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 2. 通过随机函数, 获取新增节点的层高, 如果随机出来的层高比现在的最大的层高还高, 多对出来的层进行初始化</span>    level <span class="token operator">=</span> <span class="token function">zslRandomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 随机出来的层高比现在的层高还高的话</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>level <span class="token operator">></span> zsl<span class="token operator">-></span>level<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-></span>level<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> zsl<span class="token operator">-></span>header<span class="token punctuation">;</span>            update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">=</span> zsl<span class="token operator">-></span>length<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 更新最高层数</span>        zsl<span class="token operator">-></span>level <span class="token operator">=</span> level<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 3. 创建新增节点, 保存到跳表表中</span>    x <span class="token operator">=</span> <span class="token function">zslCreateNode</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span>score<span class="token punctuation">,</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 链表的基本操作, 修改节点的上下一个节点</span>        x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">=</span> update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token comment">// 更新新增节点每一层的 span, 也就是新增节点的每一层到下一个节点所跨过的节点数</span>        <span class="token comment">// 从上面的 for 循环可以看出, rank[i] 保存的是头节点到 update[i] 节点, 中间经过的节点数</span>        <span class="token comment">// rank[0] 第一层, update[0] 的下一个节点就是新增的节点, 中间是没有跨过任何其他节点的</span>        <span class="token comment">// rank[0] - rank[i], 可以得到 update[i] 到新增节点中间跨过的节点数</span>        <span class="token comment">// 这时 update[i] 对应层的 span 减去 上一步计算出来的节点就是新增节点的 span 了</span>        x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">=</span> update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">-</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">=</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 4. 更新插入节点的前置节点的其他层的跨度</span>    <span class="token comment">// 上面的 zslRandomLevel() 可能随机出一个比原本层高还低的层数</span>    <span class="token comment">// 这时新增了一个节点, 那么原本在新增节点前面的节点的 span 都要加 1</span>    <span class="token comment">// 小于等于随机出来的 level 的在上一步处理了,  大于随机出的 level, 但是小于原本的 level 的, 这里处理</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> level<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> zsl<span class="token operator">-></span>level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 5. 确定新增节点的前一个节点</span>    x<span class="token operator">-></span>backward <span class="token operator">=</span> <span class="token punctuation">(</span>update<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> zsl<span class="token operator">-></span>header<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">NULL</span> <span class="token operator">:</span> update<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 6. 更新跳表的头尾节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">)</span>        x<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>backward <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">else</span>        zsl<span class="token operator">-></span>tail <span class="token operator">=</span> x<span class="token punctuation">;</span>    zsl<span class="token operator">-></span>length<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 返回一个随机值, 用于确定节点的层高 * 规则: 层数越高的概率越低 * 设负载因子 ZSKIPLIST_P = p, 这里等于 0.25 * 第 n 层的概率为 = p ^ (n - 1) * (1 - p) * 第一层   = 0.25 ^ (1 - 1)  * (1 - 0.25) = 0.25 * 第二层   = 0.25 ^ (2 - 1)  * (1 - 0.25) = 0.1875 * 第三层   = 0.25 ^ (3 - 1)  * (1 - 0.25) = 0.140625 * ... * 第三十二层 = 0.25 ^ (32 - 1) * (1 - 0.25) = 0.000000000 */</span><span class="token keyword">int</span> <span class="token function">zslRandomLevel</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 层数最低为 1</span>    <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 0xFFFF = 0000 0000 0000 0000 1111 1111 1111 1111</span>    <span class="token comment">// ZSKIPLIST_P = 0.25f</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>ZSKIPLIST_P <span class="token operator">*</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        level <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// </span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>level <span class="token operator">&lt;</span> ZSKIPLIST_MAXLEVEL <span class="token punctuation">)</span> <span class="token operator">?</span> level <span class="token operator">:</span> ZSKIPLIST_MAXLEVEL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://pic.imgdb.cn/item/65538d4ac458853aefebdd82.png0" alt="Alt &#39;分析跳表新增&#39;"></p><p>假设现在有一个跳表如上, 需要往里面新增一个 score &#x3D; 4 的节点, 这个节点的层高不定, 层节点里面的下一个节点和跨节点数不确定</p><blockquote><ol><li>新增节点在绿色节点的后面</li><li>新增节点的层高不确定, 但是可以知道, 新增节点时, 前 5 层的上一个节点分别为 Node2, Node2, Node2, Node1, Node1, 这些数据就存在了 update[] 数组中</li><li>确定了 update[] 时, 那么也可以确定头节点到这些节点跨过的节点数: 3, 3, 3, 1, 1 这些数据存在 rank[] 数组中</li></ol></blockquote><pre class="language-c" data-language="c"><code class="language-c">zskiplistNode <span class="token operator">*</span><span class="token function">zslInsert</span><span class="token punctuation">(</span>zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">,</span> <span class="token keyword">double</span> score<span class="token punctuation">,</span> sds ele<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-></span>level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">==</span> <span class="token punctuation">(</span>zsl<span class="token operator">-></span>level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> rank<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward             <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">&lt;</span> score <span class="token operator">||</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">==</span> score <span class="token operator">&amp;&amp;</span> <span class="token function">sdscmp</span><span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>ele<span class="token punctuation">,</span>ele<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span<span class="token punctuation">;</span>            x <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>就是为了计算出上面 update 和 rank 的数据。</p><h3 id="3-4-指定范围的查询"><a href="#3-4-指定范围的查询" class="headerlink" title="3.4 指定范围的查询"></a>3.4 指定范围的查询</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 从跳表中找到第一个符合范围的节点 * @param zsl 跳表 * @param range 范围 */</span>zskiplistNode <span class="token operator">*</span><span class="token function">zslFirstInRange</span><span class="token punctuation">(</span>zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">,</span> zrangespec <span class="token operator">*</span>range<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    zskiplistNode <span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token comment">// 判断跳表的分值是否包含了查询范围内的值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">zslIsInRange</span><span class="token punctuation">(</span>zsl<span class="token punctuation">,</span>range<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    x <span class="token operator">=</span> zsl<span class="token operator">-></span>header<span class="token punctuation">;</span>    <span class="token comment">// 从头节点出发, 找到第一个节点的下一个节点的分值大于等于范围的最小值的节点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-></span>level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">zslValueGteMin</span><span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score<span class="token punctuation">,</span>range<span class="token punctuation">)</span><span class="token punctuation">)</span>            x <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取符合条件的节点</span>    x <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>    <span class="token function">serverAssert</span><span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 判断节点的分值是否小于等于范围的最大值, 不符合返回 NULL</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">zslValueLteMax</span><span class="token punctuation">(</span>x<span class="token operator">-></span>score<span class="token punctuation">,</span>range<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 判断跳表节点的分值是否在范围内 * @param zsl 跳表 * @param range 范围 * @return 1: 存在 0: 不存在 */</span><span class="token keyword">int</span> <span class="token function">zslIsInRange</span><span class="token punctuation">(</span>zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">,</span> zrangespec <span class="token operator">*</span>range<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    zskiplistNode <span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token comment">// 入参的范围值有问题, 直接返回不存在</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>range<span class="token operator">-></span>min <span class="token operator">></span> range<span class="token operator">-></span>max <span class="token operator">||</span> <span class="token punctuation">(</span>range<span class="token operator">-></span>min <span class="token operator">==</span> range<span class="token operator">-></span>max <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>range<span class="token operator">-></span>minex <span class="token operator">||</span> range<span class="token operator">-></span>maxex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 获取尾巴节点, 也就是分值最大的节点</span>    x <span class="token operator">=</span> zsl<span class="token operator">-></span>tail<span class="token punctuation">;</span>    <span class="token comment">// 尾节点不存在或者节点的分数小于范围的最小值, 不存在</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">zslValueGteMin</span><span class="token punctuation">(</span>x<span class="token operator">-></span>score<span class="token punctuation">,</span>range<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 获取头节点的下一个节点, 也就是分值最小的节点</span>    x <span class="token operator">=</span> zsl<span class="token operator">-></span>header<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>    <span class="token comment">// 节点不存在, 或者节点的分数大于范围的最大值, 不存在</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">zslValueLteMax</span><span class="token punctuation">(</span>x<span class="token operator">-></span>score<span class="token punctuation">,</span>range<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 返回存在</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 判断入参的数值是否大于或大于等于范围的最小值 * @param value 入参的数值 * @param spec 范围 */</span><span class="token keyword">int</span> <span class="token function">zslValueGteMin</span><span class="token punctuation">(</span><span class="token keyword">double</span> value<span class="token punctuation">,</span> zrangespec <span class="token operator">*</span>spec<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// minex 是否可以等于判断值, 1: 大于 0: 大于等于</span>    <span class="token keyword">return</span> spec<span class="token operator">-></span>minex <span class="token operator">?</span> <span class="token punctuation">(</span>value <span class="token operator">></span> spec<span class="token operator">-></span>min<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>value <span class="token operator">>=</span> spec<span class="token operator">-></span>min<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 判断入参的数组是否小于或小于等于范围的最大值 */</span><span class="token keyword">int</span> <span class="token function">zslValueLteMax</span><span class="token punctuation">(</span><span class="token keyword">double</span> value<span class="token punctuation">,</span> zrangespec <span class="token operator">*</span>spec<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// maxex 是否可以等于判断值, 1: 小于 0: 小于等于</span>    <span class="token keyword">return</span> spec<span class="token operator">-></span>maxex <span class="token operator">?</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> spec<span class="token operator">-></span>max<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;=</span> spec<span class="token operator">-></span>max<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>到这里, Redis 对跳表的实现的大体逻辑基本就分解完了。</p><h2 id="4-问题"><a href="#4-问题" class="headerlink" title="4 问题"></a>4 问题</h2><h3 id="4-1-跳表的最大层数为-32"><a href="#4-1-跳表的最大层数为-32" class="headerlink" title="4.1 跳表的最大层数为 32"></a>4.1 跳表的最大层数为 32</h3><p>本身跳表的层节点是需要消耗空间的, 所以需要有一个上限。<br>而 Redis 提供的确定层高的函数</p><blockquote><ol><li>第一层的概率为 100%</li><li>第二层的概率为 25%</li><li>第五层的概率为 7.9%</li><li>第十三层的概率为 0.7%</li><li>第二十一层的概率为 0.07%</li></ol></blockquote><p>想达到 32 层基本不可能的。</p><h3 id="4-2-Redis中-为啥不用红黑树二用跳表"><a href="#4-2-Redis中-为啥不用红黑树二用跳表" class="headerlink" title="4.2 Redis中 为啥不用红黑树二用跳表"></a>4.2 Redis中 为啥不用红黑树二用跳表</h3><p>作者<a href="https://news.ycombinator.com/item?id=1171423">原文</a>, 概括如下</p><blockquote><ol><li>跳表占用的内存会比红黑树多, 但是多的内存很有限</li><li>跳表的实现比红黑树简单</li><li>范围查询的支持, 比红黑树简单</li></ol></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;1-跳表的特点&quot;&gt;&lt;a href=&quot;#1-跳表的特点&quot; class=&quot;headerlink&quot; title=&quot;1 跳表的特点&quot;&gt;&lt;/a&gt;1 跳表的特点&lt;/h2&gt;&lt;p&gt;在 &lt;strong&gt;Redis 5.x&lt;/strong&gt; 的源码中,  zset (order</summary>
        
      
    
    
    
    
    <category term="Redis" scheme="https://github.com/Lcn29/tags/Redis/"/>
    
  </entry>
  
</feed>
